<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="google-site-verification" content="GkJ68PCnxM9Ih7Zm9v8p91FOCV7ymNCO2KdGbflLh3E"><meta name="360-site-verification" content="dd6547587641bfede036f7c79561e8a0"><meta name="shenma-site-verification" content="fd96cf3751972c9b05f8471d2ccadddc_1496951214"><meta name="msvalidate.01" content="1D38B05050A977F6FDEDA481198343F1"><meta name="sogou_site_verification" content="MpPsku240L"><title>MyCAT 源码解析 —— 分片结果合并（一） | 芋道源码 —— 纯源码解析BLOG</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=3,minimum-scale=1"><meta name="author" content="芋道源码"><meta name="description" content="摘要: 原创出处 http://www.iocoder.cn/MyCAT/sharding-result-merge-first/ 「芋道源码」欢迎转载，保留摘要，谢谢！
本文主要基于 MyCAT 1.6.5 正式版  

1. 概述
2. 多分片执行 SQL
3. 合并多分片结果
3.1 记录头("><meta name="keywords" content="Java,架构,后端,服务端,RocketMQ,MyCAT,分布式消息队列,分布式存储,技术博客,Sharding-JDBC,分库分表"><link rel="alternate" href="atom.xml" title="芋道源码 —— 纯源码解析BLOG" type="application/atom+xml"><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/style.css"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?9e70e3362807c1bd185a79655b307027";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script>!function(){var t="http:"==document.location.protocol?"http://js.passport.qihucdn.com/11.0.1.js?f05b61dd54bbc38386611a5238672938":"https://jspassport.ssl.qhimg.com/11.0.1.js?f05b61dd54bbc38386611a5238672938";document.write('<script src="'+t+'" id="sozz"><\/script>')}()</script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></head></html><body><header><div><div id="textlogo"><h1 class="site-name"><a href="/" title="芋道源码 —— 纯源码解析BLOG">芋道源码 —— 纯源码解析BLOG</a></h1><a class="blog-motto">愿半生编码，如一生老友！</a></div><div class="navbar"><a class="navbutton navmobile" href="#" title="菜单"></a></div><nav class="animated"><ul><ul><li><a href="/">文章</a></li><li><a href="/2018-meet-you">知识星球</a></li><li><a href="https://github.com/YunaiV" rel="external nofollow noopener noreferrer" target="_blank">Github</a></li><li><a href="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31_bak.jpg">微信公众号</a></li><li><a href="/categories/%E5%B7%A5%E4%BD%9C%E5%86%85%E6%8E%A8/">工作内推</a></li><li><a href="/link_url">友链</a></li></ul></ul></nav></div></header><div id="container"><div id="main" class="post" itemscope="" itemprop="blogPost"><article itemprop="articleBody"><header class="article-info clearfix"><h1 itemprop="name"><a href="/MyCAT/sharding-result-merge-first/" title="MyCAT 源码解析 —— 分片结果合并（一）" itemprop="url">MyCAT 源码解析 —— 分片结果合并（一）</a></h1><p class="article-author"></p><p class="article-time">总阅读量:<span id="busuanzi_value_page_pv"></span>次</p></header><div class="article-content"><p>摘要: 原创出处 <a href="http://www.iocoder.cn/MyCAT/sharding-result-merge-first/">http://www.iocoder.cn/MyCAT/sharding-result-merge-first/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 MyCAT 1.6.5 正式版</strong></p><ul><li><a href="http://www.iocoder.cn/MyCAT/sharding-result-merge-first/">1. 概述</a></li><li><a href="http://www.iocoder.cn/MyCAT/sharding-result-merge-first/">2. 多分片执行 SQL</a></li><li><a href="http://www.iocoder.cn/MyCAT/sharding-result-merge-first/">3. 合并多分片结果</a><ul><li><a href="http://www.iocoder.cn/MyCAT/sharding-result-merge-first/">3.1 记录头(header)</a></li><li><a href="http://www.iocoder.cn/MyCAT/sharding-result-merge-first/">3.2 记录行(row)</a><ul><li><a href="http://www.iocoder.cn/MyCAT/sharding-result-merge-first/">3.1 AbstractDataNodeMerge</a></li><li><a href="http://www.iocoder.cn/MyCAT/sharding-result-merge-first/">3.2 DataNodeMergeManager</a></li><li><a href="http://www.iocoder.cn/MyCAT/sharding-result-merge-first/">3.3 UnsafeRow</a></li><li><a href="http://www.iocoder.cn/MyCAT/sharding-result-merge-first/">3.4 UnsafeExternalRowSorter</a></li><li><a href="http://www.iocoder.cn/MyCAT/sharding-result-merge-first/">3.5 UnsafeRowGrouper</a></li></ul></li></ul></li><li><a href="http://www.iocoder.cn/MyCAT/sharding-result-merge-first/">4. 救护中心</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>相信很多同学看过 MySQL 各种优化的文章，里面 99% 会提到：单表数据量大了，需要进行分片（水平拆分 or 垂直拆分）。分片之后，业务上必然面临的场景：跨分片的数据合并。今天我们就一起来瞅瞅 MyCAT 是如何实现<strong>分片结果合并</strong>。</p><p>跨分片查询大体流程如下：</p><p><img src="http://www.iocoder.cn/images/MyCAT/2017_06_13/flow.png" alt="flow"></p><p>和 <a href="http://www.iocoder.cn/Mycat/single-db-single-table-select/">《【单库单表】查询》</a> 不同的两个过程：</p><ul><li>【2】多分片执行 SQL</li><li>【4】合并多分片结果</li></ul><p>下面，我们来逐条讲解这两个过程。</p><h1 id="2-多分片执行-SQL"><a href="#2-多分片执行-SQL" class="headerlink" title="2. 多分片执行 SQL"></a>2. 多分片执行 SQL</h1><p><img src="http://www.iocoder.cn/images/MyCAT/2017_06_13/execute_sql.png" alt="execute_sql"></p><p>经过 SQL 解析后，计算出需要执行 SQL 的<strong>分片节点</strong>，遍历<strong>分片节点</strong>发送 SQL 进行执行。</p><p><strong>核心代码</strong>：</p><ul><li><a href="https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/backend/mysql/nio/handler/MultiNodeQueryHandler.java" rel="external nofollow noopener noreferrer" target="_blank">MultiNodeQueryHandler.java#execute(…)</a></li></ul><p><em><strong>SQL 解析</strong> 详细过程，我们另开文章，避免内容过多，影响大家对 <strong>分片结果合并</strong> 流程和逻辑的理解。</em></p><h1 id="3-合并多分片结果"><a href="#3-合并多分片结果" class="headerlink" title="3. 合并多分片结果"></a>3. 合并多分片结果</h1><p><img src="http://www.iocoder.cn/images/MyCAT/2017_06_13/handle_response.png" alt="handle_response"></p><p>和 <a href="http://www.iocoder.cn/Mycat/single-db-single-table-select/">《【单库单表】查询》</a> 不同，多个<strong>分片节点</strong>都会<strong>分别</strong>响应 <em>记录头(header)</em> 和 <em>记录行(row)</em> 。在开始分析 MyCAT 是怎么合并多分片结果之前，我们先来回想下 SQL 的执行顺序。</p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line">FROM       // [1] 选择表</div><div class="line">WHERE      // [2] 过滤表</div><div class="line">GROUP BY   // [3] 分组</div><div class="line"><span class="keyword">SELECT</span>     // [<span class="number">4</span>] 普通字段，<span class="keyword">max</span> / <span class="keyword">min</span> / <span class="keyword">avg</span> / <span class="keyword">sum</span> / <span class="keyword">count</span> 等函数，<span class="keyword">distinct</span></div><div class="line"><span class="keyword">HAVING</span>     // [<span class="number">5</span>] 再过滤表</div><div class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span>   // [<span class="number">6</span>] 排序</div><div class="line"><span class="keyword">LIMIT</span>      // [<span class="number">7</span>] 分页</div></pre></td></tr></table></figure><h2 id="3-1-记录头-header"><a href="#3-1-记录头-header" class="headerlink" title="3.1 记录头(header)"></a>3.1 记录头(header)</h2><p>多个<strong>分片节点</strong>响应时，会响应多次 <em>记录头(header)</em> 。MyCAT 在实际处理时，只处理第一个返回的 <em>记录头(header)</em> 。因此，在使用时要保证表的 Schema 相同。</p><p><strong>分片节点</strong>响应的 <em>记录头(header)</em> 可以直接返回 MySQL Client 吗？答案是不可以。<code>AVG</code>函数 是特殊情况，MyCAT 需要将 <code>AVG</code> 拆成 <code>SUM</code> + <code>COUNT</code> 进行计算。举个例子：</p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line">// [1] MySQL Client =&gt; MyCAT ：</div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(age) <span class="keyword">FROM</span> student;</div><div class="line"></div><div class="line">// [2] MyCAT =&gt; MySQL Server ：</div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(age) <span class="keyword">AS</span> AVG0SUM, <span class="keyword">COUNT</span>(age) <span class="keyword">AS</span> AVG0COUNT <span class="keyword">FROM</span> student;</div><div class="line"></div><div class="line">// [3] 最终：AVG(age) = SUM(age) AS AVG0SUM / COUNT(age)</div></pre></td></tr></table></figure><p><strong>核心代码</strong>：</p><ul><li><a href="https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/backend/mysql/nio/handler/MultiNodeQueryHandler.java" rel="external nofollow noopener noreferrer" target="_blank">MultiNodeQueryHandler.java#fieldEofResponse(…)</a>。</li></ul><h2 id="3-2-记录行-row"><a href="#3-2-记录行-row" class="headerlink" title="3.2 记录行(row)"></a>3.2 记录行(row)</h2><h3 id="3-1-AbstractDataNodeMerge"><a href="#3-1-AbstractDataNodeMerge" class="headerlink" title="3.1 AbstractDataNodeMerge"></a>3.1 AbstractDataNodeMerge</h3><p>MyCAT 对分片结果合并通过 <code>AbstractDataNodeMerge</code> 子类来完成。</p><p><img src="http://www.iocoder.cn/images/MyCAT/2017_06_13/merge_service.png" alt="merge_service"></p><p><code>AbstractDataNodeMerge</code> ：</p><ul><li>-packs ：待合并记录行(row)队列。队列尾部插入 <code>END_FLAG_PACK</code> 表示队列已结束。</li><li>-running ：合并逻辑是否正在执行中的标记。</li><li>~onRowMetaData(…) ：根据<strong>记录列信息(ColMeta)</strong>构建对应的排序组件和聚合组件。需要子类进行实现。</li><li>~onNewRecord(…) ：插入记录行(row) 到 <code>packs</code>。</li><li>~outputMergeResult(…) ：插入 <code>END_FLAG_PACK</code> 到 <code>packs</code>。</li><li>~run(…) ：执行<strong>合并</strong>分片结果逻辑，并将合并结果返回给 MySQL Client。需要子类进行实现。</li></ul><p><img src="http://www.iocoder.cn/images/MyCAT/2017_06_13/AbstractDataNodeMerge_run.png" alt="AbstractDataNodeMerge_run.png"></p><p><strong>通过 <code>running</code> 标记保证同一条 SQL 同时只有一个线程正在执行，并且不需要等到每个分片结果都返回就可以执行<em>聚合</em>逻辑。当然，<em>排序</em>逻辑需要等到所有分片结果都返回才可以执行。</strong></p><p><strong>核心代码</strong>：</p><ul><li><a href="https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/sqlengine/mpp/AbstractDataNodeMerge.java" rel="external nofollow noopener noreferrer" target="_blank">AbstractDataNodeMerge.java</a></li><li><a href="https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/sqlengine/mpp/DataNodeMergeManager.java" rel="external nofollow noopener noreferrer" target="_blank">DataNodeMergeManager.java#run(…)</a></li></ul><h3 id="3-2-DataNodeMergeManager"><a href="#3-2-DataNodeMergeManager" class="headerlink" title="3.2 DataNodeMergeManager"></a>3.2 DataNodeMergeManager</h3><p><code>AbstractDataNodeMerge</code> 有两种子类实现：</p><ul><li><code>DataMergeService</code> ：基于<strong>堆内内存</strong>合并分片结果。</li><li><code>DataNodeMergeManager</code> ：基于<strong>堆外内存</strong>合并分片结果。</li></ul><p>目前官方默认配置使用 <code>DataNodeMergeManager</code>。主要有如下优点：</p><ol><li>可以使用更大的内存空间。当并发量大或者数据量大时，更大的内存空间意味着更好的性能。</li><li>减少 GC 暂停时间。记录行(row)对象小且重用性很低，需要能够进行类似 C / C++ 的自主内存释放。</li><li>更快的内存复制和读取速度，对排序和聚合带来很好的提速。</li></ol><p>如果对<strong>堆外内存</strong>不太了解，推荐阅读如下文章：</p><ol><li><a href="http://www.jianshu.com/p/50be08b54bee" rel="external nofollow noopener noreferrer" target="_blank">《从0到1起步-跟我进入堆外内存的奇妙世界》</a></li><li><a href="http://www.infoq.com/cn/news/2014/12/external-memory-heap-memory" rel="external nofollow noopener noreferrer" target="_blank">《堆内内存还是堆外内存？》</a></li><li><a href="http://www.cnblogs.com/moonandstar08/p/5107648.html" rel="external nofollow noopener noreferrer" target="_blank">《JAVA堆外内存》</a></li><li><a href="https://yq.aliyun.com/articles/2948?spm=5176.100239.blogcont62539.11.a3HdFE" rel="external nofollow noopener noreferrer" target="_blank">《JVM源码分析之堆外内存完全解读》</a></li></ol><p>本文主要分析 <code>DataNodeMergeManager</code> 实现，<code>DataMergeService</code> 可以自己阅读或者等待后续文章（😈<strong>欢迎订阅我的公众号噢</strong>）。</p><p><code>DataNodeMergeManager</code> 有三个组件：</p><ul><li><code>globalSorter</code> ：<code>UnsafeExternalRowSorter</code> =&gt; 实现记录行(row)<strong>合并并排序</strong>逻辑。</li><li><code>globalMergeResult</code> ：<code>UnsafeExternalRowSorter</code> =&gt; 实现记录行(row)<strong>合并不排序</strong>逻辑。</li><li><code>unsafeRowGrouper</code> ： <code>UnsafeRowGrouper</code> =&gt; 实现记录行(row)<strong>聚合</strong>逻辑。</li></ul><p><code>DataNodeMergeManager#run(...)</code> 逻辑如下：</p><ul><li>[1] 写入记录行(row)到 <code>UnsafeRow</code>。</li><li>[2] 根据情况将 <code>UnsafeRow</code> 插入对应组件。</li><li>[3] 当所有 <code>UnsafeRow</code> 插入完后，根据情况使用组件聚合、排序。</li></ul><table><thead><tr><th>是否排序</th><th>是否聚合</th><th>依赖组件</th><th>[2]</th><th>[3]</th></tr></thead><tbody><tr><td>否</td><td>否</td><td><code>globalSorter</code></td><td>插入 <code>globalSorter</code></td><td>使用 <code>globalSorter</code> 合并并排序</td></tr><tr><td>是</td><td>否</td><td><code>globalMergeResult</code></td><td>插入 <code>globalMergeResult</code></td><td>使用 <code>globalMergeResult</code> 合并不排序</td></tr><tr><td>否</td><td>是</td><td><code>unsafeRowGrouper</code> + <code>globalSorter</code></td><td>插入 <code>unsafeRowGrouper</code> 进行聚合</td><td>使用 <code>globalSorter</code> 合并并排序</td></tr><tr><td>是</td><td>是</td><td><code>unsafeRowGrouper</code> + <code>globalMergeResult</code></td><td>插入 <code>unsafeRowGrouper</code> 进行聚合</td><td>使用 <code>globalMergeResult</code> 合并不排序</td></tr></tbody></table><p><strong>核心代码</strong>：</p><ul><li><a href="https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/sqlengine/mpp/DataNodeMergeManager.java" rel="external nofollow noopener noreferrer" target="_blank">DataNodeMergeManager.java</a>。</li></ul><p>🙃看到这里，可能很多同学都有点懵逼，问题不大，我们继续往下瞅。</p><h3 id="3-3-UnsafeRow"><a href="#3-3-UnsafeRow" class="headerlink" title="3.3 UnsafeRow"></a>3.3 UnsafeRow</h3><p><img src="http://www.iocoder.cn/images/MyCAT/2017_06_13/unsafe_row.png" alt="unsafe_row"></p><p>记录行(row)写到 <code>UnsafeRow</code> 的 <code>baseObject</code> 属性，结构如下：</p><p><img src="http://www.iocoder.cn/images/MyCAT/2017_06_13/unsafe_row_object.png" alt="unsafe_row_object"><br><img src="http://www.iocoder.cn/images/MyCAT/2017_06_13/unsafe_row_2.png" alt="unsafe_row_2.png"></p><ul><li>拆分成三个区域，<strong>每个区域按照格子记录信息，每个格子 64bits(8 Bytes)</strong>。</li><li>记录行(row)按照字段顺序位置记录到 <code>baseObject</code>。</li><li>[1] 空标记位区域 ：标记字段对应的值是否为 NULL。<ul><li>当字段对应的值为 NULL 时，其对应的字段顺序对应的 bit 设置为 1。举个例子，第 0 个位置字段为 NULL，则第一个格子对应的 64 bits 从右边第一个 bit 设置为 1。</li><li>因为每个格子是 64 bits，每 64 个字段占用一个格子，不满一个格子，按照一个格子计算。因此，该区域的长度(<code>bitSetWidthInBytes</code>) = 字段占用的格子数 * 64 bits。</li></ul></li><li>[2] 位置长度区域 ：记录字段对应的值在<code>[3]区域</code>所在的位置和长度。<ul><li>每个字段记录<code>[2]区域</code>的位置 = <code>baseOffset</code> + <code>bitSetWidthInBytes</code> + 8 Bytes * 字段顺序。</li><li>占用一个格子，前 32 bits 为<code>[3]区域</code>的位置，后 32 bits 为字段对应的值长度。</li></ul></li><li>[3] 值区域 ：记录字段对应的值。<ul><li>每个字段对应的值占用格子数 = 字段对应的值长度 / 8 Byte，如果无法整除再 + 1。</li><li>因为字段对应的值可能无法刚好占满每个格子，未使用的 bit 用 0 占位。</li></ul></li></ul><p><strong>写入 <code>UnsafeRow</code>，MyCAT 可以顺序访问每个字段，而不需要在记录行(row)进行遍历。</strong></p><p>🙃日常开发使用位操作的机会比较少，可能较为难理解，需要反复理解下，相信会获得很大启发。恩，该部分代码引用自开源运算框架 <code>Spark</code>，是不是更加有动力列😈。</p><p><strong>核心代码</strong>：</p><ul><li><a href="https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/row/UnsafeRow.java" rel="external nofollow noopener noreferrer" target="_blank">UnsafeRow.java</a></li><li><a href="https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/row/BufferHolder.java" rel="external nofollow noopener noreferrer" target="_blank">BufferHolder.java</a></li><li><a href="https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/row/UnsafeRowWriter.java" rel="external nofollow noopener noreferrer" target="_blank">UnsafeRowWriter.java</a></li></ul><h3 id="3-4-UnsafeExternalRowSorter"><a href="#3-4-UnsafeExternalRowSorter" class="headerlink" title="3.4 UnsafeExternalRowSorter"></a>3.4 UnsafeExternalRowSorter</h3><p>如果使用 Java 实现 <code>SELECT * FROM student ORDER BY age desc, nickname asc</code>，不考虑算法优化的情况下，我们可以简单如下实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Collections.sort(students, <span class="keyword">new</span> Comparator&lt;Comparable&gt;() &#123;</div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</div><div class="line">           <span class="keyword">int</span> cmp = compare(o2.age, o1.age);</div><div class="line">           <span class="keyword">return</span> cmp != <span class="number">0</span> ? cmp : compare(o1.nickname, o2.nickname);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>从功能上，<code>UnsafeExternalRowSorter</code> 是这么实现排序逻辑。当然肯定的是，不是这么“简单”的实现。</p><p><img src="http://www.iocoder.cn/images/MyCAT/2017_06_13/sorter_write.jpeg" alt="sorter_write"></p><p><code>UnsafeRow</code> 会写入到两个地方：</p><ol><li><code>List&lt;MemoryBlock&gt;</code> ：内存块数组。当前 <code>MemoryBlock</code> 无法容纳写入的 <code>UnsafeRow</code> 时，生成新的 <code>MemoryBlock</code> 提供写入。每条 <code>UnsafeRow</code> 存储在 <code>MemoryBlock</code> 由 长度 + 字节内容 组成。</li><li><code>LongArray</code> ：每条 <code>UnsafeRow</code> 存储在 <code>LongArray</code> 由两部分组成：address + prefix。<ul><li><code>address</code> ：<code>UnsafeRow</code> 存储在 <code>List&lt;MemoryBlock&gt;</code> 的位置。前 13 bits 记录所在 <code>MemoryBlock</code> 的 index，后 51 bit 记录在 <code>MemoryBlock</code> 的 offset。</li><li><code>prefix</code> ：<code>UnsafeRow</code> 第一个排序字段<strong>值</strong>前 64 bits 计算的值。</li></ul></li></ol><p><strong><code>UnsafeExternalRowSorter</code> 排序实现方式</strong> ：提供 <strong><a href="http://blog.csdn.net/yangzhongblog/article/details/8184707" rel="external nofollow noopener noreferrer" target="_blank">TimSort</a></strong> 和 <strong>RadixSort</strong> 两种排序算法，前者为默认实现。<strong>TimSort</strong> 折半查找时，使用 <code>LongArray</code>，先比较 <code>prefix</code>，若相等，则顺序对比每个排序字段直到不等，提升计算效率。插入操作在 <code>LongArray</code> 操作，<code>List&lt;MemoryBlock&gt;</code> 只作为原始数据。</p><p>另外，当需要排序特别大的数据量时，会使用存储数据到文件进行排序。限于笔者暂时未阅读该处源码，后续会另开文章分析。🙂</p><p>核心源码：</p><ul><li><a href="https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/utils/sort/UnsafeExternalRowSorter.java" rel="external nofollow noopener noreferrer" target="_blank">UnsafeExternalRowSorter.java</a></li><li><a href="https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/utils/sort/UnsafeExternalRowSorter.java" rel="external nofollow noopener noreferrer" target="_blank">UnsafeExternalRowSorter.java</a></li><li><a href="https://github.com/YunaiV/Mycat-Server/blob/1.6/src/main/java/io/mycat/memory/unsafe/utils/sort/TimSort.java" rel="external nofollow noopener noreferrer" target="_blank">TimSort.java</a></li></ul><h3 id="3-5-UnsafeRowGrouper"><a href="#3-5-UnsafeRowGrouper" class="headerlink" title="3.5 UnsafeRowGrouper"></a>3.5 UnsafeRowGrouper</h3><p>如果使用 Java 实现 <code>SELECT nickname, COUNT(*) FROM student group by nickname</code>，不考虑算法优化的情况下，我们可以简单如下实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Map&lt;String, List&lt;Object&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"><span class="comment">// 聚合</span></div><div class="line"><span class="keyword">for</span> (student : students) &#123;</div><div class="line">    <span class="keyword">if</span> (map.contains(student.nickname)) &#123;</div><div class="line">        map.put(student.nickname, map.get(student.nickname).get(<span class="number">1</span>) + <span class="number">1</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        List&lt;Object&gt; value = <span class="keyword">new</span> Array&lt;&gt;();</div><div class="line">        value.add(nickname);</div><div class="line">        value.add(<span class="number">1</span>);</div><div class="line">        map.put(student.nickname, value);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 输出</span></div><div class="line"><span class="keyword">for</span> (value : map.values) &#123;</div><div class="line">    System.out.println(value);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从功能上，<code>UnsafeRowGrouper</code> 是这么实现排序逻辑。当然肯定的是，也不是这么“简单”的实现。</p><p>😈具体怎么实现的呢？我们在《MyCAT 源码解析 —— 分片结果合并（二）》继续分析。</p><h1 id="4-救护中心"><a href="#4-救护中心" class="headerlink" title="4. 救护中心"></a>4. 救护中心</h1><p>看到此处的应该是真爱吧？！如果内容上有什么错误或者难懂的地方，可以关注我的微信公众号给我留言，我会很认真的逐条解答的。“万一”觉得本文还可以，希望转发到朋友圈让更多的人看到。</p><p>最后的最后，感谢耐心阅读本文的同学。</p><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt="wechat_mp"></p></div><footer class="article-footer clearfix"><div class="article-categories"><span></span> <a class="article-category-link" href="/categories/MyCAT/">MyCAT</a></div><div class="article-share" id="share"><div data-url="http://www.iocoder.cn/MyCAT/sharding-result-merge-first/" data-title="MyCAT 源码解析 —— 分片结果合并（一） | 芋道源码 —— 纯源码解析BLOG" data-tsina="null" class="share clearfix"></div></div></footer></article><nav class="article-nav clearfix"><div class="prev"><a href="/MyCAT/two-table-share-join/" title="MyCAT 源码分析  —— 跨库两表Join"><strong>PREVIOUS:</strong><br><span>MyCAT 源码分析 —— 跨库两表Join</span></a></div><div class="next"><a href="/MyCAT/single-db-single-table-select/" title="MyCAT 源码分析 —— 【单库单表】查询"><strong>NEXT:</strong><br><span>MyCAT 源码分析 —— 【单库单表】查询</span></a></div></nav></div><div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div><div id="toc" class="toc-aside"><strong class="toc-title">文章目录</strong><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-概述"><span class="toc-number">1.</span> <span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-多分片执行-SQL"><span class="toc-number">2.</span> <span class="toc-text">2. 多分片执行 SQL</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-合并多分片结果"><span class="toc-number">3.</span> <span class="toc-text">3. 合并多分片结果</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-记录头-header"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 记录头(header)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-记录行-row"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 记录行(row)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-AbstractDataNodeMerge"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.1 AbstractDataNodeMerge</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-DataNodeMergeManager"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2 DataNodeMergeManager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-UnsafeRow"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.3 UnsafeRow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-UnsafeExternalRowSorter"><span class="toc-number">3.2.4.</span> <span class="toc-text">3.4 UnsafeExternalRowSorter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-UnsafeRowGrouper"><span class="toc-number">3.2.5.</span> <span class="toc-text">3.5 UnsafeRowGrouper</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-救护中心"><span class="toc-number">4.</span> <span class="toc-text">4. 救护中心</span></a></li></ol></div><div id="asidepart"><aside class="clearfix"><div id="authorInfo"><div><img width="100%" src="/images/common/wechat_mp_2017_07_31_bak.jpg"></div><div class="social-list"></div></div><div class="categorieslist"><p class="asidetitle">微信公众号福利：芋道源码</p><ul><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">0. 阅读源码葵花宝典</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">1. RocketMQ / MyCAT / Sharding-JDBC 详细中文注释源码</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">2. 您对于源码的疑问每条留言都将得到认真回复</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">3. 新的源码解析文章实时收到通知，每周六十点更新</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">4. 认真的源码交流微信群</a></li></ul></div><div class="categorieslist"><p class="asidetitle">分类</p><ul><li><a href="/categories/Docker/" title="Docker">Docker<sup>2</sup></a></li><li><a href="/categories/Dubbo/" title="Dubbo">Dubbo<sup>1</sup></a></li><li><a href="/categories/Elastic-Job-Cloud/" title="Elastic-Job-Cloud">Elastic-Job-Cloud<sup>6</sup></a></li><li><a href="/categories/Elastic-Job-Lite/" title="Elastic-Job-Lite">Elastic-Job-Lite<sup>16</sup></a></li><li><a href="/categories/Eureka/" title="Eureka">Eureka<sup>23</sup></a></li><li><a href="/categories/Happylifeplat-TCC/" title="Happylifeplat-TCC">Happylifeplat-TCC<sup>1</sup></a></li><li><a href="/categories/Hystrix/" title="Hystrix">Hystrix<sup>9</sup></a></li><li><a href="/categories/JUC/" title="JUC">JUC<sup>1</sup></a></li><li><a href="/categories/MyCAT/" title="MyCAT">MyCAT<sup>9</sup></a></li><li><a href="/categories/Nginx/" title="Nginx">Nginx<sup>1</sup></a></li><li><a href="/categories/RocketMQ/" title="RocketMQ">RocketMQ<sup>14</sup></a></li><li><a href="/categories/RxJava/" title="RxJava">RxJava<sup>5</sup></a></li><li><a href="/categories/Sharding-JDBC/" title="Sharding-JDBC">Sharding-JDBC<sup>18</sup></a></li><li><a href="/categories/SkyWalking/" title="SkyWalking">SkyWalking<sup>26</sup></a></li><li><a href="/categories/Spring/" title="Spring">Spring<sup>1</sup></a></li><li><a href="/categories/Spring-Cloud-Gateway/" title="Spring-Cloud-Gateway">Spring-Cloud-Gateway<sup>24</sup></a></li><li><a href="/categories/Spring-MVC/" title="Spring-MVC">Spring-MVC<sup>1</sup></a></li><li><a href="/categories/Spring-Security/" title="Spring-Security">Spring-Security<sup>1</sup></a></li><li><a href="/categories/TCC-Transaction/" title="TCC-Transaction">TCC-Transaction<sup>7</sup></a></li><li><a href="/categories/TiKV/" title="TiKV">TiKV<sup>2</sup></a></li><li><a href="/categories/工作内推/" title="工作内推">工作内推<sup>4</sup></a></li><li><a href="/categories/技术杂文/" title="技术杂文">技术杂文<sup>5</sup></a></li><li><a href="/categories/芋道源码的周天/" title="芋道源码的周天">芋道源码的周天<sup>1</sup></a></li></ul></div></aside></div></div><footer><div id="footer"><img src="http://www.iocoder.cn/images/common/wechat_mp_simple.png" style="display:none"><p class="copyright">© 2018 <a href="http://www.iocoder.cn" target="_blank" title="芋道源码">芋道源码</a> && <span style="display:inline" id="busuanzi_container_site_uv">总访客数 <span id="busuanzi_value_site_uv" font="微软雅黑"></span> 次</span> && <span style="display:inline" id="busuanzi_container_site_pv">总访问量 <span id="busuanzi_value_site_pv" font="微软雅黑"></span> 次</span></p></div><div class="copyright">沪ICP备17037075号-1</div></footer><script src="/js/jquery-2.1.0.min.js"></script><script type="text/javascript">$(document).ready(function(){function e(){"number"==typeof window.innerWidth?n=window.innerWidth:document.documentElement&&document.documentElement.clientWidth&&(n=document.documentElement.clientWidth)}$(".navbar").click(function(){$("header nav").toggleClass("shownav")});var n=0,s=$("#main"),a=$("#asidepart"),o=$(".closeaside"),d=$(".openaside");$(window).resize(function(){e(),n>=1024?$("header nav").removeClass("shownav"):(s.removeClass("moveMain"),a.css("display","block").removeClass("fadeOut"),d.css("display","none"),$("#toc.toc-aside").css("display","none"))}),o.click(function(){a.addClass("fadeOut").css("display","none"),d.css("display","block").addClass("fadeIn"),s.addClass("moveMain")}),d.click(function(){d.css("display","none").removeClass("beforeFadeIn"),a.css("display","block").removeClass("fadeOut").addClass("fadeIn"),s.removeClass("moveMain")}),$(window).scroll(function(){d.css("top",Math.max(80,260-$(this).scrollTop()))})})</script><script type="text/javascript">$(document).ready(function(){var a=$(".article-content>iframe"),t=$(".article-content>embed"),n=$("#toc");$("article h2"),ah=$("article h2"),ta=$("#toc.toc-aside"),o=$(".openaside"),c=$(".closeaside"),a.length>0&&a.wrap('<div class="video-container" />'),t.length>0&&t.wrap('<div class="video-container" />'),0==ah.length?n.css("display","none"):(c.click(function(){ta.css("display","block").addClass("fadeIn")}),o.click(function(){ta.css("display","none")}),$(window).scroll(function(){ta.css("top",Math.max(140,320-$(this).scrollTop()))}))})</script><script type="text/javascript">$(document).ready(function(){var t=$(".share"),a=t.attr("data-url"),e=encodeURIComponent(a),r=['<a href="#" class="overlay" id="qrcode"></a>','<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url='+e+'"/></div>','<a href="#textlogo" class="article-back-to-top" title="Top"></a>','<a href="https://www.facebook.com/sharer.php?u='+e+'" class="article-share-facebook" target="_blank" title="Facebook"></a>','<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>','<a href="https://twitter.com/intent/tweet?url='+e+'" class="article-share-twitter" target="_blank" title="Twitter"></a>','<a href="http://service.weibo.com/share/share.php?title='+t.attr("data-title")+"&url="+e+"&ralateUid="+t.attr("data-tsina")+'&searchPic=true&style=number" class="article-share-weibo" target="_blank" title="Weibo"></a>','<span title="Share to"></span>'].join("");t.append(r),$(".article-share-qrcode").click(function(){var t=$("#qrcode-pic").attr("data-src");$("#qrcode-pic").attr("src",t),$("#qrcode-pic").load(function(){$(".qrcode strong").text(" ")})})})</script><link rel="stylesheet" href="/alert/css/alert.css"><script src="/alert/js/alert.js"></script><script src="/js/jquery.cookie.js"></script><script src="/js/util.js"></script><script type="text/javascript">!function(e,a,t,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=a.createElement(t),s=a.getElementsByTagName(t)[0],o.async=1,o.src="//www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s)}(window,document,"script",0,"ga"),ga("create","UA-107572620-1","auto"),ga("send","pageview")</script></body>