<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="google-site-verification" content="GkJ68PCnxM9Ih7Zm9v8p91FOCV7ymNCO2KdGbflLh3E"><meta name="360-site-verification" content="dd6547587641bfede036f7c79561e8a0"><meta name="shenma-site-verification" content="fd96cf3751972c9b05f8471d2ccadddc_1496951214"><meta name="msvalidate.01" content="1D38B05050A977F6FDEDA481198343F1"><meta name="sogou_site_verification" content="MpPsku240L"><title>Sharding-JDBC 源码分析 —— SQL 执行 | 芋道源码 —— 纯源码解析博客</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=3,minimum-scale=1"><meta name="author" content="芋道源码"><meta name="description" content="摘要: 原创出处 http://www.iocoder.cn/Sharding-JDBC/sql-execute/ 「芋道源码」欢迎转载，保留摘要，谢谢！
本文主要基于 Sharding-JDBC 1.5.0 正式版  

1. 概述
2. ExecutorEngine
2.1 ListeningE"><meta name="keywords" content="Sharding-JDBC,ShardingJDBC,Sharding-JDBC 源码,SQL 执行,Java,架构,后端,服务端,RocketMQ,MyCAT,分布式消息队列,分布式存储,技术博客,Sharding-JDBC,分库分表"><link rel="alternate" href="atom.xml" title="芋道源码 —— 纯源码解析博客" type="application/atom+xml"><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/style.css"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?9e70e3362807c1bd185a79655b307027";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script>!function(){var t="http:"==document.location.protocol?"http://js.passport.qihucdn.com/11.0.1.js?f05b61dd54bbc38386611a5238672938":"https://jspassport.ssl.qhimg.com/11.0.1.js?f05b61dd54bbc38386611a5238672938";document.write('<script src="'+t+'" id="sozz"><\/script>')}()</script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></head></html><body><header><div><div id="textlogo"><h1 class="site-name"><a href="/" title="芋道源码 —— 纯源码解析博客">芋道源码 —— 纯源码解析博客</a></h1><a class="blog-motto">愿半生编码，如一生老友！</a></div><div class="navbar"><a class="navbutton navmobile" href="#" title="菜单"></a></div><nav class="animated"><ul><ul><li><a href="/">文章</a></li><li><a href="/2018-meet-you">知识星球</a></li><li><a href="https://github.com/YunaiV" rel="external nofollow noopener noreferrer" target="_blank">Github</a></li><li><a href="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31_bak.jpg">微信公众号</a></li><li><a href="/categories/%E5%B7%A5%E4%BD%9C%E5%86%85%E6%8E%A8/">工作内推</a></li><li><a href="/link_url">友链</a></li></ul></ul></nav></div></header><div id="container"><div id="main" class="post" itemscope="" itemprop="blogPost"><article itemprop="articleBody"><header class="article-info clearfix"><h1 itemprop="name"><a href="/Sharding-JDBC/sql-execute/" title="Sharding-JDBC 源码分析 —— SQL 执行" itemprop="url">Sharding-JDBC 源码分析 —— SQL 执行</a></h1><p class="article-author"></p><p class="article-time">总阅读量:<span id="busuanzi_value_page_pv"></span>次</p></header><div class="article-content"><p>摘要: 原创出处 <a href="http://www.iocoder.cn/Sharding-JDBC/sql-execute/">http://www.iocoder.cn/Sharding-JDBC/sql-execute/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Sharding-JDBC 1.5.0 正式版</strong></p><ul><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-execute/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-execute/">2. ExecutorEngine</a><ul><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-execute/">2.1 ListeningExecutorService</a></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-execute/">2.2 关闭</a></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-execute/">2.3 执行 SQL 任务</a></li></ul></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-execute/">3. Executor</a><ul><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-execute/">3.1 StatementExecutor</a></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-execute/">3.2 PreparedStatementExecutor</a></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-execute/">3.3 BatchPreparedStatementExecutor</a></li></ul></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-execute/">4. ExecutionEvent</a><ul><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-execute/">4.1 EventBus</a></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-execute/">4.2 BestEffortsDeliveryListener</a></li></ul></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-execute/">666. 彩蛋</a></li></ul><hr><p><img src="https://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>越过千山万水（SQL 解析、SQL 路由、SQL 改写），我们终于来到了 <strong>SQL 执行</strong>。开森不开森？！</p><p><img src="http://www.iocoder.cn/images/Sharding-JDBC/2017_08_14/01.png" alt=""></p><p>本文主要分享<strong>SQL 执行</strong>的过程，不包括<strong>结果聚合</strong>。<a href="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg">《结果聚合》</a> <strong>东半球第二良心笔者</strong>会更新，关注微信公众号<a href="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg">【芋道源码】</a>完稿后<strong>第一时间</strong>通知您哟。</p><p><img src="http://www.iocoder.cn/images/Sharding-JDBC/2017_08_14/06.png" alt=""></p><p><strong>绿框部分</strong> SQL 执行主流程。</p><hr><blockquote><p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p></blockquote><h1 id="2-ExecutorEngine"><a href="#2-ExecutorEngine" class="headerlink" title="2. ExecutorEngine"></a>2. ExecutorEngine</h1><p>ExecutorEngine，SQL执行引擎。</p><p>分表分库，需要执行的 SQL 数量从单条变成了多条，此时有两种方式执行：</p><ul><li><strong>串行</strong>执行 SQL</li><li><strong>并行</strong>执行 SQL</li></ul><p>前者，编码容易，性能较差，总耗时是多条 SQL 执行时间累加。<br>后者，编码复杂，性能较好，总耗时约等于执行时间最长的 SQL。</p><p>👼 ExecutorEngine 当然采用的是<strong>后者</strong>，并行执行 SQL。</p><h2 id="2-1-ListeningExecutorService"><a href="#2-1-ListeningExecutorService" class="headerlink" title="2.1 ListeningExecutorService"></a>2.1 ListeningExecutorService</h2><p><a href="http://www.yiibai.com/guava/" rel="external nofollow noopener noreferrer" target="_blank">Guava( Java 工具库 )</a> 提供的继承自 ExecutorService 的<strong>线程服务接口</strong>，提供创建 ListenableFuture 功能。ListenableFuture 接口，继承 Future 接口，有如下好处：</p><blockquote><p>我们强烈地建议你在代码中多使用ListenableFuture来代替JDK的 Future, 因为：</p><ul><li>大多数Futures 方法中需要它。</li><li>转到ListenableFuture 编程比较容易。</li><li>Guava提供的通用公共类封装了公共的操作方方法，不需要提供Future和ListenableFuture的扩展方法。</li></ul><p>传统JDK中的Future通过异步的方式计算返回结果:在多线程运算中可能或者可能在没有结束返回结果，Future是运行中的多线程的一个引用句柄，确保在服务执行返回一个Result。</p><p>ListenableFuture可以允许你注册回调方法(callbacks)，在运算（多线程执行）完成的时候进行调用, 或者在运算（多线程执行）完成后立即执行。这样简单的改进，使得可以明显的支持更多的操作，这样的功能在JDK concurrent中的Future是不支持的。</p></blockquote><p>如上内容来自<a href="http://ifeve.com/google-guava-listenablefuture/" rel="external nofollow noopener noreferrer" target="_blank">《Google Guava包的ListenableFuture解析<br>》</a>，文章写的很棒。下文你会看到 Sharding-JDBC 是<strong>如何通过 ListenableFuture 简化并发编程的</strong>。</p><p>下面看看 ExecutorEngine 如何<strong>初始化</strong> ListeningExecutorService</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingDataSource.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ShardingDataSource</span><span class="params">(<span class="keyword">final</span> ShardingRule shardingRule, <span class="keyword">final</span> Properties props)</span> </span>&#123;</div><div class="line">    <span class="comment">// .... 省略部分代码</span></div><div class="line">   shardingProperties = <span class="keyword">new</span> ShardingProperties(props);</div><div class="line">   <span class="keyword">int</span> executorSize = shardingProperties.getValue(ShardingPropertiesConstant.EXECUTOR_SIZE);</div><div class="line">   executorEngine = <span class="keyword">new</span> ExecutorEngine(executorSize);</div><div class="line">   <span class="comment">// .... 省略部分代码</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ExecutorEngine</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorEngine</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> executorSize)</span> </span>&#123;</div><div class="line">   executorService = MoreExecutors.listeningDecorator(<span class="keyword">new</span> ThreadPoolExecutor(</div><div class="line">           executorSize, executorSize, <span class="number">0</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</div><div class="line">           <span class="keyword">new</span> ThreadFactoryBuilder().setDaemon(<span class="keyword">true</span>).setNameFormat(<span class="string">"ShardingJDBC-%d"</span>).build()));</div><div class="line">   MoreExecutors.addDelayedShutdownHook(executorService, <span class="number">60</span>, TimeUnit.SECONDS);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>一个分片数据源( ShardingDataSource ) <strong>独占</strong> 一个 SQL执行引擎( ExecutorEngine )。</li><li><code>MoreExecutors#listeningDecorator()</code> 创建 ListeningExecutorService，这样 <code>#submit()</code>，<code>#invokeAll()</code> 可以返回 ListenableFuture。</li><li>默认情况下，线程池大小为 <strong>8</strong>。可以根据实际业务需要，设置 ShardingProperties 进行调整。</li><li><code>#setNameFormat()</code> 并发编程时，一定要对线程名字做下定义，这样排查问题会方便很多。</li><li><code>MoreExecutors#addDelayedShutdownHook()</code>，<strong>应用关闭</strong>时，等待<strong>所有任务全部完成</strong>再关闭。默认配置等待时间为 60 秒，<strong>建议</strong>将等待时间做成可配的。</li></ul><h2 id="2-2-关闭"><a href="#2-2-关闭" class="headerlink" title="2.2 关闭"></a>2.2 关闭</h2><p>数据源关闭时，会调用 ExecutorEngine 也进行关闭。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingDataSource.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</div><div class="line">   executorEngine.close();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ExecutorEngine</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</div><div class="line">   executorService.shutdownNow();</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       executorService.awaitTermination(<span class="number">5</span>, TimeUnit.SECONDS);</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> InterruptedException ignored) &#123;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (!executorService.isTerminated()) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ShardingJdbcException(<span class="string">"ExecutorEngine can not been terminated"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>#shutdownNow()</code> 尝试使用 <code>Thread.interrupt()</code> 打断正在执行中的任务，未执行的任务不再执行。<strong>建议</strong>打印下哪些任务未执行，因为 SQL 未执行，可能数据未能持久化。</li><li><code>#awaitTermination()</code> 因为 <code>#shutdownNow()</code> 打断不是<strong>立即</strong>结束，需要一个过程，因此这里<strong>等待</strong>了 5 秒。</li><li><strong>等待</strong> 5 秒后，线程池不一定已经关闭，此时抛出异常给上层。<strong>建议</strong>打印下日志，记录出现这个情况。</li></ul><h2 id="2-3-执行-SQL-任务"><a href="#2-3-执行-SQL-任务" class="headerlink" title="2.3 执行 SQL 任务"></a>2.3 执行 SQL 任务</h2><p>ExecutorEngine 对外暴露 <code>#executeStatement()</code>，<code>#executePreparedStatement()</code>，<code>#executeBatch()</code></p><p>三个方法分别提供给 StatementExecutor、PreparedStatementExecutor、BatchPreparedStatementExecutor 调用。而这三个方法，内部调用的都是 <code>#execute()</code> 私有方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ExecutorEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 执行Statement.</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> sqlType SQL类型</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> statementUnits 语句对象执行单元集合</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> executeCallback 执行回调函数</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> &lt;T&gt; 返回值类型</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 执行结果</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">executeStatement</span><span class="params">(<span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> Collection&lt;StatementUnit&gt; statementUnits, <span class="keyword">final</span> ExecuteCallback&lt;T&gt; executeCallback)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> execute(sqlType, statementUnits, Collections.&lt;List&lt;Object&gt;&gt;emptyList(), executeCallback);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 执行PreparedStatement.</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> sqlType SQL类型</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> preparedStatementUnits 语句对象执行单元集合</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> parameters 参数列表</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> executeCallback 执行回调函数</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> &lt;T&gt; 返回值类型</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 执行结果</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">executePreparedStatement</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">       <span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> Collection&lt;PreparedStatementUnit&gt; preparedStatementUnits, <span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> ExecuteCallback&lt;T&gt; executeCallback)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> execute(sqlType, preparedStatementUnits, Collections.singletonList(parameters), executeCallback);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 执行Batch.</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> sqlType SQL类型</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> batchPreparedStatementUnits 语句对象执行单元集合</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> parameterSets 参数列表集</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> executeCallback 执行回调函数</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 执行结果</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; executeBatch(</div><div class="line">       <span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> Collection&lt;BatchPreparedStatementUnit&gt; batchPreparedStatementUnits, <span class="keyword">final</span> List&lt;List&lt;Object&gt;&gt; parameterSets, <span class="keyword">final</span> ExecuteCallback&lt;<span class="keyword">int</span>[]&gt; executeCallback) &#123;</div><div class="line">   <span class="keyword">return</span> execute(sqlType, batchPreparedStatementUnits, parameterSets, executeCallback);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>#execute()</code> 执行过程大体流程如下图：</p><p><img src="http://www.iocoder.cn/images/Sharding-JDBC/2017_08_14/02.png" alt=""></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 执行</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> sqlType SQL 类型</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> baseStatementUnits 语句对象执行单元集合</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> parameterSets 参数列表集</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> executeCallback 执行回调函数</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> &lt;T&gt; 返回值类型</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 执行结果</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span>  &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">execute</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">       <span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> Collection&lt;? extends BaseStatementUnit&gt; baseStatementUnits, <span class="keyword">final</span> List&lt;List&lt;Object&gt;&gt; parameterSets, <span class="keyword">final</span> ExecuteCallback&lt;T&gt; executeCallback)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (baseStatementUnits.isEmpty()) &#123;</div><div class="line">       <span class="keyword">return</span> Collections.emptyList();</div><div class="line">   &#125;</div><div class="line">   Iterator&lt;? extends BaseStatementUnit&gt; iterator = baseStatementUnits.iterator();</div><div class="line">   BaseStatementUnit firstInput = iterator.next();</div><div class="line">   <span class="comment">// 第二个任务开始所有 SQL任务 提交线程池【异步】执行任务</span></div><div class="line">   ListenableFuture&lt;List&lt;T&gt;&gt; restFutures = asyncExecute(sqlType, Lists.newArrayList(iterator), parameterSets, executeCallback);</div><div class="line">   T firstOutput;</div><div class="line">   List&lt;T&gt; restOutputs;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 第一个任务【同步】执行任务</span></div><div class="line">       firstOutput = syncExecute(sqlType, firstInput, parameterSets, executeCallback);</div><div class="line">       <span class="comment">// 等待第二个任务开始所有 SQL任务完成</span></div><div class="line">       restOutputs = restFutures.get();</div><div class="line">       <span class="comment">//CHECKSTYLE:OFF</span></div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</div><div class="line">       <span class="comment">//CHECKSTYLE:ON</span></div><div class="line">       ExecutorExceptionHandler.handleException(ex);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 返回结果</span></div><div class="line">   List&lt;T&gt; result = Lists.newLinkedList(restOutputs);</div><div class="line">   result.add(<span class="number">0</span>, firstOutput);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>第一个任务<strong>【同步】</strong>调用 <code>#executeInternal()</code> 执行任务。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">syncExecute</span><span class="params">(<span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> BaseStatementUnit baseStatementUnit, <span class="keyword">final</span> List&lt;List&lt;Object&gt;&gt; parameterSets, <span class="keyword">final</span> ExecuteCallback&lt;T&gt; executeCallback)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">   <span class="comment">// 【同步】执行任务</span></div><div class="line">   <span class="keyword">return</span> executeInternal(sqlType, baseStatementUnit, parameterSets, executeCallback, ExecutorExceptionHandler.isExceptionThrown(), ExecutorDataMap.getDataMap());</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>第二个开始的任务<strong>提交线程池异步</strong>调用 <code>#executeInternal()</code> 执行任务。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> &lt;T&gt; ListenableFuture&lt;List&lt;T&gt;&gt; asyncExecute(</div><div class="line">       <span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> Collection&lt;BaseStatementUnit&gt; baseStatementUnits, <span class="keyword">final</span> List&lt;List&lt;Object&gt;&gt; parameterSets, <span class="keyword">final</span> ExecuteCallback&lt;T&gt; executeCallback) &#123;</div><div class="line">   List&lt;ListenableFuture&lt;T&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(baseStatementUnits.size());</div><div class="line">   <span class="keyword">final</span> <span class="keyword">boolean</span> isExceptionThrown = ExecutorExceptionHandler.isExceptionThrown();</div><div class="line">   <span class="keyword">final</span> Map&lt;String, Object&gt; dataMap = ExecutorDataMap.getDataMap();</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">final</span> BaseStatementUnit each : baseStatementUnits) &#123;</div><div class="line">       <span class="comment">// 提交线程池【异步】执行任务</span></div><div class="line">       result.add(executorService.submit(<span class="keyword">new</span> Callable&lt;T&gt;() &#123;</div><div class="line">           </div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">               <span class="keyword">return</span> executeInternal(sqlType, each, parameterSets, executeCallback, isExceptionThrown, dataMap);</div><div class="line">           &#125;</div><div class="line">       &#125;));</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 返回 ListenableFuture</span></div><div class="line">   <span class="keyword">return</span> Futures.allAsList(result);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>我们注意下 <code>Futures.allAsList(result);</code> 和 <code>restOutputs = restFutures.get();</code>。神器 Guava <strong>简化并发编程</strong> 的好处就提现出来了。<code>ListenableFuture#get()</code> 当<strong>所有任务都成功</strong>时，返回所有任务执行结果；当<strong>任何一个任务失败</strong>时，<strong>马上</strong>抛出异常，无需等待其他任务执行完成。</li></ul><p><img src="http://www.iocoder.cn/images/Sharding-JDBC/2017_08_14/03.gif" alt=""></p><p>_😮 Guava 真她喵神器，公众号：<a href="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg">【芋道源码】</a>会更新 Guava 源码分享的一个系列哟！老司机还不赶紧上车？_</p><ul><li>为什么会分同步执行和异步执行呢？猜测，当<strong>SQL 执行是单表时</strong>，只要进行第一个任务的同步调用，性能更加优秀。等跟张亮大神请教确认原因后，咱会进行更新。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ExecutorEngine.java</span></div><div class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">executeInternal</span><span class="params">(<span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> BaseStatementUnit baseStatementUnit, <span class="keyword">final</span> List&lt;List&lt;Object&gt;&gt; parameterSets, <span class="keyword">final</span> ExecuteCallback&lt;T&gt; executeCallback, </span></span></div><div class="line"><span class="function"><span class="params">                     <span class="keyword">final</span> <span class="keyword">boolean</span> isExceptionThrown, <span class="keyword">final</span> Map&lt;String, Object&gt; dataMap)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">   <span class="keyword">synchronized</span> (baseStatementUnit.getStatement().getConnection()) &#123;</div><div class="line">       T result;</div><div class="line">       ExecutorExceptionHandler.setExceptionThrown(isExceptionThrown);</div><div class="line">       ExecutorDataMap.setDataMap(dataMap);</div><div class="line">       List&lt;AbstractExecutionEvent&gt; events = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">       <span class="comment">// 生成 Event</span></div><div class="line">       <span class="keyword">if</span> (parameterSets.isEmpty()) &#123;</div><div class="line">           events.add(getExecutionEvent(sqlType, baseStatementUnit, Collections.emptyList()));</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">for</span> (List&lt;Object&gt; each : parameterSets) &#123;</div><div class="line">               events.add(getExecutionEvent(sqlType, baseStatementUnit, each));</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// EventBus 发布 EventExecutionType.BEFORE_EXECUTE</span></div><div class="line">       <span class="keyword">for</span> (AbstractExecutionEvent event : events) &#123;</div><div class="line">           EventBusInstance.getInstance().post(event);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           <span class="comment">// 执行回调函数</span></div><div class="line">           result = executeCallback.execute(baseStatementUnit);</div><div class="line">       &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">           <span class="comment">// EventBus 发布 EventExecutionType.EXECUTE_FAILURE</span></div><div class="line">           <span class="keyword">for</span> (AbstractExecutionEvent each : events) &#123;</div><div class="line">               each.setEventExecutionType(EventExecutionType.EXECUTE_FAILURE);</div><div class="line">               each.setException(Optional.of(ex));</div><div class="line">               EventBusInstance.getInstance().post(each);</div><div class="line">               ExecutorExceptionHandler.handleException(ex);</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// EventBus 发布 EventExecutionType.EXECUTE_SUCCESS</span></div><div class="line">       <span class="keyword">for</span> (AbstractExecutionEvent each : events) &#123;</div><div class="line">           each.setEventExecutionType(EventExecutionType.EXECUTE_SUCCESS);</div><div class="line">           EventBusInstance.getInstance().post(each);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> result;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>result = executeCallback.execute(baseStatementUnit);</code> 执行回调函数。StatementExecutor，PreparedStatementExecutor，BatchPreparedStatementExecutor 通过传递<strong>执行回调函数</strong>( ExecuteCallback )实现给 ExecutorEngine 实现并行执行。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecuteCallback</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 执行任务.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> baseStatementUnit 语句对象执行单元</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 处理结果</span></div><div class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 执行期异常</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">T <span class="title">execute</span><span class="params">(BaseStatementUnit baseStatementUnit)</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p><code>synchronized (baseStatementUnit.getStatement().getConnection())</code> 原以为 Connection 非线程安全，因此需要用<strong>同步</strong>，后翻查资料<a href="http://blog.csdn.net/goldenfish1919/article/details/9089667" rel="external nofollow noopener noreferrer" target="_blank">《数据库连接池为什么要建立多个连接》</a>，Connection 是线程安全的。等跟张亮大神请教确认原因后，咱会进行更新。</p><ul><li><p>解答：MySQL、Oracle 的 Connection 实现是线程安全的。数据库连接池实现的 Connection 不一定是线程安全，例如 Druid 的线程池 Connection 非线程安全</p><blockquote><p>FROM <a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/166" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/dangdangdotcom/sharding-jdbc/issues/166</a><br>druid的数据源的stat这种filter在并发使用同一个connection链接时没有考虑线程安全的问题，故造成多个线程修改filter中的状态异常。<br>改造这个问题时，考虑到mysql驱动在执行statement时对同一个connection是线程安全的。也就是说同一个数据库链接的会话是串行执行的。故在sjdbc的executor对于多线程执行的情况也进行了针对数据库链接级别的同步。故该方案不会降低sjdbc的性能。<br>同时jdk1.7版本的同步采用了锁升级技术，在碰撞较低的情况下开销也是很小的。</p></blockquote></li></ul></li><li><p>ExecutionEvent 这里先不解释，在本文第四节【EventBus】分享。</p></li><li>ExecutorExceptionHandler、ExecutorDataMap 和 柔性事务 ( AbstractSoftTransaction )，放在<a href="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg">《柔性事务》</a>分享。</li></ul><h1 id="3-Executor"><a href="#3-Executor" class="headerlink" title="3. Executor"></a>3. Executor</h1><p>Executor，执行器，目前一共有三个执行器。不同的执行器对应不同的执行单元 (BaseStatementUnit)。</p><table><thead><tr><th style="text-align:left">执行器类</th><th style="text-align:left">执行器名</th><th style="text-align:left">执行单元</th></tr></thead><tbody><tr><td style="text-align:left">StatementExecutor</td><td style="text-align:left">静态语句对象执行单元</td><td style="text-align:left">StatementUnit</td></tr><tr><td style="text-align:left">PreparedStatementExecutor</td><td style="text-align:left">预编译语句对象请求的执行器</td><td style="text-align:left">PreparedStatementUnit</td></tr><tr><td style="text-align:left">BatchPreparedStatementExecutor</td><td style="text-align:left">批量预编译语句对象请求的执行器</td><td style="text-align:left">BatchPreparedStatementUnit</td></tr></tbody></table><ul><li>执行器提供的方法不同，因此不存在公用接口或者抽象类。</li><li>执行单元继承自 BaseStatementUnit</li></ul><p><img src="http://www.iocoder.cn/images/Sharding-JDBC/2017_08_14/04.png" alt=""></p><h2 id="3-1-StatementExecutor"><a href="#3-1-StatementExecutor" class="headerlink" title="3.1 StatementExecutor"></a>3.1 StatementExecutor</h2><p>StatementExecutor，<strong>多线程</strong>执行静态语句对象请求的执行器，一共有三类方法：</p><ul><li><code>#executeQuery()</code></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// StatementExecutor.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 执行SQL查询.</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 结果集列表</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;ResultSet&gt; <span class="title">executeQuery</span><span class="params">()</span> </span>&#123;</div><div class="line">   Context context = MetricsContext.start(<span class="string">"ShardingStatement-executeQuery"</span>);</div><div class="line">   List&lt;ResultSet&gt; result;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       result = executorEngine.executeStatement(sqlType, statementUnits, <span class="keyword">new</span> ExecuteCallback&lt;ResultSet&gt;() &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> ResultSet <span class="title">execute</span><span class="params">(<span class="keyword">final</span> BaseStatementUnit baseStatementUnit)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">               <span class="keyword">return</span> baseStatementUnit.getStatement().executeQuery(baseStatementUnit.getSqlExecutionUnit().getSql());</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       MetricsContext.stop(context);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>#executeUpdate()</code> 因为有四个不同情况的<code>#executeUpdate()</code>，所以抽象了 Updater 接口，从而达到逻辑重用。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// StatementExecutor.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 执行SQL更新.</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 更新数量</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> executeUpdate(<span class="keyword">new</span> Updater() &#123;</div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">(<span class="keyword">final</span> Statement statement, <span class="keyword">final</span> String sql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">           <span class="keyword">return</span> statement.executeUpdate(sql);</div><div class="line">       &#125;</div><div class="line">   &#125;);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">(<span class="keyword">final</span> Updater updater)</span> </span>&#123;</div><div class="line">   Context context = MetricsContext.start(<span class="string">"ShardingStatement-executeUpdate"</span>);</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       List&lt;Integer&gt; results = executorEngine.executeStatement(sqlType, statementUnits, <span class="keyword">new</span> ExecuteCallback&lt;Integer&gt;() &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> Integer <span class="title">execute</span><span class="params">(<span class="keyword">final</span> BaseStatementUnit baseStatementUnit)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">               <span class="keyword">return</span> updater.executeUpdate(baseStatementUnit.getStatement(), baseStatementUnit.getSqlExecutionUnit().getSql());</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">       <span class="keyword">return</span> accumulate(results);</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       MetricsContext.stop(context);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 计算总的更新数量</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> results 更新数量数组</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 更新数量</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">accumulate</span><span class="params">(<span class="keyword">final</span> List&lt;Integer&gt; results)</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">   <span class="keyword">for</span> (Integer each : results) &#123;</div><div class="line">       result += <span class="keyword">null</span> == each ? <span class="number">0</span> : each;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>#execute()</code> 因为有四个不同情况的<code>#execute()</code>，所以抽象了 Executor 接口，从而达到逻辑重用。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 执行SQL请求.</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> true表示执行DQL语句, false表示执行的DML语句</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> execute(<span class="keyword">new</span> Executor() &#123;</div><div class="line">       </div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Statement statement, <span class="keyword">final</span> String sql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">           <span class="keyword">return</span> statement.execute(sql);</div><div class="line">       &#125;</div><div class="line">   &#125;);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Executor executor)</span> </span>&#123;</div><div class="line">   Context context = MetricsContext.start(<span class="string">"ShardingStatement-execute"</span>);</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       List&lt;Boolean&gt; result = executorEngine.executeStatement(sqlType, statementUnits, <span class="keyword">new</span> ExecuteCallback&lt;Boolean&gt;() &#123; </div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> Boolean <span class="title">execute</span><span class="params">(<span class="keyword">final</span> BaseStatementUnit baseStatementUnit)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">               <span class="keyword">return</span> executor.execute(baseStatementUnit.getStatement(), baseStatementUnit.getSqlExecutionUnit().getSql());</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> == result || result.isEmpty() || <span class="keyword">null</span> == result.get(<span class="number">0</span>)) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> result.get(<span class="number">0</span>);</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       MetricsContext.stop(context);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3-2-PreparedStatementExecutor"><a href="#3-2-PreparedStatementExecutor" class="headerlink" title="3.2 PreparedStatementExecutor"></a>3.2 PreparedStatementExecutor</h2><p>PreparedStatementExecutor，<strong>多线程</strong>执行预编译语句对象请求的执行器。比 StatementExecutor 多了 <code>parameters</code> 参数，方法逻辑上基本一致，就不重复分享啦。</p><h2 id="3-3-BatchPreparedStatementExecutor"><a href="#3-3-BatchPreparedStatementExecutor" class="headerlink" title="3.3 BatchPreparedStatementExecutor"></a>3.3 BatchPreparedStatementExecutor</h2><p>BatchPreparedStatementExecutor，<strong>多线程</strong>执行批量预编译语句对象请求的执行器。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// BatchPreparedStatementExecutor.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 执行批量SQL.</span></div><div class="line"><span class="comment">* </span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 执行结果</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] executeBatch() &#123;</div><div class="line">   Context context = MetricsContext.start(<span class="string">"ShardingPreparedStatement-executeBatch"</span>);</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">return</span> accumulate(executorEngine.executeBatch(sqlType, batchPreparedStatementUnits, parameterSets, <span class="keyword">new</span> ExecuteCallback&lt;<span class="keyword">int</span>[]&gt;() &#123;</div><div class="line">           </div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="keyword">public</span> <span class="keyword">int</span>[] execute(<span class="keyword">final</span> BaseStatementUnit baseStatementUnit) <span class="keyword">throws</span> Exception &#123;</div><div class="line">               <span class="keyword">return</span> baseStatementUnit.getStatement().executeBatch();</div><div class="line">           &#125;</div><div class="line">       &#125;));</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       MetricsContext.stop(context);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 计算每个语句的更新数量</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> results 每条 SQL 更新数量</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 每个语句的更新数量</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] accumulate(<span class="keyword">final</span> List&lt;<span class="keyword">int</span>[]&gt; results) &#123;</div><div class="line">   <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[parameterSets.size()];</div><div class="line">   <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">   <span class="comment">// 每个语句按照顺序，读取到其对应的每个分片SQL影响的行数进行累加</span></div><div class="line">   <span class="keyword">for</span> (BatchPreparedStatementUnit each : batchPreparedStatementUnits) &#123;</div><div class="line">       <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : each.getJdbcAndActualAddBatchCallTimesMap().entrySet()) &#123;</div><div class="line">           result[entry.getKey()] += <span class="keyword">null</span> == results.get(count) ? <span class="number">0</span> : results.get(count)[entry.getValue()];</div><div class="line">       &#125;</div><div class="line">       count++;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>眼尖</strong>的同学会发现，为什么有 BatchPreparedStatementExecutor，而没有 BatchStatementExecutor 呢？目前 Sharding-JDBC 不支持 Statement 批量操作，只能进行 PreparedStatement 的批操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// PreparedStatement 批量操作，不会报错</span></div><div class="line">PreparedStatement ps = conn.prepareStatement(sql)</div><div class="line">ps.addBatch();</div><div class="line">ps.addBatch();</div><div class="line"></div><div class="line"><span class="comment">// Statement 批量操作，会报错</span></div><div class="line">ps.addBatch(sql); <span class="comment">// 报错：at com.dangdang.ddframe.rdb.sharding.jdbc.unsupported.AbstractUnsupportedOperationStatement.addBatch</span></div></pre></td></tr></table></figure><h1 id="4-ExecutionEvent"><a href="#4-ExecutionEvent" class="headerlink" title="4. ExecutionEvent"></a>4. ExecutionEvent</h1><p>AbstractExecutionEvent，SQL 执行事件抽象接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExecutionEvent</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 事件编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String id;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 数据源</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String dataSource;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * SQL</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String sql;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 参数</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; parameters;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 事件类型</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> EventExecutionType eventExecutionType;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 异常</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Optional&lt;SQLException&gt; exception;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>AbstractExecutionEvent 有两个实现子类：</p><ul><li>DMLExecutionEvent：DML类SQL执行时事件</li><li>DQLExecutionEvent：DQL类SQL执行时事件</li></ul><p>EventExecutionType，事件触发类型。</p><ul><li>BEFORE_EXECUTE：执行前</li><li>EXECUTE_SUCCESS：执行成功</li><li>EXECUTE_FAILURE：执行失败</li></ul><h2 id="4-1-EventBus"><a href="#4-1-EventBus" class="headerlink" title="4.1 EventBus"></a>4.1 EventBus</h2><p><strong>那究竟有什么用途呢？</strong> Sharding-JDBC 使用 Guava（<strong>没错，又是它</strong>）的 <strong>EventBus</strong> 实现了<strong>事件的发布和订阅</strong>。从上文 <code>ExecutorEngine#executeInternal()</code> 我们可以看到<strong>每个分片</strong> SQL 执行的过程中会发布相应事件：</p><ul><li>执行 SQL 前：发布类型类型为 BEFORE_EXECUTE 的事件</li><li>执行 SQL 成功：发布类型类型为 EXECUTE_SUCCESS 的事件</li><li>执行 SQL 失败：发布类型类型为 EXECUTE_FAILURE 的事件</li></ul><p><strong>怎么订阅事件呢？</strong>非常简单，例子如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">EventBusInstance.getInstance().register(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Subscribe</span> <span class="comment">// 订阅</span></div><div class="line">  <span class="meta">@AllowConcurrentEvents</span> <span class="comment">// 是否允许并发执行，即线程安全</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(<span class="keyword">final</span> DMLExecutionEvent event)</span> </span>&#123; <span class="comment">// DMLExecutionEvent</span></div><div class="line">      System.out.println(<span class="string">"DMLExecutionEvent："</span> + event.getSql() + <span class="string">"\t"</span> + event.getEventExecutionType());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Subscribe</span> <span class="comment">// 订阅</span></div><div class="line">  <span class="meta">@AllowConcurrentEvents</span> <span class="comment">// 是否允许并发执行，即线程安全</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen2</span><span class="params">(<span class="keyword">final</span> DQLExecutionEvent event)</span> </span>&#123; <span class="comment">//DQLExecutionEvent</span></div><div class="line">      System.out.println(<span class="string">"DQLExecutionEvent："</span> + event.getSql() + <span class="string">"\t"</span> + event.getEventExecutionType());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure><ul><li><code>#register()</code> 任何类都可以，并非一定需要使用 Runnable 类。此处例子单纯因为方便</li><li><code>@Subscribe</code> 注解在方法上，实现对事件的订阅</li><li><code>@AllowConcurrentEvents</code> 注解在方法上，表示线程安全，允许并发执行</li><li>方法上的<strong>参数对应的类</strong>即是订阅的事件。例如，<code>#listen()</code> 订阅了 DMLExecutionEvent 事件</li><li><code>EventBus#post()</code> 发布事件，<strong>同步</strong>调用订阅逻辑</li></ul><p><img src="http://www.iocoder.cn/images/Sharding-JDBC/2017_08_14/05.png" alt=""></p><ul><li>推荐阅读文章：<a href="http://www.cnblogs.com/peida/p/EventBus.html" rel="external nofollow noopener noreferrer" target="_blank">《Guava学习笔记：EventBus》</a></li></ul><blockquote><p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p></blockquote><h2 id="4-2-BestEffortsDeliveryListener"><a href="#4-2-BestEffortsDeliveryListener" class="headerlink" title="4.2 BestEffortsDeliveryListener"></a>4.2 BestEffortsDeliveryListener</h2><p>BestEffortsDeliveryListener，最大努力送达型事务监听器。</p><p>本文暂时暂时不分析其实现，仅仅作为另外一个<strong>订阅者</strong>的例子。我们会在<a href="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg">《柔性事务》</a>进行分享。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BestEffortsDeliveryListener</span> </span>&#123;</div><div class="line">    <span class="meta">@Subscribe</span></div><div class="line">    <span class="meta">@AllowConcurrentEvents</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(<span class="keyword">final</span> DMLExecutionEvent event)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!isProcessContinuously()) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        SoftTransactionConfiguration transactionConfig = SoftTransactionManager.getCurrentTransactionConfiguration().get();</div><div class="line">        TransactionLogStorage transactionLogStorage = TransactionLogStorageFactory.createTransactionLogStorage(transactionConfig.buildTransactionLogDataSource());</div><div class="line">        BEDSoftTransaction bedSoftTransaction = (BEDSoftTransaction) SoftTransactionManager.getCurrentTransaction().get();</div><div class="line">        <span class="keyword">switch</span> (event.getEventExecutionType()) &#123;</div><div class="line">            <span class="keyword">case</span> BEFORE_EXECUTE:</div><div class="line">                <span class="comment">//TODO 对于批量执行的SQL需要解析成两层列表</span></div><div class="line">                transactionLogStorage.add(<span class="keyword">new</span> TransactionLog(event.getId(), bedSoftTransaction.getTransactionId(), bedSoftTransaction.getTransactionType(), </div><div class="line">                        event.getDataSource(), event.getSql(), event.getParameters(), System.currentTimeMillis(), <span class="number">0</span>));</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            <span class="keyword">case</span> EXECUTE_SUCCESS: </div><div class="line">                transactionLogStorage.remove(event.getId());</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            <span class="keyword">case</span> EXECUTE_FAILURE: </div><div class="line">                <span class="keyword">boolean</span> deliverySuccess = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; transactionConfig.getSyncMaxDeliveryTryTimes(); i++) &#123;</div><div class="line">                    <span class="keyword">if</span> (deliverySuccess) &#123;</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">boolean</span> isNewConnection = <span class="keyword">false</span>;</div><div class="line">                    Connection conn = <span class="keyword">null</span>;</div><div class="line">                    PreparedStatement preparedStatement = <span class="keyword">null</span>;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        conn = bedSoftTransaction.getConnection().getConnection(event.getDataSource(), SQLType.UPDATE);</div><div class="line">                        <span class="keyword">if</span> (!isValidConnection(conn)) &#123;</div><div class="line">                            bedSoftTransaction.getConnection().release(conn);</div><div class="line">                            conn = bedSoftTransaction.getConnection().getConnection(event.getDataSource(), SQLType.UPDATE);</div><div class="line">                            isNewConnection = <span class="keyword">true</span>;</div><div class="line">                        &#125;</div><div class="line">                        preparedStatement = conn.prepareStatement(event.getSql());</div><div class="line">                        <span class="comment">//TODO 对于批量事件需要解析成两层列表</span></div><div class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> parameterIndex = <span class="number">0</span>; parameterIndex &lt; event.getParameters().size(); parameterIndex++) &#123;</div><div class="line">                            preparedStatement.setObject(parameterIndex + <span class="number">1</span>, event.getParameters().get(parameterIndex));</div><div class="line">                        &#125;</div><div class="line">                        preparedStatement.executeUpdate();</div><div class="line">                        deliverySuccess = <span class="keyword">true</span>;</div><div class="line">                        transactionLogStorage.remove(event.getId());</div><div class="line">                    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SQLException ex) &#123;</div><div class="line">                        log.error(String.format(<span class="string">"Delivery times %s error, max try times is %s"</span>, i + <span class="number">1</span>, transactionConfig.getSyncMaxDeliveryTryTimes()), ex);</div><div class="line">                    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                        close(isNewConnection, conn, preparedStatement);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            <span class="keyword">default</span>: </div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(event.getEventExecutionType().toString());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>本文完，但也未完。</p><p><strong>跨分片事务问题</strong>。例如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">UPDATE</span> t_order <span class="keyword">SET</span> nickname = ? <span class="keyword">WHERE</span> user_id = ?</div></pre></td></tr></table></figure><p>A 节点 <code>connection.commit()</code> 时，应用突然挂了！B节点 <code>connection.commit()</code> 还来不及执行。<br>我们一起去<a href="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg">《柔性事务》</a>寻找答案。</p><p><strong>道友，分享一波朋友圈可好？</strong></p></div><footer class="article-footer clearfix"><div class="article-categories"><span></span> <a class="article-category-link" href="/categories/Sharding-JDBC/">Sharding-JDBC</a></div><div class="article-share" id="share"><div data-url="http://www.iocoder.cn/Sharding-JDBC/sql-execute/" data-title="Sharding-JDBC 源码分析 —— SQL 执行 | 芋道源码 —— 纯源码解析博客" data-tsina="null" class="share clearfix"></div></div></footer></article><nav class="article-nav clearfix"><div class="prev"><a href="/Sharding-JDBC/result-merger/" title="Sharding-JDBC 源码分析 —— 结果归并"><strong>PREVIOUS:</strong><br><span>Sharding-JDBC 源码分析 —— 结果归并</span></a></div><div class="next"><a href="/Sharding-JDBC/distributed-id/" title="Sharding-JDBC 源码分析 —— 分布式主键"><strong>NEXT:</strong><br><span>Sharding-JDBC 源码分析 —— 分布式主键</span></a></div></nav></div><div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div><div id="toc" class="toc-aside"><strong class="toc-title">文章目录</strong><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-概述"><span class="toc-number">1.</span> <span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-ExecutorEngine"><span class="toc-number">2.</span> <span class="toc-text">2. ExecutorEngine</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-ListeningExecutorService"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 ListeningExecutorService</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-关闭"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 关闭</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-执行-SQL-任务"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 执行 SQL 任务</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Executor"><span class="toc-number">3.</span> <span class="toc-text">3. Executor</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-StatementExecutor"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 StatementExecutor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-PreparedStatementExecutor"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 PreparedStatementExecutor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-BatchPreparedStatementExecutor"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 BatchPreparedStatementExecutor</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-ExecutionEvent"><span class="toc-number">4.</span> <span class="toc-text">4. ExecutionEvent</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-EventBus"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 EventBus</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-BestEffortsDeliveryListener"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 BestEffortsDeliveryListener</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#666-彩蛋"><span class="toc-number">5.</span> <span class="toc-text">666. 彩蛋</span></a></li></ol></div><div id="asidepart"><aside class="clearfix"><div id="authorInfo"><div><img width="100%" src="/images/common/wechat_mp_2017_07_31_bak.jpg"></div><div class="social-list"></div></div><div class="categorieslist"><p class="asidetitle">微信公众号福利：芋道源码</p><ul><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">0. 阅读源码葵花宝典</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">1. RocketMQ / MyCAT / Sharding-JDBC 详细中文注释源码</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">2. 您对于源码的疑问每条留言都将得到认真回复</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">3. 新的源码解析文章实时收到通知，每周六十点更新</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">4. 认真的源码交流微信群</a></li></ul></div><div class="categorieslist"><p class="asidetitle">分类</p><ul><li><a href="/categories/Docker/" title="Docker">Docker<sup>2</sup></a></li><li><a href="/categories/Dubbo/" title="Dubbo">Dubbo<sup>1</sup></a></li><li><a href="/categories/Elastic-Job-Cloud/" title="Elastic-Job-Cloud">Elastic-Job-Cloud<sup>6</sup></a></li><li><a href="/categories/Elastic-Job-Lite/" title="Elastic-Job-Lite">Elastic-Job-Lite<sup>16</sup></a></li><li><a href="/categories/Eureka/" title="Eureka">Eureka<sup>23</sup></a></li><li><a href="/categories/Happylifeplat-TCC/" title="Happylifeplat-TCC">Happylifeplat-TCC<sup>1</sup></a></li><li><a href="/categories/Hystrix/" title="Hystrix">Hystrix<sup>9</sup></a></li><li><a href="/categories/JUC/" title="JUC">JUC<sup>1</sup></a></li><li><a href="/categories/MyCAT/" title="MyCAT">MyCAT<sup>9</sup></a></li><li><a href="/categories/Nginx/" title="Nginx">Nginx<sup>1</sup></a></li><li><a href="/categories/RocketMQ/" title="RocketMQ">RocketMQ<sup>14</sup></a></li><li><a href="/categories/RxJava/" title="RxJava">RxJava<sup>5</sup></a></li><li><a href="/categories/Sharding-JDBC/" title="Sharding-JDBC">Sharding-JDBC<sup>18</sup></a></li><li><a href="/categories/SkyWalking/" title="SkyWalking">SkyWalking<sup>35</sup></a></li><li><a href="/categories/Spring/" title="Spring">Spring<sup>1</sup></a></li><li><a href="/categories/Spring-Cloud-Gateway/" title="Spring-Cloud-Gateway">Spring-Cloud-Gateway<sup>24</sup></a></li><li><a href="/categories/Spring-MVC/" title="Spring-MVC">Spring-MVC<sup>1</sup></a></li><li><a href="/categories/Spring-Security/" title="Spring-Security">Spring-Security<sup>1</sup></a></li><li><a href="/categories/TCC-Transaction/" title="TCC-Transaction">TCC-Transaction<sup>7</sup></a></li><li><a href="/categories/TiKV/" title="TiKV">TiKV<sup>2</sup></a></li><li><a href="/categories/工作内推/" title="工作内推">工作内推<sup>4</sup></a></li><li><a href="/categories/技术杂文/" title="技术杂文">技术杂文<sup>5</sup></a></li><li><a href="/categories/芋道源码的周天/" title="芋道源码的周天">芋道源码的周天<sup>1</sup></a></li></ul></div></aside></div></div><footer><div id="footer"><img src="http://www.iocoder.cn/images/common/wechat_mp_simple.png" style="display:none"><p class="copyright">© 2018 <a href="http://www.iocoder.cn" target="_blank" title="芋道源码">芋道源码</a> && <span style="display:inline" id="busuanzi_container_site_uv">总访客数 <span id="busuanzi_value_site_uv" font="微软雅黑"></span> 次</span> && <span style="display:inline" id="busuanzi_container_site_pv">总访问量 <span id="busuanzi_value_site_pv" font="微软雅黑"></span> 次</span></p></div><div class="copyright">沪ICP备17037075号-1</div></footer><script src="/js/jquery-2.1.0.min.js"></script><script type="text/javascript">$(document).ready(function(){function e(){"number"==typeof window.innerWidth?n=window.innerWidth:document.documentElement&&document.documentElement.clientWidth&&(n=document.documentElement.clientWidth)}$(".navbar").click(function(){$("header nav").toggleClass("shownav")});var n=0,s=$("#main"),a=$("#asidepart"),o=$(".closeaside"),d=$(".openaside");$(window).resize(function(){e(),n>=1024?$("header nav").removeClass("shownav"):(s.removeClass("moveMain"),a.css("display","block").removeClass("fadeOut"),d.css("display","none"),$("#toc.toc-aside").css("display","none"))}),o.click(function(){a.addClass("fadeOut").css("display","none"),d.css("display","block").addClass("fadeIn"),s.addClass("moveMain")}),d.click(function(){d.css("display","none").removeClass("beforeFadeIn"),a.css("display","block").removeClass("fadeOut").addClass("fadeIn"),s.removeClass("moveMain")}),$(window).scroll(function(){d.css("top",Math.max(80,260-$(this).scrollTop()))})})</script><script type="text/javascript">$(document).ready(function(){var a=$(".article-content>iframe"),t=$(".article-content>embed"),n=$("#toc");$("article h2");ah=$("article h2"),ta=$("#toc.toc-aside"),o=$(".openaside"),c=$(".closeaside"),a.length>0&&a.wrap('<div class="video-container" />'),t.length>0&&t.wrap('<div class="video-container" />'),0==ah.length?n.css("display","none"):(c.click(function(){ta.css("display","block").addClass("fadeIn")}),o.click(function(){ta.css("display","none")}),$(window).scroll(function(){ta.css("top",Math.max(140,320-$(this).scrollTop()))}))})</script><script type="text/javascript">$(document).ready(function(){var t=$(".share"),a=t.attr("data-url"),e=encodeURIComponent(a),r=['<a href="#" class="overlay" id="qrcode"></a>','<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url='+e+'"/></div>','<a href="#textlogo" class="article-back-to-top" title="Top"></a>','<a href="https://www.facebook.com/sharer.php?u='+e+'" class="article-share-facebook" target="_blank" title="Facebook"></a>','<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>','<a href="https://twitter.com/intent/tweet?url='+e+'" class="article-share-twitter" target="_blank" title="Twitter"></a>','<a href="http://service.weibo.com/share/share.php?title='+t.attr("data-title")+"&url="+e+"&ralateUid="+t.attr("data-tsina")+'&searchPic=true&style=number" class="article-share-weibo" target="_blank" title="Weibo"></a>','<span title="Share to"></span>'].join("");t.append(r),$(".article-share-qrcode").click(function(){var t=$("#qrcode-pic").attr("data-src");$("#qrcode-pic").attr("src",t),$("#qrcode-pic").load(function(){$(".qrcode strong").text(" ")})})})</script><link rel="stylesheet" href="/alert/css/alert.css"><script src="/alert/js/alert.js"></script><script src="/js/jquery.cookie.js"></script><script src="/js/util.js"></script><script type="text/javascript">!function(e,a,t,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=a.createElement(t),s=a.getElementsByTagName(t)[0],o.async=1,o.src="//www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s)}(window,document,"script",0,"ga"),ga("create","UA-107572620-1","auto"),ga("send","pageview")</script></body>