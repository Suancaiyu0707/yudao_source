<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="google-site-verification" content="GkJ68PCnxM9Ih7Zm9v8p91FOCV7ymNCO2KdGbflLh3E"><meta name="360-site-verification" content="dd6547587641bfede036f7c79561e8a0"><meta name="shenma-site-verification" content="fd96cf3751972c9b05f8471d2ccadddc_1496951214"><meta name="msvalidate.01" content="1D38B05050A977F6FDEDA481198343F1"><meta name="sogou_site_verification" content="MpPsku240L"><title>Sharding-JDBC 源码分析 —— SQL 改写 | 芋道源码 —— 纯源码解析BLOG</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=3,minimum-scale=1"><meta name="author" content="芋道源码"><meta name="description" content="摘要: 原创出处 http://www.iocoder.cn/Sharding-JDBC/sql-rewrite/ 「芋道源码」欢迎转载，保留摘要，谢谢！
本文主要基于 Sharding-JDBC 1.5.0 正式版  

1. 概述
2. SQLToken
3.SQL 改写
3.1 TableTo"><meta name="keywords" content="Sharding-JDBC,ShardingJDBC,Sharding-JDBC 源码,SQL 改写,SQL 优化,Java,架构,后端,服务端,RocketMQ,MyCAT,分布式消息队列,分布式存储,技术博客,Sharding-JDBC,分库分表"><link rel="alternate" href="atom.xml" title="芋道源码 —— 纯源码解析BLOG" type="application/atom+xml"><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/style.css"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?9e70e3362807c1bd185a79655b307027";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script>!function(){var t="http:"==document.location.protocol?"http://js.passport.qihucdn.com/11.0.1.js?f05b61dd54bbc38386611a5238672938":"https://jspassport.ssl.qhimg.com/11.0.1.js?f05b61dd54bbc38386611a5238672938";document.write('<script src="'+t+'" id="sozz"><\/script>')}()</script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></head></html><body><header><div><div id="textlogo"><h1 class="site-name"><a href="/" title="芋道源码 —— 纯源码解析BLOG">芋道源码 —— 纯源码解析BLOG</a></h1><a class="blog-motto">愿半生编码，如一生老友！</a></div><div class="navbar"><a class="navbutton navmobile" href="#" title="菜单"></a></div><nav class="animated"><ul><ul><li><a href="/">文章</a></li><li><a href="https://github.com/YunaiV" rel="external nofollow noopener noreferrer" target="_blank">Github</a></li><li><a href="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31_bak.jpg">微信公众号</a></li><li><a href="/categories/%E5%B7%A5%E4%BD%9C%E5%86%85%E6%8E%A8/">工作内推</a></li><li><a href="/link_url">友链</a></li></ul></ul></nav></div></header><div id="container"><div id="main" class="post" itemscope="" itemprop="blogPost"><article itemprop="articleBody"><header class="article-info clearfix"><h1 itemprop="name"><a href="/Sharding-JDBC/sql-rewrite/" title="Sharding-JDBC 源码分析 —— SQL 改写" itemprop="url">Sharding-JDBC 源码分析 —— SQL 改写</a></h1><p class="article-author"></p><p class="article-time">总阅读量:<span id="busuanzi_value_page_pv"></span>次</p></header><div class="article-content"><p>摘要: 原创出处 <a href="http://www.iocoder.cn/Sharding-JDBC/sql-rewrite/">http://www.iocoder.cn/Sharding-JDBC/sql-rewrite/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Sharding-JDBC 1.5.0 正式版</strong></p><ul><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-rewrite/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-rewrite/">2. SQLToken</a></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-rewrite/">3.SQL 改写</a><ul><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-rewrite/">3.1 TableToken</a></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-rewrite/">3.2 ItemsToken</a></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-rewrite/">3.3 OffsetToken</a></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-rewrite/">3.4 RowCountToken</a><ul><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-rewrite/">3.4.1 分页补充</a></li></ul></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-rewrite/">3.5 OrderByToken</a></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-rewrite/">3.6 GeneratedKeyToken</a></li></ul></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-rewrite/">4. SQL 生成</a></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-rewrite/">666. 彩蛋</a></li></ul><hr><p><img src="https://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>前置阅读：<a href="http://www.iocoder.cn/Sharding-JDBC/sql-parse-3/?mp">《SQL 解析（三）之查询SQL》</a></p><p>本文分享<strong>SQL 改写</strong>的源码实现。主要涉及两方面：</p><ol><li>SQL 改写：改写 SQL，解决分库分表后，查询结果需要聚合，需要对 SQL 进行调整，例如分页</li><li>SQL 生成：生成分表分库的执行 SQL</li></ol><p>SQLRewriteEngine，SQL重写引擎，实现 SQL 改写、生成功能。从 Sharding-JDBC 1.5.0 版本，SQL 改写进行了调整和大量优化。</p><blockquote><p>1.4.x及之前版本，SQL改写是在SQL路由之前完成的，在1.5.x中调整为SQL路由之后，因为SQL改写可以根据路由至单库表还是多库表而进行进一步优化。</p></blockquote><p>😆 很多同学看完<a href="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg">《SQL 解析-系列》</a> 可能是一脸懵逼，特别对<strong>“SQL 半理解”</strong>。<img src="http://www.iocoder.cn/images/Sharding-JDBC/2017_08_10/01.png" alt="">希望本文能给你一些启发。</p><blockquote><p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p></blockquote><h1 id="2-SQLToken"><a href="#2-SQLToken" class="headerlink" title="2. SQLToken"></a>2. SQLToken</h1><p>😁 SQLToken 在本文中很重要，所以即使在<a href="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg">《SQL 解析-系列》</a>已经分享过，我们也换个姿势，再来一次。</p><p>SQLToken，SQL标记对象<strong>接口</strong>。SQLRewriteEngine 基于 SQLToken 实现 <strong>SQL改写</strong>。SQL解析器在 SQL解析过程中，很重要的一个目的是<strong>标记需要SQL改写的部分</strong>，也就是 SQLToken。</p><p><img src="http://www.iocoder.cn/images/Sharding-JDBC/2017_08_10/02.png" alt=""></p><p><strong>各 SQLToken 生成条件如下</strong>(<em>悲伤，做成表格形式排版是乱的</em>)：</p><ol><li>GeneratedKeyToken 自增主键标记对象<ul><li>插入SQL自增列不存在：<code>INSERT INTO t_order(nickname) VALUES ...</code> 中没有自增列 <code>order_id</code></li></ul></li><li>TableToken 表标记对象<ul><li>查询列的表别名：<code>SELECT o.order_id</code> 的 <code>o</code></li><li>查询的表名：<code>SELECT * FROM t_order</code> 的 <code>t_order</code></li></ul></li><li>ItemsToken 选择项标记对象<ul><li>AVG查询列：<code>SELECT AVG(price) FROM t_order</code> 的 <code>AVG(price)</code></li><li>ORDER BY 字段不在查询列：<code>SELECT order_id FROM t_order ORDER BY create_time</code> 的 <code>create_time</code></li><li>GROUP BY 字段不在查询列：<code>SELECT COUNT(order_id) FROM t_order GROUP BY user_id</code> 的 <code>user_id</code></li><li>自增主键未在插入列中：<code>INSERT INTO t_order(nickname) VALUES ...</code> 中没有自增列 <code>order_id</code></li></ul></li><li>OffsetToken 分页偏移量标记对象<ul><li>分页有偏移量，但<strong>不是</strong>占位符 <code>?</code></li></ul></li><li>RowCountToken 分页长度标记对象<ul><li>分页有长度，但<strong>不是</strong>占位符 <code>?</code></li></ul></li><li>OrderByToken 排序标记对象<ul><li>有 GROUP BY 条件，无 ORDER BY 条件：<code>SELECT COUNT(*) FROM t_order GROUP BY order_id</code> 的 <code>order_id</code></li></ul></li></ol><h1 id="3-SQL-改写"><a href="#3-SQL-改写" class="headerlink" title="3.SQL 改写"></a>3.SQL 改写</h1><p><code>SQLRewriteEngine#rewrite()</code> 实现了 <strong>SQL改写</strong> 功能。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLRewriteEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* SQL改写.</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> isRewriteLimit 是否重写Limit</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> SQL构建器</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> SQLBuilder <span class="title">rewrite</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> isRewriteLimit)</span> </span>&#123;</div><div class="line">   SQLBuilder result = <span class="keyword">new</span> SQLBuilder();</div><div class="line">   <span class="keyword">if</span> (sqlTokens.isEmpty()) &#123;</div><div class="line">       result.appendLiterals(originalSQL);</div><div class="line">       <span class="keyword">return</span> result;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">   <span class="comment">// 排序SQLToken，按照 beginPosition 递增</span></div><div class="line">   sortByBeginPosition();</div><div class="line">   <span class="keyword">for</span> (SQLToken each : sqlTokens) &#123;</div><div class="line">       <span class="keyword">if</span> (<span class="number">0</span> == count) &#123; <span class="comment">// 拼接第一个 SQLToken 前的字符串</span></div><div class="line">           result.appendLiterals(originalSQL.substring(<span class="number">0</span>, each.getBeginPosition()));</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 拼接每个SQLToken</span></div><div class="line">       <span class="keyword">if</span> (each <span class="keyword">instanceof</span> TableToken) &#123;</div><div class="line">           appendTableToken(result, (TableToken) each, count, sqlTokens);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (each <span class="keyword">instanceof</span> ItemsToken) &#123;</div><div class="line">           appendItemsToken(result, (ItemsToken) each, count, sqlTokens);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (each <span class="keyword">instanceof</span> RowCountToken) &#123;</div><div class="line">           appendLimitRowCount(result, (RowCountToken) each, count, sqlTokens, isRewriteLimit);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (each <span class="keyword">instanceof</span> OffsetToken) &#123;</div><div class="line">           appendLimitOffsetToken(result, (OffsetToken) each, count, sqlTokens, isRewriteLimit);</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (each <span class="keyword">instanceof</span> OrderByToken) &#123;</div><div class="line">           appendOrderByToken(result);</div><div class="line">       &#125;</div><div class="line">       count++;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>SQL改写以 SQLToken 为<strong>间隔</strong>，<strong>顺序</strong>改写。<ul><li>顺序：调用 <code>#sortByBeginPosition()</code> 将 SQLToken 按照 <code>beginPosition</code> <strong>升序</strong>。</li><li>间隔：遍历 SQLToken，逐个拼接。</li></ul></li></ul><p>例如：<br><img src="http://www.iocoder.cn/images/Sharding-JDBC/2017_08_10/03.png" alt=""></p><hr><p>SQLBuilder，SQL构建器。下文会大量用到，我们看下实现代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SQLBuilder</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 段集合</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; segments;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 当前段</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> StringBuilder currentSegment;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SQLBuilder</span><span class="params">()</span> </span>&#123;</div><div class="line">        segments = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">        currentSegment = <span class="keyword">new</span> StringBuilder();</div><div class="line">        segments.add(currentSegment);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 追加字面量.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> literals 字面量</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendLiterals</span><span class="params">(<span class="keyword">final</span> String literals)</span> </span>&#123;</div><div class="line">        currentSegment.append(literals);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 追加表占位符.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> tableName 表名称</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTable</span><span class="params">(<span class="keyword">final</span> String tableName)</span> </span>&#123;</div><div class="line">        <span class="comment">// 添加 TableToken</span></div><div class="line">        segments.add(<span class="keyword">new</span> TableToken(tableName));</div><div class="line">        <span class="comment">// 新建当前段</span></div><div class="line">        currentSegment = <span class="keyword">new</span> StringBuilder();</div><div class="line">        segments.add(currentSegment);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toSQL</span><span class="params">(<span class="keyword">final</span> Map&lt;String, String&gt; tableTokens)</span> </span>&#123;</div><div class="line">        <span class="comment">// ... 省略代码，【SQL生成】处分享</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@RequiredArgsConstructor</span></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TableToken</span> </span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 表名</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String tableName;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><p>现在我们来逐个分析每种 SQLToken 的<strong>拼接</strong>实现。</p><h2 id="3-1-TableToken"><a href="#3-1-TableToken" class="headerlink" title="3.1 TableToken"></a>3.1 TableToken</h2><p>调用 <code>#appendTableToken()</code> 方法拼接。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLRewriteEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 拼接 TableToken</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> sqlBuilder SQL构建器</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> tableToken tableToken</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> count tableToken 在 sqlTokens 的顺序</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> sqlTokens sqlTokens</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendTableToken</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder, <span class="keyword">final</span> TableToken tableToken, <span class="keyword">final</span> <span class="keyword">int</span> count, <span class="keyword">final</span> List&lt;SQLToken&gt; sqlTokens)</span> </span>&#123;</div><div class="line">   <span class="comment">// 拼接 TableToken</span></div><div class="line">   String tableName = sqlStatement.getTables().getTableNames().contains(tableToken.getTableName()) ? tableToken.getTableName() : tableToken.getOriginalLiterals();</div><div class="line">   sqlBuilder.appendTable(tableName);</div><div class="line">   <span class="comment">// 拼接 SQLToken 后面的字符串</span></div><div class="line">   <span class="keyword">int</span> beginPosition = tableToken.getBeginPosition() + tableToken.getOriginalLiterals().length();</div><div class="line">   <span class="keyword">int</span> endPosition = sqlTokens.size() - <span class="number">1</span> == count ? originalSQL.length() : sqlTokens.get(count + <span class="number">1</span>).getBeginPosition();</div><div class="line">   sqlBuilder.appendLiterals(originalSQL.substring(beginPosition, endPosition));</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>SQLBuilder#appendTable()</code> 拼接 TableToken。</li><li><code>sqlStatement.getTables().getTableNames().contains(tableToken.getTableName())</code> 目的是处理掉<strong>表名前后有的特殊字符</strong>，例如<code>SELECT * FROM &#39;t_order&#39;</code> 中 <code>t_order</code> 前后有 <code>&#39;</code> 符号。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TableToken.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获取表名称.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getTableName</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> SQLUtil.getExactlyValue(originalLiterals);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// SQLUtil.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getExactlyValue</span><span class="params">(<span class="keyword">final</span> String value)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">null</span> == value ? <span class="keyword">null</span> : CharMatcher.anyOf(<span class="string">"[]`'\""</span>).removeFrom(value);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>当 SQL 为 <code>SELECT o.* FROM t_order o</code><ul><li>TableToken 为查询列前的表别名 <code>o</code> 时返回结果：<br><img src="http://www.iocoder.cn/images/Sharding-JDBC/2017_08_10/04.png" alt=""></li><li>TableToken 为表名 <code>t_order</code> 时返回结果：<br><img src="http://www.iocoder.cn/images/Sharding-JDBC/2017_08_10/05.png" alt=""></li></ul></li></ul><h2 id="3-2-ItemsToken"><a href="#3-2-ItemsToken" class="headerlink" title="3.2 ItemsToken"></a>3.2 ItemsToken</h2><p>调用 <code>#appendItemsToken()</code> 方法拼接。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLRewriteEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 拼接 TableToken</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> sqlBuilder SQL构建器</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> itemsToken itemsToken</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> count itemsToken 在 sqlTokens 的顺序</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> sqlTokens sqlTokens</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendItemsToken</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder, <span class="keyword">final</span> ItemsToken itemsToken, <span class="keyword">final</span> <span class="keyword">int</span> count, <span class="keyword">final</span> List&lt;SQLToken&gt; sqlTokens)</span> </span>&#123;</div><div class="line">   <span class="comment">// 拼接 ItemsToken</span></div><div class="line">   <span class="keyword">for</span> (String item : itemsToken.getItems()) &#123;</div><div class="line">       sqlBuilder.appendLiterals(<span class="string">", "</span>);</div><div class="line">       sqlBuilder.appendLiterals(item);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// SQLToken 后面的字符串</span></div><div class="line">   <span class="keyword">int</span> beginPosition = itemsToken.getBeginPosition();</div><div class="line">   <span class="keyword">int</span> endPosition = sqlTokens.size() - <span class="number">1</span> == count ? originalSQL.length() : sqlTokens.get(count + <span class="number">1</span>).getBeginPosition();</div><div class="line">   sqlBuilder.appendLiterals(originalSQL.substring(beginPosition, endPosition));</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>第一种情况，<strong>AVG查询列</strong>，SQL 为 <code>SELECT AVG(order_id) FROM t_order o</code> 时返回结果：<br><img src="http://www.iocoder.cn/images/Sharding-JDBC/2017_08_10/06.png" alt=""></li><li>第二种情况，<strong>ORDER BY 字段不在查询列</strong>，SQL 为 <code>SELECT userId FROM t_order o ORDER BY order_id</code> 时返回结果：<br><img src="http://www.iocoder.cn/images/Sharding-JDBC/2017_08_10/07.png" alt=""></li><li>第三种情况，<strong>GROUP BY 字段不在查询列</strong>，类似第二种情况，就不举例子列。</li></ul><h2 id="3-3-OffsetToken"><a href="#3-3-OffsetToken" class="headerlink" title="3.3 OffsetToken"></a>3.3 OffsetToken</h2><p>调用 <code>#appendLimitOffsetToken()</code> 方法拼接。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLRewriteEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 拼接 OffsetToken</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> sqlBuilder SQL构建器</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> offsetToken offsetToken</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> count offsetToken 在 sqlTokens 的顺序</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> sqlTokens sqlTokens</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> isRewrite 是否重写。当路由结果为单分片时无需重写</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendLimitOffsetToken</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder, <span class="keyword">final</span> OffsetToken offsetToken, <span class="keyword">final</span> <span class="keyword">int</span> count, <span class="keyword">final</span> List&lt;SQLToken&gt; sqlTokens, <span class="keyword">final</span> <span class="keyword">boolean</span> isRewrite)</span> </span>&#123;</div><div class="line">   <span class="comment">// 拼接 OffsetToken</span></div><div class="line">   sqlBuilder.appendLiterals(isRewrite ? <span class="string">"0"</span> : String.valueOf(offsetToken.getOffset()));</div><div class="line">   <span class="comment">// SQLToken 后面的字符串</span></div><div class="line">   <span class="keyword">int</span> beginPosition = offsetToken.getBeginPosition() + String.valueOf(offsetToken.getOffset()).length();</div><div class="line">   <span class="keyword">int</span> endPosition = sqlTokens.size() - <span class="number">1</span> == count ? originalSQL.length() : sqlTokens.get(count + <span class="number">1</span>).getBeginPosition();</div><div class="line">   sqlBuilder.appendLiterals(originalSQL.substring(beginPosition, endPosition));</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>当分页<strong>跨分片</strong>时，需要每个分片都查询后在<strong>内存</strong>中进行聚合。此时 <code>isRewrite = true</code>。为什么是 <code>&quot;0&quot;</code> 开始呢？每个分片在 [0, offset) 的记录<strong>可能</strong>属于实际分页结果，因而查询每个分片需要从 0 开始。</li><li>当分页<strong>单分片</strong>时，则无需重写，该分片执行的结果即是最终结果。<strong>SQL改写在SQL路由之后就有这个好处</strong>。如果先改写，因为没办法知道最终是单分片还是跨分片，考虑正确性，只能统一使用跨分片。</li></ul><h2 id="3-4-RowCountToken"><a href="#3-4-RowCountToken" class="headerlink" title="3.4 RowCountToken"></a>3.4 RowCountToken</h2><p>调用 <code>#appendLimitRowCount()</code> 方法拼接。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLRewriteEngine.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendLimitRowCount</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder, <span class="keyword">final</span> RowCountToken rowCountToken, <span class="keyword">final</span> <span class="keyword">int</span> count, <span class="keyword">final</span> List&lt;SQLToken&gt; sqlTokens, <span class="keyword">final</span> <span class="keyword">boolean</span> isRewrite)</span> </span>&#123;</div><div class="line">   SelectStatement selectStatement = (SelectStatement) sqlStatement;</div><div class="line">   Limit limit = selectStatement.getLimit();</div><div class="line">   <span class="keyword">if</span> (!isRewrite) &#123; <span class="comment">// 路由结果为单分片</span></div><div class="line">       sqlBuilder.appendLiterals(String.valueOf(rowCountToken.getRowCount()));</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((!selectStatement.getGroupByItems().isEmpty() || <span class="comment">// [1.1] 跨分片分组需要在内存计算，可能需要全部加载</span></div><div class="line">           !selectStatement.getAggregationSelectItems().isEmpty()) <span class="comment">// [1.2] 跨分片聚合列需要在内存计算，可能需要全部加载</span></div><div class="line">           &amp;&amp; !selectStatement.isSameGroupByAndOrderByItems()) &#123; <span class="comment">// [2] 如果排序一致，即各分片已经排序好结果，就不需要全部加载</span></div><div class="line">       sqlBuilder.appendLiterals(String.valueOf(Integer.MAX_VALUE));</div><div class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">// 路由结果为多分片</span></div><div class="line">       sqlBuilder.appendLiterals(String.valueOf(limit.isRowCountRewriteFlag() ? rowCountToken.getRowCount() + limit.getOffsetValue() : rowCountToken.getRowCount()));</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// SQLToken 后面的字符串</span></div><div class="line">   <span class="keyword">int</span> beginPosition = rowCountToken.getBeginPosition() + String.valueOf(rowCountToken.getRowCount()).length();</div><div class="line">   <span class="keyword">int</span> endPosition = sqlTokens.size() - <span class="number">1</span> == count ? originalSQL.length() : sqlTokens.get(count + <span class="number">1</span>).getBeginPosition();</div><div class="line">   sqlBuilder.appendLiterals(originalSQL.substring(beginPosition, endPosition));</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>[1.1] <code>!selectStatement.getGroupByItems().isEmpty()</code> 跨分片<strong>分组</strong>需要在内存计算，<strong>可能</strong>需要全部加载。如果不全部加载，部分结果被分页条件错误结果，会导致结果不正确。</li><li>[1.2] <code>!selectStatement.getAggregationSelectItems().isEmpty())</code> 跨分片<strong>聚合列</strong>需要在内存计算，<strong>可能</strong>需要全部加载。如果不全部加载，部分结果被分页条件错误结果，会导致结果不正确。</li><li>[1.1][1.2]，<strong>可能</strong>变成必须的前提是 GROUP BY 和 ORDER BY 排序不一致。如果一致，各分片已经排序完成，无需内存中排序。</li></ul><h3 id="3-4-1-分页补充"><a href="#3-4-1-分页补充" class="headerlink" title="3.4.1 分页补充"></a>3.4.1 分页补充</h3><p>OffsetToken、RowCountToken 只有在分页对应位置非占位符 <code>?</code> 才存在。当对应位置是占位符时，会对<strong>分页条件对应的预编译 SQL 占位符参数</strong>进行重写，<strong>整体逻辑和 OffsetToken、RowCountToken 是一致的</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 👼 ParsingSQLRouter#route() 调用 #processLimit() </span></div><div class="line"></div><div class="line"><span class="comment">// ParsingSQLRouter.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 处理分页条件</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@see</span> SQLRewriteEngine#appendLimitRowCount(SQLBuilder, RowCountToken, int, List, boolean) </span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> parameters 占位符对应参数列表</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> selectStatement Select SQL语句对象</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> isSingleRouting 是否单表路由</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processLimit</span><span class="params">(<span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> SelectStatement selectStatement, <span class="keyword">final</span> <span class="keyword">boolean</span> isSingleRouting)</span> </span>&#123;</div><div class="line">   <span class="keyword">boolean</span> isNeedFetchAll = (!selectStatement.getGroupByItems().isEmpty() <span class="comment">// // [1.1] 跨分片分组需要在内存计算，可能需要全部加载</span></div><div class="line">                               || !selectStatement.getAggregationSelectItems().isEmpty()) <span class="comment">// [1.2] 跨分片聚合列需要在内存计算，可能需要全部加载</span></div><div class="line">                           &amp;&amp; !selectStatement.isSameGroupByAndOrderByItems(); <span class="comment">// [2] 如果排序一致，即各分片已经排序好结果，就不需要全部加载</span></div><div class="line">   selectStatement.getLimit().processParameters(parameters, !isSingleRouting, isNeedFetchAll);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Limit.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 填充改写分页参数.</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> parameters 参数</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> isRewrite 是否重写参数</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> isFetchAll 是否获取所有数据</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processParameters</span><span class="params">(<span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> <span class="keyword">boolean</span> isRewrite, <span class="keyword">final</span> <span class="keyword">boolean</span> isFetchAll)</span> </span>&#123;</div><div class="line">   fill(parameters);</div><div class="line">   <span class="keyword">if</span> (isRewrite) &#123;</div><div class="line">       rewrite(parameters, isFetchAll);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 将占位符参数里是分页的参数赋值给 offset 、rowCount</span></div><div class="line"><span class="comment">* 赋值的前提条件是 offset、rowCount 是 占位符</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> parameters 占位符参数</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">final</span> List&lt;Object&gt; parameters)</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> offset = <span class="number">0</span>;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != <span class="keyword">this</span>.offset) &#123;</div><div class="line">       offset = -<span class="number">1</span> == <span class="keyword">this</span>.offset.getIndex() ? getOffsetValue() : NumberUtil.roundHalfUp(parameters.get(<span class="keyword">this</span>.offset.getIndex()));</div><div class="line">       <span class="keyword">this</span>.offset.setValue(offset);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">int</span> rowCount = <span class="number">0</span>;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != <span class="keyword">this</span>.rowCount) &#123;</div><div class="line">       rowCount = -<span class="number">1</span> == <span class="keyword">this</span>.rowCount.getIndex() ? getRowCountValue() : NumberUtil.roundHalfUp(parameters.get(<span class="keyword">this</span>.rowCount.getIndex()));</div><div class="line">       <span class="keyword">this</span>.rowCount.setValue(rowCount);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (offset &lt; <span class="number">0</span> || rowCount &lt; <span class="number">0</span>) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> SQLParsingException(<span class="string">"LIMIT offset and row count can not be a negative value."</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 重写分页条件对应的参数</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> parameters 参数</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> isFetchAll 是否拉取所有</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rewrite</span><span class="params">(<span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> <span class="keyword">boolean</span> isFetchAll)</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> rewriteOffset = <span class="number">0</span>;</div><div class="line">   <span class="keyword">int</span> rewriteRowCount;</div><div class="line">   <span class="comment">// 重写</span></div><div class="line">   <span class="keyword">if</span> (isFetchAll) &#123;</div><div class="line">       rewriteRowCount = Integer.MAX_VALUE;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rowCountRewriteFlag) &#123;</div><div class="line">       rewriteRowCount = <span class="keyword">null</span> == rowCount ? -<span class="number">1</span> : getOffsetValue() + rowCount.getValue();</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       rewriteRowCount = rowCount.getValue();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 参数设置</span></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != offset &amp;&amp; offset.getIndex() &gt; -<span class="number">1</span>) &#123;</div><div class="line">       parameters.set(offset.getIndex(), rewriteOffset);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != rowCount &amp;&amp; rowCount.getIndex() &gt; -<span class="number">1</span>) &#123;</div><div class="line">       parameters.set(rowCount.getIndex(), rewriteRowCount);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3-5-OrderByToken"><a href="#3-5-OrderByToken" class="headerlink" title="3.5 OrderByToken"></a>3.5 OrderByToken</h2><p>调用 <code>#appendOrderByToken()</code> 方法拼接。数据库里，当无 ORDER BY条件 而有 GROUP BY 条件时候，会使用 GROUP BY条件将结果升序排序：</p><ul><li><code>SELECT order_id FROM t_order GROUP BY order_id</code> 等价于 <code>SELECT order_id FROM t_order GROUP BY order_id ORDER BY order_id ASC</code></li><li><code>SELECT order_id FROM t_order GROUP BY order_id DESC</code> 等价于 <code>SELECT order_id FROM t_order GROUP BY order_id ORDER BY order_id DESC</code></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ParsingSQLRouter.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 拼接 OrderByToken</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> sqlBuilder SQL构建器</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendOrderByToken</span><span class="params">(<span class="keyword">final</span> SQLBuilder sqlBuilder)</span> </span>&#123;</div><div class="line">   SelectStatement selectStatement = (SelectStatement) sqlStatement;</div><div class="line">   <span class="comment">// 拼接 OrderByToken</span></div><div class="line">   StringBuilder orderByLiterals = <span class="keyword">new</span> StringBuilder(<span class="string">" ORDER BY "</span>);</div><div class="line">   <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">   <span class="keyword">for</span> (OrderItem each : selectStatement.getOrderByItems()) &#123;</div><div class="line">       <span class="keyword">if</span> (<span class="number">0</span> == i) &#123;</div><div class="line">           orderByLiterals.append(each.getColumnLabel()).append(<span class="string">" "</span>).append(each.getType().name());</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           orderByLiterals.append(<span class="string">","</span>).append(each.getColumnLabel()).append(<span class="string">" "</span>).append(each.getType().name());</div><div class="line">       &#125;</div><div class="line">       i++;</div><div class="line">   &#125;</div><div class="line">   orderByLiterals.append(<span class="string">" "</span>);</div><div class="line">   sqlBuilder.appendLiterals(orderByLiterals.toString());</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>当 SQL 为 <code>SELECT order_id FROM t_order o GROUP BY order_id</code> 返回结果：<br><img src="http://www.iocoder.cn/images/Sharding-JDBC/2017_08_10/08.png" alt=""></li></ul><h2 id="3-6-GeneratedKeyToken"><a href="#3-6-GeneratedKeyToken" class="headerlink" title="3.6 GeneratedKeyToken"></a>3.6 GeneratedKeyToken</h2><p>前置阅读：<a href="http://www.iocoder.cn/Sharding-JDBC/sql-parse-4/?mp">《SQL 解析（四）之插入SQL》</a></p><p>GeneratedKeyToken，和其它 SQLToken 不同，在 <strong>SQL解析</strong> 完进行处理。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ParsingSQLRouter.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> SQLStatement <span class="title">parse</span><span class="params">(<span class="keyword">final</span> String logicSQL, <span class="keyword">final</span> <span class="keyword">int</span> parametersSize)</span> </span>&#123;</div><div class="line">   SQLParsingEngine parsingEngine = <span class="keyword">new</span> SQLParsingEngine(databaseType, logicSQL, shardingRule);</div><div class="line">   Context context = MetricsContext.start(<span class="string">"Parse SQL"</span>);</div><div class="line">   SQLStatement result = parsingEngine.parse();</div><div class="line">   <span class="keyword">if</span> (result <span class="keyword">instanceof</span> InsertStatement) &#123; <span class="comment">// 处理 GenerateKeyToken</span></div><div class="line">       ((InsertStatement) result).appendGenerateKeyToken(shardingRule, parametersSize);</div><div class="line">   &#125;</div><div class="line">   MetricsContext.stop(context);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// InsertStatement.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 追加自增主键标记对象.</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> shardingRule 分片规则</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> parametersSize 参数个数</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendGenerateKeyToken</span><span class="params">(<span class="keyword">final</span> ShardingRule shardingRule, <span class="keyword">final</span> <span class="keyword">int</span> parametersSize)</span> </span>&#123;</div><div class="line">   <span class="comment">// SQL 里有主键列</span></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != generatedKey) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// TableRule 存在</span></div><div class="line">   Optional&lt;TableRule&gt; tableRule = shardingRule.tryFindTableRule(getTables().getSingleTableName());</div><div class="line">   <span class="keyword">if</span> (!tableRule.isPresent()) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// GeneratedKeyToken 存在</span></div><div class="line">   Optional&lt;GeneratedKeyToken&gt; generatedKeysToken = findGeneratedKeyToken();</div><div class="line">   <span class="keyword">if</span> (!generatedKeysToken.isPresent()) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 处理 GenerateKeyToken</span></div><div class="line">   ItemsToken valuesToken = <span class="keyword">new</span> ItemsToken(generatedKeysToken.get().getBeginPosition());</div><div class="line">   <span class="keyword">if</span> (<span class="number">0</span> == parametersSize) &#123;</div><div class="line">       appendGenerateKeyToken(shardingRule, tableRule.get(), valuesToken);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       appendGenerateKeyToken(shardingRule, tableRule.get(), valuesToken, parametersSize);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 移除 generatedKeysToken</span></div><div class="line">   getSqlTokens().remove(generatedKeysToken.get());</div><div class="line">   <span class="comment">// 新增 ItemsToken</span></div><div class="line">   getSqlTokens().add(valuesToken);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>根据<strong>占位符参数</strong>数量不同，调用的 <code>#appendGenerateKeyToken()</code> 是<strong>不同</strong>的：</li><li><strong>占位符参数数量 = 0</strong> 时，直接生成<strong>分布式主键</strong>，保持无占位符的做法。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// InsertStatement.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendGenerateKeyToken</span><span class="params">(<span class="keyword">final</span> ShardingRule shardingRule, <span class="keyword">final</span> TableRule tableRule, <span class="keyword">final</span> ItemsToken valuesToken)</span> </span>&#123;</div><div class="line">   <span class="comment">// 生成分布式主键</span></div><div class="line">   Number generatedKey = shardingRule.generateKey(tableRule.getLogicTable());</div><div class="line">   <span class="comment">// 添加到 ItemsToken</span></div><div class="line">   valuesToken.getItems().add(generatedKey.toString());</div><div class="line">   <span class="comment">// 增加 Condition，用于路由</span></div><div class="line">   getConditions().add(<span class="keyword">new</span> Condition(<span class="keyword">new</span> Column(tableRule.getGenerateKeyColumn(), tableRule.getLogicTable()), <span class="keyword">new</span> SQLNumberExpression(generatedKey)), shardingRule);</div><div class="line">   <span class="comment">// 生成 GeneratedKey</span></div><div class="line">   <span class="keyword">this</span>.generatedKey = <span class="keyword">new</span> GeneratedKey(tableRule.getLogicTable(), -<span class="number">1</span>, generatedKey);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>占位符参数数量 &gt; 0</strong> 时，生成自增列的占位符，保持有占位符的做法。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendGenerateKeyToken</span><span class="params">(<span class="keyword">final</span> ShardingRule shardingRule, <span class="keyword">final</span> TableRule tableRule, <span class="keyword">final</span> ItemsToken valuesToken, <span class="keyword">final</span> <span class="keyword">int</span> parametersSize)</span> </span>&#123;</div><div class="line">   <span class="comment">// 生成占位符</span></div><div class="line">   valuesToken.getItems().add(<span class="string">"?"</span>);</div><div class="line">   <span class="comment">// 增加 Condition，用于路由</span></div><div class="line">   getConditions().add(<span class="keyword">new</span> Condition(<span class="keyword">new</span> Column(tableRule.getGenerateKeyColumn(), tableRule.getLogicTable()), <span class="keyword">new</span> SQLPlaceholderExpression(parametersSize)), shardingRule);</div><div class="line">   <span class="comment">// 生成 GeneratedKey</span></div><div class="line">   generatedKey = <span class="keyword">new</span> GeneratedKey(tableRule.getGenerateKeyColumn(), parametersSize, <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>因为 GenerateKeyToken 已经处理完，所以移除，避免 <code>SQLRewriteEngine#rewrite()</code> 二次改写。另外，通过 ItemsToken 补充自增列。</li><li>生成 GeneratedKey 会在 ParsingSQLRouter 进一步处理。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ParsingSQLRouter.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> SQLRouteResult <span class="title">route</span><span class="params">(<span class="keyword">final</span> String logicSQL, <span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> SQLStatement sqlStatement)</span> </span>&#123;</div><div class="line">   <span class="keyword">final</span> Context context = MetricsContext.start(<span class="string">"Route SQL"</span>);</div><div class="line">   SQLRouteResult result = <span class="keyword">new</span> SQLRouteResult(sqlStatement);</div><div class="line">   <span class="comment">// 处理 插入SQL 主键字段</span></div><div class="line">   <span class="keyword">if</span> (sqlStatement <span class="keyword">instanceof</span> InsertStatement &amp;&amp; <span class="keyword">null</span> != ((InsertStatement) sqlStatement).getGeneratedKey()) &#123;</div><div class="line">       processGeneratedKey(parameters, (InsertStatement) sqlStatement, result);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// ... 省略部分代码</span></div><div class="line">&#125;  </div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 处理 插入SQL 主键字段</span></div><div class="line"><span class="comment">* 当 主键编号 未生成时，&#123;<span class="doctag">@link</span> ShardingRule#generateKey(String)&#125; 进行生成</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> parameters 占位符参数</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> insertStatement Insert SQL语句对象</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> sqlRouteResult SQL路由结果</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processGeneratedKey</span><span class="params">(<span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> InsertStatement insertStatement, <span class="keyword">final</span> SQLRouteResult sqlRouteResult)</span> </span>&#123;</div><div class="line">   GeneratedKey generatedKey = insertStatement.getGeneratedKey();</div><div class="line">   <span class="keyword">if</span> (parameters.isEmpty()) &#123; <span class="comment">// 已有主键，无占位符，INSERT INTO t_order(order_id, user_id) VALUES (1, 100);</span></div><div class="line">       sqlRouteResult.getGeneratedKeys().add(generatedKey.getValue());</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameters.size() == generatedKey.getIndex()) &#123; <span class="comment">// 主键字段不存在存在，INSERT INTO t_order(user_id) VALUES(?);</span></div><div class="line">       Number key = shardingRule.generateKey(insertStatement.getTables().getSingleTableName()); <span class="comment">// 生成主键编号</span></div><div class="line">       parameters.add(key);</div><div class="line">       setGeneratedKeys(sqlRouteResult, key);</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (-<span class="number">1</span> != generatedKey.getIndex()) &#123; <span class="comment">// 主键字段存在，INSERT INTO t_order(order_id, user_id) VALUES(?, ?);</span></div><div class="line">       setGeneratedKeys(sqlRouteResult, (Number) parameters.get(generatedKey.getIndex()));</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 设置 主键编号 到 SQL路由结果</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> sqlRouteResult SQL路由结果</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> generatedKey 主键编号</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setGeneratedKeys</span><span class="params">(<span class="keyword">final</span> SQLRouteResult sqlRouteResult, <span class="keyword">final</span> Number generatedKey)</span> </span>&#123;</div><div class="line">   generatedKeys.add(generatedKey);</div><div class="line">   sqlRouteResult.getGeneratedKeys().clear();</div><div class="line">   sqlRouteResult.getGeneratedKeys().addAll(generatedKeys);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>parameters.size() == generatedKey.getIndex()</code> 处对应 <code>#appendGenerateKeyToken()</code> 的 <strong>占位符参数数量 &gt; 0</strong> 情况，此时会生成<strong>分布式主键</strong>。😈 该处是不是可以考虑把生成<strong>分布式主键</strong>挪到 <code>#appendGenerateKeyToken()</code>，这样更加统一一些。</li></ul><h1 id="4-SQL-生成"><a href="#4-SQL-生成" class="headerlink" title="4. SQL 生成"></a>4. SQL 生成</h1><p><strong>SQL路由</strong>完后，会生成各数据分片的<strong>执行SQL</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ParsingSQLRouter.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> SQLRouteResult <span class="title">route</span><span class="params">(<span class="keyword">final</span> String logicSQL, <span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> SQLStatement sqlStatement)</span> </span>&#123;</div><div class="line">   SQLRouteResult result = <span class="keyword">new</span> SQLRouteResult(sqlStatement);</div><div class="line">   <span class="comment">// 省略部分代码... 处理 插入SQL 主键字段</span></div><div class="line">   </div><div class="line">   <span class="comment">// 路由</span></div><div class="line">   RoutingResult routingResult = route(parameters, sqlStatement);</div><div class="line">   </div><div class="line">   <span class="comment">// 省略部分代码... SQL重写引擎</span></div><div class="line">   SQLRewriteEngine rewriteEngine = <span class="keyword">new</span> SQLRewriteEngine(shardingRule, logicSQL, sqlStatement);</div><div class="line">   <span class="keyword">boolean</span> isSingleRouting = routingResult.isSingleRouting();</div><div class="line">   <span class="comment">// 省略部分代码... 处理分页</span></div><div class="line">   <span class="comment">// SQL 重写</span></div><div class="line">   SQLBuilder sqlBuilder = rewriteEngine.rewrite(!isSingleRouting);</div><div class="line">   <span class="comment">// 生成 ExecutionUnit</span></div><div class="line">   <span class="keyword">if</span> (routingResult <span class="keyword">instanceof</span> CartesianRoutingResult) &#123;</div><div class="line">       <span class="keyword">for</span> (CartesianDataSource cartesianDataSource : ((CartesianRoutingResult) routingResult).getRoutingDataSources()) &#123;</div><div class="line">           <span class="keyword">for</span> (CartesianTableReference cartesianTableReference : cartesianDataSource.getRoutingTableReferences()) &#123;</div><div class="line">               <span class="comment">// 👼 生成 SQL</span></div><div class="line">               result.getExecutionUnits().add(<span class="keyword">new</span> SQLExecutionUnit(cartesianDataSource.getDataSource(), rewriteEngine.generateSQL(cartesianTableReference, sqlBuilder)));</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">for</span> (TableUnit each : routingResult.getTableUnits().getTableUnits()) &#123;</div><div class="line">           <span class="comment">// 👼 生成 SQL</span></div><div class="line">           result.getExecutionUnits().add(<span class="keyword">new</span> SQLExecutionUnit(each.getDataSourceName(), rewriteEngine.generateSQL(each, sqlBuilder)));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>RewriteEngine#generateSQL()</code> 生成<strong>执行SQL</strong>。对于笛卡尔积路由结果和简单路由结果传递的参数略有不同：前者使用 CartesianDataSource ( CartesianTableReference )，后者使用路由表单元 ( TableUnit )。对路由结果不是很了解的同学，建议看下 <a href="http://www.iocoder.cn/Sharding-JDBC/sql-route-2/?mp">《SQL 路由（二）之分库分表路由》</a>。</li></ul><p><code>RewriteEngine#generateSQL()</code> 对于笛卡尔积路由结果和简单路由结果两种情况，处理上大体是一致的：1. 获得 SQL 相关<strong>逻辑表</strong>对应的<strong>真实表</strong>映射，2. 根据映射改写 SQL 相关<strong>逻辑表</strong>为<strong>真实表</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLRewriteEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 生成SQL语句.</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> tableUnit 路由表单元</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> sqlBuilder SQL构建器</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> SQL语句</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">generateSQL</span><span class="params">(<span class="keyword">final</span> TableUnit tableUnit, <span class="keyword">final</span> SQLBuilder sqlBuilder)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> sqlBuilder.toSQL(getTableTokens(tableUnit));</div><div class="line">&#125;  </div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 生成SQL语句.</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> cartesianTableReference 笛卡尔积路由表单元</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> sqlBuilder SQL构建器</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> SQL语句</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">generateSQL</span><span class="params">(<span class="keyword">final</span> CartesianTableReference cartesianTableReference, <span class="keyword">final</span> SQLBuilder sqlBuilder)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> sqlBuilder.toSQL(getTableTokens(cartesianTableReference));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// SQLRewriteEngine.java</span></div><div class="line"><span class="comment">// SQLBuilder.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 生成SQL语句.</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> tableTokens 占位符集合（逻辑表与真实表映射）</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> SQL语句</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toSQL</span><span class="params">(<span class="keyword">final</span> Map&lt;String, String&gt; tableTokens)</span> </span>&#123;</div><div class="line">   StringBuilder result = <span class="keyword">new</span> StringBuilder();</div><div class="line">   <span class="keyword">for</span> (Object each : segments) &#123;</div><div class="line">       <span class="keyword">if</span> (each <span class="keyword">instanceof</span> TableToken &amp;&amp; tableTokens.containsKey(((TableToken) each).tableName)) &#123;</div><div class="line">           result.append(tableTokens.get(((TableToken) each).tableName));</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           result.append(each);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>#toSQL()</code> 结果如图： <img src="http://www.iocoder.cn/images/Sharding-JDBC/2017_08_10/09.png" alt=""><br>😜 对 <strong>SQL改写</strong> 是不是清晰很多了。</li></ul><hr><p>下面我们以<strong>笛卡尔积路由结果</strong>获得 SQL 相关<strong>逻辑表</strong>对应的<strong>真实表</strong>映射为例子(<em>简单路由结果基本类似而且简单</em>)。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SQLRewriteEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获得（笛卡尔积表路由组里的路由表单元逻辑表 和 与其互为BindingTable关系的逻辑表）对应的真实表映射（逻辑表需要在 SQL 中存在）</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> cartesianTableReference 笛卡尔积表路由组</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> Map&lt;String, String&gt; <span class="title">getTableTokens</span><span class="params">(<span class="keyword">final</span> CartesianTableReference cartesianTableReference)</span> </span>&#123;</div><div class="line">   Map&lt;String, String&gt; tableTokens = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">   <span class="keyword">for</span> (TableUnit each : cartesianTableReference.getTableUnits()) &#123;</div><div class="line">       tableTokens.put(each.getLogicTableName(), each.getActualTableName());</div><div class="line">       <span class="comment">// 查找 BindingTableRule</span></div><div class="line">       Optional&lt;BindingTableRule&gt; bindingTableRule = shardingRule.findBindingTableRule(each.getLogicTableName());</div><div class="line">       <span class="keyword">if</span> (bindingTableRule.isPresent()) &#123;</div><div class="line">           tableTokens.putAll(getBindingTableTokens(each, bindingTableRule.get()));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> tableTokens;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获得 BindingTable 关系的逻辑表对应的真实表映射（逻辑表需要在 SQL 中存在）</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> tableUnit 路由单元</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> bindingTableRule Binding表规则配置对象</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 映射</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> Map&lt;String, String&gt; <span class="title">getBindingTableTokens</span><span class="params">(<span class="keyword">final</span> TableUnit tableUnit, <span class="keyword">final</span> BindingTableRule bindingTableRule)</span> </span>&#123;</div><div class="line">   Map&lt;String, String&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">   <span class="keyword">for</span> (String eachTable : sqlStatement.getTables().getTableNames()) &#123;</div><div class="line">       <span class="keyword">if</span> (!eachTable.equalsIgnoreCase(tableUnit.getLogicTableName()) &amp;&amp; bindingTableRule.hasLogicTable(eachTable)) &#123;</div><div class="line">           result.put(eachTable, bindingTableRule.getBindingActualTable(tableUnit.getDataSourceName(), eachTable, tableUnit.getActualTableName()));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>笛卡尔积表路由组( CartesianTableReference )包含<strong>多个</strong>路由表单元( TableUnit )。每个路由表单元需要遍历。</li><li>路由表单元本身包含逻辑表和真实表，直接添加到映射即可。</li><li>互为 BindingTable 关系的表只计算一次路由分片，因此<strong>未计算</strong>的真实表需要以其对应的<strong>已计算</strong>的真实表去查找，即 <code>bindingTableRule.getBindingActualTable(tableUnit.getDataSourceName(), eachTable, tableUnit.getActualTableName())</code> 处逻辑。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// BindingTableRule.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 根据其他Binding表真实表名称获取相应的真实Binding表名称.</span></div><div class="line"><span class="comment">* </span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> dataSource 数据源名称</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> logicTable 逻辑表名称</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> otherActualTable 其他真实Binding表名称</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 真实Binding表名称</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getBindingActualTable</span><span class="params">(<span class="keyword">final</span> String dataSource, <span class="keyword">final</span> String logicTable, <span class="keyword">final</span> String otherActualTable)</span> </span>&#123;</div><div class="line">   <span class="comment">// 计算 otherActualTable 在其 TableRule 的 actualTable 是第几个</span></div><div class="line">   <span class="keyword">int</span> index = -<span class="number">1</span>;</div><div class="line">   <span class="keyword">for</span> (TableRule each : tableRules) &#123;</div><div class="line">       <span class="keyword">if</span> (each.isDynamic()) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Dynamic table cannot support Binding table."</span>);</div><div class="line">       &#125;</div><div class="line">       index = each.findActualTableIndex(dataSource, otherActualTable);</div><div class="line">       <span class="keyword">if</span> (-<span class="number">1</span> != index) &#123;</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   Preconditions.checkState(-<span class="number">1</span> != index, String.format(<span class="string">"Actual table [%s].[%s] is not in table config"</span>, dataSource, otherActualTable));</div><div class="line">   <span class="comment">// 计算 logicTable 在其 TableRule 的 第index 的 真实表</span></div><div class="line">   <span class="keyword">for</span> (TableRule each : tableRules) &#123;</div><div class="line">       <span class="keyword">if</span> (each.getLogicTable().equalsIgnoreCase(logicTable)) &#123;</div><div class="line">           <span class="keyword">return</span> each.getActualTables().get(index).getTableName();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(String.format(<span class="string">"Cannot find binding actual table, data source: %s, logic table: %s, other actual table: %s"</span>, dataSource, logicTable, otherActualTable));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可能看起来有些绕，我们看张图：</p><p><img src="http://www.iocoder.cn/images/Sharding-JDBC/2017_08_10/10.png" alt=""></p><p><strong>友情提示</strong>：这里不嫌啰嗦在提一句，互为 BindingTable 的表，配置 TableRule 时，<code>actualTables</code> 数量一定要一致，否则多出来的表，可能会无法被路由到。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>哈哈哈，看完<strong>SQL改写</strong>后，<strong>SQL解析</strong>是不是清晰多了！嘿嘿嘿，反正我现在有点嗨。恩，蛮嗨的。</p><p>当然，如果<strong>SQL解析</strong>理解上有点疑惑的你，<strong>欢迎</strong>加我的微信，咱 <strong>1对1</strong> 搞基。关注我的微信公众号：<a href="https://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg">【芋道源码】</a> 即可获得。</p><p><img src="https://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><p>道友，转发一波朋友圈可好？</p><p>Let’s Go! <a href="https://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg">《分布式主键》</a>、<a href="https://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg">《SQL 执行》</a>、<a href="https://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg">《结果聚合》</a> 继续。</p><p><em>感谢技术牛逼如你耐心的阅读本文。</em></p></div><footer class="article-footer clearfix"><div class="article-categories"><span></span> <a class="article-category-link" href="/categories/Sharding-JDBC/">Sharding-JDBC</a></div><div class="article-share" id="share"><div data-url="http://www.iocoder.cn/Sharding-JDBC/sql-rewrite/" data-title="Sharding-JDBC 源码分析 —— SQL 改写 | 芋道源码 —— 纯源码解析BLOG" data-tsina="null" class="share clearfix"></div></div></footer></article><nav class="article-nav clearfix"><div class="prev"><a href="/Sharding-JDBC/distributed-id/" title="Sharding-JDBC 源码分析 —— 分布式主键"><strong>PREVIOUS:</strong><br><span>Sharding-JDBC 源码分析 —— 分布式主键</span></a></div><div class="next"><a href="/Sharding-JDBC/sql-route-3/" title="Sharding-JDBC 源码分析 —— SQL 路由（三）之Spring与YAML配置"><strong>NEXT:</strong><br><span>Sharding-JDBC 源码分析 —— SQL 路由（三）之Spring与YAML配置</span></a></div></nav></div><div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div><div id="toc" class="toc-aside"><strong class="toc-title">文章目录</strong><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-概述"><span class="toc-number">1.</span> <span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-SQLToken"><span class="toc-number">2.</span> <span class="toc-text">2. SQLToken</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-SQL-改写"><span class="toc-number">3.</span> <span class="toc-text">3.SQL 改写</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-TableToken"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 TableToken</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-ItemsToken"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 ItemsToken</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-OffsetToken"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 OffsetToken</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-RowCountToken"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 RowCountToken</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-分页补充"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.4.1 分页补充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-OrderByToken"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 OrderByToken</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-GeneratedKeyToken"><span class="toc-number">3.6.</span> <span class="toc-text">3.6 GeneratedKeyToken</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-SQL-生成"><span class="toc-number">4.</span> <span class="toc-text">4. SQL 生成</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#666-彩蛋"><span class="toc-number">5.</span> <span class="toc-text">666. 彩蛋</span></a></li></ol></div><div id="asidepart"><aside class="clearfix"><div id="authorInfo"><div><img width="100%" src="/images/common/wechat_mp_2017_07_31_bak.jpg"></div><div class="social-list"></div></div><div class="categorieslist"><p class="asidetitle">微信公众号福利：芋道源码</p><ul><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">0. 阅读源码葵花宝典</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">1. RocketMQ / MyCAT / Sharding-JDBC 详细中文注释源码</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">2. 您对于源码的疑问每条留言都将得到认真回复</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">3. 新的源码解析文章实时收到通知，每周六十点更新</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">4. 认真的源码交流微信群</a></li></ul></div><div class="categorieslist"><p class="asidetitle">分类</p><ul><li><a href="/categories/Docker/" title="Docker">Docker<sup>2</sup></a></li><li><a href="/categories/Dubbo/" title="Dubbo">Dubbo<sup>1</sup></a></li><li><a href="/categories/Elastic-Job-Cloud/" title="Elastic-Job-Cloud">Elastic-Job-Cloud<sup>6</sup></a></li><li><a href="/categories/Elastic-Job-Lite/" title="Elastic-Job-Lite">Elastic-Job-Lite<sup>16</sup></a></li><li><a href="/categories/Eureka/" title="Eureka">Eureka<sup>23</sup></a></li><li><a href="/categories/Happylifeplat-TCC/" title="Happylifeplat-TCC">Happylifeplat-TCC<sup>1</sup></a></li><li><a href="/categories/Hystrix/" title="Hystrix">Hystrix<sup>9</sup></a></li><li><a href="/categories/JUC/" title="JUC">JUC<sup>1</sup></a></li><li><a href="/categories/MyCAT/" title="MyCAT">MyCAT<sup>9</sup></a></li><li><a href="/categories/Nginx/" title="Nginx">Nginx<sup>1</sup></a></li><li><a href="/categories/RocketMQ/" title="RocketMQ">RocketMQ<sup>14</sup></a></li><li><a href="/categories/RxJava/" title="RxJava">RxJava<sup>5</sup></a></li><li><a href="/categories/Sharding-JDBC/" title="Sharding-JDBC">Sharding-JDBC<sup>18</sup></a></li><li><a href="/categories/SkyWalking/" title="SkyWalking">SkyWalking<sup>11</sup></a></li><li><a href="/categories/Spring/" title="Spring">Spring<sup>1</sup></a></li><li><a href="/categories/Spring-Cloud-Gateway/" title="Spring-Cloud-Gateway">Spring-Cloud-Gateway<sup>24</sup></a></li><li><a href="/categories/Spring-MVC/" title="Spring-MVC">Spring-MVC<sup>1</sup></a></li><li><a href="/categories/Spring-Security/" title="Spring-Security">Spring-Security<sup>1</sup></a></li><li><a href="/categories/TCC-Transaction/" title="TCC-Transaction">TCC-Transaction<sup>7</sup></a></li><li><a href="/categories/TiKV/" title="TiKV">TiKV<sup>2</sup></a></li><li><a href="/categories/工作内推/" title="工作内推">工作内推<sup>3</sup></a></li><li><a href="/categories/技术杂文/" title="技术杂文">技术杂文<sup>5</sup></a></li></ul></div></aside></div></div><footer><div id="footer"><img src="http://www.iocoder.cn/images/common/wechat_mp_simple.png" style="display:none"><p class="copyright">© 2017 <a href="http://www.iocoder.cn" target="_blank" title="芋道源码">芋道源码</a> && <span style="display:inline" id="busuanzi_container_site_uv">总访客数 <span id="busuanzi_value_site_uv" font="微软雅黑"></span> 次</span> && <span style="display:inline" id="busuanzi_container_site_pv">总访问量 <span id="busuanzi_value_site_pv" font="微软雅黑"></span> 次</span></p></div><div class="copyright">沪ICP备17037075号-1</div></footer><script src="/js/jquery-2.1.0.min.js"></script><script type="text/javascript">$(document).ready(function(){function e(){"number"==typeof window.innerWidth?n=window.innerWidth:document.documentElement&&document.documentElement.clientWidth&&(n=document.documentElement.clientWidth)}$(".navbar").click(function(){$("header nav").toggleClass("shownav")});var n=0,s=$("#main"),a=$("#asidepart"),o=$(".closeaside"),d=$(".openaside");$(window).resize(function(){e(),n>=1024?$("header nav").removeClass("shownav"):(s.removeClass("moveMain"),a.css("display","block").removeClass("fadeOut"),d.css("display","none"),$("#toc.toc-aside").css("display","none"))}),o.click(function(){a.addClass("fadeOut").css("display","none"),d.css("display","block").addClass("fadeIn"),s.addClass("moveMain")}),d.click(function(){d.css("display","none").removeClass("beforeFadeIn"),a.css("display","block").removeClass("fadeOut").addClass("fadeIn"),s.removeClass("moveMain")}),$(window).scroll(function(){d.css("top",Math.max(80,260-$(this).scrollTop()))})})</script><script type="text/javascript">$(document).ready(function(){var a=$(".article-content>iframe"),t=$(".article-content>embed"),n=$("#toc");$("article h2"),ah=$("article h2"),ta=$("#toc.toc-aside"),o=$(".openaside"),c=$(".closeaside"),a.length>0&&a.wrap('<div class="video-container" />'),t.length>0&&t.wrap('<div class="video-container" />'),0==ah.length?n.css("display","none"):(c.click(function(){ta.css("display","block").addClass("fadeIn")}),o.click(function(){ta.css("display","none")}),$(window).scroll(function(){ta.css("top",Math.max(140,320-$(this).scrollTop()))}))})</script><script type="text/javascript">$(document).ready(function(){var t=$(".share"),a=t.attr("data-url"),e=encodeURIComponent(a),r=['<a href="#" class="overlay" id="qrcode"></a>','<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url='+e+'"/></div>','<a href="#textlogo" class="article-back-to-top" title="Top"></a>','<a href="https://www.facebook.com/sharer.php?u='+e+'" class="article-share-facebook" target="_blank" title="Facebook"></a>','<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>','<a href="https://twitter.com/intent/tweet?url='+e+'" class="article-share-twitter" target="_blank" title="Twitter"></a>','<a href="http://service.weibo.com/share/share.php?title='+t.attr("data-title")+"&url="+e+"&ralateUid="+t.attr("data-tsina")+'&searchPic=true&style=number" class="article-share-weibo" target="_blank" title="Weibo"></a>','<span title="Share to"></span>'].join("");t.append(r),$(".article-share-qrcode").click(function(){var t=$("#qrcode-pic").attr("data-src");$("#qrcode-pic").attr("src",t),$("#qrcode-pic").load(function(){$(".qrcode strong").text(" ")})})})</script><link rel="stylesheet" href="/alert/css/alert.css"><script src="/alert/js/alert.js"></script><script src="/js/jquery.cookie.js"></script><script src="/js/util.js"></script><script type="text/javascript">!function(e,a,t,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=a.createElement(t),s=a.getElementsByTagName(t)[0],o.async=1,o.src="//www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s)}(window,document,"script",0,"ga"),ga("create","UA-107572620-1","auto"),ga("send","pageview")</script></body>