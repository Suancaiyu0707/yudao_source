<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="google-site-verification" content="GkJ68PCnxM9Ih7Zm9v8p91FOCV7ymNCO2KdGbflLh3E"><meta name="360-site-verification" content="dd6547587641bfede036f7c79561e8a0"><meta name="shenma-site-verification" content="fd96cf3751972c9b05f8471d2ccadddc_1496951214"><meta name="msvalidate.01" content="1D38B05050A977F6FDEDA481198343F1"><meta name="sogou_site_verification" content="MpPsku240L"><title>Sharding-JDBC 源码分析 —— SQL 路由（二）之分库分表路由 | 芋道源码 —— 纯源码解析BLOG</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=3,minimum-scale=1"><meta name="author" content="王文斌"><meta name="description" content="摘要: 原创出处 http://www.iocoder.cn/Sharding-JDBC/sql-route-2/ 「芋道源码」欢迎转载，保留摘要，谢谢！
本文主要基于 Sharding-JDBC 1.5.0 正式版  

1. 概述
2. SQLRouteResult
3. 路由策略 x 算法
4"><meta name="keywords" content="Sharding-JDBC,ShardingJDBC,Sharding-JDBC 源码,SQL 路由,路由,路由配置,Java,架构,后端,服务端,RocketMQ,MyCAT,分布式消息队列,分布式存储,技术博客,Sharding-JDBC,分库分表"><link rel="alternate" href="atom.xml" title="芋道源码 —— 纯源码解析BLOG" type="application/atom+xml"><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/style.css"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?9e70e3362807c1bd185a79655b307027";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script>!function(){var t="http:"==document.location.protocol?"http://js.passport.qihucdn.com/11.0.1.js?f05b61dd54bbc38386611a5238672938":"https://jspassport.ssl.qhimg.com/11.0.1.js?f05b61dd54bbc38386611a5238672938";document.write('<script src="'+t+'" id="sozz"><\/script>')}()</script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></head></html><body><header><div><div id="textlogo"><h1 class="site-name"><a href="/" title="芋道源码 —— 纯源码解析BLOG">芋道源码 —— 纯源码解析BLOG</a></h1><a class="blog-motto">愿半生编码，如一生老友！</a></div><div class="navbar"><a class="navbutton navmobile" href="#" title="菜单"></a></div><nav class="animated"><ul><ul><li><a href="/">文章</a></li><li><a href="https://github.com/YunaiV" rel="external nofollow noopener noreferrer" target="_blank">Github</a></li><li><a href="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31_bak.jpg">微信公众号</a></li><li><a href="/link_url">友链</a></li></ul></ul></nav></div></header><div id="container"><div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div><div id="toc" class="toc-aside"><strong class="toc-title">文章目录</strong><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-概述"><span class="toc-number">1.</span> <span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-SQLRouteResult"><span class="toc-number">2.</span> <span class="toc-text">2. SQLRouteResult</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-路由策略-x-算法"><span class="toc-number">3.</span> <span class="toc-text">3. 路由策略 x 算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-SQL-路由"><span class="toc-number">4.</span> <span class="toc-text">4. SQL 路由</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-DatabaseHintSQLRouter"><span class="toc-number">5.</span> <span class="toc-text">5. DatabaseHintSQLRouter</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-ParsingSQLRouter"><span class="toc-number">6.</span> <span class="toc-text">6. ParsingSQLRouter</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-SimpleRoutingEngine"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 SimpleRoutingEngine</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-ComplexRoutingEngine"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 ComplexRoutingEngine</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-CartesianRoutingEngine"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 CartesianRoutingEngine</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-ParsingSQLRouter-主-route"><span class="toc-number">6.4.</span> <span class="toc-text">6.4 ParsingSQLRouter 主#route()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#666-彩蛋"><span class="toc-number">7.</span> <span class="toc-text">666. 彩蛋</span></a></li></ol></div><div id="asidepart"><aside class="clearfix"><div id="authorInfo"><div><img width="100%" src="/images/common/wechat_mp_2017_07_31_bak.jpg"></div><div class="social-list"></div></div><div class="categorieslist"><p class="asidetitle">微信公众号福利：芋道源码</p><ul><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">0. 阅读源码葵花宝典</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">1. RocketMQ / MyCAT / Sharding-JDBC 详细中文注释源码</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">2. 您对于源码的疑问每条留言都将得到认真回复</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">3. 新的源码解析文章实时收到通知，每周六十点更新</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">4. 认真的源码交流微信群</a></li></ul></div><div class="categorieslist"><p class="asidetitle">分类</p><ul><li><a href="/categories/Docker/" title="Docker">Docker<sup>2</sup></a></li><li><a href="/categories/Elastic-Job-Cloud/" title="Elastic-Job-Cloud">Elastic-Job-Cloud<sup>6</sup></a></li><li><a href="/categories/Elastic-Job-Lite/" title="Elastic-Job-Lite">Elastic-Job-Lite<sup>16</sup></a></li><li><a href="/categories/Eureka/" title="Eureka">Eureka<sup>23</sup></a></li><li><a href="/categories/Hystrix/" title="Hystrix">Hystrix<sup>5</sup></a></li><li><a href="/categories/MyCAT/" title="MyCAT">MyCAT<sup>9</sup></a></li><li><a href="/categories/Nginx/" title="Nginx">Nginx<sup>1</sup></a></li><li><a href="/categories/RocketMQ/" title="RocketMQ">RocketMQ<sup>14</sup></a></li><li><a href="/categories/RxJava/" title="RxJava">RxJava<sup>5</sup></a></li><li><a href="/categories/Sharding-JDBC/" title="Sharding-JDBC">Sharding-JDBC<sup>18</sup></a></li><li><a href="/categories/TCC-Transaction/" title="TCC-Transaction">TCC-Transaction<sup>7</sup></a></li><li><a href="/categories/技术杂文/" title="技术杂文">技术杂文<sup>5</sup></a></li></ul></div></aside></div><div id="main" class="post" itemscope="" itemprop="blogPost"><article itemprop="articleBody"><header class="article-info clearfix"><h1 itemprop="name"><a href="/Sharding-JDBC/sql-route-2/" title="Sharding-JDBC 源码分析 —— SQL 路由（二）之分库分表路由" itemprop="url">Sharding-JDBC 源码分析 —— SQL 路由（二）之分库分表路由</a></h1><p class="article-author"></p><p class="article-time">总阅读量:<span id="busuanzi_value_page_pv"></span>次</p></header><div class="article-content"><p>摘要: 原创出处 <a href="http://www.iocoder.cn/Sharding-JDBC/sql-route-2/">http://www.iocoder.cn/Sharding-JDBC/sql-route-2/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Sharding-JDBC 1.5.0 正式版</strong></p><ul><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-route-2/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-route-2/">2. SQLRouteResult</a></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-route-2/">3. 路由策略 x 算法</a></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-route-2/">4. SQL 路由</a></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-route-2/">5. DatabaseHintSQLRouter</a></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-route-2/">6. ParsingSQLRouter</a><ul><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-route-2/">6.1 SimpleRoutingEngine</a></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-route-2/">6.2 ComplexRoutingEngine</a></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-route-2/">6.3 CartesianRoutingEngine</a></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-route-2/">6.3 ParsingSQLRouter 主#route()</a></li></ul></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-route-2/">666. 彩蛋</a></li></ul><hr><p><img src="https://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文分享分表分库<strong>路由</strong>相关的实现。涉及内容如下：</p><ol><li>SQL 路由结果</li><li>路由策略 x 算法</li><li>SQL 路由器</li></ol><p>内容顺序如编号。</p><blockquote><p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p></blockquote><p>SQL 路由大体流程如下：</p><p><img src="http://www.iocoder.cn/images/Sharding-JDBC/2017_08_06/06.png" alt=""></p><h1 id="2-SQLRouteResult"><a href="#2-SQLRouteResult" class="headerlink" title="2. SQLRouteResult"></a>2. SQLRouteResult</h1><p>经过 <strong>SQL解析</strong>、<strong>SQL路由</strong>后，产生<strong>SQL路由结果</strong>，即 SQLRouteResult。根据路由结果，<strong>生成SQL</strong>，<strong>执行SQL</strong>。</p><p><img src="http://www.iocoder.cn/images/Sharding-JDBC/2017_08_06/01.png" alt=""></p><ul><li><code>sqlStatement</code> ：SQL语句对象，经过<strong>SQL解析</strong>的结果对象。</li><li><code>executionUnits</code> ：SQL最小执行单元集合。<strong>SQL执行</strong>时，执行每个单元。</li><li><code>generatedKeys</code> ：<strong>插入</strong>SQL语句生成的主键编号集合。目前不支持批量插入而使用集合的原因，猜测是为了未来支持批量插入做准备。</li></ul><h1 id="3-路由策略-x-算法"><a href="#3-路由策略-x-算法" class="headerlink" title="3. 路由策略 x 算法"></a>3. 路由策略 x 算法</h1><p><img src="http://www.iocoder.cn/images/Sharding-JDBC/2017_08_04/04.png" alt=""></p><p>ShardingStrategy，分片策略。目前支持两种分片：</p><p><em>分片资源：在分库策略里指的是库，在分表策略里指的是表。</em></p><p>【1】 计算<strong>静态</strong>分片（常用）</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingStrategy.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 计算静态分片.</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> sqlType SQL语句的类型</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> availableTargetNames 所有的可用分片资源集合</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> shardingValues 分片值集合</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 分库后指向的数据源名称集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doStaticSharding</span><span class="params">(<span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> Collection&lt;ShardingValue&lt;?&gt;&gt; shardingValues)</span> </span>&#123;</div><div class="line">   Collection&lt;String&gt; result = <span class="keyword">new</span> TreeSet&lt;&gt;(String.CASE_INSENSITIVE_ORDER);</div><div class="line">   <span class="keyword">if</span> (shardingValues.isEmpty()) &#123;</div><div class="line">       Preconditions.checkState(!isInsertMultiple(sqlType, availableTargetNames), <span class="string">"INSERT statement should contain sharding value."</span>); <span class="comment">// 插入不能有多资源对象</span></div><div class="line">       result.addAll(availableTargetNames);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       result.addAll(doSharding(shardingValues, availableTargetNames));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 插入SQL 是否插入多个分片</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> sqlType SQL类型</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> availableTargetNames 所有的可用分片资源集合</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 是否</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isInsertMultiple</span><span class="params">(<span class="keyword">final</span> SQLType sqlType, <span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> SQLType.INSERT == sqlType &amp;&amp; availableTargetNames.size() &gt; <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>插入SQL 需要有片键值，否则无法判断单个分片资源。<em>（Sharding-JDBC 目前仅支持单条记录插入）</em></li></ul><p>【2】计算<strong>动态</strong>分片</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingStrategy.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 计算动态分片.</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> shardingValues 分片值集合</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 分库后指向的分片资源集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doDynamicSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;ShardingValue&lt;?&gt;&gt; shardingValues)</span> </span>&#123;</div><div class="line">   Preconditions.checkState(!shardingValues.isEmpty(), <span class="string">"Dynamic table should contain sharding value."</span>); <span class="comment">// 动态分片必须有分片值</span></div><div class="line">   Collection&lt;String&gt; availableTargetNames = Collections.emptyList();</div><div class="line">   Collection&lt;String&gt; result = <span class="keyword">new</span> TreeSet&lt;&gt;(String.CASE_INSENSITIVE_ORDER);</div><div class="line">   result.addAll(doSharding(shardingValues, availableTargetNames));</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>动态分片对应 <code>TableRule.dynamic=true</code></li><li>动态分片必须有分片值</li></ul><p>😈 闷了，看起来两者没啥区别？答案在<strong>分片算法</strong>上。我们先看 <code>#doSharding()</code> 方法的实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingStrategy.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 计算分片</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> shardingValues 分片值集合</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> availableTargetNames 所有的可用分片资源集合</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 分库后指向的分片资源集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> Collection&lt;String&gt; <span class="title">doSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;ShardingValue&lt;?&gt;&gt; shardingValues, <span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames)</span> </span>&#123;</div><div class="line">   <span class="comment">// 无片键</span></div><div class="line">   <span class="keyword">if</span> (shardingAlgorithm <span class="keyword">instanceof</span> NoneKeyShardingAlgorithm) &#123;</div><div class="line">       <span class="keyword">return</span> Collections.singletonList(((NoneKeyShardingAlgorithm) shardingAlgorithm).doSharding(availableTargetNames, shardingValues.iterator().next()));</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 单片键</span></div><div class="line">   <span class="keyword">if</span> (shardingAlgorithm <span class="keyword">instanceof</span> SingleKeyShardingAlgorithm) &#123;</div><div class="line">       SingleKeyShardingAlgorithm&lt;?&gt; singleKeyShardingAlgorithm = (SingleKeyShardingAlgorithm&lt;?&gt;) shardingAlgorithm;</div><div class="line">       ShardingValue shardingValue = shardingValues.iterator().next();</div><div class="line">       <span class="keyword">switch</span> (shardingValue.getType()) &#123;</div><div class="line">           <span class="keyword">case</span> SINGLE:</div><div class="line">               <span class="keyword">return</span> Collections.singletonList(singleKeyShardingAlgorithm.doEqualSharding(availableTargetNames, shardingValue));</div><div class="line">           <span class="keyword">case</span> LIST:</div><div class="line">               <span class="keyword">return</span> singleKeyShardingAlgorithm.doInSharding(availableTargetNames, shardingValue);</div><div class="line">           <span class="keyword">case</span> RANGE:</div><div class="line">               <span class="keyword">return</span> singleKeyShardingAlgorithm.doBetweenSharding(availableTargetNames, shardingValue);</div><div class="line">           <span class="keyword">default</span>:</div><div class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(shardingValue.getType().getClass().getName());</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 多片键</span></div><div class="line">   <span class="keyword">if</span> (shardingAlgorithm <span class="keyword">instanceof</span> MultipleKeysShardingAlgorithm) &#123;</div><div class="line">       <span class="keyword">return</span> ((MultipleKeysShardingAlgorithm) shardingAlgorithm).doSharding(availableTargetNames, shardingValues);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(shardingAlgorithm.getClass().getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>无分片键算法：对应 NoneKeyShardingAlgorithm 分片算法接口。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NoneKeyShardingAlgorithm</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;?&gt;&gt; <span class="keyword">extends</span> <span class="title">ShardingAlgorithm</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">doSharding</span><span class="params">(Collection&lt;String&gt; availableTargetNames, ShardingValue&lt;T&gt; shardingValue)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>单片键算法：对应 SingleKeyShardingAlgorithm 分片算法接口。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SingleKeyShardingAlgorithm</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;?&gt;&gt; <span class="keyword">extends</span> <span class="title">ShardingAlgorithm</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">doEqualSharding</span><span class="params">(Collection&lt;String&gt; availableTargetNames, ShardingValue&lt;T&gt; shardingValue)</span></span>;</div><div class="line">    <span class="function">Collection&lt;String&gt; <span class="title">doInSharding</span><span class="params">(Collection&lt;String&gt; availableTargetNames, ShardingValue&lt;T&gt; shardingValue)</span></span>;</div><div class="line">    <span class="function">Collection&lt;String&gt; <span class="title">doBetweenSharding</span><span class="params">(Collection&lt;String&gt; availableTargetNames, ShardingValue&lt;T&gt; shardingValue)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">ShardingValueType</th><th style="text-align:left">SQL 操作符</th><th style="text-align:left">接口方法</th></tr></thead><tbody><tr><td style="text-align:left">SINGLE</td><td style="text-align:left">=</td><td style="text-align:left"><code>#doEqualSharding()</code></td></tr><tr><td style="text-align:left">LIST</td><td style="text-align:left">IN</td><td style="text-align:left"><code>#doInSharding()</code></td></tr><tr><td style="text-align:left">RANGE</td><td style="text-align:left">BETWEEN</td><td style="text-align:left"><code>#doBetweenSharding()</code></td></tr></tbody></table><ul><li>多片键算法：对应 MultipleKeysShardingAlgorithm 分片算法接口。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MultipleKeysShardingAlgorithm</span> <span class="keyword">extends</span> <span class="title">ShardingAlgorithm</span> </span>&#123;</div><div class="line">    <span class="function">Collection&lt;String&gt; <span class="title">doSharding</span><span class="params">(Collection&lt;String&gt; availableTargetNames, Collection&lt;ShardingValue&lt;?&gt;&gt; shardingValues)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>分片算法类结构如下：</p><p><img src="http://www.iocoder.cn/images/Sharding-JDBC/2017_08_06/02.png" alt=""></p><p>来看看 Sharding-JDBC 实现的无需分库的分片算法 NoneDatabaseShardingAlgorithm (NoneTableShardingAlgorithm 基本一模一样)：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NoneDatabaseShardingAlgorithm</span> <span class="keyword">implements</span> <span class="title">SingleKeyDatabaseShardingAlgorithm</span>&lt;<span class="title">String</span>&gt;, <span class="title">MultipleKeysDatabaseShardingAlgorithm</span> </span>&#123; </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> Collection&lt;ShardingValue&lt;?&gt;&gt; shardingValues)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> availableTargetNames;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doEqualSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> ShardingValue&lt;String&gt; shardingValue)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> availableTargetNames.isEmpty() ? <span class="keyword">null</span> : availableTargetNames.iterator().next();</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doInSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> ShardingValue&lt;String&gt; shardingValue)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> availableTargetNames;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doBetweenSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> ShardingValue&lt;String&gt; shardingValue)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> availableTargetNames;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>一定要注意，NoneXXXXShardingAlgorithm 只适用于无分库/表的需求，否则会是错误的路由结果。</strong>例如，<code>#doEqualSharding()</code> 返回的是第一个分片资源。</li></ul><hr><p>再来看测试目录下实现的<strong>余数基偶分表算法</strong> ModuloTableShardingAlgorithm 的实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// com.dangdang.ddframe.rdb.integrate.fixture.ModuloTableShardingAlgorithm.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ModuloTableShardingAlgorithm</span> <span class="keyword">implements</span> <span class="title">SingleKeyTableShardingAlgorithm</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doEqualSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; tableNames, <span class="keyword">final</span> ShardingValue&lt;Integer&gt; shardingValue)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (String each : tableNames) &#123;</div><div class="line">            <span class="keyword">if</span> (each.endsWith(shardingValue.getValue() % <span class="number">2</span> + <span class="string">""</span>)) &#123;</div><div class="line">                <span class="keyword">return</span> each;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doInSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; tableNames, <span class="keyword">final</span> ShardingValue&lt;Integer&gt; shardingValue)</span> </span>&#123;</div><div class="line">        Collection&lt;String&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(tableNames.size());</div><div class="line">        <span class="keyword">for</span> (Integer value : shardingValue.getValues()) &#123;</div><div class="line">            <span class="keyword">for</span> (String tableName : tableNames) &#123;</div><div class="line">                <span class="keyword">if</span> (tableName.endsWith(value % <span class="number">2</span> + <span class="string">""</span>)) &#123;</div><div class="line">                    result.add(tableName);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doBetweenSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; tableNames, <span class="keyword">final</span> ShardingValue&lt;Integer&gt; shardingValue)</span> </span>&#123;</div><div class="line">        Collection&lt;String&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(tableNames.size());</div><div class="line">        Range&lt;Integer&gt; range = shardingValue.getValueRange();</div><div class="line">        <span class="keyword">for</span> (Integer i = range.lowerEndpoint(); i &lt;= range.upperEndpoint(); i++) &#123;</div><div class="line">            <span class="keyword">for</span> (String each : tableNames) &#123;</div><div class="line">                <span class="keyword">if</span> (each.endsWith(i % <span class="number">2</span> + <span class="string">""</span>)) &#123;</div><div class="line">                    result.add(each);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>我们可以参考这个例子编写自己的分片算哟 👼。</li><li>多片键分库算法接口实现例子：<a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/d6ac50704f5e45beeeded09a4f0b160c7320b993/sharding-jdbc-core/src/test/java/com/dangdang/ddframe/rdb/integrate/fixture/MultipleKeysModuloDatabaseShardingAlgorithm.java" rel="external nofollow noopener noreferrer" target="_blank">MultipleKeysModuloDatabaseShardingAlgorithm.java</a></li></ul><hr><p>😈 来看看<strong>动态计算分片</strong>需要怎么实现分片算法。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// com.dangdang.ddframe.rdb.integrate.fixture.SingleKeyDynamicModuloTableShardingAlgorithm.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleKeyDynamicModuloTableShardingAlgorithm</span> <span class="keyword">implements</span> <span class="title">SingleKeyTableShardingAlgorithm</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">    * 表前缀</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String tablePrefix;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doEqualSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> ShardingValue&lt;Integer&gt; shardingValue)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> tablePrefix + shardingValue.getValue() % <span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doInSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> ShardingValue&lt;Integer&gt; shardingValue)</span> </span>&#123;</div><div class="line">        Collection&lt;String&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(shardingValue.getValues().size());</div><div class="line">        <span class="keyword">for</span> (Integer value : shardingValue.getValues()) &#123;</div><div class="line">            result.add(tablePrefix + value % <span class="number">10</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doBetweenSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> ShardingValue&lt;Integer&gt; shardingValue)</span> </span>&#123;</div><div class="line">        Collection&lt;String&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(availableTargetNames.size());</div><div class="line">        Range&lt;Integer&gt; range = shardingValue.getValueRange();</div><div class="line">        <span class="keyword">for</span> (Integer i = range.lowerEndpoint(); i &lt;= range.upperEndpoint(); i++) &#123;</div><div class="line">            result.add(tablePrefix + i % <span class="number">10</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>骚年，是不是明白了一些？<strong>动态表</strong>无需把真实表配置到 TableRule，而是通过<strong>分片算法</strong>计算出<strong>真实表</strong>。</li></ul><h1 id="4-SQL-路由"><a href="#4-SQL-路由" class="headerlink" title="4. SQL 路由"></a>4. SQL 路由</h1><p>SQLRouter，SQL 路由器接口，共有两种实现：</p><ul><li>DatabaseHintSQLRouter：通过提示且仅路由至数据库的SQL路由器</li><li>ParsingSQLRouter：需要解析的SQL路由器</li></ul><p>它们实现 <code>#parse()</code>进行<strong>SQL解析</strong>，<code>#route()</code>进行<strong>SQL路由</strong>。</p><p><img src="http://www.iocoder.cn/images/Sharding-JDBC/2017_08_06/03.png" alt=""></p><hr><p>RoutingEngine，路由引擎接口，共有四种实现：</p><ul><li>DatabaseHintRoutingEngine：基于数据库提示的路由引擎</li><li>SimpleRoutingEngine：简单路由引擎</li><li>CartesianRoutingEngine：笛卡尔积的库表路由</li><li>ComplexRoutingEngine：混合多库表路由引擎</li></ul><p><strong>ComplexRoutingEngine 根据路由结果会转化成 SimpleRoutingEngine 或 ComplexRoutingEngine</strong>。下文会看相应源码。</p><p><img src="http://www.iocoder.cn/images/Sharding-JDBC/2017_08_06/04.png" alt=""></p><hr><p>路由结果有两种：</p><ul><li>RoutingResult：简单路由结果</li><li>CartesianRoutingResult：笛卡尔积路由结果</li></ul><p><img src="http://www.iocoder.cn/images/Sharding-JDBC/2017_08_06/05.png" alt=""></p><p>从图中，我们已经能大概看到两者有什么区别，更具体的下文随源码一起分享。</p><p>😈 SQLRouteResult 和 RoutingResult 有什么区别？</p><ul><li>SQLRouteResult：<strong>整个SQL路由</strong>返回的路由结果</li><li>RoutingResult：<strong>RoutingEngine</strong>返回路由结果</li></ul><p><img src="http://www.iocoder.cn/images/Sharding-JDBC/2017_08_06/06.png" alt=""></p><hr><p>一下子看到这么多<strong>“对象”</strong>，可能有点<strong>紧张</strong>。不要紧张，我们一起在整理下。</p><table><thead><tr><th style="text-align:left">路由器</th><th style="text-align:left">路由引擎</th><th style="text-align:left">路由结果</th></tr></thead><tbody><tr><td style="text-align:left">DatabaseHintSQLRouter</td><td style="text-align:left">DatabaseHintRoutingEngine</td><td style="text-align:left">RoutingResult</td></tr><tr><td style="text-align:left">ParsingSQLRouter</td><td style="text-align:left">SimpleRoutingEngine</td><td style="text-align:left">RoutingResult</td></tr><tr><td style="text-align:left">ParsingSQLRouter</td><td style="text-align:left">CartesianRoutingEngine</td><td style="text-align:left">CartesianRoutingResult</td></tr></tbody></table><p>😈 逗比博主给大家解决了<strong>“对象”</strong>，是不是应该<strong>分享朋友圈</strong>。</p><h1 id="5-DatabaseHintSQLRouter"><a href="#5-DatabaseHintSQLRouter" class="headerlink" title="5. DatabaseHintSQLRouter"></a>5. DatabaseHintSQLRouter</h1><p>DatabaseHintSQLRouter，基于数据库提示的路由引擎。路由器工厂 SQLRouterFactory 创建路由器时，判断到使用数据库提示( Hint ) 时，创建 DatabaseHintSQLRouter。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DatabaseHintRoutingEngine.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SQLRouter <span class="title">createSQLRouter</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> HintManagerHolder.isDatabaseShardingOnly() ? <span class="keyword">new</span> DatabaseHintSQLRouter(shardingContext) : <span class="keyword">new</span> ParsingSQLRouter(shardingContext);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>先来看下 HintManagerHolder、HintManager <strong>部分相关</strong>的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// HintManagerHolder.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HintManagerHolder</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * HintManager 线程变量</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;HintManager&gt; HINT_MANAGER_HOLDER = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 判断是否当前只分库.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 是否当前只分库.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDatabaseShardingOnly</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span> != HINT_MANAGER_HOLDER.get() &amp;&amp; HINT_MANAGER_HOLDER.get().isDatabaseShardingOnly();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 清理线索分片管理器的本地线程持有者.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        HINT_MANAGER_HOLDER.remove();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// HintManager.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HintManager</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 库分片值集合</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ShardingKey, ShardingValue&lt;?&gt;&gt; databaseShardingValues = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 只做库分片</span></div><div class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> DatabaseHintRoutingEngine&#125;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Getter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> databaseShardingOnly;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获取线索分片管理器实例.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 线索分片管理器实例</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HintManager <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        HintManager result = <span class="keyword">new</span> HintManager();</div><div class="line">        HintManagerHolder.setHintManager(result);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 设置分库分片值.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * &lt;p&gt;分片操作符为等号.该方法适用于只分库的场景&lt;/p&gt;</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> value 分片值</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDatabaseShardingValue</span><span class="params">(<span class="keyword">final</span> Comparable&lt;?&gt; value)</span> </span>&#123;</div><div class="line">        databaseShardingOnly = <span class="keyword">true</span>;</div><div class="line">        addDatabaseShardingValue(HintManagerHolder.DB_TABLE_NAME, HintManagerHolder.DB_COLUMN_NAME, value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>那么如果要使用 DatabaseHintSQLRouter，我们只需要 <code>HintManager.getInstance().setDatabaseShardingValue(库分片值)</code> 即可。这里有两点要注意下：</p><ul><li><code>HintManager#getInstance()</code>，每次获取到的都是<strong>新</strong>的 HintManager，多次赋值需要小心。</li><li><code>HintManager#close()</code>，使用完需要去清理，避免下个请求读到遗漏的线程变量。</li></ul><hr><p>看看 DatabaseHintSQLRouter 的实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DatabaseHintSQLRouter.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> SQLStatement <span class="title">parse</span><span class="params">(<span class="keyword">final</span> String logicSQL, <span class="keyword">final</span> <span class="keyword">int</span> parametersSize)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> SQLJudgeEngine(logicSQL).judge(); <span class="comment">// 只解析 SQL 类型</span></div><div class="line">&#125;  </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="comment">// TODO insert的SQL仍然需要解析自增主键</span></div><div class="line"><span class="function"><span class="keyword">public</span> SQLRouteResult <span class="title">route</span><span class="params">(<span class="keyword">final</span> String logicSQL, <span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> SQLStatement sqlStatement)</span> </span>&#123;</div><div class="line">   Context context = MetricsContext.start(<span class="string">"Route SQL"</span>);</div><div class="line">   SQLRouteResult result = <span class="keyword">new</span> SQLRouteResult(sqlStatement);</div><div class="line">   <span class="comment">// 路由</span></div><div class="line">   RoutingResult routingResult = <span class="keyword">new</span> DatabaseHintRoutingEngine(shardingRule.getDataSourceRule(), shardingRule.getDatabaseShardingStrategy(), sqlStatement.getType())</div><div class="line">           .route();</div><div class="line">   <span class="comment">// SQL最小执行单元</span></div><div class="line">   <span class="keyword">for</span> (TableUnit each : routingResult.getTableUnits().getTableUnits()) &#123;</div><div class="line">       result.getExecutionUnits().add(<span class="keyword">new</span> SQLExecutionUnit(each.getDataSourceName(), logicSQL));</div><div class="line">   &#125;</div><div class="line">   MetricsContext.stop(context);</div><div class="line">   <span class="keyword">if</span> (showSQL) &#123;</div><div class="line">       SQLLogger.logSQL(logicSQL, sqlStatement, result.getExecutionUnits(), parameters);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>#parse()</code> 只解析了 SQL 类型，即 SELECT / UPDATE / DELETE / INSERT 。</li><li><strong>使用的分库策略来自 ShardingRule，不是 TableRule，这个一定要留心。</strong>❓因为 SQL 未解析<strong>表名</strong>。因此，即使在 TableRule 设置了 <code>actualTables</code> 属性也是没有效果的。</li><li>目前不支持 Sharding-JDBC 的主键自增。❓因为 SQL 未解析<strong>自增主键</strong>。从代码上的<code>TODO</code>应该会支持。</li><li><code>HintManager.getInstance().setDatabaseShardingValue(库分片值)</code> 设置的库分片值使用的是 EQUALS，因而分库策略计算出来的只有<strong>一个库分片</strong>，即 TableUnit 只有一个，SQLExecutionUnit 只有一个。</li></ul><hr><p>看看 DatabaseHintSQLRouter 的实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DatabaseHintRoutingEngine.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> RoutingResult <span class="title">route</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 从 Hint 获得 分片键值</span></div><div class="line">   Optional&lt;ShardingValue&lt;?&gt;&gt; shardingValue = HintManagerHolder.getDatabaseShardingValue(<span class="keyword">new</span> ShardingKey(HintManagerHolder.DB_TABLE_NAME, HintManagerHolder.DB_COLUMN_NAME));</div><div class="line">   Preconditions.checkState(shardingValue.isPresent());</div><div class="line">   log.debug(<span class="string">"Before database sharding only db:&#123;&#125; sharding values: &#123;&#125;"</span>, dataSourceRule.getDataSourceNames(), shardingValue.get());</div><div class="line">   <span class="comment">// 路由。表分片规则使用的是 ShardingRule 里的。因为没 SQL 解析。</span></div><div class="line">   Collection&lt;String&gt; routingDataSources = databaseShardingStrategy.doStaticSharding(sqlType, dataSourceRule.getDataSourceNames(), Collections.&lt;ShardingValue&lt;?&gt;&gt;singleton(shardingValue.get()));</div><div class="line">   Preconditions.checkState(!routingDataSources.isEmpty(), <span class="string">"no database route info"</span>);</div><div class="line">   log.debug(<span class="string">"After database sharding only result: &#123;&#125;"</span>, routingDataSources);</div><div class="line">   <span class="comment">// 路由结果</span></div><div class="line">   RoutingResult result = <span class="keyword">new</span> RoutingResult();</div><div class="line">   <span class="keyword">for</span> (String each : routingDataSources) &#123;</div><div class="line">       result.getTableUnits().getTableUnits().add(<span class="keyword">new</span> TableUnit(each, <span class="string">""</span>, <span class="string">""</span>));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>只</strong>调用 <code>databaseShardingStrategy.doStaticSharding()</code> 方法计算<strong>库</strong>分片。</li><li><code>new TableUnit(each, &quot;&quot;, &quot;&quot;)</code> 的 <code>logicTableName</code>，<code>actualTableName</code> 都是空串，相信原因你已经知道。</li></ul><h1 id="6-ParsingSQLRouter"><a href="#6-ParsingSQLRouter" class="headerlink" title="6. ParsingSQLRouter"></a>6. ParsingSQLRouter</h1><p>ParsingSQLRouter，需要解析的SQL路由器。</p><p>ParsingSQLRouter 使用 SQLParsingEngine <strong>解析SQL</strong>。对<strong>SQL解析</strong>有兴趣的同学可以看看拙作<a href="http://www.iocoder.cn/categories/Sharding-JDBC/?mp">《Sharding-JDBC 源码分析 —— SQL 解析》</a>。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ParsingSQLRouter.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> SQLStatement <span class="title">parse</span><span class="params">(<span class="keyword">final</span> String logicSQL, <span class="keyword">final</span> <span class="keyword">int</span> parametersSize)</span> </span>&#123;</div><div class="line">   SQLParsingEngine parsingEngine = <span class="keyword">new</span> SQLParsingEngine(databaseType, logicSQL, shardingRule);</div><div class="line">   Context context = MetricsContext.start(<span class="string">"Parse SQL"</span>);</div><div class="line">   SQLStatement result = parsingEngine.parse();</div><div class="line">   <span class="keyword">if</span> (result <span class="keyword">instanceof</span> InsertStatement) &#123;</div><div class="line">       ((InsertStatement) result).appendGenerateKeyToken(shardingRule, parametersSize);</div><div class="line">   &#125;</div><div class="line">   MetricsContext.stop(context);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>#appendGenerateKeyToken()</code> 会在<a href="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg">《SQL 改写》</a>分享</li></ul><hr><p>ParsingSQLRouter 在路由时，会根据<strong>表情况</strong>使用 SimpleRoutingEngine 或 CartesianRoutingEngine 进行路由。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> RoutingResult <span class="title">route</span><span class="params">(<span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> SQLStatement sqlStatement)</span> </span>&#123;</div><div class="line">   Collection&lt;String&gt; tableNames = sqlStatement.getTables().getTableNames();</div><div class="line">   RoutingEngine routingEngine;</div><div class="line">   <span class="keyword">if</span> (<span class="number">1</span> == tableNames.size() || shardingRule.isAllBindingTables(tableNames)) &#123;</div><div class="line">       routingEngine = <span class="keyword">new</span> SimpleRoutingEngine(shardingRule, parameters, tableNames.iterator().next(), sqlStatement);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="comment">// TODO 可配置是否执行笛卡尔积</span></div><div class="line">       routingEngine = <span class="keyword">new</span> ComplexRoutingEngine(shardingRule, parameters, tableNames, sqlStatement);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> routingEngine.route();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>当只进行<strong>一张表</strong>或者<strong>多表互为BindingTable关系</strong>时，使用 SimpleRoutingEngine 简单路由引擎。<strong>多表互为BindingTable关系</strong>时，每张表的路由结果是相同的，所以只要计算第一张表的分片即可。</li><li><code>tableNames.iterator().next()</code> 注意下，<code>tableNames</code> 变量是 <code>new TreeMap&lt;&gt;(String.CASE_INSENSITIVE_ORDER)</code>。所以 <code>SELECT * FROM t_order o join t_order_item i ON o.order_id = i.order_id</code> 即使 <code>t_order_item</code> 排在 <code>t_order</code> 前面，<code>tableNames.iterator().next()</code> 返回的是 <code>t_order</code>。当 <code>t_order</code> 和 <code>t_order_item</code> 为 <strong>BindingTable关系</strong> 时，计算的是 <code>t_order</code> 路由分片。</li><li>BindingTable关系在 ShardingRule 的 <code>tableRules</code> 配置。配置该关系 TableRule 有如下需要遵守的规则：<ul><li>分片策略与算法相同</li><li>数据源配置对象相同</li><li>真实表<strong>数量</strong>相同</li></ul></li></ul><p><strong>举个例子</strong>：</p><ul><li>SQL ：<code>SELECT * FROM t_order o join t_order_item i ON o.order_id = i.order_id</code></li><li>分库分表情况：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">multi_db_multi_table_01</div><div class="line">  ├── t_order_0                        ├── t_order_item_01</div><div class="line">  └── t_order_1                        ├── t_order_item_02</div><div class="line">                                       ├── t_order_item_03</div><div class="line">                                       ├── t_order_item_04</div><div class="line">multi_db_multi_table_02</div><div class="line">  ├── t_order_0                        ├── t_order_item_01</div><div class="line">  └── t_order_1                        ├── t_order_item_02</div><div class="line">                                       ├── t_order_item_03</div><div class="line">                                       ├── t_order_item_04</div></pre></td></tr></table></figure><p>最终执行的SQL如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_item_01 i <span class="keyword">JOIN</span> t_order_01 o <span class="keyword">ON</span> o.order_id = i.order_id </div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_item_01 i <span class="keyword">JOIN</span> t_order_01 o <span class="keyword">ON</span> o.order_id = i.order_id </div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_item_02 i <span class="keyword">JOIN</span> t_order_02 o <span class="keyword">ON</span> o.order_id = i.order_id</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order_item_02 i <span class="keyword">JOIN</span> t_order_02 o <span class="keyword">ON</span> o.order_id = i.order_id</div></pre></td></tr></table></figure><ul><li><code>t_order_item_03</code>、<code>t_order_item_04</code> 无法被查询到。</li></ul><p>下面我们看看 <code>#isAllBindingTables()</code> 如何实现<strong>多表互为BindingTable关系</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ShardingRule.java</span></div><div class="line"><span class="comment">// 调用顺序 #isAllBindingTables()=&gt;#filterAllBindingTables()=&gt;#findBindingTableRule()=&gt;#findBindingTableRule()</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 判断逻辑表名称集合是否全部属于Binding表.</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> logicTables 逻辑表名称集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAllBindingTables</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; logicTables)</span> </span>&#123;</div><div class="line">   Collection&lt;String&gt; bindingTables = filterAllBindingTables(logicTables);</div><div class="line">   <span class="keyword">return</span> !bindingTables.isEmpty() &amp;&amp; bindingTables.containsAll(logicTables);</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 过滤出所有的Binding表名称.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">filterAllBindingTables</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; logicTables)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (logicTables.isEmpty()) &#123;</div><div class="line">       <span class="keyword">return</span> Collections.emptyList();</div><div class="line">   &#125;</div><div class="line">   Optional&lt;BindingTableRule&gt; bindingTableRule = findBindingTableRule(logicTables);</div><div class="line">   <span class="keyword">if</span> (!bindingTableRule.isPresent()) &#123;</div><div class="line">       <span class="keyword">return</span> Collections.emptyList();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 交集</span></div><div class="line">   Collection&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(bindingTableRule.get().getAllLogicTables());</div><div class="line">   result.retainAll(logicTables);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获得包含&lt;strong&gt;任一&lt;/strong&gt;在逻辑表名称集合的binding表配置的逻辑表名称集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> Optional&lt;BindingTableRule&gt; <span class="title">findBindingTableRule</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; logicTables)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (String each : logicTables) &#123;</div><div class="line">       Optional&lt;BindingTableRule&gt; result = findBindingTableRule(each);</div><div class="line">       <span class="keyword">if</span> (result.isPresent()) &#123;</div><div class="line">           <span class="keyword">return</span> result;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> Optional.absent();</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 根据逻辑表名称获取binding表配置的逻辑表名称集合.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> Optional&lt;BindingTableRule&gt; <span class="title">findBindingTableRule</span><span class="params">(<span class="keyword">final</span> String logicTable)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (BindingTableRule each : bindingTableRules) &#123;</div><div class="line">       <span class="keyword">if</span> (each.hasLogicTable(logicTable)) &#123;</div><div class="line">           <span class="keyword">return</span> Optional.of(each);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> Optional.absent();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>逻辑看起来比较长，目的是找到一条 BindingTableRule 包含<strong>所有</strong>逻辑表集合</li><li>不支持<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E9%80%92%E5%85%B3%E7%B3%BB" rel="external nofollow noopener noreferrer" target="_blank">《传递关系》</a>：配置 BindingTableRule 时，<strong>相同绑定关系一定要配置在一条</strong>，必须是 <code>[a, b, c]</code>，而不能是 <code>[a, b], [b, c]</code>。</li></ul><h2 id="6-1-SimpleRoutingEngine"><a href="#6-1-SimpleRoutingEngine" class="headerlink" title="6.1 SimpleRoutingEngine"></a>6.1 SimpleRoutingEngine</h2><p>SimpleRoutingEngine，简单路由引擎。</p><p><img src="http://www.iocoder.cn/images/Sharding-JDBC/2017_08_06/07.png" alt=""></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SimpleRoutingEngine.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> Collection&lt;String&gt; <span class="title">routeDataSources</span><span class="params">(<span class="keyword">final</span> TableRule tableRule)</span> </span>&#123;</div><div class="line">   DatabaseShardingStrategy strategy = shardingRule.getDatabaseShardingStrategy(tableRule);</div><div class="line">   List&lt;ShardingValue&lt;?&gt;&gt; shardingValues = HintManagerHolder.isUseShardingHint() ? getDatabaseShardingValuesFromHint(strategy.getShardingColumns())</div><div class="line">           : getShardingValues(strategy.getShardingColumns());</div><div class="line">   Collection&lt;String&gt; result = strategy.doStaticSharding(sqlStatement.getType(), tableRule.getActualDatasourceNames(), shardingValues);</div><div class="line">   Preconditions.checkState(!result.isEmpty(), <span class="string">"no database route info"</span>);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> List&lt;ShardingValue&lt;?&gt;&gt; getShardingValues(<span class="keyword">final</span> Collection&lt;String&gt; shardingColumns) &#123;</div><div class="line">   List&lt;ShardingValue&lt;?&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(shardingColumns.size());</div><div class="line">   <span class="keyword">for</span> (String each : shardingColumns) &#123;</div><div class="line">       Optional&lt;Condition&gt; condition = sqlStatement.getConditions().find(<span class="keyword">new</span> Column(each, logicTableName));</div><div class="line">       <span class="keyword">if</span> (condition.isPresent()) &#123;</div><div class="line">           result.add(condition.get().getShardingValue(parameters));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>可以使用 HintManager 设置<strong>库</strong>分片值进行<strong>强制路由</strong>。</li><li><code>#getShardingValues()</code> 我们看到了<a href="http://www.iocoder.cn/Sharding-JDBC/sql-parse-2/">《SQL 解析（二）之SQL解析》</a>分享的 Condition 对象。之前我们提到过<strong>Parser 半理解SQL的目的之一是：提炼分片上下文</strong>，此处即是该目的的体现。Condition 里只放<strong>明确</strong>影响路由的条件，例如：<code>order_id = 1</code>, <code>order_id IN (1, 2)</code>, <code>order_id BETWEEN (1, 3)</code>，不放<strong>无法计算</strong>的条件，例如：<code>o.order_id = i.order_id</code>。该方法里，使用<strong>分片键</strong>从 Condition 查找 <strong>分片值</strong>。🙂 是不是对 Condition 的认识更加清晰一丢丢落。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SimpleRoutingEngine.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> Collection&lt;String&gt; <span class="title">routeTables</span><span class="params">(<span class="keyword">final</span> TableRule tableRule, <span class="keyword">final</span> Collection&lt;String&gt; routedDataSources)</span> </span>&#123;</div><div class="line">   TableShardingStrategy strategy = shardingRule.getTableShardingStrategy(tableRule);</div><div class="line">   List&lt;ShardingValue&lt;?&gt;&gt; shardingValues = HintManagerHolder.isUseShardingHint() ? getTableShardingValuesFromHint(strategy.getShardingColumns())</div><div class="line">           : getShardingValues(strategy.getShardingColumns());</div><div class="line">   Collection&lt;String&gt; result = tableRule.isDynamic() ? strategy.doDynamicSharding(shardingValues)</div><div class="line">           : strategy.doStaticSharding(sqlStatement.getType(), tableRule.getActualTableNames(routedDataSources), shardingValues);</div><div class="line">   Preconditions.checkState(!result.isEmpty(), <span class="string">"no table route info"</span>);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>可以使用 HintManager 设置<strong>表</strong>分片值进行<strong>强制路由</strong>。</li><li>根据 <code>dynamic</code> 属性来判断调用 <code>#doDynamicSharding()</code> 还是 <code>#doStaticSharding()</code> 计算分片。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SimpleRoutingEngine.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> RoutingResult <span class="title">generateRoutingResult</span><span class="params">(<span class="keyword">final</span> TableRule tableRule, <span class="keyword">final</span> Collection&lt;String&gt; routedDataSources, <span class="keyword">final</span> Collection&lt;String&gt; routedTables)</span> </span>&#123;</div><div class="line">   RoutingResult result = <span class="keyword">new</span> RoutingResult();</div><div class="line">   <span class="keyword">for</span> (DataNode each : tableRule.getActualDataNodes(routedDataSources, routedTables)) &#123;</div><div class="line">       result.getTableUnits().getTableUnits().add(<span class="keyword">new</span> TableUnit(each.getDataSourceName(), logicTableName, each.getTableName()));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// TableRule.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 根据数据源名称过滤获取真实数据单元.</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> targetDataSources 数据源名称集合</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> targetTables 真实表名称集合</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 真实数据单元</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> Collection&lt;DataNode&gt; <span class="title">getActualDataNodes</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; targetDataSources, <span class="keyword">final</span> Collection&lt;String&gt; targetTables)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> dynamic ? getDynamicDataNodes(targetDataSources, targetTables) : getStaticDataNodes(targetDataSources, targetTables);</div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">private</span> Collection&lt;DataNode&gt; <span class="title">getDynamicDataNodes</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; targetDataSources, <span class="keyword">final</span> Collection&lt;String&gt; targetTables)</span> </span>&#123;</div><div class="line">   Collection&lt;DataNode&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(targetDataSources.size() * targetTables.size());</div><div class="line">   <span class="keyword">for</span> (String targetDataSource : targetDataSources) &#123;</div><div class="line">       <span class="keyword">for</span> (String targetTable : targetTables) &#123;</div><div class="line">           result.add(<span class="keyword">new</span> DataNode(targetDataSource, targetTable));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125; </div><div class="line"><span class="function"><span class="keyword">private</span> Collection&lt;DataNode&gt; <span class="title">getStaticDataNodes</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; targetDataSources, <span class="keyword">final</span> Collection&lt;String&gt; targetTables)</span> </span>&#123;</div><div class="line">   Collection&lt;DataNode&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(actualTables.size());</div><div class="line">   <span class="keyword">for</span> (DataNode each : actualTables) &#123;</div><div class="line">       <span class="keyword">if</span> (targetDataSources.contains(each.getDataSourceName()) &amp;&amp; targetTables.contains(each.getTableName())) &#123;</div><div class="line">           result.add(each);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>在 SimpleRoutingEngine 只生成了当前表的 TableUnits。如果存在<strong>与其互为BindingTable关系</strong>的表的 TableUnits 怎么获得？你可以想想噢，当然在后文<a href="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg">《SQL 改写》</a>也会给出答案，看看和你想的是否一样。</li></ul><h2 id="6-2-ComplexRoutingEngine"><a href="#6-2-ComplexRoutingEngine" class="headerlink" title="6.2 ComplexRoutingEngine"></a>6.2 ComplexRoutingEngine</h2><p>ComplexRoutingEngine，混合多库表路由引擎。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ComplexRoutingEngine.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> RoutingResult <span class="title">route</span><span class="params">()</span> </span>&#123;</div><div class="line">   Collection&lt;RoutingResult&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(logicTables.size());</div><div class="line">   Collection&lt;String&gt; bindingTableNames = <span class="keyword">new</span> TreeSet&lt;&gt;(String.CASE_INSENSITIVE_ORDER);</div><div class="line">   <span class="comment">// 计算每个逻辑表的简单路由分片</span></div><div class="line">   <span class="keyword">for</span> (String each : logicTables) &#123;</div><div class="line">       Optional&lt;TableRule&gt; tableRule = shardingRule.tryFindTableRule(each);</div><div class="line">       <span class="keyword">if</span> (tableRule.isPresent()) &#123;</div><div class="line">           <span class="keyword">if</span> (!bindingTableNames.contains(each)) &#123;</div><div class="line">               result.add(<span class="keyword">new</span> SimpleRoutingEngine(shardingRule, parameters, tableRule.get().getLogicTable(), sqlStatement).route());</div><div class="line">           &#125;</div><div class="line">           <span class="comment">// 互为 BindingTable 关系的表加到 bindingTableNames 里，不重复计算分片</span></div><div class="line">           Optional&lt;BindingTableRule&gt; bindingTableRule = shardingRule.findBindingTableRule(each);</div><div class="line">           <span class="keyword">if</span> (bindingTableRule.isPresent()) &#123;</div><div class="line">               bindingTableNames.addAll(Lists.transform(bindingTableRule.get().getTableRules(), <span class="keyword">new</span> Function&lt;TableRule, String&gt;() &#123;</div><div class="line">                   </div><div class="line">                   <span class="meta">@Override</span></div><div class="line">                   <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(<span class="keyword">final</span> TableRule input)</span> </span>&#123;</div><div class="line">                       <span class="keyword">return</span> input.getLogicTable();</div><div class="line">                   &#125;</div><div class="line">               &#125;));</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   log.trace(<span class="string">"mixed tables sharding result: &#123;&#125;"</span>, result);</div><div class="line">   <span class="keyword">if</span> (result.isEmpty()) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ShardingJdbcException(<span class="string">"Cannot find table rule and default data source with logic tables: '%s'"</span>, logicTables);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 防御性编程。shardingRule#isAllBindingTables() 已经过滤了这个情况。</span></div><div class="line">   <span class="keyword">if</span> (<span class="number">1</span> == result.size()) &#123;</div><div class="line">       <span class="keyword">return</span> result.iterator().next();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 交给 CartesianRoutingEngine 形成笛卡尔积结果</span></div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> CartesianRoutingEngine(result).route();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>ComplexRoutingEngine 计算每个逻辑表的简单路由分片，路由结果交给 CartesianRoutingEngine <strong>继续</strong>路由形成笛卡尔积结果。</li></ul><p><img src="http://www.iocoder.cn//images/Sharding-JDBC/2017_08_06/08.png" alt=""></p><ul><li>由于目前 ComplexRoutingEngine 路由前已经判断<strong>全部表互为 BindingTable 关系</strong>，因而不会出现 <code>result.size == 1</code>，属于防御性编程。</li><li><strong>部分表互为 BindingTable 关系</strong>时，ComplexRoutingEngine 不重复计算分片。</li></ul><h2 id="6-3-CartesianRoutingEngine"><a href="#6-3-CartesianRoutingEngine" class="headerlink" title="6.3 CartesianRoutingEngine"></a>6.3 CartesianRoutingEngine</h2><p>CartesianRoutingEngine，笛卡尔积的库表路由。</p><p>实现逻辑上<strong>相对</strong>复杂，请保持耐心哟，😈 其实目的就是实现<strong>连连看</strong>的效果：</p><ul><li>RoutingResult[0] <code>x</code> RoutingResult[1] …… <code>x</code> RoutingResult[n- 1] <code>x</code> RoutingResult[n]</li><li><strong>同库</strong> 才可以进行笛卡尔积</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// CartesianRoutingEngine.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> CartesianRoutingResult <span class="title">route</span><span class="params">()</span> </span>&#123;</div><div class="line">   CartesianRoutingResult result = <span class="keyword">new</span> CartesianRoutingResult();</div><div class="line">   <span class="keyword">for</span> (Entry&lt;String, Set&lt;String&gt;&gt; entry : getDataSourceLogicTablesMap().entrySet()) &#123; <span class="comment">// Entry&lt;数据源（库）, Set&lt;逻辑表&gt;&gt; entry</span></div><div class="line">       <span class="comment">// 获得当前数据源（库）的 路由表单元分组</span></div><div class="line">       List&lt;Set&lt;String&gt;&gt; actualTableGroups = getActualTableGroups(entry.getKey(), entry.getValue()); <span class="comment">// List&lt;Set&lt;真实表&gt;&gt;</span></div><div class="line">       List&lt;Set&lt;TableUnit&gt;&gt; tableUnitGroups = toTableUnitGroups(entry.getKey(), actualTableGroups);</div><div class="line">       <span class="comment">// 笛卡尔积，并合并结果</span></div><div class="line">       result.merge(entry.getKey(), getCartesianTableReferences(Sets.cartesianProduct(tableUnitGroups)));</div><div class="line">   &#125;</div><div class="line">   log.trace(<span class="string">"cartesian tables sharding result: &#123;&#125;"</span>, result);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>第一步，获得<strong>同库</strong>对应的<strong>逻辑表</strong>集合，即 <strong>Entry&lt;数据源（库）, Set&lt;逻辑表&gt;&gt; entry</strong>。</li><li>第二步，遍历<strong>数据源（库）</strong>，获得当前<strong>数据源（库）</strong>的<strong>路由表单元分组</strong>。</li><li>第三步，对<strong>路由表单元分组</strong>进行<strong>笛卡尔积</strong>，并合并到路由结果。</li></ul><p>下面，我们一起逐步看看代码实现。</p><ul><li>SQL ：<code>SELECT * FROM t_order o join t_order_item i ON o.order_id = i.order_id</code></li><li>分库分表情况：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">multi_db_multi_table_01</div><div class="line">  ├── t_order_0                        ├── t_order_item_01</div><div class="line">  └── t_order_1                        ├── t_order_item_02</div><div class="line">multi_db_multi_table_02</div><div class="line">  ├── t_order_0                        ├── t_order_item_01</div><div class="line">  └── t_order_1                        ├── t_order_item_02</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 第一步</span></div><div class="line"><span class="comment">// CartesianRoutingEngine.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获得同库对应的逻辑表集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> Map&lt;String, Set&lt;String&gt;&gt; getDataSourceLogicTablesMap() &#123;</div><div class="line">   Collection&lt;String&gt; intersectionDataSources = getIntersectionDataSources();</div><div class="line">   Map&lt;String, Set&lt;String&gt;&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;(routingResults.size());</div><div class="line">   <span class="comment">// 获得同库对应的逻辑表集合</span></div><div class="line">   <span class="keyword">for</span> (RoutingResult each : routingResults) &#123;</div><div class="line">       <span class="keyword">for</span> (Entry&lt;String, Set&lt;String&gt;&gt; entry : each.getTableUnits().getDataSourceLogicTablesMap(intersectionDataSources).entrySet()) &#123; <span class="comment">// 过滤掉不在数据源（库）交集的逻辑表</span></div><div class="line">           <span class="keyword">if</span> (result.containsKey(entry.getKey())) &#123;</div><div class="line">               result.get(entry.getKey()).addAll(entry.getValue());</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               result.put(entry.getKey(), entry.getValue());</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获得所有路由结果里的数据源（库）交集</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> Collection&lt;String&gt; <span class="title">getIntersectionDataSources</span><span class="params">()</span> </span>&#123;</div><div class="line">   Collection&lt;String&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">   <span class="keyword">for</span> (RoutingResult each : routingResults) &#123;</div><div class="line">       <span class="keyword">if</span> (result.isEmpty()) &#123;</div><div class="line">           result.addAll(each.getTableUnits().getDataSourceNames());</div><div class="line">       &#125;</div><div class="line">       result.retainAll(each.getTableUnits().getDataSourceNames()); <span class="comment">// 交集</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>#getDataSourceLogicTablesMap()</code> 返回如图：<img src="http://www.iocoder.cn//images/Sharding-JDBC/2017_08_06/09.png" alt=""></li></ul><hr><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 第二步</span></div><div class="line"><span class="comment">// CartesianRoutingEngine.java</span></div><div class="line"><span class="keyword">private</span> List&lt;Set&lt;String&gt;&gt; getActualTableGroups(<span class="keyword">final</span> String dataSource, <span class="keyword">final</span> Set&lt;String&gt; logicTables) &#123;</div><div class="line">   List&lt;Set&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(logicTables.size());</div><div class="line">   <span class="keyword">for</span> (RoutingResult each : routingResults) &#123;</div><div class="line">       result.addAll(each.getTableUnits().getActualTableNameGroups(dataSource, logicTables));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> List&lt;Set&lt;TableUnit&gt;&gt; toTableUnitGroups(<span class="keyword">final</span> String dataSource, <span class="keyword">final</span> List&lt;Set&lt;String&gt;&gt; actualTableGroups) &#123;</div><div class="line">   List&lt;Set&lt;TableUnit&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(actualTableGroups.size());</div><div class="line">   <span class="keyword">for</span> (Set&lt;String&gt; each : actualTableGroups) &#123;</div><div class="line">       result.add(<span class="keyword">new</span> HashSet&lt;&gt;(Lists.transform(<span class="keyword">new</span> ArrayList&lt;&gt;(each), <span class="keyword">new</span> Function&lt;String, TableUnit&gt;() &#123;</div><div class="line">    </div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> TableUnit <span class="title">apply</span><span class="params">(<span class="keyword">final</span> String input)</span> </span>&#123;</div><div class="line">               <span class="keyword">return</span> findTableUnit(dataSource, input);</div><div class="line">           &#125;</div><div class="line">       &#125;)));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>#getActualTableGroups()</code> 返回如图：<img src="http://www.iocoder.cn//images/Sharding-JDBC/2017_08_06/10.png" alt=""></li><li><code>#toTableUnitGroups()</code> 返回如图：<img src="http://www.iocoder.cn//images/Sharding-JDBC/2017_08_06/11.png" alt=""></li></ul><hr><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// CartesianRoutingEngine.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> List&lt;CartesianTableReference&gt; <span class="title">getCartesianTableReferences</span><span class="params">(<span class="keyword">final</span> Set&lt;List&lt;TableUnit&gt;&gt; cartesianTableUnitGroups)</span> </span>&#123;</div><div class="line">   List&lt;CartesianTableReference&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(cartesianTableUnitGroups.size());</div><div class="line">   <span class="keyword">for</span> (List&lt;TableUnit&gt; each : cartesianTableUnitGroups) &#123;</div><div class="line">       result.add(<span class="keyword">new</span> CartesianTableReference(each));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// CartesianRoutingResult.java</span></div><div class="line"><span class="meta">@Getter</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;CartesianDataSource&gt; routingDataSources = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">final</span> String dataSource, <span class="keyword">final</span> Collection&lt;CartesianTableReference&gt; routingTableReferences)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (CartesianTableReference each : routingTableReferences) &#123;</div><div class="line">       merge(dataSource, each);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">final</span> String dataSource, <span class="keyword">final</span> CartesianTableReference routingTableReference)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (CartesianDataSource each : routingDataSources) &#123;</div><div class="line">       <span class="keyword">if</span> (each.getDataSource().equalsIgnoreCase(dataSource)) &#123;</div><div class="line">           each.getRoutingTableReferences().add(routingTableReference);</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   routingDataSources.add(<span class="keyword">new</span> CartesianDataSource(dataSource, routingTableReference));</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>Sets.cartesianProduct(tableUnitGroups)</code> 返回如图（Guava 工具库真强大）：<img src="http://www.iocoder.cn//images/Sharding-JDBC/2017_08_06/12.png" alt=""></li><li><p><code>#getCartesianTableReferences()</code> 返回如图：<img src="http://www.iocoder.cn//images/Sharding-JDBC/2017_08_06/13.png" alt=""></p><p>CartesianTableReference，笛卡尔积表<strong>路由组</strong>，包含<strong>多条</strong> TableUnit，即 TableUnit[0] <code>x</code> TableUnit[1] …… <code>x</code> TableUnit[n]。例如图中：<code>t_order_01 x t_order_item_02</code>，最终转换成 SQL 为 <code>SELECT * FROM t_order_01 o join t_order_item_02 i ON o.order_id = i.order_id</code>。</p></li><li><code>#merge()</code> 合并笛卡尔积路由结果。CartesianRoutingResult 包含多个 CartesianDataSource，因此需要将 CartesianTableReference 合并（添加）到对应的 CartesianDataSource。当然，目前在实现时已经是按照<strong>数据源（库）</strong>生成对应的 CartesianTableReference。</li></ul><h2 id="6-4-ParsingSQLRouter-主-route"><a href="#6-4-ParsingSQLRouter-主-route" class="headerlink" title="6.4 ParsingSQLRouter 主#route()"></a>6.4 ParsingSQLRouter 主#route()</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ParsingSQLRouter.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> SQLRouteResult <span class="title">route</span><span class="params">(<span class="keyword">final</span> String logicSQL, <span class="keyword">final</span> List&lt;Object&gt; parameters, <span class="keyword">final</span> SQLStatement sqlStatement)</span> </span>&#123;</div><div class="line">   <span class="keyword">final</span> Context context = MetricsContext.start(<span class="string">"Route SQL"</span>);</div><div class="line">   SQLRouteResult result = <span class="keyword">new</span> SQLRouteResult(sqlStatement);</div><div class="line">   <span class="comment">// 处理 插入SQL 主键字段</span></div><div class="line">   <span class="keyword">if</span> (sqlStatement <span class="keyword">instanceof</span> InsertStatement &amp;&amp; <span class="keyword">null</span> != ((InsertStatement) sqlStatement).getGeneratedKey()) &#123;</div><div class="line">       processGeneratedKey(parameters, (InsertStatement) sqlStatement, result);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 🐒🐒🐒 路由 🐒🐒🐒</span></div><div class="line">   RoutingResult routingResult = route(parameters, sqlStatement);</div><div class="line">   <span class="comment">// SQL重写引擎</span></div><div class="line">   SQLRewriteEngine rewriteEngine = <span class="keyword">new</span> SQLRewriteEngine(shardingRule, logicSQL, sqlStatement);</div><div class="line">   <span class="keyword">boolean</span> isSingleRouting = routingResult.isSingleRouting();</div><div class="line">   <span class="comment">// 处理分页</span></div><div class="line">   <span class="keyword">if</span> (sqlStatement <span class="keyword">instanceof</span> SelectStatement &amp;&amp; <span class="keyword">null</span> != ((SelectStatement) sqlStatement).getLimit()) &#123;</div><div class="line">       processLimit(parameters, (SelectStatement) sqlStatement, isSingleRouting);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// SQL 重写</span></div><div class="line">   SQLBuilder sqlBuilder = rewriteEngine.rewrite(!isSingleRouting);</div><div class="line">   <span class="comment">// 生成 ExecutionUnit</span></div><div class="line">   <span class="keyword">if</span> (routingResult <span class="keyword">instanceof</span> CartesianRoutingResult) &#123;</div><div class="line">       <span class="keyword">for</span> (CartesianDataSource cartesianDataSource : ((CartesianRoutingResult) routingResult).getRoutingDataSources()) &#123;</div><div class="line">           <span class="keyword">for</span> (CartesianTableReference cartesianTableReference : cartesianDataSource.getRoutingTableReferences()) &#123;</div><div class="line">               result.getExecutionUnits().add(<span class="keyword">new</span> SQLExecutionUnit(cartesianDataSource.getDataSource(), rewriteEngine.generateSQL(cartesianTableReference, sqlBuilder))); <span class="comment">// 生成 SQL</span></div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">for</span> (TableUnit each : routingResult.getTableUnits().getTableUnits()) &#123;</div><div class="line">           result.getExecutionUnits().add(<span class="keyword">new</span> SQLExecutionUnit(each.getDataSourceName(), rewriteEngine.generateSQL(each, sqlBuilder))); <span class="comment">// 生成 SQL</span></div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   MetricsContext.stop(context);</div><div class="line">   <span class="comment">// 打印 SQL</span></div><div class="line">   <span class="keyword">if</span> (showSQL) &#123;</div><div class="line">       SQLLogger.logSQL(logicSQL, sqlStatement, result.getExecutionUnits(), parameters);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>RoutingResult routingResult = route(parameters, sqlStatement);</code> <strong>调用</strong>的就是上文分析的 SimpleRoutingEngine、ComplexRoutingEngine、CartesianRoutingEngine 的 <code>#route()</code> 方法。</li><li><code>#processGeneratedKey()</code>、<code>#processLimit()</code>、<code>#rewrite()</code>、<code>#generateSQL()</code> 等会放在<a href="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg">《SQL 改写》</a> 分享。</li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>篇幅有些长，希望能让大家对<strong>路由</strong>有比较完整的认识。<br>如果内容有错误，烦请您指正，我会<strong>认真</strong>修改。<br>如果表述不清晰，不太理解的，欢迎加我微信（wangwenbin-server）一起探讨。</p><p>谢谢你技术这么好，还<strong>耐心</strong>看完了本文。</p><p>强制路由 HintManager 讲的相对略过，可以看如下内容进一步了解：</p><ol><li><a href="http://dangdangdotcom.github.io/sharding-jdbc/02-guide/hint-sharding-value/" rel="external nofollow noopener noreferrer" target="_blank">《官方文档-强制路由》</a></li><li><a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/9354031743b63e44cbded5618980ae71a15f0260/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/api/HintManager.java#L41" rel="external nofollow noopener noreferrer" target="_blank">HintManager.java 源码</a></li></ol><p>厚着脸皮，道友，辛苦<strong>分享朋友圈</strong>可好？！</p></div><footer class="article-footer clearfix"><div class="article-categories"><span></span> <a class="article-category-link" href="/categories/Sharding-JDBC/">Sharding-JDBC</a></div><div class="article-share" id="share"><div data-url="http://www.iocoder.cn/Sharding-JDBC/sql-route-2/" data-title="Sharding-JDBC 源码分析 —— SQL 路由（二）之分库分表路由 | 芋道源码 —— 纯源码解析BLOG" data-tsina="null" class="share clearfix"></div></div></footer></article><nav class="article-nav clearfix"><div class="prev"><a href="/Sharding-JDBC/sql-route-3/" title="Sharding-JDBC 源码分析 —— SQL 路由（三）之Spring与YAML配置"><strong>PREVIOUS:</strong><br><span>Sharding-JDBC 源码分析 —— SQL 路由（三）之Spring与YAML配置</span></a></div><div class="next"><a href="/Sharding-JDBC/sql-route-1/" title="Sharding-JDBC 源码分析 —— SQL 路由（一）之分库分表配置"><strong>NEXT:</strong><br><span>Sharding-JDBC 源码分析 —— SQL 路由（一）之分库分表配置</span></a></div></nav></div></div><footer><div id="footer"><img src="http://www.iocoder.cn/images/common/wechat_mp_simple.png" style="display:none"><p class="copyright">© 2017 <a href="http://www.iocoder.cn" target="_blank" title="王文斌">王文斌</a> && <span style="display:inline" id="busuanzi_container_site_uv">总访客数 <span id="busuanzi_value_site_uv" font="微软雅黑"></span> 次</span> && <span style="display:inline" id="busuanzi_container_site_pv">总访问量 <span id="busuanzi_value_site_pv" font="微软雅黑"></span> 次</span></p></div><div class="copyright">沪ICP备17037075号-1</div></footer><script src="/js/jquery-2.1.0.min.js"></script><script type="text/javascript">$(document).ready(function(){function e(){"number"==typeof window.innerWidth?n=window.innerWidth:document.documentElement&&document.documentElement.clientWidth&&(n=document.documentElement.clientWidth)}$(".navbar").click(function(){$("header nav").toggleClass("shownav")});var n=0,s=$("#main"),a=$("#asidepart"),o=$(".closeaside"),d=$(".openaside");$(window).resize(function(){e(),n>=1024?$("header nav").removeClass("shownav"):(s.removeClass("moveMain"),a.css("display","block").removeClass("fadeOut"),d.css("display","none"),$("#toc.toc-aside").css("display","none"))}),o.click(function(){a.addClass("fadeOut").css("display","none"),d.css("display","block").addClass("fadeIn"),s.addClass("moveMain")}),d.click(function(){d.css("display","none").removeClass("beforeFadeIn"),a.css("display","block").removeClass("fadeOut").addClass("fadeIn"),s.removeClass("moveMain")}),$(window).scroll(function(){d.css("top",Math.max(80,260-$(this).scrollTop()))})})</script><script type="text/javascript">$(document).ready(function(){var a=$(".article-content>iframe"),t=$(".article-content>embed"),n=$("#toc");$("article h2");ah=$("article h2"),ta=$("#toc.toc-aside"),o=$(".openaside"),c=$(".closeaside"),a.length>0&&a.wrap('<div class="video-container" />'),t.length>0&&t.wrap('<div class="video-container" />'),0==ah.length?n.css("display","none"):(c.click(function(){ta.css("display","block").addClass("fadeIn")}),o.click(function(){ta.css("display","none")}),$(window).scroll(function(){ta.css("top",Math.max(140,320-$(this).scrollTop()))}))})</script><script type="text/javascript">$(document).ready(function(){var t=$(".share"),a=t.attr("data-url"),e=encodeURIComponent(a),r=['<a href="#" class="overlay" id="qrcode"></a>','<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url='+e+'"/></div>','<a href="#textlogo" class="article-back-to-top" title="Top"></a>','<a href="https://www.facebook.com/sharer.php?u='+e+'" class="article-share-facebook" target="_blank" title="Facebook"></a>','<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>','<a href="https://twitter.com/intent/tweet?url='+e+'" class="article-share-twitter" target="_blank" title="Twitter"></a>','<a href="http://service.weibo.com/share/share.php?title='+t.attr("data-title")+"&url="+e+"&ralateUid="+t.attr("data-tsina")+'&searchPic=true&style=number" class="article-share-weibo" target="_blank" title="Weibo"></a>','<span title="Share to"></span>'].join("");t.append(r),$(".article-share-qrcode").click(function(){var t=$("#qrcode-pic").attr("data-src");$("#qrcode-pic").attr("src",t),$("#qrcode-pic").load(function(){$(".qrcode strong").text(" ")})})})</script><link rel="stylesheet" href="/alert/css/alert.css"><script src="/alert/js/alert.js"></script><script src="/js/jquery.cookie.js"></script><script src="/js/util.js"></script><script type="text/javascript">!function(e,a,t,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=a.createElement(t),s=a.getElementsByTagName(t)[0],o.async=1,o.src="//www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s)}(window,document,"script",0,"ga"),ga("create","UA-107572620-1","auto"),ga("send","pageview")</script></body>