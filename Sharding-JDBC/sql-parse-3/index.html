<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="google-site-verification" content="GkJ68PCnxM9Ih7Zm9v8p91FOCV7ymNCO2KdGbflLh3E"><meta name="360-site-verification" content="dd6547587641bfede036f7c79561e8a0"><meta name="shenma-site-verification" content="fd96cf3751972c9b05f8471d2ccadddc_1496951214"><meta name="msvalidate.01" content="1D38B05050A977F6FDEDA481198343F1"><meta name="sogou_site_verification" content="MpPsku240L"><title>Sharding-JDBC 源码分析 —— SQL 解析（三）之查询SQL | 芋道源码 —— 纯源码解析博客</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=3,minimum-scale=1"><meta name="author" content="芋道源码"><meta name="description" content="摘要: 原创出处 http://www.iocoder.cn/Sharding-JDBC/sql-parse-3/ 「芋道源码」欢迎转载，保留摘要，谢谢！
本文主要基于 Sharding-JDBC 1.5.0 正式版  

1. 概述
2. SelectStatement
2.1 AbstractS"><meta name="keywords" content="Sharding-JDBC,ShardingJDBC,Sharding-JDBC 源码,SQL解析, SQL 解析,Java,架构,后端,服务端,RocketMQ,MyCAT,分布式消息队列,分布式存储,技术博客,Sharding-JDBC,分库分表"><link rel="alternate" href="atom.xml" title="芋道源码 —— 纯源码解析博客" type="application/atom+xml"><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/style.css"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?9e70e3362807c1bd185a79655b307027";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script>!function(){var t="http:"==document.location.protocol?"http://js.passport.qihucdn.com/11.0.1.js?f05b61dd54bbc38386611a5238672938":"https://jspassport.ssl.qhimg.com/11.0.1.js?f05b61dd54bbc38386611a5238672938";document.write('<script src="'+t+'" id="sozz"><\/script>')}()</script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></head></html><body><header><div><div id="textlogo"><h1 class="site-name"><a href="/" title="芋道源码 —— 纯源码解析博客">芋道源码 —— 纯源码解析博客</a></h1><a class="blog-motto">愿半生编码，如一生老友！</a></div><div class="navbar"><a class="navbutton navmobile" href="#" title="菜单"></a></div><nav class="animated"><ul><ul><li><a href="/">文章</a></li><li><a href="/2018-meet-you">知识星球</a></li><li><a href="https://github.com/YunaiV" rel="external nofollow noopener noreferrer" target="_blank">Github</a></li><li><a href="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31_bak.jpg">微信公众号</a></li><li><a href="/categories/%E5%B7%A5%E4%BD%9C%E5%86%85%E6%8E%A8/">工作内推</a></li><li><a href="/link_url">友链</a></li></ul></ul></nav></div></header><div id="container"><div id="main" class="post" itemscope="" itemprop="blogPost"><article itemprop="articleBody"><header class="article-info clearfix"><h1 itemprop="name"><a href="/Sharding-JDBC/sql-parse-3/" title="Sharding-JDBC 源码分析 —— SQL 解析（三）之查询SQL" itemprop="url">Sharding-JDBC 源码分析 —— SQL 解析（三）之查询SQL</a></h1><p class="article-author"></p><p class="article-time">总阅读量:<span id="busuanzi_value_page_pv"></span>次</p></header><div class="article-content"><p>摘要: 原创出处 <a href="http://www.iocoder.cn/Sharding-JDBC/sql-parse-3/">http://www.iocoder.cn/Sharding-JDBC/sql-parse-3/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Sharding-JDBC 1.5.0 正式版</strong></p><ul><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-parse-3/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-parse-3/">2. SelectStatement</a><ul><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-parse-3/">2.1 AbstractSQLStatement</a></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-parse-3/">2.2 SQLToken</a></li></ul></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-parse-3/">3. #query()</a><ul><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-parse-3/">3.1 #parseDistinct()</a></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-parse-3/">3.2 #parseSelectList()</a></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-parse-3/">3.3 #skipToFrom()</a></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-parse-3/">3.4 #parseFrom()</a></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-parse-3/">3.5 #parseWhere()</a></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-parse-3/">3.6 #parseGroupBy()</a></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-parse-3/">3.7 #parseOrderBy()</a></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-parse-3/">3.8 #parseLimit()</a></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-parse-3/">3.9 #queryRest()</a></li></ul></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-parse-3/">4. appendDerived等方法</a><ul><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-parse-3/">4.1 appendAvgDerivedColumns</a></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-parse-3/">4.2 appendDerivedOrderColumns</a></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-parse-3/">4.3 ItemsToken</a></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-parse-3/">4.4 appendDerivedOrderBy()</a></li></ul></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-parse-3/">666. 彩蛋</a></li></ul><hr><p><img src="https://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文前置阅读：</p><ul><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-parse-1/?self">《SQL 解析（一）之词法解析》</a></li><li><a href="http://www.iocoder.cn/Sharding-JDBC/sql-parse-2/?self">《SQL 解析（二）之SQL解析》</a></li></ul><p>本文分享<strong>插入SQL解析</strong>的源码实现。</p><p>由于每个数据库在遵守 SQL 语法规范的同时，又有各自独特的语法。因此，在 Sharding-JDBC 里每个数据库都有自己的 SELECT 语句的解析器实现方式，当然绝大部分逻辑是相同的。<strong>本文主要分享笔者最常用的 MySQL 查询</strong>。</p><p>查询 SQL 解析主流程如下：</p><p><img src="http://www.iocoder.cn/images/Sharding-JDBC/2017_07_27/03.png" alt=""></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractSelectParser.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectStatement <span class="title">parse</span><span class="params">()</span> </span>&#123;</div><div class="line">   query();</div><div class="line">   parseOrderBy();</div><div class="line">   customizedSelect();</div><div class="line">   appendDerivedColumns();</div><div class="line">   appendDerivedOrderBy();</div><div class="line">   <span class="keyword">return</span> selectStatement;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>#parseOrderBy()</code> ：对于 MySQL 查询语句解析器无效果，因为已经在 <code>#query()</code> 方法里面已经调用 <code>#parseOrderBy()</code>，因此图中省略该方法。</li><li><code>#customizedSelect()</code> ：Oracle、SQLServer 查询语句解析器重写了该方法，对于 MySQL 查询解析器是个空方法，进行省略。有兴趣的同学可以单独去研究研究。</li></ul><blockquote><p><strong>Sharding-JDBC 正在收集使用公司名单：<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。<br>🙂 你的登记，会让更多人参与和使用 Sharding-JDBC。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>Sharding-JDBC 也会因此，能够覆盖更多的业务场景。<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a><br>登记吧，骚年！<a href="https://github.com/dangdangdotcom/sharding-jdbc/issues/234" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></strong></p></blockquote><p>👼 查询语句解析是增删改查里面<strong>最灵活也是最复杂的</strong>，希望大家有耐心看完本文。理解查询语句解析，另外三种语句理解起来简直是 SO EASY。骗人是小狗🐶。<br>🙂如果对本文有不理解的地方，可以给我的公众号<strong>（<a href="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg">芋道源码</a>）</strong>留言，我会<strong>逐条认真耐心</strong>回复。骗人是小猪🐷。</p><p>OK，不废话啦，开始我们这段痛并快乐的旅途。</p><h1 id="2-SelectStatement"><a href="#2-SelectStatement" class="headerlink" title="2. SelectStatement"></a>2. SelectStatement</h1><p>🙂 <strong>本节只介绍这些类，方便本文下节分析源码实现大家能知道认识它们</strong> 🙂</p><p>SelectStatement，查询语句解析结果对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SelectStatement.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectStatement</span> <span class="keyword">extends</span> <span class="title">AbstractSQLStatement</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 是否行 DISTINCT / DISTINCTROW / UNION</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> distinct;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 是否查询所有字段，即 SELECT *</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> containStar;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 最后一个查询项下一个 Token 的开始位置</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@see</span> #items</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> selectListLastPosition;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 最后一个分组项下一个 Token 的开始位置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> groupByLastPosition;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 查询项</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;SelectItem&gt; items = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 分组项</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;OrderItem&gt; groupByItems = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 排序项</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;OrderItem&gt; orderByItems = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 分页</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Limit limit;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们对属性按照类型进行归类：</p><ul><li>特殊<ul><li>distinct</li></ul></li><li>查询字段<ul><li>containStar</li><li>items</li><li>selectListLastPosition</li></ul></li><li>分组条件<ul><li>groupByItems</li><li>groupByLastPosition</li></ul></li><li>排序条件<ul><li>orderByItems</li></ul></li><li>分页条件<ul><li>limit</li></ul></li></ul><h2 id="2-1-AbstractSQLStatement"><a href="#2-1-AbstractSQLStatement" class="headerlink" title="2.1 AbstractSQLStatement"></a>2.1 AbstractSQLStatement</h2><p>增删改查解析结果对象的<strong>抽象父类</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSQLStatement</span> <span class="keyword">implements</span> <span class="title">SQLStatement</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * SQL 类型</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SQLType type;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 表</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Tables tables = <span class="keyword">new</span> Tables();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 过滤条件。</span></div><div class="line"><span class="comment">     * 只有对路由结果有影响的条件，才添加进数组</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Conditions conditions = <span class="keyword">new</span> Conditions();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * SQL标记对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;SQLToken&gt; sqlTokens = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="2-2-SQLToken"><a href="#2-2-SQLToken" class="headerlink" title="2.2 SQLToken"></a>2.2 SQLToken</h2><p>SQLToken，SQL标记对象接口，SQL 改写时使用到。下面都是它的实现类：</p><table><thead><tr><th style="text-align:left">类</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">GeneratedKeyToken</td><td style="text-align:left">自增主键标记对象</td></tr><tr><td style="text-align:left">TableToken</td><td style="text-align:left">表标记对象</td></tr><tr><td style="text-align:left">ItemsToken</td><td style="text-align:left">选择项标记对象</td></tr><tr><td style="text-align:left">OffsetToken</td><td style="text-align:left">分页偏移量标记对象</td></tr><tr><td style="text-align:left">OrderByToken</td><td style="text-align:left">排序标记对象</td></tr><tr><td style="text-align:left">RowCountToken</td><td style="text-align:left">分页长度标记对象</td></tr></tbody></table><h1 id="3-query"><a href="#3-query" class="headerlink" title="3. #query()"></a>3. #query()</h1><p><code>#query()</code>，查询 SQL 解析。</p><p><strong>MySQL SELECT Syntax</strong>：</p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line">// https://dev.mysql.com/doc/refman/5.7/en/select.html</div><div class="line"><span class="keyword">SELECT</span></div><div class="line">    [ALL | <span class="keyword">DISTINCT</span> | <span class="keyword">DISTINCTROW</span> ]</div><div class="line">      [<span class="keyword">HIGH_PRIORITY</span>]</div><div class="line">      [<span class="keyword">STRAIGHT_JOIN</span>]</div><div class="line">      [<span class="keyword">SQL_SMALL_RESULT</span>] [<span class="keyword">SQL_BIG_RESULT</span>] [<span class="keyword">SQL_BUFFER_RESULT</span>]</div><div class="line">      [<span class="keyword">SQL_CACHE</span> | SQL_NO_CACHE] [<span class="keyword">SQL_CALC_FOUND_ROWS</span>]</div><div class="line">    select_expr [, select_expr ...]</div><div class="line">    [<span class="keyword">FROM</span> table_references</div><div class="line">      [<span class="keyword">PARTITION</span> partition_list]</div><div class="line">    [<span class="keyword">WHERE</span> where_condition]</div><div class="line">    [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &#123;col_name | expr | <span class="keyword">position</span>&#125;</div><div class="line">      [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>], ... [<span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>]]</div><div class="line">    [<span class="keyword">HAVING</span> where_condition]</div><div class="line">    [<span class="keyword">ORDER</span> <span class="keyword">BY</span> &#123;col_name | expr | <span class="keyword">position</span>&#125;</div><div class="line">      [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>], ...]</div><div class="line">    [<span class="keyword">LIMIT</span> &#123;[<span class="keyword">offset</span>,] <span class="keyword">row_count</span> | <span class="keyword">row_count</span> <span class="keyword">OFFSET</span> <span class="keyword">offset</span>&#125;]</div><div class="line">    [<span class="keyword">PROCEDURE</span> procedure_name(argument_list)]</div><div class="line">    [<span class="keyword">INTO</span> <span class="keyword">OUTFILE</span> <span class="string">'file_name'</span></div><div class="line">        [<span class="built_in">CHARACTER</span> <span class="keyword">SET</span> charset_name]</div><div class="line">        export_options</div><div class="line">      | <span class="keyword">INTO</span> <span class="keyword">DUMPFILE</span> <span class="string">'file_name'</span></div><div class="line">      | <span class="keyword">INTO</span> var_name [, var_name]]</div><div class="line">    [<span class="keyword">FOR</span> <span class="keyword">UPDATE</span> | <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>]]</div></pre></td></tr></table></figure><p>大体流程如下：</p><p><img src="http://www.iocoder.cn/images/Sharding-JDBC/2017_07_27/04.png" alt=""></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// MySQLSelectParser.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (getSqlParser().equalAny(DefaultKeyword.SELECT)) &#123;</div><div class="line">       getSqlParser().getLexer().nextToken();</div><div class="line">       parseDistinct();</div><div class="line">       getSqlParser().skipAll(MySQLKeyword.HIGH_PRIORITY, DefaultKeyword.STRAIGHT_JOIN, MySQLKeyword.SQL_SMALL_RESULT, MySQLKeyword.SQL_BIG_RESULT, MySQLKeyword.SQL_BUFFER_RESULT,</div><div class="line">               MySQLKeyword.SQL_CACHE, MySQLKeyword.SQL_NO_CACHE, MySQLKeyword.SQL_CALC_FOUND_ROWS);</div><div class="line">       parseSelectList(); <span class="comment">// 解析 查询字段</span></div><div class="line">       skipToFrom(); <span class="comment">// 跳到 FROM 处</span></div><div class="line">   &#125;</div><div class="line">   parseFrom();<span class="comment">// 解析 表（JOIN ON / FROM 单&amp;多表）</span></div><div class="line">   parseWhere(); <span class="comment">// 解析 WHERE 条件</span></div><div class="line">   parseGroupBy(); <span class="comment">// 解析 Group By 和 Having（目前不支持）条件</span></div><div class="line">   parseOrderBy(); <span class="comment">// 解析 Order By 条件</span></div><div class="line">   parseLimit(); <span class="comment">// 解析 分页 Limit 条件</span></div><div class="line">   <span class="comment">// [PROCEDURE] 暂不支持</span></div><div class="line">   <span class="keyword">if</span> (getSqlParser().equalAny(DefaultKeyword.PROCEDURE)) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> SQLParsingUnsupportedException(getSqlParser().getLexer().getCurrentToken().getType());</div><div class="line">   &#125;</div><div class="line">   queryRest();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3-1-parseDistinct"><a href="#3-1-parseDistinct" class="headerlink" title="3.1 #parseDistinct()"></a>3.1 #parseDistinct()</h2><p>解析 DISTINCT、DISTINCTROW、UNION 谓语。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractSelectParser.java</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">parseDistinct</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (sqlParser.equalAny(DefaultKeyword.DISTINCT, DefaultKeyword.DISTINCTROW, DefaultKeyword.UNION)) &#123;</div><div class="line">       selectStatement.setDistinct(<span class="keyword">true</span>);</div><div class="line">       sqlParser.getLexer().nextToken();</div><div class="line">       <span class="keyword">if</span> (hasDistinctOn() &amp;&amp; sqlParser.equalAny(DefaultKeyword.ON)) &#123; <span class="comment">// PostgreSQL 独有语法： DISTINCT ON</span></div><div class="line">           sqlParser.getLexer().nextToken();</div><div class="line">           sqlParser.skipParentheses();</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sqlParser.equalAny(DefaultKeyword.ALL)) &#123;</div><div class="line">       sqlParser.getLexer().nextToken();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>此处 DISTINCT 和 DISTINCT(字段) 不同，它是针对查询结果做去重，即整行重复。举个例子：</p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line">mysql&gt; SELECT item_id, order_id FROM t_order_item;</div><div class="line">+<span class="comment">---------+----------+</span></div><div class="line">| item_id | order_id |</div><div class="line">+<span class="comment">---------+----------+</span></div><div class="line">| 1       | 1        |</div><div class="line">| 1       | 1        |</div><div class="line">+<span class="comment">---------+----------+</span></div><div class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.03</span> sec)</div><div class="line"></div><div class="line">mysql&gt; <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> item_id, order_id <span class="keyword">FROM</span> t_order_item;</div><div class="line">+<span class="comment">---------+----------+</span></div><div class="line">| item_id | order_id |</div><div class="line">+<span class="comment">---------+----------+</span></div><div class="line">| 1       | 1        |</div><div class="line">+<span class="comment">---------+----------+</span></div><div class="line">1 rows in <span class="keyword">set</span> (<span class="number">0.02</span> sec)</div></pre></td></tr></table></figure><h2 id="3-2-parseSelectList"><a href="#3-2-parseSelectList" class="headerlink" title="3.2 #parseSelectList()"></a>3.2 #parseSelectList()</h2><table><thead><tr><th>SELECT</th><th>o.user_id</th><th>COUNT(DISTINCT i.item_id) AS item_count</th><th>MAX(i.item_id)</th><th>FROM</th></tr></thead><tbody><tr><td></td><td>SelectItem</td><td>SelectItem</td><td>SelectItem</td></tr></tbody></table><p>将 SQL <strong>查询字段</strong> 按照<strong>逗号( , )</strong>切割成<strong>多个</strong>选择项( SelectItem)。核心代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractSelectParser.java</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">parseSelectList</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">do</span> &#123;</div><div class="line">       <span class="comment">// 解析单个选择项</span></div><div class="line">       parseSelectItem();</div><div class="line">   &#125; <span class="keyword">while</span> (sqlParser.skipIfEqual(Symbol.COMMA));</div><div class="line">   <span class="comment">// 设置 最后一个查询项下一个 Token 的开始位置</span></div><div class="line">   selectStatement.setSelectListLastPosition(sqlParser.getLexer().getCurrentToken().getEndPosition() - sqlParser.getLexer().getCurrentToken().getLiterals().length());</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-2-1-SelectItem-选择项"><a href="#3-2-1-SelectItem-选择项" class="headerlink" title="3.2.1 SelectItem 选择项"></a>3.2.1 SelectItem 选择项</h3><p>SelectItem 接口，<strong>属于分片上下文信息</strong>，有 2 个实现类：</p><ul><li>CommonSelectItem ：通用选择项</li><li>AggregationSelectItem ：聚合选择项</li></ul><p><img src="http://www.iocoder.cn/images/Sharding-JDBC/2017_07_27/01.png" alt=""></p><p>解析单个 SelectItem 核心代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractSelectParser.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseSelectItem</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 第四种情况，SQL Server 独有</span></div><div class="line">   <span class="keyword">if</span> (isRowNumberSelectItem()) &#123;</div><div class="line">       selectStatement.getItems().add(parseRowNumberSelectItem());</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   sqlParser.skipIfEqual(DefaultKeyword.CONNECT_BY_ROOT); <span class="comment">// Oracle 独有：https://docs.oracle.com/cd/B19306_01/server.102/b14200/operators004.htm</span></div><div class="line">   String literals = sqlParser.getLexer().getCurrentToken().getLiterals();</div><div class="line">   <span class="comment">// 第一种情况，* 通用选择项，SELECT *</span></div><div class="line">   <span class="keyword">if</span> (sqlParser.equalAny(Symbol.STAR) || Symbol.STAR.getLiterals().equals(SQLUtil.getExactlyValue(literals))) &#123;</div><div class="line">       sqlParser.getLexer().nextToken();</div><div class="line">       selectStatement.getItems().add(<span class="keyword">new</span> CommonSelectItem(Symbol.STAR.getLiterals(), sqlParser.parseAlias()));</div><div class="line">       selectStatement.setContainStar(<span class="keyword">true</span>);</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 第二种情况，聚合选择项</span></div><div class="line">   <span class="keyword">if</span> (sqlParser.skipIfEqual(DefaultKeyword.MAX, DefaultKeyword.MIN, DefaultKeyword.SUM, DefaultKeyword.AVG, DefaultKeyword.COUNT)) &#123;</div><div class="line">       selectStatement.getItems().add(<span class="keyword">new</span> AggregationSelectItem(AggregationType.valueOf(literals.toUpperCase()), sqlParser.skipParentheses(), sqlParser.parseAlias()));</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 第三种情况，非 * 通用选择项</span></div><div class="line">   StringBuilder expression = <span class="keyword">new</span> StringBuilder();</div><div class="line">   Token lastToken = <span class="keyword">null</span>;</div><div class="line">   <span class="keyword">while</span> (!sqlParser.equalAny(DefaultKeyword.AS) &amp;&amp; !sqlParser.equalAny(Symbol.COMMA) &amp;&amp; !sqlParser.equalAny(DefaultKeyword.FROM) &amp;&amp; !sqlParser.equalAny(Assist.END)) &#123;</div><div class="line">       String value = sqlParser.getLexer().getCurrentToken().getLiterals();</div><div class="line">       <span class="keyword">int</span> position = sqlParser.getLexer().getCurrentToken().getEndPosition() - value.length();</div><div class="line">       expression.append(value);</div><div class="line">       lastToken = sqlParser.getLexer().getCurrentToken();</div><div class="line">       sqlParser.getLexer().nextToken();</div><div class="line">       <span class="keyword">if</span> (sqlParser.equalAny(Symbol.DOT)) &#123;</div><div class="line">           selectStatement.getSqlTokens().add(<span class="keyword">new</span> TableToken(position, value));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 不带 AS，并且有别名，并且别名不等于自己（tips：这里重点看。判断这么复杂的原因：防止substring操作截取结果错误）</span></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != lastToken &amp;&amp; Literals.IDENTIFIER == lastToken.getType()</div><div class="line">           &amp;&amp; !isSQLPropertyExpression(expression, lastToken) <span class="comment">// 过滤掉，别名是自己的情况【1】（例如，SELECT u.user_id u.user_id FROM t_user）</span></div><div class="line">           &amp;&amp; !expression.toString().equals(lastToken.getLiterals())) &#123; <span class="comment">// 过滤掉，无别名的情况【2】（例如，SELECT user_id FROM t_user）</span></div><div class="line">       selectStatement.getItems().add(</div><div class="line">               <span class="keyword">new</span> CommonSelectItem(SQLUtil.getExactlyValue(expression.substring(<span class="number">0</span>, expression.lastIndexOf(lastToken.getLiterals()))), Optional.of(lastToken.getLiterals())));</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 带 AS（例如，SELECT user_id AS userId） 或者 无别名（例如，SELECT user_id）</span></div><div class="line">   selectStatement.getItems().add(<span class="keyword">new</span> CommonSelectItem(SQLUtil.getExactlyValue(expression.toString()), sqlParser.parseAlias()));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>一共分成 4 种大的情况，我们来逐条梳理：</p><ul><li>第一种：<strong><code>*</code> 通用选择项</strong>：<br>例如，<code>SELECT * FROM t_user</code> 的 <code>*</code>。<br>为什么要加 <code>Symbol.STAR.getLiterals().equals(SQLUtil.getExactlyValue(literals))</code> 判断呢？</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="string">`*`</span> <span class="keyword">FROM</span> t_user; // 也能达到查询所有字段的效果</div></pre></td></tr></table></figure><ul><li>第二种：<strong>聚合选择项</strong>：<br>例如，<code>SELECT COUNT(user_id) FROM t_user</code> 的 <code>COUNT(user_id)</code>。</li></ul><p>解析结果 AggregationSelectItem：<br><img src="http://www.iocoder.cn/images/Sharding-JDBC/2017_07_27/05.png" alt=""></p><p><code>sqlParser.skipParentheses()</code> 解析见<a href="http://www.iocoder.cn/Sharding-JDBC/sql-parse-2/?self">《SQL 解析（二）之SQL解析》的AbstractParser小节</a>。</p><ul><li>第三种：<strong>非 <code>*</code> 通用选择项</strong>：</li></ul><p>例如，<code>SELECT user_id FROM t_user</code>。</p><p>从实现上，逻辑会复杂很多。相比第一种，可以根据 <code>*</code> 做字段判断；相比第二种，可以使用 <code>(</code> 和 <code>)</code> 做字段判断。能够判断一个<strong>包含别名的</strong> SelectItem 结束有 4 种 Token，根据结束方式我们分成 2 种：</p><ul><li>DefaultKeyword.AS ：能够接触出 SelectItem 字段，<strong>即不包含别名</strong>。例如，<code>SELECT user_id AS uid FROM t_user</code>，能够直接解析出 <code>user_id</code>。</li><li>Symbol.COMMA / DefaultKeyword.FROM / Assist.END ：<strong>包含别名</strong>。例如，<code>SELECT user_id uid FROM t_user</code>，解析结果为 <code>user_id uid</code>。</li></ul><p>基于这个在配合上面的代码注释，大家再重新理解下第三种情况的实现。</p><ul><li>第四种：SQLServer ROW_NUMBER：</li></ul><p>ROW_NUMBER 是 SQLServer 独有的。由于本文大部分的读者使用的 MySQL / Oracle，就跳过了。有兴趣的同学可以看 <a href="https://github.com/dangdangdotcom/sharding-jdbc/blob/9354031743b63e44cbded5618980ae71a15f0260/sharding-jdbc-core/src/main/java/com/dangdang/ddframe/rdb/sharding/parsing/parser/dialect/sqlserver/SQLServerSelectParser.java" rel="external nofollow noopener noreferrer" target="_blank">SQLServerSelectParser#parseRowNumberSelectItem()</a> 方法。</p><h3 id="3-2-2-parseAlias-解析别名"><a href="#3-2-2-parseAlias-解析别名" class="headerlink" title="3.2.2 #parseAlias() 解析别名"></a>3.2.2 #parseAlias() 解析别名</h3><p>解析别名，分成是否带 <code>AS</code> 两种情况。解析代码：<a href="http://www.iocoder.cn/Sharding-JDBC/sql-parse-2/?self">《SQL 解析（二）之SQL解析》的#parseAlias()小节</a>。</p><h3 id="3-2-3-TableToken-表标记对象"><a href="#3-2-3-TableToken-表标记对象" class="headerlink" title="3.2.3 TableToken 表标记对象"></a>3.2.3 TableToken 表标记对象</h3><p>TableToken，记录表名在 SQL 里出现的<strong>位置</strong>和<strong>名字</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TableToken</span> <span class="keyword">implements</span> <span class="title">SQLToken</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 开始位置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> beginPosition;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 表达式</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String originalLiterals;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获取表名称.</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 表名称</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTableName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> SQLUtil.getExactlyValue(originalLiterals);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>例如上文第三种情况。<br><img src="http://www.iocoder.cn/images/Sharding-JDBC/2017_07_27/06.png" alt=""></p><h2 id="3-3-skipToFrom"><a href="#3-3-skipToFrom" class="headerlink" title="3.3 #skipToFrom()"></a>3.3 #skipToFrom()</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 跳到 FROM 处</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">skipToFrom</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">while</span> (!getSqlParser().equalAny(DefaultKeyword.FROM) &amp;&amp; !getSqlParser().equalAny(Assist.END)) &#123;</div><div class="line">       getSqlParser().getLexer().nextToken();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3-4-parseFrom"><a href="#3-4-parseFrom" class="headerlink" title="3.4 #parseFrom()"></a>3.4 #parseFrom()</h2><p>解析表以及表连接关系。<strong>这块相对比较复杂，请大家耐心+耐心+耐心。</strong></p><p><strong>MySQL JOIN Syntax</strong>：</p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line">// https://dev.mysql.com/doc/refman/5.7/en/join.html</div><div class="line">table_references:</div><div class="line">    escaped_table_reference [, escaped_table_reference] ...</div><div class="line"></div><div class="line">escaped_table_reference:</div><div class="line">    table_reference</div><div class="line">  | &#123; OJ table_reference &#125;</div><div class="line"></div><div class="line">table_reference:</div><div class="line">    table_factor</div><div class="line">  | join_table</div><div class="line"></div><div class="line">table_factor:</div><div class="line">    tbl_name [PARTITION (partition_names)]</div><div class="line">        [[AS] alias] [index_hint_list]</div><div class="line">  | table_subquery [AS] alias</div><div class="line">  | ( table_references )</div><div class="line"></div><div class="line">join_table:</div><div class="line">    table_reference [INNER | CROSS] JOIN table_factor [join_condition]</div><div class="line">  | table_reference STRAIGHT_JOIN table_factor</div><div class="line">  | table_reference STRAIGHT_JOIN table_factor ON conditional_expr</div><div class="line">  | table_reference &#123;LEFT|RIGHT&#125; [OUTER] JOIN table_reference join_condition</div><div class="line">  | table_reference NATURAL [&#123;LEFT|RIGHT&#125; [OUTER]] JOIN table_factor</div><div class="line"></div><div class="line">join_condition:</div><div class="line">    ON conditional_expr</div><div class="line">  | USING (column_list)</div><div class="line"></div><div class="line">index_hint_list:</div><div class="line">    index_hint [, index_hint] ...</div><div class="line"></div><div class="line">index_hint:</div><div class="line">    <span class="keyword">USE</span> &#123;<span class="keyword">INDEX</span>|<span class="keyword">KEY</span>&#125;</div><div class="line">      [<span class="keyword">FOR</span> &#123;<span class="keyword">JOIN</span>|<span class="keyword">ORDER</span> <span class="keyword">BY</span>|<span class="keyword">GROUP</span> <span class="keyword">BY</span>&#125;] ([index_list])</div><div class="line">  | <span class="keyword">IGNORE</span> &#123;<span class="keyword">INDEX</span>|<span class="keyword">KEY</span>&#125;</div><div class="line">      [<span class="keyword">FOR</span> &#123;<span class="keyword">JOIN</span>|<span class="keyword">ORDER</span> <span class="keyword">BY</span>|<span class="keyword">GROUP</span> <span class="keyword">BY</span>&#125;] (index_list)</div><div class="line">  | <span class="keyword">FORCE</span> &#123;<span class="keyword">INDEX</span>|<span class="keyword">KEY</span>&#125;</div><div class="line">      [<span class="keyword">FOR</span> &#123;<span class="keyword">JOIN</span>|<span class="keyword">ORDER</span> <span class="keyword">BY</span>|<span class="keyword">GROUP</span> <span class="keyword">BY</span>&#125;] (index_list)</div><div class="line"></div><div class="line">index_list:</div><div class="line">    index_name [, index_name] ...</div></pre></td></tr></table></figure><h3 id="3-4-1-JOIN-ON-FROM-TABLE"><a href="#3-4-1-JOIN-ON-FROM-TABLE" class="headerlink" title="3.4.1 JOIN ON / FROM TABLE"></a>3.4.1 JOIN ON / FROM TABLE</h3><p>先抛开<strong>子查询</strong>的情况，只考虑如下两种 SQL 情况。</p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line">// JOIN ON ： 实际可以继续 JOIN ON 更多表</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order o <span class="keyword">JOIN</span> t_order_item i <span class="keyword">ON</span> o.order_id = i.order_id; </div><div class="line">// FROM 多表 ：实际可以继续 FROM 多更表</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order o, t_order_item i</div></pre></td></tr></table></figure><p>在看实现代码之前，先一起看下调用顺序图：</p><p><img src="http://www.iocoder.cn/images/Sharding-JDBC/2017_07_27/02.png" alt=""></p><p>看懂上图后，来继续看下实现代码（🙂<strong>代码有点多，不要方！</strong>）：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractSelectParser.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 解析所有表名和表别名</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">parseFrom</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (sqlParser.skipIfEqual(DefaultKeyword.FROM)) &#123;</div><div class="line">       parseTable();</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 解析所有表名和表别名</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseTable</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 解析子查询</span></div><div class="line">   <span class="keyword">if</span> (sqlParser.skipIfEqual(Symbol.LEFT_PAREN)) &#123;</div><div class="line">       <span class="keyword">if</span> (!selectStatement.getTables().isEmpty()) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Cannot support subquery for nested tables."</span>);</div><div class="line">       &#125;</div><div class="line">       selectStatement.setContainStar(<span class="keyword">false</span>);</div><div class="line">       sqlParser.skipUselessParentheses(); <span class="comment">// 去掉子查询左括号</span></div><div class="line">       parse(); <span class="comment">// 解析子查询 SQL</span></div><div class="line">       sqlParser.skipUselessParentheses(); <span class="comment">// 去掉子查询右括号</span></div><div class="line">       <span class="comment">//</span></div><div class="line">       <span class="keyword">if</span> (!selectStatement.getTables().isEmpty()) &#123;</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   parseTableFactor(); <span class="comment">// 解析当前表</span></div><div class="line">   parseJoinTable(); <span class="comment">// 解析下一个表</span></div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 解析单个表名和表别名</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">parseTableFactor</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> beginPosition = sqlParser.getLexer().getCurrentToken().getEndPosition() - sqlParser.getLexer().getCurrentToken().getLiterals().length();</div><div class="line">   String literals = sqlParser.getLexer().getCurrentToken().getLiterals();</div><div class="line">   sqlParser.getLexer().nextToken();</div><div class="line">   <span class="comment">// TODO 包含Schema解析</span></div><div class="line">   <span class="keyword">if</span> (sqlParser.skipIfEqual(Symbol.DOT)) &#123; <span class="comment">// https://dev.mysql.com/doc/refman/5.7/en/information-schema.html ：SELECT table_name, table_type, engine FROM information_schema.tables</span></div><div class="line">       sqlParser.getLexer().nextToken();</div><div class="line">       sqlParser.parseAlias();</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// FIXME 根据shardingRule过滤table</span></div><div class="line">   selectStatement.getSqlTokens().add(<span class="keyword">new</span> TableToken(beginPosition, literals));</div><div class="line">   <span class="comment">// 表 以及 表别名</span></div><div class="line">   selectStatement.getTables().add(<span class="keyword">new</span> Table(SQLUtil.getExactlyValue(literals), sqlParser.parseAlias()));</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 解析 Join Table 或者 FROM 下一张 Table</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseJoinTable</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (sqlParser.skipJoin()) &#123;</div><div class="line">       <span class="comment">// 这里调用 parseJoinTable() 而不是 parseTableFactor() ：下一个 Table 可能是子查询</span></div><div class="line">       <span class="comment">// 例如：SELECT * FROM t_order JOIN (SELECT * FROM t_order_item JOIN t_order_other ON ) .....</span></div><div class="line">       parseTable();</div><div class="line">       <span class="keyword">if</span> (sqlParser.skipIfEqual(DefaultKeyword.ON)) &#123; <span class="comment">// JOIN 表时 ON 条件</span></div><div class="line">           <span class="keyword">do</span> &#123;</div><div class="line">               parseTableCondition(sqlParser.getLexer().getCurrentToken().getEndPosition());</div><div class="line">               sqlParser.accept(Symbol.EQ);</div><div class="line">               parseTableCondition(sqlParser.getLexer().getCurrentToken().getEndPosition() - sqlParser.getLexer().getCurrentToken().getLiterals().length());</div><div class="line">           &#125; <span class="keyword">while</span> (sqlParser.skipIfEqual(DefaultKeyword.AND));</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sqlParser.skipIfEqual(DefaultKeyword.USING)) &#123; <span class="comment">// JOIN 表时 USING 为使用两表相同字段相同时对 ON 的简化。例如以下两条 SQL 等价：</span></div><div class="line">                                                                   <span class="comment">// SELECT * FROM t_order o JOIN t_order_item i USING (order_id);</span></div><div class="line">                                                                   <span class="comment">// SELECT * FROM t_order o JOIN t_order_item i ON o.order_id = i.order_id</span></div><div class="line">           sqlParser.skipParentheses();</div><div class="line">       &#125;</div><div class="line">       parseJoinTable(); <span class="comment">// 继续递归</span></div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 解析 ON 条件里的 TableToken</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> startPosition 开始位置</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseTableCondition</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> startPosition)</span> </span>&#123;</div><div class="line">   SQLExpression sqlExpression = sqlParser.parseExpression();</div><div class="line">   <span class="keyword">if</span> (!(sqlExpression <span class="keyword">instanceof</span> SQLPropertyExpression)) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   SQLPropertyExpression sqlPropertyExpression = (SQLPropertyExpression) sqlExpression;</div><div class="line">   <span class="keyword">if</span> (selectStatement.getTables().getTableNames().contains(SQLUtil.getExactlyValue(sqlPropertyExpression.getOwner().getName()))) &#123;</div><div class="line">       selectStatement.getSqlTokens().add(<span class="keyword">new</span> TableToken(startPosition, sqlPropertyExpression.getOwner().getName()));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>OK，递归因为平时日常中写的比较少，可能理解起来可能会困难一些，努力看懂！🙂<strong>如果真的看不懂，可以加微信公众号（<a href="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg">芋道源码</a>），我来帮你一起理解。</strong></p><h3 id="3-4-2-子查询"><a href="#3-4-2-子查询" class="headerlink" title="3.4.2 子查询"></a>3.4.2 子查询</h3><p>Sharding-JDBC 目前支持<strong>第一个</strong>包含多层级的数据子查询。例如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> o3.* <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order o) o2) o3;</div><div class="line"><span class="keyword">SELECT</span> o3.* <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order o) o2) o3 <span class="keyword">JOIN</span> t_order_item i <span class="keyword">ON</span> o3.order_id = i.order_id;</div></pre></td></tr></table></figure><p>不支持<strong>第二个开始</strong>包含多层级的数据子查询。例如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> o3.* <span class="keyword">FROM</span> t_order_item i <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order o) o2) o3 <span class="keyword">ON</span> o3.order_id = i.order_id; // 此条 SQL 是上面第二条 SQL 左右量表颠倒</div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_order o <span class="keyword">WHERE</span> o.id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> t_order <span class="keyword">WHERE</span> <span class="keyword">status</span> = ?)) // <span class="keyword">FROM</span> 官方不支持 <span class="keyword">SQL</span> 举例</div></pre></td></tr></table></figure><p>使用<strong>第二个开始</strong>的子查询会抛出异常，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// AbstractSelectParser.java#parseTable()片段</div><div class="line">if (!selectStatement.getTables().isEmpty()) &#123;</div><div class="line">    throw new UnsupportedOperationException(&quot;Cannot support subquery for nested tables.&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用子查询，建议认真阅读官方<a href="http://dangdangdotcom.github.io/sharding-jdbc/02-guide/subquery/" rel="external nofollow noopener noreferrer" target="_blank">《分页及子查询》</a>文档。</p><h3 id="3-4-3-parseJoinTable"><a href="#3-4-3-parseJoinTable" class="headerlink" title="3.4.3 #parseJoinTable()"></a>3.4.3 #parseJoinTable()</h3><p>MySQLSelectParser 重写了 <code>#parseJoinTable()</code> 方法用于解析 USE / IGNORE / FORCE index_hint。具体语法见上文 <strong>JOIN Syntax</strong>。这里就跳过，有兴趣的同学可以去看看。</p><h3 id="3-4-4-Tables-表集合对象"><a href="#3-4-4-Tables-表集合对象" class="headerlink" title="3.4.4 Tables 表集合对象"></a>3.4.4 Tables 表集合对象</h3><p><strong>属于分片上下文信息</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Tables.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Tables</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Table&gt; tables = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Table.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Table</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 表</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 别名</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Optional&lt;String&gt; alias;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// AbstractSelectParser.java#parseTableFactor()片段</span></div><div class="line">selectStatement.getTables().add(<span class="keyword">new</span> Table(SQLUtil.getExactlyValue(literals), sqlParser.parseAlias()));</div></pre></td></tr></table></figure><h2 id="3-5-parseWhere"><a href="#3-5-parseWhere" class="headerlink" title="3.5 #parseWhere()"></a>3.5 #parseWhere()</h2><p>解析 WHERE 条件。解析代码：<a href="http://www.iocoder.cn/Sharding-JDBC/sql-parse-2/?self">《SQL 解析（二）之SQL解析》的#parseWhere()小节</a>。</p><h2 id="3-6-parseGroupBy"><a href="#3-6-parseGroupBy" class="headerlink" title="3.6 #parseGroupBy()"></a>3.6 #parseGroupBy()</h2><p>解析分组条件，实现上比较类似 <code>#parseSelectList</code>，会更加简单一些。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractSelectParser.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 解析 Group By 和 Having（暂时不支持）</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseGroupBy</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (sqlParser.skipIfEqual(DefaultKeyword.GROUP)) &#123;</div><div class="line">       sqlParser.accept(DefaultKeyword.BY);</div><div class="line">       <span class="comment">// 解析 Group By 每个字段</span></div><div class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">           addGroupByItem(sqlParser.parseExpression(selectStatement));</div><div class="line">           <span class="keyword">if</span> (!sqlParser.equalAny(Symbol.COMMA)) &#123;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           &#125;</div><div class="line">           sqlParser.getLexer().nextToken();</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">while</span> (sqlParser.equalAny(DefaultKeyword.WITH) || sqlParser.getLexer().getCurrentToken().getLiterals().equalsIgnoreCase(<span class="string">"ROLLUP"</span>)) &#123;</div><div class="line">           sqlParser.getLexer().nextToken();</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// Having（暂时不支持）</span></div><div class="line">       <span class="keyword">if</span> (sqlParser.skipIfEqual(DefaultKeyword.HAVING)) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Cannot support Having"</span>);</div><div class="line">       &#125;</div><div class="line">       selectStatement.setGroupByLastPosition(sqlParser.getLexer().getCurrentToken().getEndPosition());</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sqlParser.skipIfEqual(DefaultKeyword.HAVING)) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Cannot support Having"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 解析 Group By 单个字段</span></div><div class="line"><span class="comment">* Group By 条件是带有排序功能，默认ASC</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> sqlExpression 表达式</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addGroupByItem</span><span class="params">(<span class="keyword">final</span> SQLExpression sqlExpression)</span> </span>&#123;</div><div class="line">   <span class="comment">// Group By 字段 DESC / ASC / ;默认是 ASC。</span></div><div class="line">   OrderType orderByType = OrderType.ASC;</div><div class="line">   <span class="keyword">if</span> (sqlParser.equalAny(DefaultKeyword.ASC)) &#123;</div><div class="line">       sqlParser.getLexer().nextToken();</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sqlParser.skipIfEqual(DefaultKeyword.DESC)) &#123;</div><div class="line">       orderByType = OrderType.DESC;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 解析 OrderItem</span></div><div class="line">   OrderItem orderItem;</div><div class="line">   <span class="keyword">if</span> (sqlExpression <span class="keyword">instanceof</span> SQLPropertyExpression) &#123;</div><div class="line">       SQLPropertyExpression sqlPropertyExpression = (SQLPropertyExpression) sqlExpression;</div><div class="line">       orderItem = <span class="keyword">new</span> OrderItem(SQLUtil.getExactlyValue(sqlPropertyExpression.getOwner().getName()), SQLUtil.getExactlyValue(sqlPropertyExpression.getName()), orderByType,</div><div class="line">               getAlias(SQLUtil.getExactlyValue(sqlPropertyExpression.getOwner() + <span class="string">"."</span> + SQLUtil.getExactlyValue(sqlPropertyExpression.getName()))));</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sqlExpression <span class="keyword">instanceof</span> SQLIdentifierExpression) &#123;</div><div class="line">       SQLIdentifierExpression sqlIdentifierExpression = (SQLIdentifierExpression) sqlExpression;</div><div class="line">       orderItem = <span class="keyword">new</span> OrderItem(SQLUtil.getExactlyValue(sqlIdentifierExpression.getName()), orderByType, getAlias(SQLUtil.getExactlyValue(sqlIdentifierExpression.getName())));</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   selectStatement.getGroupByItems().add(orderItem);</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 字段在查询项里的别名</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> name 字段</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 别名</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> Optional&lt;String&gt; <span class="title">getAlias</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (selectStatement.isContainStar()) &#123;</div><div class="line">       <span class="keyword">return</span> Optional.absent();</div><div class="line">   &#125;</div><div class="line">   String rawName = SQLUtil.getExactlyValue(name);</div><div class="line">   <span class="keyword">for</span> (SelectItem each : selectStatement.getItems()) &#123;</div><div class="line">       <span class="keyword">if</span> (rawName.equalsIgnoreCase(SQLUtil.getExactlyValue(each.getExpression()))) &#123;</div><div class="line">           <span class="keyword">return</span> each.getAlias();</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (rawName.equalsIgnoreCase(each.getAlias().orNull())) &#123;</div><div class="line">           <span class="keyword">return</span> Optional.of(rawName);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> Optional.absent();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-6-1-OrderItem-排序项"><a href="#3-6-1-OrderItem-排序项" class="headerlink" title="3.6.1 OrderItem 排序项"></a>3.6.1 OrderItem 排序项</h3><p><strong>属于分片上下文信息</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderItem</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">    * 所属表别名</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Optional&lt;String&gt; owner;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">    * 排序字段</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Optional&lt;String&gt; name;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">    * 排序类型</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OrderType type;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">    * 按照第几个查询字段排序</span></div><div class="line"><span class="comment">    * ORDER BY 数字 的 数字代表的是第几个字段</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    <span class="meta">@Setter</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = -<span class="number">1</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">    * 字段在查询项(&#123;<span class="doctag">@link</span> com.dangdang.ddframe.rdb.sharding.parsing.parser.context.selectitem.SelectItem&#125; 的别名</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    <span class="meta">@Setter</span></div><div class="line">    <span class="keyword">private</span> Optional&lt;String&gt; alias;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3-7-parseOrderBy"><a href="#3-7-parseOrderBy" class="headerlink" title="3.7 #parseOrderBy()"></a>3.7 #parseOrderBy()</h2><p>解析排序条件。实现逻辑类似 <code>#parseGroupBy()</code>，这里就跳过，有兴趣的同学可以去看看。</p><h2 id="3-8-parseLimit"><a href="#3-8-parseLimit" class="headerlink" title="3.8 #parseLimit()"></a>3.8 #parseLimit()</h2><p>解析分页 Limit 条件。相对简单，这里就跳过，有兴趣的同学可以去看看。注意下，分成 3 种情况：</p><ul><li>LIMIT row_count</li><li>LIMIT offset, row_count</li><li>LIMIT row_count OFFSET offset</li></ul><h3 id="3-8-1-Limit"><a href="#3-8-1-Limit" class="headerlink" title="3.8.1 Limit"></a>3.8.1 Limit</h3><p>分页对象。<strong>属于分片上下文信息</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Limit.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Limit</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 是否重写rowCount</span></div><div class="line"><span class="comment">     * TODO 待补充：预计和内存分页合并有关</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> rowCountRewriteFlag;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * offset</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> LimitValue offset;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * row</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> LimitValue rowCount;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// LimitValue.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LimitValue</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 值</span></div><div class="line"><span class="comment">     * 当 value == -1 时，为占位符</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 第几个占位符</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-8-2-OffsetToken-RowCountToken"><a href="#3-8-2-OffsetToken-RowCountToken" class="headerlink" title="3.8.2 OffsetToken RowCountToken"></a>3.8.2 OffsetToken RowCountToken</h3><ul><li>OffsetToken：分页偏移量标记对象</li><li>RowCountToken：分页长度标记对象</li></ul><p><strong>只有在对应位置非占位符才有该 SQLToken</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// OffsetToken.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OffsetToken</span> <span class="keyword">implements</span> <span class="title">SQLToken</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * SQL 所在开始位置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> beginPosition;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 偏移值</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// RowCountToken.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RowCountToken</span> <span class="keyword">implements</span> <span class="title">SQLToken</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * SQL 所在开始位置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> beginPosition;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 行数</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> rowCount;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3-9-queryRest"><a href="#3-9-queryRest" class="headerlink" title="3.9 #queryRest()"></a>3.9 #queryRest()</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractSelectParser.java</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">queryRest</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (sqlParser.equalAny(DefaultKeyword.UNION, DefaultKeyword.EXCEPT, DefaultKeyword.INTERSECT, DefaultKeyword.MINUS)) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> SQLParsingUnsupportedException(sqlParser.getLexer().getCurrentToken().getType());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>不支持 UNION / EXCEPT / INTERSECT / MINUS ，调用会抛出异常。</p><h1 id="4-appendDerived等方法"><a href="#4-appendDerived等方法" class="headerlink" title="4. appendDerived等方法"></a>4. appendDerived等方法</h1><p>因为 Sharding-JDBC 对表做了分片，在 AVG , GROUP BY , ORDER BY 需要对 SQL 进行一些改写，<strong>以达到能在内存里对结果做进一步处理</strong>，例如求平均值、分组、排序等。</p><p>😈：打起精神，此块是非常有趣的。</p><h2 id="4-1-appendAvgDerivedColumns"><a href="#4-1-appendAvgDerivedColumns" class="headerlink" title="4.1 appendAvgDerivedColumns"></a>4.1 appendAvgDerivedColumns</h2><p>解决 AVG 查询。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractSelectParser.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 针对 AVG 聚合字段，增加推导字段</span></div><div class="line"><span class="comment">* AVG 改写成 SUM + COUNT 查询，内存计算出 AVG 结果。</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> itemsToken 选择项标记对象</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendAvgDerivedColumns</span><span class="params">(<span class="keyword">final</span> ItemsToken itemsToken)</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> derivedColumnOffset = <span class="number">0</span>;</div><div class="line">   <span class="keyword">for</span> (SelectItem each : selectStatement.getItems()) &#123;</div><div class="line">       <span class="keyword">if</span> (!(each <span class="keyword">instanceof</span> AggregationSelectItem) || AggregationType.AVG != ((AggregationSelectItem) each).getType()) &#123;</div><div class="line">           <span class="keyword">continue</span>;</div><div class="line">       &#125;</div><div class="line">       AggregationSelectItem avgItem = (AggregationSelectItem) each;</div><div class="line">       <span class="comment">// COUNT 字段</span></div><div class="line">       String countAlias = String.format(DERIVED_COUNT_ALIAS, derivedColumnOffset);</div><div class="line">       AggregationSelectItem countItem = <span class="keyword">new</span> AggregationSelectItem(AggregationType.COUNT, avgItem.getInnerExpression(), Optional.of(countAlias));</div><div class="line">       <span class="comment">// SUM 字段</span></div><div class="line">       String sumAlias = String.format(DERIVED_SUM_ALIAS, derivedColumnOffset);</div><div class="line">       AggregationSelectItem sumItem = <span class="keyword">new</span> AggregationSelectItem(AggregationType.SUM, avgItem.getInnerExpression(), Optional.of(sumAlias));</div><div class="line">       <span class="comment">// AggregationSelectItem 设置</span></div><div class="line">       avgItem.getDerivedAggregationSelectItems().add(countItem);</div><div class="line">       avgItem.getDerivedAggregationSelectItems().add(sumItem);</div><div class="line">       <span class="comment">// TODO 将AVG列替换成常数，避免数据库再计算无用的AVG函数</span></div><div class="line">       <span class="comment">// ItemsToken</span></div><div class="line">       itemsToken.getItems().add(countItem.getExpression() + <span class="string">" AS "</span> + countAlias + <span class="string">" "</span>);</div><div class="line">       itemsToken.getItems().add(sumItem.getExpression() + <span class="string">" AS "</span> + sumAlias + <span class="string">" "</span>);</div><div class="line">       <span class="comment">//</span></div><div class="line">       derivedColumnOffset++;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="4-2-appendDerivedOrderColumns"><a href="#4-2-appendDerivedOrderColumns" class="headerlink" title="4.2 appendDerivedOrderColumns"></a>4.2 appendDerivedOrderColumns</h2><p>解决 GROUP BY , ORDER BY。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractSelectParser.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 针对 GROUP BY 或 ORDER BY 字段，增加推导字段</span></div><div class="line"><span class="comment">* 如果该字段不在查询字段里，需要额外查询该字段，这样才能在内存里 GROUP BY 或 ORDER BY</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> itemsToken 选择项标记对象</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> orderItems 排序字段</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> aliasPattern 别名模式</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendDerivedOrderColumns</span><span class="params">(<span class="keyword">final</span> ItemsToken itemsToken, <span class="keyword">final</span> List&lt;OrderItem&gt; orderItems, <span class="keyword">final</span> String aliasPattern)</span> </span>&#123;</div><div class="line">   <span class="keyword">int</span> derivedColumnOffset = <span class="number">0</span>;</div><div class="line">   <span class="keyword">for</span> (OrderItem each : orderItems) &#123;</div><div class="line">       <span class="keyword">if</span> (!isContainsItem(each)) &#123;</div><div class="line">           String alias = String.format(aliasPattern, derivedColumnOffset++);</div><div class="line">           each.setAlias(Optional.of(alias));</div><div class="line">           itemsToken.getItems().add(each.getQualifiedName().get() + <span class="string">" AS "</span> + alias + <span class="string">" "</span>);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 查询字段是否包含排序字段</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> orderItem 排序字段</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 是否</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isContainsItem</span><span class="params">(<span class="keyword">final</span> OrderItem orderItem)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (selectStatement.isContainStar()) &#123; <span class="comment">// SELECT *</span></div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> (SelectItem each : selectStatement.getItems()) &#123;</div><div class="line">       <span class="keyword">if</span> (-<span class="number">1</span> != orderItem.getIndex()) &#123; <span class="comment">// ORDER BY 使用数字</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (each.getAlias().isPresent() &amp;&amp; orderItem.getAlias().isPresent() &amp;&amp; each.getAlias().get().equalsIgnoreCase(orderItem.getAlias().get())) &#123; <span class="comment">// 字段别名比较</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (!each.getAlias().isPresent() &amp;&amp; orderItem.getQualifiedName().isPresent() &amp;&amp; each.getExpression().equalsIgnoreCase(orderItem.getQualifiedName().get())) &#123; <span class="comment">// 字段原名比较</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="4-3-ItemsToken"><a href="#4-3-ItemsToken" class="headerlink" title="4.3 ItemsToken"></a>4.3 ItemsToken</h2><p>选择项标记对象，<strong>属于分片上下文信息</strong>，目前有 3 个情况会创建：</p><ol><li><code>AVG</code> 查询额外 COUNT 和 SUM：<code>#appendAvgDerivedColumns()</code></li><li><code>GROUP BY</code> 不在 查询字段，额外查询该字段 ：<code>#appendDerivedOrderColumns()</code></li><li><code>ORDER BY</code> 不在 查询字段，额外查询该字段 ：<code>#appendDerivedOrderColumns()</code></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemsToken</span> <span class="keyword">implements</span> <span class="title">SQLToken</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * SQL 开始位置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> beginPosition;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 字段名数组</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; items = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="4-4-appendDerivedOrderBy"><a href="#4-4-appendDerivedOrderBy" class="headerlink" title="4.4 appendDerivedOrderBy()"></a>4.4 appendDerivedOrderBy()</h2><p>当 SQL 有聚合条件而无排序条件，根据聚合条件进行排序。这是数据库自己的执行规则。</p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line">mysql&gt; SELECT order_id FROM t_order GROUP BY order_id;</div><div class="line">+<span class="comment">----------+</span></div><div class="line">| order_id |</div><div class="line">+<span class="comment">----------+</span></div><div class="line">| 1        |</div><div class="line">| 2        |</div><div class="line">| 3        |</div><div class="line">+<span class="comment">----------+</span></div><div class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.05</span> sec)</div><div class="line"></div><div class="line">mysql&gt; <span class="keyword">SELECT</span> order_id <span class="keyword">FROM</span> t_order <span class="keyword">GROUP</span> <span class="keyword">BY</span> order_id <span class="keyword">DESC</span>;</div><div class="line">+<span class="comment">----------+</span></div><div class="line">| order_id |</div><div class="line">+<span class="comment">----------+</span></div><div class="line">| 3        |</div><div class="line">| 2        |</div><div class="line">| 1        |</div><div class="line">+<span class="comment">----------+</span></div><div class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.02</span> sec)</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractSelectParser.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 当无 Order By 条件时，使用 Group By 作为排序条件（数据库本身规则）</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendDerivedOrderBy</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (!getSelectStatement().getGroupByItems().isEmpty() &amp;&amp; getSelectStatement().getOrderByItems().isEmpty()) &#123;</div><div class="line">       getSelectStatement().getOrderByItems().addAll(getSelectStatement().getGroupByItems());</div><div class="line">       getSelectStatement().getSqlTokens().add(<span class="keyword">new</span> OrderByToken(getSelectStatement().getGroupByLastPosition()));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="4-3-1-OrderByToken"><a href="#4-3-1-OrderByToken" class="headerlink" title="4.3.1 OrderByToken"></a>4.3.1 OrderByToken</h3><p>排序标记对象。当无 Order By 条件时，使用 Group By 作为排序条件（数据库本身规则）。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// OrderByToken.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderByToken</span> <span class="keyword">implements</span> <span class="title">SQLToken</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * SQL 所在开始位置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> beginPosition;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p><img src="http://www.iocoder.cn/images/Architecture/2017_12_29/01.png" alt="知识星球"></p><p>咳咳咳，确实有一些略长。但请相信，INSERT / UPDATE / DELETE 会简单很多很多。考试考的 SQL 最多的是什么？SELECT 语句呀！为啥，难呗。恩，我相信看到此处的你，一定是能看懂的，加油！</p><p>🙂如果对本文有不理解的地方，可以关注我的公众号<strong>（<a href="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg">芋道源码</a>）</strong>获得<strong>微信号</strong>，我们来一场，1 对 1 的搞基吧，不不不，是交流交流。</p><p>道友，帮我分享一波怎么样？</p></div><footer class="article-footer clearfix"><div class="article-categories"><span></span> <a class="article-category-link" href="/categories/Sharding-JDBC/">Sharding-JDBC</a></div><div class="article-share" id="share"><div data-url="http://www.iocoder.cn/Sharding-JDBC/sql-parse-3/" data-title="Sharding-JDBC 源码分析 —— SQL 解析（三）之查询SQL | 芋道源码 —— 纯源码解析博客" data-tsina="null" class="share clearfix"></div></div></footer></article><nav class="article-nav clearfix"><div class="prev"><a href="/Sharding-JDBC/sql-parse-4/" title="Sharding-JDBC 源码分析 —— SQL 解析（四）之插入SQL"><strong>PREVIOUS:</strong><br><span>Sharding-JDBC 源码分析 —— SQL 解析（四）之插入SQL</span></a></div><div class="next"><a href="/Sharding-JDBC/sql-parse-2/" title="Sharding-JDBC 源码分析 —— SQL 解析（二）之SQL解析"><strong>NEXT:</strong><br><span>Sharding-JDBC 源码分析 —— SQL 解析（二）之SQL解析</span></a></div></nav></div><div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div><div id="toc" class="toc-aside"><strong class="toc-title">文章目录</strong><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-概述"><span class="toc-number">1.</span> <span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-SelectStatement"><span class="toc-number">2.</span> <span class="toc-text">2. SelectStatement</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-AbstractSQLStatement"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 AbstractSQLStatement</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-SQLToken"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 SQLToken</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-query"><span class="toc-number">3.</span> <span class="toc-text">3. #query()</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-parseDistinct"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 #parseDistinct()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-parseSelectList"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 #parseSelectList()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-SelectItem-选择项"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1 SelectItem 选择项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-parseAlias-解析别名"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2 #parseAlias() 解析别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-TableToken-表标记对象"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.2.3 TableToken 表标记对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-skipToFrom"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 #skipToFrom()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-parseFrom"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 #parseFrom()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-JOIN-ON-FROM-TABLE"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.4.1 JOIN ON / FROM TABLE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-子查询"><span class="toc-number">3.4.2.</span> <span class="toc-text">3.4.2 子查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3-parseJoinTable"><span class="toc-number">3.4.3.</span> <span class="toc-text">3.4.3 #parseJoinTable()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-4-Tables-表集合对象"><span class="toc-number">3.4.4.</span> <span class="toc-text">3.4.4 Tables 表集合对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-parseWhere"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 #parseWhere()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-parseGroupBy"><span class="toc-number">3.6.</span> <span class="toc-text">3.6 #parseGroupBy()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-1-OrderItem-排序项"><span class="toc-number">3.6.1.</span> <span class="toc-text">3.6.1 OrderItem 排序项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-parseOrderBy"><span class="toc-number">3.7.</span> <span class="toc-text">3.7 #parseOrderBy()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-parseLimit"><span class="toc-number">3.8.</span> <span class="toc-text">3.8 #parseLimit()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-1-Limit"><span class="toc-number">3.8.1.</span> <span class="toc-text">3.8.1 Limit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-2-OffsetToken-RowCountToken"><span class="toc-number">3.8.2.</span> <span class="toc-text">3.8.2 OffsetToken RowCountToken</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9-queryRest"><span class="toc-number">3.9.</span> <span class="toc-text">3.9 #queryRest()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-appendDerived等方法"><span class="toc-number">4.</span> <span class="toc-text">4. appendDerived等方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-appendAvgDerivedColumns"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 appendAvgDerivedColumns</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-appendDerivedOrderColumns"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 appendDerivedOrderColumns</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-ItemsToken"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 ItemsToken</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-appendDerivedOrderBy"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 appendDerivedOrderBy()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-OrderByToken"><span class="toc-number">4.4.1.</span> <span class="toc-text">4.3.1 OrderByToken</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#666-彩蛋"><span class="toc-number">5.</span> <span class="toc-text">666. 彩蛋</span></a></li></ol></div><div id="asidepart"><aside class="clearfix"><div id="authorInfo"><div><img width="100%" src="/images/common/wechat_mp_2017_07_31_bak.jpg"></div><div class="social-list"></div></div><div class="categorieslist"><p class="asidetitle">微信公众号福利：芋道源码</p><ul><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">0. 阅读源码葵花宝典</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">1. RocketMQ / MyCAT / Sharding-JDBC 详细中文注释源码</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">2. 您对于源码的疑问每条留言都将得到认真回复</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">3. 新的源码解析文章实时收到通知，每周六十点更新</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">4. 认真的源码交流微信群</a></li></ul></div><div class="categorieslist"><p class="asidetitle">分类</p><ul><li><a href="/categories/Elastic-Job-Cloud/" title="Elastic-Job-Cloud">Elastic-Job-Cloud<sup>6</sup></a></li><li><a href="/categories/Elastic-Job-Lite/" title="Elastic-Job-Lite">Elastic-Job-Lite<sup>16</sup></a></li><li><a href="/categories/Eureka/" title="Eureka">Eureka<sup>23</sup></a></li><li><a href="/categories/Hystrix/" title="Hystrix">Hystrix<sup>9</sup></a></li><li><a href="/categories/MyCAT/" title="MyCAT">MyCAT<sup>9</sup></a></li><li><a href="/categories/RocketMQ/" title="RocketMQ">RocketMQ<sup>14</sup></a></li><li><a href="/categories/RxJava/" title="RxJava">RxJava<sup>5</sup></a></li><li><a href="/categories/Sharding-JDBC/" title="Sharding-JDBC">Sharding-JDBC<sup>18</sup></a></li><li><a href="/categories/SkyWalking/" title="SkyWalking">SkyWalking<sup>35</sup></a></li><li><a href="/categories/Spring-Cloud-Gateway/" title="Spring-Cloud-Gateway">Spring-Cloud-Gateway<sup>24</sup></a></li><li><a href="/categories/TCC-Transaction/" title="TCC-Transaction">TCC-Transaction<sup>7</sup></a></li><li><a href="/categories/工作内推/" title="工作内推">工作内推<sup>2</sup></a></li><li><a href="/categories/芋道源码的周八/" title="芋道源码的周八">芋道源码的周八<sup>13</sup></a></li></ul></div><div id="authorInfo2"><div><img width="100%" src="/images/common/zsxq/02.png"></div></div></aside></div></div><footer><div id="footer"><img src="http://www.iocoder.cn/images/common/wechat_mp_simple.png" style="display:none"><p class="copyright">© 2018 <a href="http://www.iocoder.cn" target="_blank" title="芋道源码">芋道源码</a> && <span style="display:inline" id="busuanzi_container_site_uv">总访客数 <span id="busuanzi_value_site_uv" font="微软雅黑"></span> 次</span> && <span style="display:inline" id="busuanzi_container_site_pv">总访问量 <span id="busuanzi_value_site_pv" font="微软雅黑"></span> 次</span> && Hosted by <a href="https://pages.coding.me" style="font-weight:700" rel="external nofollow noopener noreferrer" target="_blank">Coding Pages</a></p></div><div class="copyright">沪ICP备17037075号-1</div></footer><script src="/js/jquery-2.1.0.min.js"></script><script type="text/javascript">$(document).ready(function(){function e(){"number"==typeof window.innerWidth?n=window.innerWidth:document.documentElement&&document.documentElement.clientWidth&&(n=document.documentElement.clientWidth)}$(".navbar").click(function(){$("header nav").toggleClass("shownav")});var n=0,s=$("#main"),a=$("#asidepart"),o=$(".closeaside"),d=$(".openaside");$(window).resize(function(){e(),n>=1024?$("header nav").removeClass("shownav"):(s.removeClass("moveMain"),a.css("display","block").removeClass("fadeOut"),d.css("display","none"),$("#toc.toc-aside").css("display","none"))}),o.click(function(){a.addClass("fadeOut").css("display","none"),d.css("display","block").addClass("fadeIn"),s.addClass("moveMain")}),d.click(function(){d.css("display","none").removeClass("beforeFadeIn"),a.css("display","block").removeClass("fadeOut").addClass("fadeIn"),s.removeClass("moveMain")}),$(window).scroll(function(){d.css("top",Math.max(80,260-$(this).scrollTop()))})})</script><script type="text/javascript">$(document).ready(function(){var a=$(".article-content>iframe"),t=$(".article-content>embed"),n=$("#toc");$("article h2");ah=$("article h2"),ta=$("#toc.toc-aside"),o=$(".openaside"),c=$(".closeaside"),a.length>0&&a.wrap('<div class="video-container" />'),t.length>0&&t.wrap('<div class="video-container" />'),0==ah.length?n.css("display","none"):(c.click(function(){ta.css("display","block").addClass("fadeIn")}),o.click(function(){ta.css("display","none")}),$(window).scroll(function(){ta.css("top",Math.max(140,320-$(this).scrollTop()))}))})</script><script type="text/javascript">$(document).ready(function(){var t=$(".share"),a=t.attr("data-url"),e=encodeURIComponent(a),r=['<a href="#" class="overlay" id="qrcode"></a>','<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url='+e+'"/></div>','<a href="#textlogo" class="article-back-to-top" title="Top"></a>','<a href="https://www.facebook.com/sharer.php?u='+e+'" class="article-share-facebook" target="_blank" title="Facebook"></a>','<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>','<a href="https://twitter.com/intent/tweet?url='+e+'" class="article-share-twitter" target="_blank" title="Twitter"></a>','<a href="http://service.weibo.com/share/share.php?title='+t.attr("data-title")+"&url="+e+"&ralateUid="+t.attr("data-tsina")+'&searchPic=true&style=number" class="article-share-weibo" target="_blank" title="Weibo"></a>','<span title="Share to"></span>'].join("");t.append(r),$(".article-share-qrcode").click(function(){var t=$("#qrcode-pic").attr("data-src");$("#qrcode-pic").attr("src",t),$("#qrcode-pic").load(function(){$(".qrcode strong").text(" ")})})})</script><link rel="stylesheet" href="/alert/css/alert.css"><script src="/alert/js/alert.js"></script><script src="/js/jquery.cookie.js"></script><script src="/js/util.js"></script><script type="text/javascript">!function(e,a,t,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=a.createElement(t),s=a.getElementsByTagName(t)[0],o.async=1,o.src="//www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s)}(window,document,"script",0,"ga"),ga("create","UA-107572620-1","auto"),ga("send","pageview")</script></body>