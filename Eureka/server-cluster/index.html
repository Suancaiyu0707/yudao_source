<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="google-site-verification" content="GkJ68PCnxM9Ih7Zm9v8p91FOCV7ymNCO2KdGbflLh3E"><meta name="360-site-verification" content="dd6547587641bfede036f7c79561e8a0"><meta name="shenma-site-verification" content="fd96cf3751972c9b05f8471d2ccadddc_1496951214"><meta name="msvalidate.01" content="1D38B05050A977F6FDEDA481198343F1"><meta name="sogou_site_verification" content="MpPsku240L"><title>Eureka 源码解析 —— Eureka-Server 集群同步 | 芋道源码 —— 纯源码解析博客</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=3,minimum-scale=1"><meta name="author" content="芋道源码"><meta name="description" content="摘要: 原创出处 http://www.iocoder.cn/Eureka/server-cluster/ 「芋道源码」欢迎转载，保留摘要，谢谢！
本文主要基于 Eureka 1.8.X 版本

1. 概述
2. 集群节点初始化与更新
2.1 集群节点启动
2.2 更新集群节点信息
2.3 集群节点"><meta name="keywords" content="Java,架构,后端,服务端,RocketMQ,MyCAT,分布式消息队列,分布式存储,技术博客,Sharding-JDBC,分库分表"><link rel="alternate" href="atom.xml" title="芋道源码 —— 纯源码解析博客" type="application/atom+xml"><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/style.css"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?9e70e3362807c1bd185a79655b307027";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script>!function(){var t="http:"==document.location.protocol?"http://js.passport.qihucdn.com/11.0.1.js?f05b61dd54bbc38386611a5238672938":"https://jspassport.ssl.qhimg.com/11.0.1.js?f05b61dd54bbc38386611a5238672938";document.write('<script src="'+t+'" id="sozz"><\/script>')}()</script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></head></html><body><header><div><div id="textlogo"><h1 class="site-name"><a href="/" title="芋道源码 —— 纯源码解析博客">芋道源码 —— 纯源码解析博客</a></h1><a class="blog-motto">愿半生编码，如一生老友！</a></div><div class="navbar"><a class="navbutton navmobile" href="#" title="菜单"></a></div><nav class="animated"><ul><ul><li><a href="/">文章</a></li><li><a href="/2018-meet-you">知识星球</a></li><li><a href="https://github.com/YunaiV" rel="external nofollow noopener noreferrer" target="_blank">Github</a></li><li><a href="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31_bak.jpg">微信公众号</a></li><li><a href="/categories/%E5%B7%A5%E4%BD%9C%E5%86%85%E6%8E%A8/">工作内推</a></li><li><a href="/link_url">友链</a></li></ul></ul></nav></div></header><div id="container"><div id="main" class="post" itemscope="" itemprop="blogPost"><article itemprop="articleBody"><header class="article-info clearfix"><h1 itemprop="name"><a href="/Eureka/server-cluster/" title="Eureka 源码解析 —— Eureka-Server 集群同步" itemprop="url">Eureka 源码解析 —— Eureka-Server 集群同步</a></h1><p class="article-author"></p><p class="article-time">总阅读量:<span id="busuanzi_value_page_pv"></span>次</p></header><div class="article-content"><p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/server-cluster/">http://www.iocoder.cn/Eureka/server-cluster/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">2. 集群节点初始化与更新</a><ul><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">2.1 集群节点启动</a></li><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">2.2 更新集群节点信息</a></li><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">2.3 集群节点</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">3. 获取初始注册信息</a></li><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">4. 同步注册信息</a><ul><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">4.1 同步操作类型</a></li><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">4.2 发起 Eureka-Server 同步操作</a></li><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">4.3 接收 Eureka-Server 同步操作</a></li><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">4.4 处理 Eureka-Server 同步结果</a></li></ul></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Eureka-Server 集群同步注册信息</strong>。</p><p>Eureka-Server 集群如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_08_07/01.png" alt=""></p><ul><li>Eureka-Server 集群不区分<strong>主从节点</strong>或者 <strong>Primary &amp; Secondary 节点</strong>，所有节点<strong>相同角色( 也就是没有角色 )，完全对等</strong>。</li><li>Eureka-Client 可以向<strong>任意</strong> Eureka-Client 发起任意<strong>读写</strong>操作，Eureka-Server 将操作复制到另外的 Eureka-Server 以达到<strong>最终一致性</strong>。注意，Eureka-Server 是选择了 AP 的组件。</li></ul><p>Eureka-Server 可以使用直接配置所有节点的服务地址，或者基于 DNS 配置。推荐阅读：<a href="http://blog.didispace.com/springcloud6/?from=http://www.iocoder.cn" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud构建微服务架构（六）高可用服务注册中心》</a> 。</p><p>本文主要类在 <code>com.netflix.eureka.cluster</code> 包下。</p><p>OK，让我们开始愉快的遨游在代码的海洋。</p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><p>ps ：<strong>注意</strong>，本文提到的<strong>同步</strong>，准确来说是<strong>复制( Replication )</strong>。</p><h1 id="2-集群节点初始化与更新"><a href="#2-集群节点初始化与更新" class="headerlink" title="2. 集群节点初始化与更新"></a>2. 集群节点初始化与更新</h1><p><code>com.netflix.eureka.cluster.PeerEurekaNodes</code> ，Eureka-Server 集群节点集合 。构造方法如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeerEurekaNodes</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(PeerEurekaNodes.class);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用实例注册表</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> PeerAwareInstanceRegistry registry;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Eureka-Server 配置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> EurekaServerConfig serverConfig;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Eureka-Client 配置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> EurekaClientConfig clientConfig;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Eureka-Server 编解码</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> ServerCodecs serverCodecs;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用实例信息管理器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApplicationInfoManager applicationInfoManager;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Eureka-Server 集群节点数组</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;PeerEurekaNode&gt; peerEurekaNodes = Collections.emptyList();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Eureka-Server 服务地址数组</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Set&lt;String&gt; peerEurekaNodeUrls = Collections.emptySet();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 定时任务服务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> ScheduledExecutorService taskExecutor;</div><div class="line"></div><div class="line">    <span class="meta">@Inject</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PeerEurekaNodes</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">            PeerAwareInstanceRegistry registry,</span></span></div><div class="line"><span class="function"><span class="params">            EurekaServerConfig serverConfig,</span></span></div><div class="line"><span class="function"><span class="params">            EurekaClientConfig clientConfig,</span></span></div><div class="line"><span class="function"><span class="params">            ServerCodecs serverCodecs,</span></span></div><div class="line"><span class="function"><span class="params">            ApplicationInfoManager applicationInfoManager)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.registry = registry;</div><div class="line">        <span class="keyword">this</span>.serverConfig = serverConfig;</div><div class="line">        <span class="keyword">this</span>.clientConfig = clientConfig;</div><div class="line">        <span class="keyword">this</span>.serverCodecs = serverCodecs;</div><div class="line">        <span class="keyword">this</span>.applicationInfoManager = applicationInfoManager;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>peerEurekaNodes</code>, <code>peerEurekaNodeUrls</code>, <code>taskExecutor</code> 属性，在构造方法中<strong>未设置和初始化</strong>，而是在 <code>PeerEurekaNodes#start()</code> 方法，设置和初始化，下文我们会解析这个方法。</li><li>Eureka-Server 在初始化时，调用 <code>EurekaBootStrap#getPeerEurekaNodes(...)</code> 方法，创建 PeerEurekaNodes ，点击 <a href="https://github.com/YunaiV/eureka/blob/94a4a1ebd35a3350893369a05757c01b2534b702/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java#L245" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看该方法的实现。</li></ul><h2 id="2-1-集群节点启动"><a href="#2-1-集群节点启动" class="headerlink" title="2.1 集群节点启动"></a>2.1 集群节点启动</h2><p>调用 <code>PeerEurekaNodes#start()</code> 方法，集群节点启动，主要完成两个逻辑：</p><ul><li>初始化集群节点信息</li><li>初始化固定周期( 默认：10 分钟，可配置 )更新集群节点信息的任务</li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// 创建 定时任务服务</span></div><div class="line"> <span class="number">3</span>:     taskExecutor = Executors.newSingleThreadScheduledExecutor(</div><div class="line"> <span class="number">4</span>:             <span class="keyword">new</span> ThreadFactory() &#123;</div><div class="line"> <span class="number">5</span>:                 <span class="meta">@Override</span></div><div class="line"> <span class="number">6</span>:                 <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line"> <span class="number">7</span>:                     Thread thread = <span class="keyword">new</span> Thread(r, <span class="string">"Eureka-PeerNodesUpdater"</span>);</div><div class="line"> <span class="number">8</span>:                     thread.setDaemon(<span class="keyword">true</span>);</div><div class="line"> <span class="number">9</span>:                     <span class="keyword">return</span> thread;</div><div class="line"><span class="number">10</span>:                 &#125;</div><div class="line"><span class="number">11</span>:             &#125;</div><div class="line"><span class="number">12</span>:     );</div><div class="line"><span class="number">13</span>:     <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">14</span>:         <span class="comment">// 初始化 集群节点信息</span></div><div class="line"><span class="number">15</span>:         updatePeerEurekaNodes(resolvePeerUrls());</div><div class="line"><span class="number">16</span>:         <span class="comment">// 初始化 初始化固定周期更新集群节点信息的任务</span></div><div class="line"><span class="number">17</span>:         Runnable peersUpdateTask = <span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="number">18</span>:             <span class="meta">@Override</span></div><div class="line"><span class="number">19</span>:             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">20</span>:                 <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">21</span>:                     updatePeerEurekaNodes(resolvePeerUrls());</div><div class="line"><span class="number">22</span>:                 &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"><span class="number">23</span>:                     logger.error(<span class="string">"Cannot update the replica Nodes"</span>, e);</div><div class="line"><span class="number">24</span>:                 &#125;</div><div class="line"><span class="number">25</span>: </div><div class="line"><span class="number">26</span>:             &#125;</div><div class="line"><span class="number">27</span>:         &#125;;</div><div class="line"><span class="number">28</span>:         taskExecutor.scheduleWithFixedDelay(</div><div class="line"><span class="number">29</span>:                 peersUpdateTask,</div><div class="line"><span class="number">30</span>:                 serverConfig.getPeerEurekaNodesUpdateIntervalMs(),</div><div class="line"><span class="number">31</span>:                 serverConfig.getPeerEurekaNodesUpdateIntervalMs(),</div><div class="line"><span class="number">32</span>:                 TimeUnit.MILLISECONDS</div><div class="line"><span class="number">33</span>:         );</div><div class="line"><span class="number">34</span>:     &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"><span class="number">35</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</div><div class="line"><span class="number">36</span>:     &#125;</div><div class="line"><span class="number">37</span>:     <span class="comment">// 打印 集群节点信息</span></div><div class="line"><span class="number">38</span>:     <span class="keyword">for</span> (PeerEurekaNode node : peerEurekaNodes) &#123;</div><div class="line"><span class="number">39</span>:         logger.info(<span class="string">"Replica node URL:  "</span> + node.getServiceUrl());</div><div class="line"><span class="number">40</span>:     &#125;</div><div class="line"><span class="number">41</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 15 行 &amp;&amp; 第 21 行 ：调用 <code>#updatePeerEurekaNodes()</code> 方法，更新集群节点信息。</li></ul><h2 id="2-2-更新集群节点信息"><a href="#2-2-更新集群节点信息" class="headerlink" title="2.2 更新集群节点信息"></a>2.2 更新集群节点信息</h2><p>调用 <code>#resolvePeerUrls()</code> 方法，获得 Eureka-Server 集群服务地址数组，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">resolvePeerUrls</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// 获得 Eureka-Server 集群服务地址数组</span></div><div class="line"> <span class="number">3</span>:     InstanceInfo myInfo = applicationInfoManager.getInfo();</div><div class="line"> <span class="number">4</span>:     String zone = InstanceInfo.getZone(clientConfig.getAvailabilityZones(clientConfig.getRegion()), myInfo);</div><div class="line"> <span class="number">5</span>:     List&lt;String&gt; replicaUrls = EndpointUtils.getDiscoveryServiceUrls(clientConfig, zone, <span class="keyword">new</span> EndpointUtils.InstanceInfoBasedUrlRandomizer(myInfo));</div><div class="line"> <span class="number">6</span>: </div><div class="line"> <span class="number">7</span>:     <span class="comment">// 移除自己（避免向自己同步）</span></div><div class="line"> <span class="number">8</span>:     <span class="keyword">int</span> idx = <span class="number">0</span>;</div><div class="line"> <span class="number">9</span>:     <span class="keyword">while</span> (idx &lt; replicaUrls.size()) &#123;</div><div class="line"><span class="number">10</span>:         <span class="keyword">if</span> (isThisMyUrl(replicaUrls.get(idx))) &#123;</div><div class="line"><span class="number">11</span>:             replicaUrls.remove(idx);</div><div class="line"><span class="number">12</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">13</span>:             idx++;</div><div class="line"><span class="number">14</span>:         &#125;</div><div class="line"><span class="number">15</span>:     &#125;</div><div class="line"><span class="number">16</span>:     <span class="keyword">return</span> replicaUrls;</div><div class="line"><span class="number">17</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 2 至 5 行 ：获得 Eureka-Server 集群服务地址数组。<code>EndpointUtils#getDiscoveryServiceUrls(...)</code> 方法，逻辑与 <a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/?self">《Eureka 源码解析 —— EndPoint 与 解析器》「3.4 ConfigClusterResolver」</a> 基本类似。EndpointUtils 正在逐步，猜测未来这里会替换。</li><li>第 7 至 15 行 ：移除自身节点，避免向自己同步。</li></ul><hr><p>调用 <code>#updatePeerEurekaNodes()</code> 方法，更新集群节点信息，主要完成两部分逻辑：</p><ul><li>添加新增的集群节点</li><li>关闭删除的集群节点</li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">updatePeerEurekaNodes</span><span class="params">(List&lt;String&gt; newPeerUrls)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="keyword">if</span> (newPeerUrls.isEmpty()) &#123;</div><div class="line"> <span class="number">3</span>:         logger.warn(<span class="string">"The replica size seems to be empty. Check the route 53 DNS Registry"</span>);</div><div class="line"> <span class="number">4</span>:         <span class="keyword">return</span>;</div><div class="line"> <span class="number">5</span>:     &#125;</div><div class="line"> <span class="number">6</span>: </div><div class="line"> <span class="number">7</span>:     <span class="comment">// 计算 新增的集群节点地址</span></div><div class="line"> <span class="number">8</span>:     Set&lt;String&gt; toShutdown = <span class="keyword">new</span> HashSet&lt;&gt;(peerEurekaNodeUrls);</div><div class="line"> <span class="number">9</span>:     toShutdown.removeAll(newPeerUrls);</div><div class="line"><span class="number">10</span>: </div><div class="line"><span class="number">11</span>:     <span class="comment">// 计算 删除的集群节点地址</span></div><div class="line"><span class="number">12</span>:     Set&lt;String&gt; toAdd = <span class="keyword">new</span> HashSet&lt;&gt;(newPeerUrls);</div><div class="line"><span class="number">13</span>:     toAdd.removeAll(peerEurekaNodeUrls);</div><div class="line"><span class="number">14</span>: </div><div class="line"><span class="number">15</span>:     <span class="keyword">if</span> (toShutdown.isEmpty() &amp;&amp; toAdd.isEmpty()) &#123; <span class="comment">// No change</span></div><div class="line"><span class="number">16</span>:         <span class="keyword">return</span>;</div><div class="line"><span class="number">17</span>:     &#125;</div><div class="line"><span class="number">18</span>: </div><div class="line"><span class="number">19</span>:     <span class="comment">// 关闭删除的集群节点</span></div><div class="line"><span class="number">20</span>:     <span class="comment">// Remove peers no long available</span></div><div class="line"><span class="number">21</span>:     List&lt;PeerEurekaNode&gt; newNodeList = <span class="keyword">new</span> ArrayList&lt;&gt;(peerEurekaNodes);</div><div class="line"><span class="number">22</span>:     <span class="keyword">if</span> (!toShutdown.isEmpty()) &#123;</div><div class="line"><span class="number">23</span>:         logger.info(<span class="string">"Removing no longer available peer nodes &#123;&#125;"</span>, toShutdown);</div><div class="line"><span class="number">24</span>:         <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"><span class="number">25</span>:         <span class="keyword">while</span> (i &lt; newNodeList.size()) &#123;</div><div class="line"><span class="number">26</span>:             PeerEurekaNode eurekaNode = newNodeList.get(i);</div><div class="line"><span class="number">27</span>:             <span class="keyword">if</span> (toShutdown.contains(eurekaNode.getServiceUrl())) &#123;</div><div class="line"><span class="number">28</span>:                 newNodeList.remove(i);</div><div class="line"><span class="number">29</span>:                 eurekaNode.shutDown(); <span class="comment">// 关闭</span></div><div class="line"><span class="number">30</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">31</span>:                 i++;</div><div class="line"><span class="number">32</span>:             &#125;</div><div class="line"><span class="number">33</span>:         &#125;</div><div class="line"><span class="number">34</span>:     &#125;</div><div class="line"><span class="number">35</span>: </div><div class="line"><span class="number">36</span>:     <span class="comment">// 添加新增的集群节点</span></div><div class="line"><span class="number">37</span>:     <span class="comment">// Add new peers</span></div><div class="line"><span class="number">38</span>:     <span class="keyword">if</span> (!toAdd.isEmpty()) &#123;</div><div class="line"><span class="number">39</span>:         logger.info(<span class="string">"Adding new peer nodes &#123;&#125;"</span>, toAdd);</div><div class="line"><span class="number">40</span>:         <span class="keyword">for</span> (String peerUrl : toAdd) &#123;</div><div class="line"><span class="number">41</span>:             newNodeList.add(createPeerEurekaNode(peerUrl));</div><div class="line"><span class="number">42</span>:         &#125;</div><div class="line"><span class="number">43</span>:     &#125;</div><div class="line"><span class="number">44</span>: </div><div class="line"><span class="number">45</span>:     <span class="comment">// 赋值</span></div><div class="line"><span class="number">46</span>:     <span class="keyword">this</span>.peerEurekaNodes = newNodeList;</div><div class="line"><span class="number">47</span>:     <span class="keyword">this</span>.peerEurekaNodeUrls = <span class="keyword">new</span> HashSet&lt;&gt;(newPeerUrls);</div><div class="line"><span class="number">48</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 7 至 9 行 ：<strong>计算</strong>新增的集群节点地址。</li><li>第 11 至 13 行 ：<strong>计算</strong>删除的集群节点地址。</li><li>第 19 至 34 行 ：<strong>关闭</strong>删除的集群节点。</li><li><p>第 36 至 43 行 ：<strong>添加</strong>新增的集群节点。调用 <code>#createPeerEurekaNode(peerUrl)</code> 方法，创建集群节点，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="number">1</span>: <span class="function"><span class="keyword">protected</span> PeerEurekaNode <span class="title">createPeerEurekaNode</span><span class="params">(String peerEurekaNodeUrl)</span> </span>&#123;</div><div class="line"><span class="number">2</span>:     HttpReplicationClient replicationClient = JerseyReplicationClient.createReplicationClient(serverConfig, serverCodecs, peerEurekaNodeUrl);</div><div class="line"><span class="number">3</span>:     String targetHost = hostFromUrl(peerEurekaNodeUrl);</div><div class="line"><span class="number">4</span>:     <span class="keyword">if</span> (targetHost == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">5</span>:         targetHost = <span class="string">"host"</span>;</div><div class="line"><span class="number">6</span>:     &#125;</div><div class="line"><span class="number">7</span>:     <span class="keyword">return</span> <span class="keyword">new</span> PeerEurekaNode(registry, targetHost, peerEurekaNodeUrl, replicationClient, serverConfig);</div><div class="line"><span class="number">8</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 2 行 ：创建 Eureka-Server 集群通信客户端，在 <a href="http://www.iocoder.cn/Eureka/transport/?self">《Eureka 源码解析 —— 网络通信》「4.2 JerseyReplicationClient」</a> 有详细解析。</li><li>第 7 行 ：创建 PeerEurekaNode ，在 <a href="#">「2.3 PeerEurekaNode」</a> 有详细解析。</li></ul></li></ul><h2 id="2-3-集群节点"><a href="#2-3-集群节点" class="headerlink" title="2.3 集群节点"></a>2.3 集群节点</h2><p><code>com.netflix.eureka.cluster.PeerEurekaNode</code> ，单个集群节点。</p><p>点击 <a href="https://github.com/YunaiV/eureka/blob/fcc9027a197783a23e7cb72ad0f617b7dc63d221/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java#L111" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看<strong>构造方法</strong></p><ul><li>第 129 行 ：创建 ReplicationTaskProcessor 。在 <a href="#">「4.1.2 同步操作任务处理器」</a> 详细解析</li><li>第 131 至 140 行 ：创建<strong>批量任务</strong>分发器，在 <a href="http://www.iocoder.cn/Eureka/batch-tasks/?self">《Eureka 源码解析 —— 任务批处理》</a> 有详细解析。</li><li>第 142 至 151 行 ：创建<strong>单任务</strong>分发器，用于 Eureka-Server 向亚马逊 AWS 的 ASG ( <code>Autoscaling Group</code> ) 同步状态。暂时跳过。</li></ul><h1 id="3-获取初始注册信息"><a href="#3-获取初始注册信息" class="headerlink" title="3. 获取初始注册信息"></a>3. 获取初始注册信息</h1><p>Eureka-Server 启动时，调用 <code>PeerAwareInstanceRegistryImpl#syncUp()</code> 方法，从集群的一个 Eureka-Server 节点获取<strong>初始</strong>注册信息，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">syncUp</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="comment">// Copy entire entry from neighboring DS node</span></div><div class="line"> <span class="number">4</span>:     <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"> <span class="number">5</span>: </div><div class="line"> <span class="number">6</span>:     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ((i &lt; serverConfig.getRegistrySyncRetries()) &amp;&amp; (count == <span class="number">0</span>)); i++) &#123;</div><div class="line"> <span class="number">7</span>:         <span class="comment">// 未读取到注册信息，sleep 等待</span></div><div class="line"> <span class="number">8</span>:         <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</div><div class="line"> <span class="number">9</span>:             <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">10</span>:                 Thread.sleep(serverConfig.getRegistrySyncRetryWaitMs());</div><div class="line"><span class="number">11</span>:             &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line"><span class="number">12</span>:                 logger.warn(<span class="string">"Interrupted during registry transfer.."</span>);</div><div class="line"><span class="number">13</span>:                 <span class="keyword">break</span>;</div><div class="line"><span class="number">14</span>:             &#125;</div><div class="line"><span class="number">15</span>:         &#125;</div><div class="line"><span class="number">16</span>: </div><div class="line"><span class="number">17</span>:         <span class="comment">// 获取注册信息</span></div><div class="line"><span class="number">18</span>:         Applications apps = eurekaClient.getApplications();</div><div class="line"><span class="number">19</span>:         <span class="keyword">for</span> (Application app : apps.getRegisteredApplications()) &#123;</div><div class="line"><span class="number">20</span>:             <span class="keyword">for</span> (InstanceInfo instance : app.getInstances()) &#123;</div><div class="line"><span class="number">21</span>:                 <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">22</span>:                     <span class="keyword">if</span> (isRegisterable(instance)) &#123; <span class="comment">// 判断是否能够注册</span></div><div class="line"><span class="number">23</span>:                         register(instance, instance.getLeaseInfo().getDurationInSecs(), <span class="keyword">true</span>); <span class="comment">// 注册</span></div><div class="line"><span class="number">24</span>:                         count++;</div><div class="line"><span class="number">25</span>:                     &#125;</div><div class="line"><span class="number">26</span>:                 &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line"><span class="number">27</span>:                     logger.error(<span class="string">"During DS init copy"</span>, t);</div><div class="line"><span class="number">28</span>:                 &#125;</div><div class="line"><span class="number">29</span>:             &#125;</div><div class="line"><span class="number">30</span>:         &#125;</div><div class="line"><span class="number">31</span>:     &#125;</div><div class="line"><span class="number">32</span>:     <span class="keyword">return</span> count;</div><div class="line"><span class="number">33</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 7 至 15 行 ：未获取到注册信息，<code>sleep</code> 等待再次重试。</li><li>第 17 至 30 行 ：获取注册信息，若获取到，注册到自身节点。<ul><li>第 22 行 ：判断应用实例是否能够注册到自身节点。主要用于亚马逊 AWS 环境下的判断，若非部署在亚马逊里，都返回 <code>true</code> 。点击 <a href="https://github.com/YunaiV/eureka/blob/94a4a1ebd35a3350893369a05757c01b2534b702/eureka-core/src/main/java/com/netflix/eureka/registry/PeerAwareInstanceRegistryImpl.java#L593" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看实现。</li><li>第 23 行 ：调用 <code>#register()</code> 方法，注册应用实例到自身节点。在 <a href="http://www.iocoder.cn/Eureka/instance-registry-register/">《Eureka 源码解析 —— 应用实例注册发现（一）之注册》</a> 有详细解析。</li></ul></li></ul><hr><p>若调用 <code>#syncUp()</code> 方法，未获取到应用实例，则 Eureka-Server 会有一段时间( 默认：5 分钟，可配 )不允许被 Eureka-Client 获取注册信息，避免影响 Eureka-Client 。</p><ul><li><p>标记 Eureka-Server 启动时，未获取到应用实例，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// PeerAwareInstanceRegistryImpl.java</span></div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> peerInstancesTransferEmptyOnStartup = <span class="keyword">true</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openForTraffic</span><span class="params">(ApplicationInfoManager applicationInfoManager, <span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">    <span class="comment">// ... 省略其他代码</span></div><div class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.peerInstancesTransferEmptyOnStartup = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// ... 省略其他代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><ul><li><p>判断 Eureka-Server 是否允许被 Eureka-Client 获取注册信息，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// PeerAwareInstanceRegistryImpl.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldAllowAccess</span><span class="params">(<span class="keyword">boolean</span> remoteRegionRequired)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.peerInstancesTransferEmptyOnStartup) &#123;</div><div class="line">       <span class="comment">// 设置启动时间</span></div><div class="line">       <span class="keyword">this</span>.startupTime = System.currentTimeMillis();</div><div class="line">       <span class="keyword">if</span> (!(System.currentTimeMillis() &gt; <span class="keyword">this</span>.startupTime + serverConfig.getWaitTimeInMsWhenSyncEmpty())) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// ... 省略其他代码</span></div><div class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h1 id="4-同步注册信息"><a href="#4-同步注册信息" class="headerlink" title="4. 同步注册信息"></a>4. 同步注册信息</h1><p>Eureka-Server 集群同步注册信息如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_08_07/02.png" alt=""></p><ul><li>Eureka-Server 接收到 Eureka-Client 的 Register、Heartbeat、Cancel、StatusUpdate、DeleteStatusOverride 操作，固定间隔( 默认值 ：500 毫秒，可配 )向 Eureka-Server 集群内其他节点同步( <strong>准实时，非实时</strong> )。</li></ul><h2 id="4-1-同步操作类型"><a href="#4-1-同步操作类型" class="headerlink" title="4.1 同步操作类型"></a>4.1 同步操作类型</h2><p><code>com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl.Action</code> ，同步操作类型，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Action &#123;</div><div class="line">   Heartbeat, Register, Cancel, StatusUpdate, DeleteStatusOverride;</div><div class="line"></div><div class="line">   <span class="comment">// ... 省略监控相关属性</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>Register ，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-register/?self">《Eureka 源码解析 —— 应用实例注册发现（一）之注册》</a> 有详细解析</li><li>Heartbeat ，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-renew/?self">《Eureka 源码解析 —— 应用实例注册发现（二）之续租》</a> 有详细解析</li><li>Cancel ，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-cancel/?self">《Eureka 源码解析 —— 应用实例注册发现（三）之下线》</a> 有详细解析</li><li>StatusUpdate ，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/?self">《Eureka 源码解析 —— 应用实例注册发现（八）之覆盖状态》</a> 有详细解析</li><li>DeleteStatusOverride ，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/?self">《Eureka 源码解析 —— 应用实例注册发现（八）之覆盖状态》</a> 有详细解析</li></ul><h2 id="4-2-发起-Eureka-Server-同步操作"><a href="#4-2-发起-Eureka-Server-同步操作" class="headerlink" title="4.2 发起 Eureka-Server 同步操作"></a>4.2 发起 Eureka-Server 同步操作</h2><p>Eureka-Server 在完成 Eureka-Client 发起的上述操作在<strong>自身节点的执行后</strong>，向集群内其他 Eureka-Server 发起同步操作。以 Register 操作举例子，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// PeerAwareInstanceRegistryImpl.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> InstanceInfo info, <span class="keyword">final</span> <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">   <span class="comment">// 租约过期时间</span></div><div class="line">   <span class="keyword">int</span> leaseDuration = Lease.DEFAULT_DURATION_IN_SECS;</div><div class="line">   <span class="keyword">if</span> (info.getLeaseInfo() != <span class="keyword">null</span> &amp;&amp; info.getLeaseInfo().getDurationInSecs() &gt; <span class="number">0</span>) &#123;</div><div class="line">       leaseDuration = info.getLeaseInfo().getDurationInSecs();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 注册应用实例信息</span></div><div class="line">   <span class="keyword">super</span>.register(info, leaseDuration, isReplication);</div><div class="line">   <span class="comment">// Eureka-Server 复制</span></div><div class="line">   replicateToPeers(Action.Register, info.getAppName(), info.getId(), info, <span class="keyword">null</span>, isReplication);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>最后一行，调用 <code>#replicateToPeers(...)</code> 方法，传递<strong>对应的同步操作类型</strong>，发起同步操作。</li></ul><hr><p><code>#replicateToPeers(...)</code> 方法，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replicateToPeers</span><span class="params">(Action action, String appName, String id,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">2</span>:                               InstanceInfo info <span class="comment">/* optional */</span>,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">3</span>:                               InstanceStatus newStatus <span class="comment">/* optional */</span>, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line"> <span class="number">4</span>:     Stopwatch tracer = action.getTimer().start();</div><div class="line"> <span class="number">5</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">6</span>:         <span class="keyword">if</span> (isReplication) &#123;</div><div class="line"> <span class="number">7</span>:             numberOfReplicationsLastMin.increment();</div><div class="line"> <span class="number">8</span>:         &#125;</div><div class="line"> <span class="number">9</span>: </div><div class="line"><span class="number">10</span>:         <span class="comment">// Eureka-Server 发起的请求 或者 集群为空</span></div><div class="line"><span class="number">11</span>:         <span class="comment">// If it is a replication already, do not replicate again as this will create a poison replication</span></div><div class="line"><span class="number">12</span>:         <span class="keyword">if</span> (peerEurekaNodes == Collections.EMPTY_LIST || isReplication) &#123;</div><div class="line"><span class="number">13</span>:             <span class="keyword">return</span>;</div><div class="line"><span class="number">14</span>:         &#125;</div><div class="line"><span class="number">15</span>: </div><div class="line"><span class="number">16</span>:         <span class="keyword">for</span> (<span class="keyword">final</span> PeerEurekaNode node : peerEurekaNodes.getPeerEurekaNodes()) &#123;</div><div class="line"><span class="number">17</span>:             <span class="comment">// If the url represents this host, do not replicate to yourself.</span></div><div class="line"><span class="number">18</span>:             <span class="keyword">if</span> (peerEurekaNodes.isThisMyUrl(node.getServiceUrl())) &#123;</div><div class="line"><span class="number">19</span>:                 <span class="keyword">continue</span>;</div><div class="line"><span class="number">20</span>:             &#125;</div><div class="line"><span class="number">21</span>:             replicateInstanceActionsToPeers(action, appName, id, info, newStatus, node);</div><div class="line"><span class="number">22</span>:         &#125;</div><div class="line"><span class="number">23</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">24</span>:         tracer.stop();</div><div class="line"><span class="number">25</span>:     &#125;</div><div class="line"><span class="number">26</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 10 至 14 行 ：Eureka-Server 在处理上述操作( Action )，无论来自 Eureka-Client 发起请求，还是 Eureka-Server 发起同步，调用的内部方法相同，通过 <code>isReplication=true</code> 参数，避免死循环同步。</li><li>第 16 至 22 行 ：<strong>循环</strong>集群内<strong>每个</strong>节点，调用 <code>#replicateInstanceActionsToPeers(...)</code> 方法，发起同步操作。</li></ul><hr><p><code>#replicateInstanceActionsToPeers(...)</code> 方法，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replicateInstanceActionsToPeers</span><span class="params">(Action action, String appName,</span></span></div><div class="line"><span class="function"><span class="params">                                            String id, InstanceInfo info, InstanceStatus newStatus,</span></span></div><div class="line"><span class="function"><span class="params">                                            PeerEurekaNode node)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       InstanceInfo infoFromRegistry;</div><div class="line">       CurrentRequestVersion.set(Version.V2);</div><div class="line">       <span class="keyword">switch</span> (action) &#123;</div><div class="line">           <span class="keyword">case</span> Cancel:</div><div class="line">               node.cancel(appName, id);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> Heartbeat:</div><div class="line">               InstanceStatus overriddenStatus = overriddenInstanceStatusMap.get(id);</div><div class="line">               infoFromRegistry = getInstanceByAppAndId(appName, id, <span class="keyword">false</span>);</div><div class="line">               node.heartbeat(appName, id, infoFromRegistry, overriddenStatus, <span class="keyword">false</span>);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> Register:</div><div class="line">               node.register(info);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> StatusUpdate:</div><div class="line">               infoFromRegistry = getInstanceByAppAndId(appName, id, <span class="keyword">false</span>);</div><div class="line">               node.statusUpdate(appName, id, newStatus, infoFromRegistry);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> DeleteStatusOverride:</div><div class="line">               infoFromRegistry = getInstanceByAppAndId(appName, id, <span class="keyword">false</span>);</div><div class="line">               node.deleteStatusOverride(appName, id, infoFromRegistry);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">       logger.error(<span class="string">"Cannot replicate information to &#123;&#125; for action &#123;&#125;"</span>, node.getServiceUrl(), action.name(), t);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>Cancel</strong> ：调用 <code>PeerEurekaNode#cancel(...)</code> 方法，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java#L157" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看实现。</li><li><strong>Heartbeat</strong> ：调用 <code>PeerEurekaNode#heartbeat(...)</code> 方法，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java#L194" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看实现。</li><li><strong>Register</strong> ：调用 <code>PeerEurekaNode#register(...)</code> 方法，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java#L134" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看实现。</li><li><strong>StatusUpdate</strong> ：调用 <code>PeerEurekaNode#statusUpdate(...)</code> 方法，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java#L243" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看实现。</li><li><strong>DeleteStatusOverride</strong> ：调用 <code>PeerEurekaNode#deleteStatusOverride(...)</code> 方法，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java#L294" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看实现。</li><li><p>上面的每个方法实现，我们<strong>都</strong>会看到类似这么一段代码 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">batchingDispatcher.process(</div><div class="line">    taskId(<span class="string">"$&#123;action&#125;"</span>, appName, id), <span class="comment">// id</span></div><div class="line">    <span class="keyword">new</span> InstanceReplicationTask(targetHost, Action.Cancel, appName, id) &#123;</div><div class="line">        </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> replicationClient.doString(...);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleFailure</span><span class="params">(<span class="keyword">int</span> statusCode, Object responseEntity)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">            <span class="comment">// do Something...</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;, <span class="comment">// ReplicationTask 子类</span></div><div class="line">    expiryTime</div><div class="line">)</div></pre></td></tr></table></figure><ul><li><p><code>#task(...)</code> 方法，生成同步操作任务<strong>编号</strong>。代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">taskId</span><span class="params">(String requestType, String appName, String id)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> requestType + <span class="string">'#'</span> + appName + <span class="string">'/'</span> + id;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>相同应用实例的相同同步操作使用相同任务编号</strong>。在 <a href="http://www.iocoder.cn/Eureka/batch-tasks/?self">《Eureka 源码解析 —— 任务批处理》「2. 整体流程」</a> 中，我们看到” 接收线程( Runner )合并任务，将相同任务编号的任务合并，只执行一次。 “，因此，相同应用实例的相同同步操作就能被合并，减少操作量。例如，Eureka-Server 同步某个应用实例的 Heartbeat 操作，接收同步的 Eureak-Server 挂了，一方面这个应用的这次操作会<strong>重试</strong>，另一方面，这个应用实例会发起<strong>新的</strong> Heartbeat 操作，通过任务编号合并，接收同步的 Eureka-Server 恢复后，减少收到<strong>重复积压</strong>的任务。</li></ul><ul><li>InstanceReplicationTask ，同步操作任务，在 <a href="#">「4.1.1 同步操作任务」</a> 详细解析。</li><li><code>expiryTime</code> ，任务过期时间。</li></ul></li></ul></li></ul><h3 id="4-1-1-同步操作任务"><a href="#4-1-1-同步操作任务" class="headerlink" title="4.1.1 同步操作任务"></a>4.1.1 同步操作任务</h3><p><img src="http://www.iocoder.cn/images/Eureka/2018_08_07/03.png" alt=""></p><ul><li><code>com.netflix.eureka.cluster.ReplicationTask</code> ，同步任务<strong>抽象类</strong><ul><li>点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTask.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 ReplicationTask 代码。</li><li>定义了 <code>#getTaskName()</code> <strong>抽象</strong>方法。</li><li>定义了 <code>#execute()</code> <strong>抽象</strong>方法，执行同步任务。</li><li>实现了 <code>#handleSuccess()</code> 方法，处理成功执行同步结果。</li><li>实现了 <code>#handleFailure(...)</code> 方法，处理失败执行同步结果。</li></ul></li><li><code>com.netflix.eureka.cluster.InstanceReplicationTask</code> ，同步应用实例任务<strong>抽象类</strong><ul><li>点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/InstanceReplicationTask.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 InstanceReplicationTask 代码。</li><li>实现了父类 <code>#getTaskName()</code> <strong>抽象</strong>方法。</li></ul></li><li><code>com.netflix.eureka.cluster.AsgReplicationTask</code> ，亚马逊 AWS 使用，暂时跳过。</li></ul><p>从上面 <code>PeerEurekaNode#同步操作(...)</code> 方法，<strong>全部</strong>实现了 InstanceReplicationTask 类的 <code>#execute()</code> 方法，<strong>部分</strong>重写了 <code>#handleFailure(...)</code> 方法。</p><h3 id="4-1-2-同步操作任务处理器"><a href="#4-1-2-同步操作任务处理器" class="headerlink" title="4.1.2 同步操作任务处理器"></a>4.1.2 同步操作任务处理器</h3><p><code>com.netflix.eureka.cluster.InstanceReplicationTask</code> ，实现 TaskProcessor <strong>接口</strong>，同步操作任务处理器。</p><ul><li>TaskProcessor ，在 <a href="http://www.iocoder.cn/Eureka/batch-tasks/?self">《Eureka 源码解析 —— 任务批处理》「10. 任务执行器【执行任务】」</a> 有详细解析。</li><li>点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 InstanceReplicationTask 代码。</li></ul><p><code>ReplicationTaskProcessor#process(task)</code> ，<strong>处理单任务</strong>，用于 Eureka-Server 向亚马逊 AWS 的 ASG ( <code>Autoscaling Group</code> ) 同步状态，暂时跳过，感兴趣的同学可以点击 <a href="https://github.com/YunaiV/eureka/blob/94a4a1ebd35a3350893369a05757c01b2534b702/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java#L38" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看方法代码。</p><p><code>ReplicationTaskProcessor#process(tasks)</code> ，<strong>处理批量任务</strong>，用于 Eureka-Server 集群注册信息的同步操作任务，通过调用被同步的 Eureka-Server 的 <code>peerreplication/batch/</code> 接口，一次性将批量( 多个 )的同步操作任务发起请求，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> ProcessingResult <span class="title">process</span><span class="params">(List&lt;ReplicationTask&gt; tasks)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="comment">// 创建 批量提交同步操作任务的请求对象</span></div><div class="line"> <span class="number">4</span>:     ReplicationList list = createReplicationListOf(tasks);</div><div class="line"> <span class="number">5</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">6</span>:         <span class="comment">// 发起 批量提交同步操作任务的请求</span></div><div class="line"> <span class="number">7</span>:         EurekaHttpResponse&lt;ReplicationListResponse&gt; response = replicationClient.submitBatchUpdates(list);</div><div class="line"> <span class="number">8</span>:         <span class="comment">// 处理 批量提交同步操作任务的响应</span></div><div class="line"> <span class="number">9</span>:         <span class="keyword">int</span> statusCode = response.getStatusCode();</div><div class="line"><span class="number">10</span>:         <span class="keyword">if</span> (!isSuccess(statusCode)) &#123;</div><div class="line"><span class="number">11</span>:             <span class="keyword">if</span> (statusCode == <span class="number">503</span>) &#123;</div><div class="line"><span class="number">12</span>:                 logger.warn(<span class="string">"Server busy (503) HTTP status code received from the peer &#123;&#125;; rescheduling tasks after delay"</span>, peerId);</div><div class="line"><span class="number">13</span>:                 <span class="keyword">return</span> ProcessingResult.Congestion;</div><div class="line"><span class="number">14</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">15</span>:                 <span class="comment">// Unexpected error returned from the server. This should ideally never happen.</span></div><div class="line"><span class="number">16</span>:                 logger.error(<span class="string">"Batch update failure with HTTP status code &#123;&#125;; discarding &#123;&#125; replication tasks"</span>, statusCode, tasks.size());</div><div class="line"><span class="number">17</span>:                 <span class="keyword">return</span> ProcessingResult.PermanentError;</div><div class="line"><span class="number">18</span>:             &#125;</div><div class="line"><span class="number">19</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">20</span>:             handleBatchResponse(tasks, response.getEntity().getResponseList());</div><div class="line"><span class="number">21</span>:         &#125;</div><div class="line"><span class="number">22</span>:     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"><span class="number">23</span>:         <span class="keyword">if</span> (isNetworkConnectException(e)) &#123;</div><div class="line"><span class="number">24</span>:             logNetworkErrorSample(<span class="keyword">null</span>, e);</div><div class="line"><span class="number">25</span>:             <span class="keyword">return</span> ProcessingResult.TransientError;</div><div class="line"><span class="number">26</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">27</span>:             logger.error(<span class="string">"Not re-trying this exception because it does not seem to be a network exception"</span>, e);</div><div class="line"><span class="number">28</span>:             <span class="keyword">return</span> ProcessingResult.PermanentError;</div><div class="line"><span class="number">29</span>:         &#125;</div><div class="line"><span class="number">30</span>:     &#125;</div><div class="line"><span class="number">31</span>:     <span class="keyword">return</span> ProcessingResult.Success;</div><div class="line"><span class="number">32</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 4 行 ：创建批量提交同步操作任务的请求对象( ReplicationList ) 。比较易懂，咱就不啰嗦贴代码了。<ul><li>ReplicationList ，点击 <a href="https://github.com/YunaiV/eureka/blob/94a4a1ebd35a3350893369a05757c01b2534b702/eureka-core/src/main/java/com/netflix/eureka/cluster/protocol/ReplicationList.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看类。</li><li>ReplicationInstance ，点击 <a href="https://github.com/YunaiV/eureka/blob/94a4a1ebd35a3350893369a05757c01b2534b702/eureka-core/src/main/java/com/netflix/eureka/cluster/protocol/ReplicationInstance.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看类。</li><li><code>#createReplicationListOf(...)</code> ，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java#L142" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看方法。</li><li><code>#createReplicationInstanceOf(...)</code> ，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java#L173" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看方法。</li></ul></li><li>第 7 行 ：调用 <code>JerseyReplicationClient#submitBatchUpdates(...)</code> 方法，请求 <code>peerreplication/batch/</code> 接口，一次性将批量( 多个 )的同步操作任务发起请求。<ul><li><code>JerseyReplicationClient#submitBatchUpdates(...)</code> 方法，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/transport/JerseyReplicationClient.java#L109" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看方法。</li><li>ReplicationListResponse ，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/protocol/ReplicationListResponse.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看类。</li><li>ReplicationInstanceResponse ，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/protocol/ReplicationInstanceResponse.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看类。</li></ul></li><li>第 9 至 31 行 ：处理批量提交同步操作任务的响应，在 <a href="#">「4.4 处理 Eureka-Server 同步结果」</a> 详细解析。</li></ul><h2 id="4-3-接收-Eureka-Server-同步操作"><a href="#4-3-接收-Eureka-Server-同步操作" class="headerlink" title="4.3 接收 Eureka-Server 同步操作"></a>4.3 接收 Eureka-Server 同步操作</h2><p><code>com.netflix.eureka.resources.PeerReplicationResource</code> ，同步操作任务 Resource ( Controller )。</p><p><code>peerreplication/batch/</code> 接口，映射 <code>PeerReplicationResource#batchReplication(...)</code> 方法，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Path</span>(<span class="string">"batch"</span>)</div><div class="line"> <span class="number">2</span>: <span class="meta">@POST</span></div><div class="line"> <span class="number">3</span>: <span class="function"><span class="keyword">public</span> Response <span class="title">batchReplication</span><span class="params">(ReplicationList replicationList)</span> </span>&#123;</div><div class="line"> <span class="number">4</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">5</span>:         ReplicationListResponse batchResponse = <span class="keyword">new</span> ReplicationListResponse();</div><div class="line"> <span class="number">6</span>:         <span class="comment">// 逐个同步操作任务处理，并将处理结果( ReplicationInstanceResponse ) 合并到 ReplicationListResponse 。</span></div><div class="line"> <span class="number">7</span>:         <span class="keyword">for</span> (ReplicationInstance instanceInfo : replicationList.getReplicationList()) &#123;</div><div class="line"> <span class="number">8</span>:             <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">9</span>:                 batchResponse.addResponse(dispatch(instanceInfo));</div><div class="line"><span class="number">10</span>:             &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"><span class="number">11</span>:                 batchResponse.addResponse(<span class="keyword">new</span> ReplicationInstanceResponse(Status.INTERNAL_SERVER_ERROR.getStatusCode(), <span class="keyword">null</span>));</div><div class="line"><span class="number">12</span>:                 logger.error(instanceInfo.getAction() + <span class="string">" request processing failed for batch item "</span></div><div class="line"><span class="number">13</span>:                         + instanceInfo.getAppName() + <span class="string">'/'</span> + instanceInfo.getId(), e);</div><div class="line"><span class="number">14</span>:             &#125;</div><div class="line"><span class="number">15</span>:         &#125;</div><div class="line"><span class="number">16</span>:         <span class="keyword">return</span> Response.ok(batchResponse).build();</div><div class="line"><span class="number">17</span>:     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"><span class="number">18</span>:         logger.error(<span class="string">"Cannot execute batch Request"</span>, e);</div><div class="line"><span class="number">19</span>:         <span class="keyword">return</span> Response.status(Status.INTERNAL_SERVER_ERROR).build();</div><div class="line"><span class="number">20</span>:     &#125;</div><div class="line"><span class="number">21</span>: &#125;</div><div class="line"><span class="number">22</span>: </div><div class="line"><span class="number">23</span>: <span class="function"><span class="keyword">private</span> ReplicationInstanceResponse <span class="title">dispatch</span><span class="params">(ReplicationInstance instanceInfo)</span> </span>&#123;</div><div class="line"><span class="number">24</span>:     ApplicationResource applicationResource = createApplicationResource(instanceInfo);</div><div class="line"><span class="number">25</span>:     InstanceResource resource = createInstanceResource(instanceInfo, applicationResource);</div><div class="line"><span class="number">26</span>: </div><div class="line"><span class="number">27</span>:     String lastDirtyTimestamp = toString(instanceInfo.getLastDirtyTimestamp());</div><div class="line"><span class="number">28</span>:     String overriddenStatus = toString(instanceInfo.getOverriddenStatus());</div><div class="line"><span class="number">29</span>:     String instanceStatus = toString(instanceInfo.getStatus());</div><div class="line"><span class="number">30</span>: </div><div class="line"><span class="number">31</span>:     Builder singleResponseBuilder = <span class="keyword">new</span> Builder();</div><div class="line"><span class="number">32</span>:     <span class="keyword">switch</span> (instanceInfo.getAction()) &#123;</div><div class="line"><span class="number">33</span>:         <span class="keyword">case</span> Register:</div><div class="line"><span class="number">34</span>:             singleResponseBuilder = handleRegister(instanceInfo, applicationResource);</div><div class="line"><span class="number">35</span>:             <span class="keyword">break</span>;</div><div class="line"><span class="number">36</span>:         <span class="keyword">case</span> Heartbeat:</div><div class="line"><span class="number">37</span>:             singleResponseBuilder = handleHeartbeat(serverConfig, resource, lastDirtyTimestamp, overriddenStatus, instanceStatus);</div><div class="line"><span class="number">38</span>:             <span class="keyword">break</span>;</div><div class="line"><span class="number">39</span>:         <span class="keyword">case</span> Cancel:</div><div class="line"><span class="number">40</span>:             singleResponseBuilder = handleCancel(resource);</div><div class="line"><span class="number">41</span>:             <span class="keyword">break</span>;</div><div class="line"><span class="number">42</span>:         <span class="keyword">case</span> StatusUpdate:</div><div class="line"><span class="number">43</span>:             singleResponseBuilder = handleStatusUpdate(instanceInfo, resource);</div><div class="line"><span class="number">44</span>:             <span class="keyword">break</span>;</div><div class="line"><span class="number">45</span>:         <span class="keyword">case</span> DeleteStatusOverride:</div><div class="line"><span class="number">46</span>:             singleResponseBuilder = handleDeleteStatusOverride(instanceInfo, resource);</div><div class="line"><span class="number">47</span>:             <span class="keyword">break</span>;</div><div class="line"><span class="number">48</span>:     &#125;</div><div class="line"><span class="number">49</span>:     <span class="keyword">return</span> singleResponseBuilder.build();</div><div class="line"><span class="number">50</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 7 至 15 行 ：逐个处理<strong>单个</strong>同步操作任务，并将处理结果( ReplicationInstanceResponse ) 添加到 ReplicationListResponse 。</li><li>第 23 至 50 行 ：处理<strong>单个</strong>同步操作任务，返回处理结果( ReplicationInstanceResponse )。<ul><li>第 24 至 25 行 ：创建 ApplicationResource , InstanceResource 。我们看到，实际该方法是把<strong>单个</strong>同步操作任务提交到其他 Resource ( Controller ) 处理，Eureka-Server 收到 Eureka-Client 请求响应的 Resource ( Controller ) 是<strong>相同的逻辑</strong>。</li><li>Register ：点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java#L137" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 <code>#handleRegister(...)</code> 方法。</li><li>Heartbeat ：点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java#L147" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 <code>#handleHeartbeat(...)</code> 方法。</li><li>Cancel ：点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java#L142" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 <code>#handleCancel(...)</code> 方法。</li><li>StatusUpdate ：点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java#L165" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 <code>#handleStatusUpdate(...)</code> 方法。</li><li>DeleteStatusOverride ：点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java#L170" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 <code>#handleDeleteStatusOverride(...)</code> 方法。</li></ul></li></ul><h2 id="4-4-处理-Eureka-Server-同步结果"><a href="#4-4-处理-Eureka-Server-同步结果" class="headerlink" title="4.4 处理 Eureka-Server 同步结果"></a>4.4 处理 Eureka-Server 同步结果</h2><p>😈 想想就有小激动，终于写到这里了。</p><p>接 <code>ReplicationTaskProcessor#process(tasks)</code> 方法，处理批量提交同步操作任务的响应，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> ProcessingResult <span class="title">process</span><span class="params">(List&lt;ReplicationTask&gt; tasks)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="comment">// 创建 批量提交同步操作任务的请求对象</span></div><div class="line"> <span class="number">4</span>:     ReplicationList list = createReplicationListOf(tasks);</div><div class="line"> <span class="number">5</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">6</span>:         <span class="comment">// 发起 批量提交同步操作任务的请求</span></div><div class="line"> <span class="number">7</span>:         EurekaHttpResponse&lt;ReplicationListResponse&gt; response = replicationClient.submitBatchUpdates(list);</div><div class="line"> <span class="number">8</span>:         <span class="comment">// 处理 批量提交同步操作任务的响应</span></div><div class="line"> <span class="number">9</span>:         <span class="keyword">int</span> statusCode = response.getStatusCode();</div><div class="line"><span class="number">10</span>:         <span class="keyword">if</span> (!isSuccess(statusCode)) &#123;</div><div class="line"><span class="number">11</span>:             <span class="keyword">if</span> (statusCode == <span class="number">503</span>) &#123;</div><div class="line"><span class="number">12</span>:                 logger.warn(<span class="string">"Server busy (503) HTTP status code received from the peer &#123;&#125;; rescheduling tasks after delay"</span>, peerId);</div><div class="line"><span class="number">13</span>:                 <span class="keyword">return</span> ProcessingResult.Congestion;</div><div class="line"><span class="number">14</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">15</span>:                 <span class="comment">// Unexpected error returned from the server. This should ideally never happen.</span></div><div class="line"><span class="number">16</span>:                 logger.error(<span class="string">"Batch update failure with HTTP status code &#123;&#125;; discarding &#123;&#125; replication tasks"</span>, statusCode, tasks.size());</div><div class="line"><span class="number">17</span>:                 <span class="keyword">return</span> ProcessingResult.PermanentError;</div><div class="line"><span class="number">18</span>:             &#125;</div><div class="line"><span class="number">19</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">20</span>:             handleBatchResponse(tasks, response.getEntity().getResponseList());</div><div class="line"><span class="number">21</span>:         &#125;</div><div class="line"><span class="number">22</span>:     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"><span class="number">23</span>:         <span class="keyword">if</span> (isNetworkConnectException(e)) &#123;</div><div class="line"><span class="number">24</span>:             logNetworkErrorSample(<span class="keyword">null</span>, e);</div><div class="line"><span class="number">25</span>:             <span class="keyword">return</span> ProcessingResult.TransientError;</div><div class="line"><span class="number">26</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">27</span>:             logger.error(<span class="string">"Not re-trying this exception because it does not seem to be a network exception"</span>, e);</div><div class="line"><span class="number">28</span>:             <span class="keyword">return</span> ProcessingResult.PermanentError;</div><div class="line"><span class="number">29</span>:         &#125;</div><div class="line"><span class="number">30</span>:     &#125;</div><div class="line"><span class="number">31</span>:     <span class="keyword">return</span> ProcessingResult.Success;</div><div class="line"><span class="number">32</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 10 行 ，调用 <code>#isSuccess(...)</code> 方法，判断请求是否成功，响应状态码是否在 [200, 300) 范围内。</li><li>第 11 至 13 行 ：状态码 503 ，目前 Eureka-Server 返回 503 的原因是被限流。在 <a href="http://www.iocoder.cn/Eureka/rate-limiter/?self">《Eureka 源码解析 —— 基于令牌桶算法的 RateLimiter》</a> 详细解析。<strong>该情况为瞬时错误，会重试该同步操作任务</strong>，在 <a href="http://www.iocoder.cn/Eureka/batch-tasks/?self">《Eureka 源码解析 —— 任务批处理》「3. 任务处理器」</a> 有详细解析。</li><li>第 14 至 18 行 ：非<strong>预期</strong>状态码，目前 Eureka-Server 在代码上看下来，不会返回这样的状态码。<strong>该情况为永久错误，会重试该同步操作任务</strong>，在 <a href="http://www.iocoder.cn/Eureka/batch-tasks/?self">《Eureka 源码解析 —— 任务批处理》「3. 任务处理器」</a> 有详细解析。</li><li>第 20 行 ：请求成功，调用 <code>#handleBatchResponse(...)</code> 方法，逐个处理<strong>每个</strong> ReplicationTask 和 ReplicationInstanceResponse 。<strong>这里有一点要注意下，请求成功指的是整个请求成功，实际每个 ReplicationInstanceResponse 可能返回的状态码不在 [200, 300) 范围内</strong>。该方法下文详细解析。</li><li><p>第 23 至 25 行 ：请求发生网络异常，例如网络超时，打印网络异常日志。目前日志的打印为部分采样，条件为网络发生异常每间隔 10 秒打印一条，避免网络发生异常打印超级大量的日志。<strong>该情况为永久错误，会重试该同步操作任务</strong>，在 <a href="http://www.iocoder.cn/Eureka/batch-tasks/?self">《Eureka 源码解析 —— 任务批处理》「3. 任务处理器」</a> 有详细解析。</p><ul><li><code>#isNetworkConnectException(...)</code> ，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java#L163" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看方法。</li><li><code>#logNetworkErrorSample(...)</code> ，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java#L103" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看方法。</li></ul></li><li><p>第 26 至 29 行 ：非<strong>预期</strong>异常，目前 Eureka-Server 在代码上看下来，不会抛出这样的异常。<strong>该情况为永久错误，会重试该同步操作任务</strong>，在 <a href="http://www.iocoder.cn/Eureka/batch-tasks/?self">《Eureka 源码解析 —— 任务批处理》「3. 任务处理器」</a> 有详细解析。</p></li></ul><hr><p><code>#handleBatchResponse(...)</code> 方法，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBatchResponse</span><span class="params">(List&lt;ReplicationTask&gt; tasks, List&lt;ReplicationInstanceResponse&gt; responseList)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (tasks.size() != responseList.size()) &#123;</div><div class="line">       <span class="comment">// This should ideally never happen unless there is a bug in the software.</span></div><div class="line">       logger.error(<span class="string">"Batch response size different from submitted task list (&#123;&#125; != &#123;&#125;); skipping response analysis"</span>, responseList.size(), tasks.size());</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks.size(); i++) &#123;</div><div class="line">       handleBatchResponse(tasks.get(i), responseList.get(i));</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBatchResponse</span><span class="params">(ReplicationTask task, ReplicationInstanceResponse response)</span> </span>&#123;</div><div class="line">   <span class="comment">// 执行成功</span></div><div class="line">   <span class="keyword">int</span> statusCode = response.getStatusCode();</div><div class="line">   <span class="keyword">if</span> (isSuccess(statusCode)) &#123;</div><div class="line">       task.handleSuccess();</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// 执行失败</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       task.handleFailure(response.getStatusCode(), response.getResponseEntity());</div><div class="line">   &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">       logger.error(<span class="string">"Replication task "</span> + task.getTaskName() + <span class="string">" error handler failure"</span>, e);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p><code>ReplicationTask#handleSuccess()</code> 方法，无任务同步操作任务重写，是个<strong>空方法</strong>，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// ReplicationTask.java</div><div class="line">public void handleSuccess() &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p><code>ReplicationTask#handleFailure()</code> 方法，有<strong>两个</strong>同步操作任务重写：</p><ul><li><p>Cancel ：当 Eureka-Server 不存在下线的应用实例时，返回 404 状态码，此时打印错误日志，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// PeerEurekaNode#cancel(...)</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleFailure</span><span class="params">(<span class="keyword">int</span> statusCode, Object responseEntity)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">    <span class="keyword">super</span>.handleFailure(statusCode, responseEntity);</div><div class="line">    <span class="keyword">if</span> (statusCode == <span class="number">404</span>) &#123;</div><div class="line">        logger.warn(<span class="string">"&#123;&#125;: missing entry."</span>, getTaskName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul></li><li><p>Heartbeat ：情况较为复杂，我们换一行继续说，避免排版有问题，影响阅读。</p></li></ul></li></ul><p>噔噔噔恰，本文的重要头戏来啦！Last But Very Importment ！！！</p><p>Eureka-Server 是允许<strong>同一时刻</strong>允许在任意节点被 Eureka-Client 发起<strong>写入</strong>相关的操作，网络是不可靠的资源，Eureka-Client 可能向一个 Eureka-Server 注册成功，但是网络波动，导致 Eureka-Client 误以为失败，此时恰好 Eureka-Client 变更了应用实例的状态，重试向另一个 Eureka-Server 注册，那么两个 Eureka-Server 对该应用实例的状态产生冲突。</p><p>再例如…… 我们不要继续举例子，网络波动真的很复杂。我们来看看 Eureka 是怎么处理的。</p><p>应用实例( InstanceInfo ) 的 <code>lastDirtyTimestamp</code> 属性，使用<strong>时间戳</strong>，表示应用实例的<strong>版本号</strong>，当请求方( 不仅仅是 Eureka-Client ，也可能是同步注册操作的 Eureka-Server ) 向 Eureka-Server 发起注册时，若 Eureka-Server 已存在拥有更大 <code>lastDirtyTimestamp</code> 该实例( <strong>相同应用并且相同应用实例编号被认为是相同实例</strong> )，则请求方注册的应用实例( InstanceInfo ) 无法覆盖注册此 Eureka-Server 的该实例( 见 <code>AbstractInstanceRegistry#register(...)</code> 方法 )。例如我们上面举的例子，第一个 Eureka-Server 向 第二个 Eureka-Server 同步注册应用实例时，不会注册覆盖，反倒是第二个 Eureka-Server 同步注册应用到第一个 Eureka-Server ，注册覆盖成功，因为 <code>lastDirtyTimestamp</code> ( 应用实例状态变更时，可以设置 <code>lastDirtyTimestamp</code> 为当前时间，见 <code>ApplicationInfoManager#setInstanceStatus(status)</code> 方法 )。</p><p>但是光靠<strong>注册</strong>请求判断 <code>lastDirtyTimestamp</code> 显然是不够的，因为网络异常情况下时，同步操作任务多次执行失败到达过期时间后，此时在 Eureka-Server 集群同步起到最终一致性<strong>最最最</strong>关键性出现了：Heartbeat 。因为 Heartbeat 会周期性的执行，通过它一方面可以判断 Eureka-Server 是否存在心跳对应的应用实例，另外一方面可以比较应用实例的 <code>lastDirtyTimestamp</code> 。当满足下面任意条件，Eureka-Server 返回 404 状态码：</p><ul><li>1）Eureka-Server 应用实例不存在，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/registry/AbstractInstanceRegistry.java#L438" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看触发条件代码位置。</li><li>2）Eureka-Server 应用实例状态为 <code>UNKNOWN</code>，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/registry/AbstractInstanceRegistry.java#L450" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看触发条件代码位置。为什么会是 <code>UNKNOWN</code> ，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/?self">《Eureka 源码解析 —— 应用实例注册发现（八）之覆盖状态》「 4.3 续租场景」</a> 有详细解析。</li><li><strong>3）</strong>请求的 <code>lastDirtyTimestamp</code> 更大，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java#L306" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看触发条件代码位置。</li></ul><p>请求方接收到 404 状态码返回后，<strong>认为 Eureka-Server 应用实例实际是不存在的</strong>，重新发起应用实例的注册。以本文的 Heartbeat 为例子，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// PeerEurekaNode#heartbeat(...)</span></div><div class="line">  <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line">  <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleFailure</span><span class="params">(<span class="keyword">int</span> statusCode, Object responseEntity)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">  <span class="number">3</span>:     <span class="keyword">super</span>.handleFailure(statusCode, responseEntity);</div><div class="line">  <span class="number">4</span>:     <span class="keyword">if</span> (statusCode == <span class="number">404</span>) &#123;</div><div class="line">  <span class="number">5</span>:         logger.warn(<span class="string">"&#123;&#125;: missing entry."</span>, getTaskName());</div><div class="line">  <span class="number">6</span>:         <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</div><div class="line">  <span class="number">7</span>:             logger.warn(<span class="string">"&#123;&#125;: cannot find instance id &#123;&#125; and hence replicating the instance with status &#123;&#125;"</span>,</div><div class="line">  <span class="number">8</span>:                     getTaskName(), info.getId(), info.getStatus());</div><div class="line">  <span class="number">9</span>:             register(info);</div><div class="line"> <span class="number">10</span>:         &#125;</div><div class="line"> <span class="number">11</span>:     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config.shouldSyncWhenTimestampDiffers()) &#123;</div><div class="line"> <span class="number">12</span>:         InstanceInfo peerInstanceInfo = (InstanceInfo) responseEntity;</div><div class="line"> <span class="number">13</span>:         <span class="keyword">if</span> (peerInstanceInfo != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">14</span>:             syncInstancesIfTimestampDiffers(appName, id, info, peerInstanceInfo);</div><div class="line"> <span class="number">15</span>:         &#125;</div><div class="line"> <span class="number">16</span>:     &#125;</div><div class="line"> <span class="number">17</span>: &#125;</div></pre></td></tr></table></figure><ul><li><p>第 4 至 10 行 ：接收到 404 状态码，调用 <code>#register(...)</code> 方法，向该被心跳同步操作失败的 Eureka-Server 发起注册<strong>本地的应用实例</strong>的请求。</p><ul><li>上述 <strong>3）</strong> ，会使用请求参数 <code>overriddenStatus</code> 存储到 Eureka-Server 的应用实例覆盖状态集合( <code>AbstractInstanceRegistry.overriddenInstanceStatusMap</code> )，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java#L123" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看触发条件代码位置。</li></ul></li><li><p>第 11 至 16 行 ：恰好是 <strong>3）</strong> 反过来的情况，本地的应用实例的 <code>lastDirtyTimestamp</code> 小于 Eureka-Server 该应用实例的，此时 Eureka-Server 返回 409 状态码，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java#L314" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看触发条件代码位置。调用 <code>#syncInstancesIfTimestampDiffers()</code> 方法，覆盖注册本地应用实例，点击 <a href="https://github.com/YunaiV/eureka/blob/7f868f9ca715a8862c0c10cac04e238bbf371db0/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java#L387" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看方法。</p></li></ul><p>OK，撒花！记住：Eureka 通过 Heartbeat 实现 Eureka-Server 集群同步的最终一致性。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>写的比较嗨皮，所以就送胖友一只胖友</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_08_07/04.png" alt=""></p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p><p>以下是草稿，可以凑合看</p><p>eureka server 集群假定是 s1 s2</p><p>1）client 向 s1 注册，有一个 lastDirtyTime ，正常情况下成功， s1 会向 s2 同步<br>2）client 向 s1 注册（成功，但是网络波动），然后 client 发生状态的变化，lastDirtyTime 变化，向 s2 注册。<br>这个时候，s1 s2 是冲突的，但是他们会互相同步，实际 s2 =&gt; s1 的注册会真正成功，s1 =&gt; s2 的注册不会返回失败，但是实际 s2 处理的时候，用的是自身的。</p><p>心跳只是最终去校验。</p><p>理论来说，心跳不应该带 lastDirtyTime 参数。带的原因就是为了做固定周期的比较。</p><p>最优解是 注册 就处理掉数据不一致<br>次优解是 心跳 处理掉数据不一致</p><p>如果在类比，</p><p>注册，相当于 insertOrUpdate<br>心跳，附加了校验是否要发起【注册】</p></div><footer class="article-footer clearfix"><div class="article-categories"><span></span> <a class="article-category-link" href="/categories/Eureka/">Eureka</a></div><div class="article-share" id="share"><div data-url="http://www.iocoder.cn/Eureka/server-cluster/" data-title="Eureka 源码解析 —— Eureka-Server 集群同步 | 芋道源码 —— 纯源码解析博客" data-tsina="null" class="share clearfix"></div></div></footer></article><nav class="article-nav clearfix"><div class="prev"><a href="/Eureka/rate-limiter/" title="Eureka 源码解析 —— 基于令牌桶算法的 RateLimiter"><strong>PREVIOUS:</strong><br><span>Eureka 源码解析 —— 基于令牌桶算法的 RateLimiter</span></a></div><div class="next"><a href="/Eureka/transport/" title="Eureka 源码解析 —— 网络通信"><strong>NEXT:</strong><br><span>Eureka 源码解析 —— 网络通信</span></a></div></nav></div><div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div><div id="toc" class="toc-aside"><strong class="toc-title">文章目录</strong><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-概述"><span class="toc-number">1.</span> <span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-集群节点初始化与更新"><span class="toc-number">2.</span> <span class="toc-text">2. 集群节点初始化与更新</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-集群节点启动"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 集群节点启动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-更新集群节点信息"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 更新集群节点信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-集群节点"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 集群节点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-获取初始注册信息"><span class="toc-number">3.</span> <span class="toc-text">3. 获取初始注册信息</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-同步注册信息"><span class="toc-number">4.</span> <span class="toc-text">4. 同步注册信息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-同步操作类型"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 同步操作类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-发起-Eureka-Server-同步操作"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 发起 Eureka-Server 同步操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-同步操作任务"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.1.1 同步操作任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-同步操作任务处理器"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.1.2 同步操作任务处理器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-接收-Eureka-Server-同步操作"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 接收 Eureka-Server 同步操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-处理-Eureka-Server-同步结果"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 处理 Eureka-Server 同步结果</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#666-彩蛋"><span class="toc-number">5.</span> <span class="toc-text">666. 彩蛋</span></a></li></ol></div><div id="asidepart"><aside class="clearfix"><div id="authorInfo"><div><img width="100%" src="/images/common/wechat_mp_2017_07_31_bak.jpg"></div><div class="social-list"></div></div><div class="categorieslist"><p class="asidetitle">微信公众号福利：芋道源码</p><ul><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">0. 阅读源码葵花宝典</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">1. RocketMQ / MyCAT / Sharding-JDBC 详细中文注释源码</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">2. 您对于源码的疑问每条留言都将得到认真回复</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">3. 新的源码解析文章实时收到通知，每周六十点更新</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">4. 认真的源码交流微信群</a></li></ul></div><div class="categorieslist"><p class="asidetitle">分类</p><ul><li><a href="/categories/Docker/" title="Docker">Docker<sup>2</sup></a></li><li><a href="/categories/Dubbo/" title="Dubbo">Dubbo<sup>1</sup></a></li><li><a href="/categories/Elastic-Job-Cloud/" title="Elastic-Job-Cloud">Elastic-Job-Cloud<sup>6</sup></a></li><li><a href="/categories/Elastic-Job-Lite/" title="Elastic-Job-Lite">Elastic-Job-Lite<sup>16</sup></a></li><li><a href="/categories/Eureka/" title="Eureka">Eureka<sup>23</sup></a></li><li><a href="/categories/Happylifeplat-TCC/" title="Happylifeplat-TCC">Happylifeplat-TCC<sup>1</sup></a></li><li><a href="/categories/Hystrix/" title="Hystrix">Hystrix<sup>9</sup></a></li><li><a href="/categories/JUC/" title="JUC">JUC<sup>1</sup></a></li><li><a href="/categories/MyCAT/" title="MyCAT">MyCAT<sup>9</sup></a></li><li><a href="/categories/Nginx/" title="Nginx">Nginx<sup>1</sup></a></li><li><a href="/categories/RocketMQ/" title="RocketMQ">RocketMQ<sup>14</sup></a></li><li><a href="/categories/RxJava/" title="RxJava">RxJava<sup>5</sup></a></li><li><a href="/categories/Sharding-JDBC/" title="Sharding-JDBC">Sharding-JDBC<sup>18</sup></a></li><li><a href="/categories/SkyWalking/" title="SkyWalking">SkyWalking<sup>34</sup></a></li><li><a href="/categories/Spring/" title="Spring">Spring<sup>1</sup></a></li><li><a href="/categories/Spring-Cloud-Gateway/" title="Spring-Cloud-Gateway">Spring-Cloud-Gateway<sup>24</sup></a></li><li><a href="/categories/Spring-MVC/" title="Spring-MVC">Spring-MVC<sup>1</sup></a></li><li><a href="/categories/Spring-Security/" title="Spring-Security">Spring-Security<sup>1</sup></a></li><li><a href="/categories/TCC-Transaction/" title="TCC-Transaction">TCC-Transaction<sup>7</sup></a></li><li><a href="/categories/TiKV/" title="TiKV">TiKV<sup>2</sup></a></li><li><a href="/categories/工作内推/" title="工作内推">工作内推<sup>4</sup></a></li><li><a href="/categories/技术杂文/" title="技术杂文">技术杂文<sup>5</sup></a></li><li><a href="/categories/芋道源码的周天/" title="芋道源码的周天">芋道源码的周天<sup>1</sup></a></li></ul></div></aside></div></div><footer><div id="footer"><img src="http://www.iocoder.cn/images/common/wechat_mp_simple.png" style="display:none"><p class="copyright">© 2018 <a href="http://www.iocoder.cn" target="_blank" title="芋道源码">芋道源码</a> && <span style="display:inline" id="busuanzi_container_site_uv">总访客数 <span id="busuanzi_value_site_uv" font="微软雅黑"></span> 次</span> && <span style="display:inline" id="busuanzi_container_site_pv">总访问量 <span id="busuanzi_value_site_pv" font="微软雅黑"></span> 次</span></p></div><div class="copyright">沪ICP备17037075号-1</div></footer><script src="/js/jquery-2.1.0.min.js"></script><script type="text/javascript">$(document).ready(function(){function e(){"number"==typeof window.innerWidth?n=window.innerWidth:document.documentElement&&document.documentElement.clientWidth&&(n=document.documentElement.clientWidth)}$(".navbar").click(function(){$("header nav").toggleClass("shownav")});var n=0,s=$("#main"),a=$("#asidepart"),o=$(".closeaside"),d=$(".openaside");$(window).resize(function(){e(),n>=1024?$("header nav").removeClass("shownav"):(s.removeClass("moveMain"),a.css("display","block").removeClass("fadeOut"),d.css("display","none"),$("#toc.toc-aside").css("display","none"))}),o.click(function(){a.addClass("fadeOut").css("display","none"),d.css("display","block").addClass("fadeIn"),s.addClass("moveMain")}),d.click(function(){d.css("display","none").removeClass("beforeFadeIn"),a.css("display","block").removeClass("fadeOut").addClass("fadeIn"),s.removeClass("moveMain")}),$(window).scroll(function(){d.css("top",Math.max(80,260-$(this).scrollTop()))})})</script><script type="text/javascript">$(document).ready(function(){var a=$(".article-content>iframe"),t=$(".article-content>embed"),n=$("#toc");$("article h2");ah=$("article h2"),ta=$("#toc.toc-aside"),o=$(".openaside"),c=$(".closeaside"),a.length>0&&a.wrap('<div class="video-container" />'),t.length>0&&t.wrap('<div class="video-container" />'),0==ah.length?n.css("display","none"):(c.click(function(){ta.css("display","block").addClass("fadeIn")}),o.click(function(){ta.css("display","none")}),$(window).scroll(function(){ta.css("top",Math.max(140,320-$(this).scrollTop()))}))})</script><script type="text/javascript">$(document).ready(function(){var t=$(".share"),a=t.attr("data-url"),e=encodeURIComponent(a),r=['<a href="#" class="overlay" id="qrcode"></a>','<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url='+e+'"/></div>','<a href="#textlogo" class="article-back-to-top" title="Top"></a>','<a href="https://www.facebook.com/sharer.php?u='+e+'" class="article-share-facebook" target="_blank" title="Facebook"></a>','<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>','<a href="https://twitter.com/intent/tweet?url='+e+'" class="article-share-twitter" target="_blank" title="Twitter"></a>','<a href="http://service.weibo.com/share/share.php?title='+t.attr("data-title")+"&url="+e+"&ralateUid="+t.attr("data-tsina")+'&searchPic=true&style=number" class="article-share-weibo" target="_blank" title="Weibo"></a>','<span title="Share to"></span>'].join("");t.append(r),$(".article-share-qrcode").click(function(){var t=$("#qrcode-pic").attr("data-src");$("#qrcode-pic").attr("src",t),$("#qrcode-pic").load(function(){$(".qrcode strong").text(" ")})})})</script><link rel="stylesheet" href="/alert/css/alert.css"><script src="/alert/js/alert.js"></script><script src="/js/jquery.cookie.js"></script><script src="/js/util.js"></script><script type="text/javascript">!function(e,a,t,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=a.createElement(t),s=a.getElementsByTagName(t)[0],o.async=1,o.src="//www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s)}(window,document,"script",0,"ga"),ga("create","UA-107572620-1","auto"),ga("send","pageview")</script></body>