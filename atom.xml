<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>芋道源码 —— 纯源码解析BLOG</title>
  
  <subtitle>愿半生编码，如一生老友！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.iocoder.cn/"/>
  <updated>2017-12-27T12:55:08.000Z</updated>
  <id>http://www.iocoder.cn/</id>
  
  <author>
    <name>芋道源码</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SkyWalking 源码分析 —— Agent DictionaryManager 字典管理</title>
    <link href="http://www.iocoder.cn/SkyWalking/agent-dictionary/"/>
    <id>http://www.iocoder.cn/SkyWalking/agent-dictionary/</id>
    <published>2020-09-27T16:00:00.000Z</published>
    <updated>2017-12-27T12:55:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/agent-dictionary/">http://www.iocoder.cn/SkyWalking/agent-dictionary/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-dictionary/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-dictionary/">2. Collector 同步相关 API</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-dictionary/">2.1 应用的同步 API</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-dictionary/">2.2 操作的同步 API</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-dictionary/">3. Agent 调用同步 API</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-dictionary/">3.1 DictionaryManager</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-dictionary/">3.2 PossibleFound</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-dictionary/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Agent DictionaryManager 字典管理</strong>。先来简单了解下字典的定义和用途：</p><ul><li>字典实际上是一个 Map 映射。目前 Agent 上有两种字典：应用编码与应用编号的映射，操作名与操作编号的映射。<ul><li>应用的定义：例如，Tomcat 启动的应用，或者程序里访问的 MongoDB 、MySQL 都可以认为是应用。</li><li>操作的定义：例如，访问的 URL 地址，Mongo 的执行操作。</li></ul></li><li>Agent 在每次上传调用链路 Segment 给 Collector 时，Segment 里面需要包含应用和操作相关信息。考虑到减少网络流量，应用编号少于应用编号，操作编号少于操作名。</li></ul><p>Agent 字典，会<strong>定时</strong>从 Collector 【<strong>同步</strong>】<strong>需要</strong>( <em>需要的定义，下文代码会看到</em> )的字典。</p><p>下面，我们分成两个小节，分别从 API 的<strong>实现</strong>与<strong>调用</strong>，分享代码的具体实现。</p><h1 id="2-Collector-同步相关-API"><a href="#2-Collector-同步相关-API" class="headerlink" title="2. Collector 同步相关 API"></a>2. Collector 同步相关 API</h1><p>Collector 同步相关 API 相关有四个接口：</p><ul><li>2.1 应用的同步 API</li><li>2.2 操作的同步 API</li></ul><p>API 处理的流程大体如下：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_25/01.png" alt=""></p><h2 id="2-1-应用的同步-API"><a href="#2-1-应用的同步-API" class="headerlink" title="2.1 应用的同步 API"></a>2.1 应用的同步 API</h2><p>应用的同步 API ，实际使用的是<strong>应用的注册 API</strong>，在 <a href="http://www.iocoder.cn/SkyWalking/register/?self">「2.1 应用的注册 API」</a> 有详细解析。</p><h2 id="2-2-操作的同步-API"><a href="#2-2-操作的同步-API" class="headerlink" title="2.2 操作的同步 API"></a>2.2 操作的同步 API</h2><p>我们先来看看 API 的定义，<a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-network/src/main/proto/DiscoveryService.proto#L11" rel="external nofollow noopener noreferrer" target="_blank"><code>DiscoveryService</code></a> ，如下图所示：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_28/01.png" alt=""></p><p>整体代码和 <a href="#">「2.1 应用的同步 API」</a> 非常相似，所以本小节，更多的是提供代码的链接地址。</p><h3 id="2-2-1-ServiceNameDiscoveryServiceHandler-discovery-…"><a href="#2-2-1-ServiceNameDiscoveryServiceHandler-discovery-…" class="headerlink" title="2.2.1 ServiceNameDiscoveryServiceHandler#discovery(…)"></a>2.2.1 ServiceNameDiscoveryServiceHandler#discovery(…)</h3><p><a href="https://github.com/YunaiV/skywalking/blob/0830d985227c42f0e0f3787ebc99a2b197486b69/apm-collector/apm-collector-agent-grpc/collector-agent-grpc-provider/src/main/java/org/skywalking/apm/collector/agent/grpc/handler/ServiceNameDiscoveryServiceHandler.java#L49" rel="external nofollow noopener noreferrer" target="_blank"><code>ServiceNameDiscoveryServiceHandler#discovery(ServiceNameCollection, StreamObserver&lt;ServiceNameMappingCollection&gt;)</code></a>，根据操作名数组，查找操作编号数组。</p><h3 id="2-2-2-IServiceNameService-getOrCreate-…"><a href="#2-2-2-IServiceNameService-getOrCreate-…" class="headerlink" title="2.2.2 IServiceNameService#getOrCreate(…)"></a>2.2.2 IServiceNameService#getOrCreate(…)</h3><p><code>org.skywalking.apm.collector.agent.stream.service.register.IServiceNameService</code> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> 接口，操作名服务接口。</p><ul><li>定义了 <a href="https://github.com/YunaiV/skywalking/blob/a4db2c4dd5e2adc861e7fb9e9b7b7ffdc57dfb88/apm-collector/apm-collector-agent-stream/collector-agent-stream-define/src/main/java/org/skywalking/apm/collector/agent/stream/service/register/IInstanceIDService.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>#getOrCreate(applicationId, serviceName)</code></a> <strong>接口</strong>方法，根据应用编号 + 操作名字，获取或创建操作名( ServiceName )，并获得操作编号。</li></ul><p><code>org.skywalking.apm.collector.agent.stream.worker.register.ServiceNameService</code> ，实现 IServiceNameService 接口，操作名服务实现类。</p><ul><li>实现了 <a href="https://github.com/YunaiV/skywalking/blob/0830d985227c42f0e0f3787ebc99a2b197486b69/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ServiceNameService.java#L64" rel="external nofollow noopener noreferrer" target="_blank"><code>#getOrCreate(applicationId, serviceName)</code></a> 方法。</li></ul><h3 id="2-2-3-Graph-start-ServiceName"><a href="#2-2-3-Graph-start-ServiceName" class="headerlink" title="2.2.3 Graph#start(ServiceName)"></a>2.2.3 Graph#start(ServiceName)</h3><p>在 <a href="https://github.com/YunaiV/skywalking/blob/a9873b9bf07882746bd30f29b3c64f4b44887bf2/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/graph/RegisterStreamGraph.java#L79" rel="external nofollow noopener noreferrer" target="_blank"><code>#createServiceNameRegisterGraph()</code></a> 方法中，我们可以看到 ServiceName 对应的 <code>Graph&lt;ServiceName&gt;</code> 对象的创建。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/a9873b9bf07882746bd30f29b3c64f4b44887bf2/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ServiceNameRegisterRemoteWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.register.ServiceNameRegisterRemoteWorker</code></a> ，继承 AbstractRemoteWorker 抽象类，操作名注册远程 Worker 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/0830d985227c42f0e0f3787ebc99a2b197486b69/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ServiceNameRegisterSerialWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.register.ServiceNameRegisterSerialWorker</code></a> ，继承 AbstractLocalAsyncWorker 抽象类，异步保存应用 Worker 。<ul><li>相同于 Application ，ServiceName 的操作编号，从 <code>&quot;1&quot;</code> <strong>双向</strong>递增。 </li><li><a href="https://github.com/YunaiV/skywalking/blob/a4db2c4dd5e2adc861e7fb9e9b7b7ffdc57dfb88/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/ServiceNameEsRegisterDAO.java#L52" rel="external nofollow noopener noreferrer" target="_blank">ServiceNameEsRegisterDAO#save(ServiceName)</a></li></ul></li></ul><h3 id="2-2-4-ServiceName"><a href="#2-2-4-ServiceName" class="headerlink" title="2.2.4 ServiceName"></a>2.2.4 ServiceName</h3><p><a href="https://github.com/YunaiV/skywalking/blob/a9873b9bf07882746bd30f29b3c64f4b44887bf2/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/register/ServiceName.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.register.ServiceName</code></a> ，操作名。例如记录在 ES 如下图：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_28/02.png" alt=""></p><h1 id="3-Agent-调用同步-API"><a href="#3-Agent-调用同步-API" class="headerlink" title="3. Agent 调用同步 API"></a>3. Agent 调用同步 API</h1><p>在 <a href="#">《SkyWalking 源码分析 —— 应用于应用实例的注册》「3. Agent 调用注册 API」</a> 一文中，在 <a href="https://github.com/YunaiV/skywalking/blob/bb8cb1b7dcb428c161f225f0b5d57441105f84c0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/AppAndServiceRegisterClient.java#L170" rel="external nofollow noopener noreferrer" target="_blank">【第 170 至 173 行】的代码</a>，我们可以看到，AppAndServiceRegisterClient 会定时从 Collector 同步所有字典信息。</p><h2 id="3-1-DictionaryManager"><a href="#3-1-DictionaryManager" class="headerlink" title="3.1 DictionaryManager"></a>3.1 DictionaryManager</h2><p><a href="https://github.com/YunaiV/skywalking/blob/0830d985227c42f0e0f3787ebc99a2b197486b69/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/dictionary/DictionaryManager.java#L27" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.dictionary.DictionaryManager</code></a> ，字典管理器。目前管理有两种字典：</p><ul><li>ApplicationDictionary</li><li>OperationNameDictionary</li></ul><h3 id="3-1-ApplicationDictionary"><a href="#3-1-ApplicationDictionary" class="headerlink" title="3.1 ApplicationDictionary"></a>3.1 ApplicationDictionary</h3><p><code>org.skywalking.apm.agent.core.dictionary.ApplicationDictionary</code> ，应用字典。</p><ul><li><code>INSTANCE</code> 枚举属性，单例。</li><li><code>applicationDictionary</code> 属性，应用编码与应用编号的映射。</li><li><code>unRegisterApplications</code> 属性，未知应用编码集合。Agent 会定时从 Collector 同步。这也是文章开头说的，“<strong>需要</strong>”的定义。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/0830d985227c42f0e0f3787ebc99a2b197486b69/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/dictionary/ApplicationDictionary.java#L56" rel="external nofollow noopener noreferrer" target="_blank"><code>#find(applicationCode)</code></a> 方法，根据应用编码，查询应用编号。</p><ul><li>第 57 行：根据应用编码，从 <code>applicationDictionary</code> 中，查询应用编号。</li><li>第 58 至 59 行：当应用编号查找到时，返回 Found 。Found 会在下文详细解析。</li><li>第 61 至 64 行：当应用编号查找不到时，添加到 <code>unRegisterApplications</code> 中，返回 NotFound 。NotFound 会在下文详细解析。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/0830d985227c42f0e0f3787ebc99a2b197486b69/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/dictionary/ApplicationDictionary.java#L74" rel="external nofollow noopener noreferrer" target="_blank"><code>#syncRemoteDictionary(ApplicationRegisterServiceGrpc.ApplicationRegisterServiceBlockingStub)</code></a> 方法，调用 <a href="#">「2.1 应用的同步 API」</a> ，从 Collector 同步 <code>unRegisterApplications</code> 对应的应用编号集合。</p><h3 id="3-2-OperationNameDictionary"><a href="#3-2-OperationNameDictionary" class="headerlink" title="3.2 OperationNameDictionary"></a>3.2 OperationNameDictionary</h3><p><code>org.skywalking.apm.agent.core.dictionary.OperationNameDictionary</code> ，操作名字典。</p><p>和 ApplicationDictionary 基本类似，胖友点击 <a href="https://github.com/YunaiV/skywalking/blob/0830d985227c42f0e0f3787ebc99a2b197486b69/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/dictionary/OperationNameDictionary.java" rel="external nofollow noopener noreferrer" target="_blank">代码</a> ，自己阅读理解。</p><h1 id="3-2-PossibleFound"><a href="#3-2-PossibleFound" class="headerlink" title="3.2 PossibleFound"></a>3.2 PossibleFound</h1><p>在分享 PossibleFound 之前，我们先来看一段代码，了解该类的意图：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_28/03.png" alt=""></p><ul><li>我们在使用 <code>XXXXDictionary#find(xxx)</code> 方法时，返回的会是 Found 或者 NotFound 。这两个类本身是<strong>互斥</strong>的，并且继承 PossibleFound 。在 PossibleFound 提供 <code>#doInCondition(method01, method02)</code> 方法，<strong>优雅</strong>的处理两种情况。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/0830d985227c42f0e0f3787ebc99a2b197486b69/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/dictionary/PossibleFound.java#L26" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.dictionary.PossibleFound</code></a> ，<strong>抽象类</strong>，代码如下：</p><ul><li><code>found</code> 属性，是否找到。</li><li><code>value</code> 属性，找到的结果。</li><li><a href="https://github.com/YunaiV/skywalking/blob/0830d985227c42f0e0f3787ebc99a2b197486b69/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/dictionary/Found.java#L26" rel="external nofollow noopener noreferrer" target="_blank">org.skywalking.apm.agent.core.dictionary.Found</a> 实现 PossibleFound 类，<code>found = true</code> 并且 <code>value</code> 为找到的值。</li><li><a href="https://github.com/YunaiV/skywalking/blob/0830d985227c42f0e0f3787ebc99a2b197486b69/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/dictionary/NotFound.java#L26" rel="external nofollow noopener noreferrer" target="_blank">org.skywalking.apm.agent.core.dictionary.NotFound</a> 实现 PossibleFound 类，<code>found = false</code> 并且 <code>value</code> 不赋值。</li><li><a href="https://github.com/YunaiV/skywalking/blob/0830d985227c42f0e0f3787ebc99a2b197486b69/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/dictionary/PossibleFound.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#doInCondition(Found, NotFound)</code></a> 方法，根据查找结果，执行不同的逻辑，【无返回】。<ul><li>第一个参数，<a href="https://github.com/YunaiV/skywalking/blob/0830d985227c42f0e0f3787ebc99a2b197486b69/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/dictionary/PossibleFound.java#L72" rel="external nofollow noopener noreferrer" target="_blank"><code>PossibleFound.Found</code></a> 接口，Found 时的处理逻辑接口。</li><li>第二个参数，<a href="https://github.com/YunaiV/skywalking/blob/0830d985227c42f0e0f3787ebc99a2b197486b69/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/dictionary/PossibleFound.java#L79" rel="external nofollow noopener noreferrer" target="_blank"><code>PossibleFound.NotFound</code></a> 接口，NotFound 时的处理逻辑接口。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/0830d985227c42f0e0f3787ebc99a2b197486b69/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/dictionary/PossibleFound.java#L61" rel="external nofollow noopener noreferrer" target="_blank"><code>#doInCondition(FoundAndObtain, NotFoundAndObtain)</code></a> 方法，根据查找结果，执行不同的逻辑，【有返回】。<ul><li>第一个参数，<a href="https://github.com/YunaiV/skywalking/blob/0830d985227c42f0e0f3787ebc99a2b197486b69/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/dictionary/PossibleFound.java#L86" rel="external nofollow noopener noreferrer" target="_blank"><code>PossibleFound.FoundAndObtain</code></a> 接口，Found 时的处理逻辑接口。</li><li>第二个参数，<a href="https://github.com/YunaiV/skywalking/blob/0830d985227c42f0e0f3787ebc99a2b197486b69/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/dictionary/PossibleFound.java#L93" rel="external nofollow noopener noreferrer" target="_blank"><code>PossibleFound.NotFoundAndObtain</code></a> 接口，NotFound 时的处理逻辑接口。</li></ul></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>写水文，好枯燥。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_28/04.png" alt=""></p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注&lt;strong&gt;微信公众号：【芋道源码】&lt;/strong&gt;
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— 应用于应用实例的注册</title>
    <link href="http://www.iocoder.cn/SkyWalking/register/"/>
    <id>http://www.iocoder.cn/SkyWalking/register/</id>
    <published>2020-09-24T16:00:00.000Z</published>
    <updated>2017-12-28T00:56:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/register/">http://www.iocoder.cn/SkyWalking/register/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/register/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/register/">2. Collector 注册相关 API</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/register/">2.1 应用的注册 API</a></li><li><a href="http://www.iocoder.cn/SkyWalking/register/">2.2 应用实例的正常注册 API</a></li><li><a href="http://www.iocoder.cn/SkyWalking/register/">2.3 应用实例的恢复注册 API</a></li><li><a href="http://www.iocoder.cn/SkyWalking/register/">2.4 应用实例的心跳 API</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/register/">3. Agent 调用注册 API</a></li><li><a href="http://www.iocoder.cn/SkyWalking/register/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>应用与应用实例的注册</strong>。先来简单了解下注册的整体流程：</p><ul><li>应用启动，Agent 向 Collector 注册<strong>应用</strong>。</li><li>注册应用成功后，Agent 向 Collector 注册应用<strong>实例</strong>。</li></ul><p>下面，我们分成两个小节，分别从 API 的<strong>实现</strong>与<strong>调用</strong>，分享代码的具体实现。</p><blockquote><p>友情提示：推荐阅读 <a href="https://github.com/apache/incubator-skywalking/blob/master/docs/cn/How-to-communicate-with-the-collector-CN.md" rel="external nofollow noopener noreferrer" target="_blank">《探针与Collector间通讯协议》</a> 。</p></blockquote><h1 id="2-Collector-注册相关-API"><a href="#2-Collector-注册相关-API" class="headerlink" title="2. Collector 注册相关 API"></a>2. Collector 注册相关 API</h1><p>Collector 注册相关 API 相关有四个接口：</p><ul><li>2.1 应用的注册 API</li><li>2.2 应用实例的正常注册 API </li><li>2.3 应用实例的恢复注册 API</li><li>2.4 应用实例的心跳 API</li></ul><p>API 处理的流程大体如下：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_25/01.png" alt=""></p><ul><li>绿框部分，【2.3】【2.4】两个 API ，直接 Service 调用 DAO 方法，无需经过 Graph / Stream 相关方法。</li></ul><h2 id="2-1-应用的注册-API"><a href="#2-1-应用的注册-API" class="headerlink" title="2.1 应用的注册 API"></a>2.1 应用的注册 API</h2><p>我们先来看看 API 的定义，<a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-network/src/main/proto/ApplicationRegisterService.proto#L9" rel="external nofollow noopener noreferrer" target="_blank"><code>ApplicationRegisterService.proto</code></a> ，如下图所示：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_25/02.png" alt=""></p><ul><li>其中，KeyWithIntegerValue 数据类型，在 <a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-network/src/main/proto/KeyWithIntegerValue.proto" rel="external nofollow noopener noreferrer" target="_blank"><code>KeyWithIntegerValue.proto</code></a> 中定义。</li></ul><h3 id="2-1-1-ApplicationRegisterServiceHandler-register-…"><a href="#2-1-1-ApplicationRegisterServiceHandler-register-…" class="headerlink" title="2.1.1 ApplicationRegisterServiceHandler#register(…)"></a>2.1.1 ApplicationRegisterServiceHandler#register(…)</h3><p><a href="https://github.com/YunaiV/skywalking/blob/b4b2ff52a7dccd000264677a7a6bbb2285a8cd53/apm-collector/apm-collector-agent-grpc/collector-agent-grpc-provider/src/main/java/org/skywalking/apm/collector/agent/grpc/handler/ApplicationRegisterServiceHandler.java#L49" rel="external nofollow noopener noreferrer" target="_blank"><code>ApplicationRegisterServiceHandler#register(Application, StreamObserver&lt;ApplicationMapping&gt;)</code></a>, 代码如下：</p><ul><li>第 51 行：获得请求的应用编码( <code>applicationCode</code> )<strong>数组</strong>。</li><li>第 54 至 64 行：循环应用编码数组，<strong>获取</strong>或<strong>创建</strong>应用。<ul><li>第 57 行：调用 <code>IApplicationIDService#getOrCreate(applicationCode)</code> 方法，<strong>获取</strong>或<strong>创建</strong>应用，最终获得应用编号( <code>applicationId</code> )。</li><li>第 60 至 63 行：获得到应用编号( <code>applicationId != 0</code> )，则添加到响应。<strong>为什么会存在获得不到的情况呢</strong>？在下文中，我们会看到，实际<strong>异步</strong>保存应用，所以会存在获取失败的情况。当获取失败，调用方( 例如 Agent )可以重新发起该请求进行注册应用，从而在异步保存应用，获取到应用编号。</li><li>第 67 至 68 行：响应。</li></ul></li></ul><h3 id="2-1-2-IApplicationIDService-getOrCreate-…"><a href="#2-1-2-IApplicationIDService-getOrCreate-…" class="headerlink" title="2.1.2 IApplicationIDService#getOrCreate(…)"></a>2.1.2 IApplicationIDService#getOrCreate(…)</h3><p><code>org.skywalking.apm.collector.agent.stream.service.register.IApplicationIDService</code> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> 接口，应用编号服务接口。</p><ul><li>定义了 <a href="https://github.com/YunaiV/skywalking/blob/a9873b9bf07882746bd30f29b3c64f4b44887bf2/apm-collector/apm-collector-agent-stream/collector-agent-stream-define/src/main/java/org/skywalking/apm/collector/agent/stream/service/register/IApplicationIDService.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><code>#getOrCreate(applicationCode)</code></a> <strong>接口</strong>方法，根据应用编码获取或创建应用，并获得应用编号。</li></ul><p><code>org.skywalking.apm.collector.agent.stream.worker.register.ApplicationIDService</code> ，实现 IApplicationIDService 接口，应用编号服务实现类。</p><ul><li><p>实现了 <a href="https://github.com/YunaiV/skywalking/blob/a9873b9bf07882746bd30f29b3c64f4b44887bf2/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationIDService.java#L64" rel="external nofollow noopener noreferrer" target="_blank"><code>#getOrCreate(applicationCode)</code></a> 方法，代码如下：</p><ul><li>第 66 行：调用 <code>ApplicationCacheService#get(applicationCode)</code> 方法，从<strong>缓存</strong>中获取应用编号。在 <a href="http://www.iocoder.cn/SkyWalking/collector-cache-module/?self">《SkyWalking 源码分析 —— Collector Cache 缓存组件》</a> 有详细解析。</li><li>第 69 至 76 行：当获取不到应用编号时，获取 Application 对应的 <code>Graph&lt;Application&gt;</code> 对象，调用 <code>Graph#start(application)</code> 方法，进行流式处理。在这过程中，会保存应用到存储器。</li><li>第 77 行：返回应用编号。</li></ul></li></ul><h3 id="2-1-3-Graph-start-application"><a href="#2-1-3-Graph-start-application" class="headerlink" title="2.1.3 Graph#start(application)"></a>2.1.3 Graph#start(application)</h3><p>在 <a href="https://github.com/YunaiV/skywalking/blob/a9873b9bf07882746bd30f29b3c64f4b44887bf2/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/graph/RegisterStreamGraph.java#L57" rel="external nofollow noopener noreferrer" target="_blank"><code>#createApplicationRegisterGraph()</code></a> 方法中，我们可以看到 Application 对应的 <code>Graph&lt;Application&gt;</code> 对象的创建。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/a9873b9bf07882746bd30f29b3c64f4b44887bf2/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationRegisterRemoteWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.register.ApplicationRegisterRemoteWorker</code></a> ，继承 AbstractRemoteWorker 抽象类，应用注册远程 Worker 。<ul><li><a href="https://github.com/YunaiV/skywalking/blob/a9873b9bf07882746bd30f29b3c64f4b44887bf2/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationRegisterRemoteWorker.java#L55" rel="external nofollow noopener noreferrer" target="_blank">Factory</a> 内部类，实现 AbstractRemoteWorkerProvider 抽象类，在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（一）》「3.2.3 AbstractRemoteWorker」</a> 有详细解析。</li><li><strong>AbstractRemoteWorker</strong> ，在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（一）》「3.2.3 AbstractRemoteWorker」</a> 有详细解析。</li><li><a href="https://github.com/YunaiV/skywalking/blob/a9873b9bf07882746bd30f29b3c64f4b44887bf2/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationRegisterRemoteWorker.java#L42" rel="external nofollow noopener noreferrer" target="_blank"><code>#id()</code></a> 实现方法，返回 10006 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/a9873b9bf07882746bd30f29b3c64f4b44887bf2/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationRegisterRemoteWorker.java#L51" rel="external nofollow noopener noreferrer" target="_blank"><code>#selector</code></a> 实现方法，返回 <code>Selector.ForeverFirst</code> 。在 <a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/?self">《SkyWalking 源码分析 —— Collector Remote 远程通信服务》</a> 有详细解析。</li><li><a href="https://github.com/YunaiV/skywalking/blob/a9873b9bf07882746bd30f29b3c64f4b44887bf2/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationRegisterRemoteWorker.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#onWork(Application)</code></a> 实现方法，调用 <code>Next#execute(message)</code> 方法，提交数据给下面的节点，继续流式处理。</li><li>总结：ApplicationRegisterRemoteWorker ，使用 Collector 集群的第一个节点( <a href="https://github.com/YunaiV/skywalking/blob/b4b2ff52a7dccd000264677a7a6bbb2285a8cd53/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteClient.java#L194" rel="external nofollow noopener noreferrer" target="_blank">按照 <code>ip</code> 排序</a> ) 进行后续的流式处理，即，保存应用。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/a9873b9bf07882746bd30f29b3c64f4b44887bf2/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationRegisterSerialWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.register.ApplicationRegisterSerialWorker</code></a> ，继承 AbstractLocalAsyncWorker 抽象类，异步保存应用 Worker 。<ul><li><a href="https://github.com/YunaiV/skywalking/blob/a9873b9bf07882746bd30f29b3c64f4b44887bf2/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationRegisterSerialWorker.java#L84" rel="external nofollow noopener noreferrer" target="_blank">Factory</a> 内部类，实现 AbstractLocalAsyncWorkerProvider 抽象类，在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（一）》「3.2.2 AbstractLocalAsyncWorker」</a> 有详细解析。</li><li><strong>AbstractLocalAsyncWorker</strong> ，在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（一）》「3.2.2 AbstractLocalAsyncWorker」</a> 有详细解析。</li><li><a href="https://github.com/YunaiV/skywalking/blob/a9873b9bf07882746bd30f29b3c64f4b44887bf2/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationRegisterSerialWorker.java#L52" rel="external nofollow noopener noreferrer" target="_blank"><code>#id()</code></a> 实现方法，返回 101 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/69ec2bb309f4fe3cdbda56587a6193be933c4388/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationRegisterSerialWorker.java#L56" rel="external nofollow noopener noreferrer" target="_blank"><code>#onWork(Application)</code></a> 实现方法，保存应用( Application )。代码如下( 以 ES 作为 DAO 实现为例子 )：<ul><li>第 58 行：调用 <code>ApplicationCacheService#get(applicationCode)</code> 方法，从<strong>缓存</strong>中获取应用编号。</li><li>第 60 行：当获取不到应用编号时，使用 <code>applicationCode</code> 创建应用并保存。</li><li>第 62 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/69ec2bb309f4fe3cdbda56587a6193be933c4388/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/ApplicationEsRegisterDAO.java#L49" rel="external nofollow noopener noreferrer" target="_blank"><code>ApplicationH2RegisterDAO#getMinApplicationId()</code></a> 方法，获得 Application 记录的应用编号的<strong>最小值</strong>。</li><li>——— 分隔 ———</li><li>第 63 行：当 <code>min == 0</code> 时，说明没有 Application 记录。</li><li>第 64 至 68 行：创建<strong>第一条</strong>、<strong>特殊</strong>的 Application 记录。该记录 <code>applicationId = 1</code> ，<code>applicationCode = User</code> ，用于表示用户发起请求。在 SkyWaling UI 中，我们可以看到该条 Application 记录如下图：<img src="http://www.iocoder.cn/images/SkyWalking/2020_09_25/03.png" alt=""></li><li>第 70 至 74 行：创建当前请求的对应的 Application 记录，并且 <code>applicationId = -1</code> 。</li><li>——— 分隔 ———</li><li>第 76 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/69ec2bb309f4fe3cdbda56587a6193be933c4388/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/ApplicationEsRegisterDAO.java#L45" rel="external nofollow noopener noreferrer" target="_blank"><code>ApplicationH2RegisterDAO#getMaxApplicationId()</code></a> 方法，获得 Application 记录的应用编号的<strong>最大值</strong>。</li><li>第 77 行：调用 <code>IdAutoIncrement#increment(min, max)</code> 方法，获得应用编号。该方法较为有趣，在下文详细解析。</li><li>第 79 至 82 行：创建当前请求的对应的 Application 记录。</li><li>——— 分隔 ———</li><li>第 85 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/69ec2bb309f4fe3cdbda56587a6193be933c4388/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/ApplicationEsRegisterDAO.java#L53" rel="external nofollow noopener noreferrer" target="_blank"><code>ApplicationEsRegisterDAO#save(Application)</code></a> 方法，保存应用。</li></ul></li></ul></li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/69ec2bb309f4fe3cdbda56587a6193be933c4388/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/IdAutoIncrement.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><code>IdAutoIncrement#increment(min, max)</code></a> 方法，<strong>双向</strong>均匀自增。可能看起来比较奇怪，以上文 Application 的调用举例子：</p><table><thead><tr><th>min</th><th>max</th><th>result</th><th>applicationCode</th></tr></thead><tbody><tr><td>0</td><td>/</td><td>1</td><td>User</td></tr><tr><td>0</td><td>/</td><td>-1</td><td>应用 A</td></tr><tr><td>-1</td><td>1</td><td>2</td><td>应用 B</td></tr><tr><td>-1</td><td>2</td><td>-2</td><td>应用 C</td></tr><tr><td>-2</td><td>2</td><td>3</td><td>应用 D</td></tr></tbody></table><ul><li>【User】和【应用 A】是直接获得 <code>result</code> ，不调用 <code>#increment(min, max)</code>  方法。</li><li>总的来说，我们可以看到，以 <code>min + max = 0</code> 为中心点( 实际以 <code>0</code> 为中心点)， <strong>双向</strong>均匀自增。</li></ul><p>TODO 【4007】</p><h3 id="2-1-4-Application"><a href="#2-1-4-Application" class="headerlink" title="2.1.4 Application"></a>2.1.4 Application</h3><p><a href="https://github.com/YunaiV/skywalking/blob/69ec2bb309f4fe3cdbda56587a6193be933c4388/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/register/Application.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.register.Application</code></a> ，应用。例如记录在 ES 如下图：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_25/05.png" alt=""></p><h2 id="2-2-应用实例的正常注册-API"><a href="#2-2-应用实例的正常注册-API" class="headerlink" title="2.2 应用实例的正常注册 API"></a>2.2 应用实例的正常注册 API</h2><p>我们先来看看 API 的定义，<a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-network/src/main/proto/InstanceDiscoveryService.proto#L11" rel="external nofollow noopener noreferrer" target="_blank"><code>InstanceDiscoveryService</code></a> ，如下图所示：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_25/04.png" alt=""></p><p>整体代码和 <a href="#">「2.1 应用的注册 API」</a> 非常相似，所以本小节，更多的是提供代码的链接地址。</p><h3 id="2-2-1-InstanceDiscoveryServiceHandler-register-…"><a href="#2-2-1-InstanceDiscoveryServiceHandler-register-…" class="headerlink" title="2.2.1 InstanceDiscoveryServiceHandler#register(…)"></a>2.2.1 InstanceDiscoveryServiceHandler#register(…)</h3><p><a href="https://github.com/YunaiV/skywalking/blob/69ec2bb309f4fe3cdbda56587a6193be933c4388/apm-collector/apm-collector-agent-grpc/collector-agent-grpc-provider/src/main/java/org/skywalking/apm/collector/agent/grpc/handler/InstanceDiscoveryServiceHandler.java#L54" rel="external nofollow noopener noreferrer" target="_blank"><code>InstanceDiscoveryServiceHandler#register(ApplicationInstance, StreamObserver&lt;ApplicationInstanceMapping&gt;)</code></a>，注册应用实例。</p><h3 id="2-2-2-IInstanceIDService-getOrCreate-…"><a href="#2-2-2-IInstanceIDService-getOrCreate-…" class="headerlink" title="2.2.2 IInstanceIDService#getOrCreate(…)"></a>2.2.2 IInstanceIDService#getOrCreate(…)</h3><p><code>org.skywalking.apm.collector.agent.stream.service.register.IInstanceIDService</code> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> 接口，应用实例编号服务接口。</p><ul><li>定义了 <a href="https://github.com/YunaiV/skywalking/blob/a4db2c4dd5e2adc861e7fb9e9b7b7ffdc57dfb88/apm-collector/apm-collector-agent-stream/collector-agent-stream-define/src/main/java/org/skywalking/apm/collector/agent/stream/service/register/IInstanceIDService.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>#getOrCreate(applicationCode)</code></a> <strong>接口</strong>方法，根据应用编号 + AgentUUID，获取或创建应用实例，并获得应用编号。</li></ul><p><code>org.skywalking.apm.collector.agent.stream.worker.register.InstanceIDService</code> ，实现 IInstanceIDService 接口，应用编号服务实现类。</p><ul><li>实现了 <a href="https://github.com/YunaiV/skywalking/blob/a4db2c4dd5e2adc861e7fb9e9b7b7ffdc57dfb88/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/InstanceIDService.java#L74" rel="external nofollow noopener noreferrer" target="_blank"><code>#getOrCreate(applicationCode)</code></a> 方法。</li></ul><h3 id="2-2-3-Graph-start-instance"><a href="#2-2-3-Graph-start-instance" class="headerlink" title="2.2.3 Graph#start(instance)"></a>2.2.3 Graph#start(instance)</h3><p>在 <a href="https://github.com/YunaiV/skywalking/blob/a9873b9bf07882746bd30f29b3c64f4b44887bf2/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/graph/RegisterStreamGraph.java#L68" rel="external nofollow noopener noreferrer" target="_blank"><code>#createInstanceRegisterGraph()</code></a> 方法中，我们可以看到 Instance 对应的 <code>Graph&lt;Instance&gt;</code> 对象的创建。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/a9873b9bf07882746bd30f29b3c64f4b44887bf2/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/InstanceRegisterRemoteWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.register.InstanceRegisterRemoteWorker</code></a> ，继承 AbstractRemoteWorker 抽象类，应用实例注册远程 Worker 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/a9873b9bf07882746bd30f29b3c64f4b44887bf2/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationRegisterSerialWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.register.ApplicationRegisterSerialWorker</code></a> ，继承 AbstractLocalAsyncWorker 抽象类，异步保存应用 Worker 。<ul><li>不同 Application ，Instance 的应用实例编号，从 <code>&quot;1&quot;</code> <strong>正向</strong>递增。 </li><li><a href="https://github.com/YunaiV/skywalking/blob/a4db2c4dd5e2adc861e7fb9e9b7b7ffdc57dfb88/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/InstanceEsRegisterDAO.java#L53" rel="external nofollow noopener noreferrer" target="_blank">InstanceEsRegisterDAO#save(Instance)</a></li></ul></li></ul><h3 id="2-2-4-Instance"><a href="#2-2-4-Instance" class="headerlink" title="2.2.4 Instance"></a>2.2.4 Instance</h3><p><a href="https://github.com/YunaiV/skywalking/blob/69ec2bb309f4fe3cdbda56587a6193be933c4388/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/register/Instance.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.register.Instance</code></a> ，应用实例。例如记录在 ES 如下图：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_25/06.png" alt=""></p><h2 id="2-3-应用实例的恢复注册-API"><a href="#2-3-应用实例的恢复注册-API" class="headerlink" title="2.3 应用实例的恢复注册 API"></a>2.3 应用实例的恢复注册 API</h2><p>我们先来看看 API 的定义，<a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-network/src/main/proto/InstanceDiscoveryService.proto#L17" rel="external nofollow noopener noreferrer" target="_blank"><code>InstanceDiscoveryService.proto</code></a> ，如下图所示：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_25/07.png" alt=""></p><ul><li>其中，Downstream 数据类型，在 <a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-network/src/main/proto/Downstream.proto" rel="external nofollow noopener noreferrer" target="_blank"><code>Downstream.proto</code></a> 中定义。</li></ul><p>一般情况下，Agent 在注册应用时候成功后，如果因为各种原因原因和 Collector 断开了 gRPC Channel 连接( 例如，网络 )，恢复连接后，需要调用该 API ，进行<strong>恢复</strong>注册。</p><h3 id="2-3-1-InstanceDiscoveryServiceHandler-recover-…"><a href="#2-3-1-InstanceDiscoveryServiceHandler-recover-…" class="headerlink" title="2.3.1 InstanceDiscoveryServiceHandler#recover(…)"></a>2.3.1 InstanceDiscoveryServiceHandler#recover(…)</h3><p><a href="https://github.com/YunaiV/skywalking/blob/9a01c67f47efc07b9754c77198324cb2d5bb212d/apm-collector/apm-collector-agent-grpc/collector-agent-grpc-provider/src/main/java/org/skywalking/apm/collector/agent/grpc/handler/InstanceDiscoveryServiceHandler.java#L69" rel="external nofollow noopener noreferrer" target="_blank"><code>InstanceDiscoveryServiceHandler#recover(ApplicationInstanceRecover, StreamObserver&lt;Downstream&gt;)</code></a>, 代码如下：</p><ul><li>第 71 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/9a01c67f47efc07b9754c77198324cb2d5bb212d/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/util/TimeBucketUtils.java#L51" rel="external nofollow noopener noreferrer" target="_blank"><code>TimeBucketUtils#getSecondTimeBucket(time)</code></a> 方法，将 <code>registerTime</code> 转成 timeBucket 。</li><li>第 73 行：调用 <code>IInstanceIDService#recover(instanceId, applicationId, registerTime, osInfo)</code> 方法，恢复注册应用实例。</li><li>第 75 至 76 行：响应。</li></ul><h3 id="2-3-2-IInstanceIDService-recover-…"><a href="#2-3-2-IInstanceIDService-recover-…" class="headerlink" title="2.3.2 IInstanceIDService#recover(…)"></a>2.3.2 IInstanceIDService#recover(…)</h3><p><a href="https://github.com/YunaiV/skywalking/blob/bb8cb1b7dcb428c161f225f0b5d57441105f84c0/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/InstanceIDService.java#L95" rel="external nofollow noopener noreferrer" target="_blank"><code>InstanceIDService#recover(instanceId, applicationId, registerTime, osInfo)</code></a> <strong>实现</strong>方法，恢复注册。代码如下：</p><ul><li>第 96 至 103 行：创建 Instance 对象，用于下面更新操作。<ul><li>第 99 行： TODO 【4008】</li></ul></li><li>第 106 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/a4db2c4dd5e2adc861e7fb9e9b7b7ffdc57dfb88/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/InstanceEsRegisterDAO.java#L53" rel="external nofollow noopener noreferrer" target="_blank">InstanceEsRegisterDAO#save(Instance)</a> 方法，更新应用实例。</li></ul><h2 id="2-4-应用实例的心跳-API"><a href="#2-4-应用实例的心跳-API" class="headerlink" title="2.4 应用实例的心跳 API"></a>2.4 应用实例的心跳 API</h2><p>我们先来看看 API 的定义，<a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-network/src/main/proto/InstanceDiscoveryService.proto#L14" rel="external nofollow noopener noreferrer" target="_blank"><code>InstanceDiscoveryService.proto</code></a> ，如下图所示：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_25/08.png" alt=""></p><ul><li>其中，Downstream 数据类型，在 <a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-network/src/main/proto/Downstream.proto" rel="external nofollow noopener noreferrer" target="_blank"><code>Downstream.proto</code></a> 中定义。</li></ul><p>一般情况下，Agent 在注册应用时候成功后，定时向 Collector 发送<strong>心跳</strong>，记录应用存活。</p><h3 id="2-4-1-InstanceDiscoveryServiceHandler-heartbeat-…"><a href="#2-4-1-InstanceDiscoveryServiceHandler-heartbeat-…" class="headerlink" title="2.4.1 InstanceDiscoveryServiceHandler#heartbeat(…)"></a>2.4.1 InstanceDiscoveryServiceHandler#heartbeat(…)</h3><p><a href="#">InstanceDiscoveryServiceHandler#heartbeat(ApplicationInstanceHeartbeat, StreamObserver<org.skywalking.apm.network.proto.downstream>)</org.skywalking.apm.network.proto.downstream></a> ，目前该方法暂未实现。实现后，会首先调用一个 Service 方法，而后调用 <a href="https://github.com/YunaiV/skywalking/blob/bb8cb1b7dcb428c161f225f0b5d57441105f84c0/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/InstanceEsRegisterDAO.java#L68" rel="external nofollow noopener noreferrer" target="_blank"><code>InstanceEsRegisterDAO#updateHeartbeatTime(instanceId, heartbeatTime)</code></a> 方法，记录应用实例的心跳时间。</p><h1 id="3-Agent-调用注册-API"><a href="#3-Agent-调用注册-API" class="headerlink" title="3. Agent 调用注册 API"></a>3. Agent 调用注册 API</h1><p><a href="https://github.com/YunaiV/skywalking/blob/bb8cb1b7dcb428c161f225f0b5d57441105f84c0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/AppAndServiceRegisterClient.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.remote.AppAndServiceRegisterClient</code></a> ，实现 BootService 、GRPCChannelListener 、Runnable 、TracingContextListener 接口，注册应用与实例的客户端。该客户端会调用上述所有 API 。</p><ul><li><code>PROCESS_UUID</code> <strong>静态</strong>属性，Agent UUID ，使用 <strong>UUID</strong> 算法生成，去除多余 <code>&quot;-&quot;</code> 。</li><li>———- 分割线 ———-</li><li><code>status</code> 属性，gRPC 连接状态。</li><li><code>applicationRegisterServiceBlockingStub</code> / <code>instanceDiscoveryServiceBlockingStub</code> / <code>serviceNameDiscoveryServiceBlockingStub</code> 属性，对应 gRPC 提供 API 的<strong>阻塞</strong> Stub 。</li><li><code>needRegisterRecover</code> 属性，是否需要发起恢复的注册。</li><li>如上五个属性，在 <a href="https://github.com/YunaiV/skywalking/blob/bb8cb1b7dcb428c161f225f0b5d57441105f84c0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/AppAndServiceRegisterClient.java#L79" rel="external nofollow noopener noreferrer" target="_blank"><code>#statusChanged(GRPCChannelStatus)</code></a> <strong>实现</strong>方法，根据 gRPC 连接状态的变更，创建或销毁 Stub 。</li><li>在 <a href="https://github.com/YunaiV/skywalking/blob/bb8cb1b7dcb428c161f225f0b5d57441105f84c0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/AppAndServiceRegisterClient.java#L103" rel="external nofollow noopener noreferrer" target="_blank"><code>#boot()</code></a> <strong>实现</strong>方法，将自己作为监听器( 因为实现了 GRPCChannelListener 接口 )添加到 GRPCChannelManager 中，从而监听 gRPC Channel 的状态。在 <a href="http://www.iocoder.cn/SkyWalking/agent-remote-manager/?self">《SkyWalking 源码分析 —— Agent Remote 远程通信服务》</a> 有详细解析。</li><li>———- 分割线 ———-</li><li><code>applicationRegisterFuture</code> 属性，注册应用与实例的定时任务。</li><li><a href="https://github.com/YunaiV/skywalking/blob/bb8cb1b7dcb428c161f225f0b5d57441105f84c0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/AppAndServiceRegisterClient.java#L103" rel="external nofollow noopener noreferrer" target="_blank"><code>#boot()</code></a> <strong>实现</strong>方法，创建 <code>applicationRegisterFuture</code> 。该定时任务<strong>无初始化延迟</strong>，每 <code>Config.Collector.APP_AND_SERVICE_REGISTER_CHECK_INTERVAL</code> ( 默认：3 s ) 执行一次 <code>#run()</code> 方法。</li><li>———- 分割线 ———-</li><li><code>lastSegmentTime</code> 属性，最后记录 Segment 的时间。</li><li><a href="https://github.com/YunaiV/skywalking/blob/bb8cb1b7dcb428c161f225f0b5d57441105f84c0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/AppAndServiceRegisterClient.java#L186" rel="external nofollow noopener noreferrer" target="_blank"><code>#afterFinished()</code></a> <strong>实现</strong>方法，记录 Segment 最后的时间。</li><li><a href="https://github.com/YunaiV/skywalking/blob/bb8cb1b7dcb428c161f225f0b5d57441105f84c0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/AppAndServiceRegisterClient.java#L103" rel="external nofollow noopener noreferrer" target="_blank"><code>#afterBoot()</code></a> <strong>实现</strong>方法，将自己作为监听器( 因为实现了 TracingContextListener 接口 )添加到 GRPCChannelManager 中，从而监听 Segment 的记录。在 <a href="http://www.iocoder.cn/SkyWalking/agent-remote-manager/?self">《TODO 【4009】》</a> 有详细解析。</li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/bb8cb1b7dcb428c161f225f0b5d57441105f84c0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/AppAndServiceRegisterClient.java#L120" rel="external nofollow noopener noreferrer" target="_blank"><code>#run()</code></a> <strong>实现</strong>方法，执行应用的注册，应用实例的正常注册、恢复注册、心跳的逻辑。</p><ul><li>第 123 行：循环，当 gRPC 处于<strong>连接中</strong>，并且需要重试( <code>shouldTry</code> )。可能对 <code>shouldTry</code> 会比较疑惑？该变量用于，应用的注册成功后，重新标记 <code>shouldTry = true</code> ，继续执行应用实例的注册。</li><li>第 126 至 135 行：当本地<strong>应用编号</strong>为空时，说明应用暂未注册，调用 <a href="#">「2.1 应用的注册 API」</a> 。</li><li>第 138 至 148 行：当本地<strong>应用实例编号</strong>为空时，说明应用实例暂未注册，调用 <a href="#">「2.2 应用实例的正常注册 API」</a> 。</li><li>第 150 至 158 行：当需要发起恢复注册时，即 gRPC Channel 断开后重连成功，调用 <a href="#">「2.3 应用实例的恢复注册 API」</a> 。</li><li>第 159 至 167 行：当<strong>现在时间</strong>超过 <code>lastSegmentTime</code> <strong>一分钟</strong>，调用 <a href="#">「2.4 应用实例的心跳 API」</a> 。</li><li>第 170 至 173 行：同步应用字典、操作字典。在 <a href="http://www.iocoder.cn/SkyWalking/agent-dictionary/?">《SkyWalking 源码分析 —— Agent DictionaryManager 字典管理》</a> 详细解析。</li><li>第 178 至 180 行：当发生异常时，调用 <code>GRPCChannelManager#reportError(t)</code> 方法，处理异常，例如请求超时。</li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>😈 距离 Segment 已经不远了。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_25/09.png" alt=""></p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/register/&quot;&gt;http://www.iocoder.cn/SkyWalking/register/&lt;/a&gt; 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;ul&gt;
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Agent Remote 远程通信服务</title>
    <link href="http://www.iocoder.cn/SkyWalking/agent-remote-manager/"/>
    <id>http://www.iocoder.cn/SkyWalking/agent-remote-manager/</id>
    <published>2020-09-19T16:00:00.000Z</published>
    <updated>2017-12-26T03:21:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/agent-remote-manager/">http://www.iocoder.cn/SkyWalking/agent-remote-manager/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-remote-manager/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-remote-manager/">2. GRPCChannelManager</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-remote-manager/">3. GRPCChannelListener</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-remote-manager/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>SkyWalking Agent Remote 远程通信服务</strong>。该服务用于 Agent 和Collector 集群的通信。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_20/01.png" alt=""></p><p>在 <a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/?self">《SkyWalking 源码分析 —— Collector Naming Server 命名服务》</a> 一文中，我们已经看到，Agent 使用<strong>定时轮询</strong>，从 Collector Naming Server 中，获得 Collector 集群的 Collector Agent gRPC Server 的<strong>所有地址</strong>。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_20/02.jpeg" alt=""></p><ul><li><strong>红框</strong>部分，即为 Agent 和Collector 集群的通信部分。</li><li>另外，Collector 也提供 <a href="https://github.com/YunaiV/skywalking/tree/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-collector/apm-collector-agent-jetty" rel="external nofollow noopener noreferrer" target="_blank">Collector Agent Jetty Server</a> ，目前暂不使用。相比来说，<a href="https://github.com/YunaiV/skywalking/tree/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-collector/apm-collector-agent-grpc" rel="external nofollow noopener noreferrer" target="_blank">Collector Agent gRPC Server</a> 性能更优。</li></ul><h1 id="2-GRPCChannelManager"><a href="#2-GRPCChannelManager" class="headerlink" title="2. GRPCChannelManager"></a>2. GRPCChannelManager</h1><p><code>org.skywalking.apm.agent.core.remote.GRPCChannelManager</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/ac6c98c1732d6aa62b9d244369478654411ac203/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/boot/BootService.java" rel="external nofollow noopener noreferrer" target="_blank">BootService</a> 、Runnable <strong>接口</strong>，gRPC Channel 管理器。GRPCChannelManager 负责管理与 Collector Agent gRPC Server 集群的<strong>连接的管理</strong>，<strong>提供给其他服务使用</strong>。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/GRPCChannelManager.java#L54" rel="external nofollow noopener noreferrer" target="_blank"><code>managedChannel</code></a> 属性，连接 gRPC Server 的 Channel 。<strong>同一时间，GRPCChannelManager 只连接一个 Collector Agent gRPC Server 节点，并且在 Channel 不因为各种网络问题断开的情况下，持续保持</strong>。</li><li><a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/GRPCChannelManager.java#L58" rel="external nofollow noopener noreferrer" target="_blank"><code>connectCheckFuture</code></a> 属性，定时重连 gRPC Server 的<strong>定时任务</strong>。</li><li><a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/GRPCChannelManager.java#L63" rel="external nofollow noopener noreferrer" target="_blank"><code>reconnect</code></a> 属性，是否重连。当 Channel 未连接需要连接，或者 Channel 断开需要重连时，标记 <code>reconnect = true</code> 。后台线程会根据该标识进行连接( 重连 )。</li><li><a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/GRPCChannelManager.java#L68" rel="external nofollow noopener noreferrer" target="_blank"><code>listeners</code></a> 属性，监听器( <code>org.skywalking.apm.agent.core.remote.GRPCChannelListener</code> ) 数组。使用 Channel 的其他服务，注册监听器到 GRPCChannelManager 上，从而根据连接状态( <code>org.skywalking.apm.agent.core.remote.GRPCChannelStatus</code> )，实现自定义逻辑。 </li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/GRPCChannelManager.java#L76" rel="external nofollow noopener noreferrer" target="_blank"><code>#boot()</code></a> <strong>实现</strong>方法，调用 <code>ScheduledExecutorService#scheduleAtFixedRate(...)</code> 方法，创建定时任务。该定时任务<strong>无初始化延迟</strong>，每 <code>Config.GRPC_CHANNEL_CHECK_INTERVAL</code> ( 默认：30 s ) 执行一次 <code>#run()</code> 方法。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/GRPCChannelManager.java#L97" rel="external nofollow noopener noreferrer" target="_blank"><code>#run()</code></a> <strong>实现</strong>方法，执行 Channel 的连接( 重连 )逻辑。代码如下：</p><ul><li>第 99 行：当 <code>reconnect = true</code> 时，才执行连接( 重连 )。</li><li>第 100 行：当本地已经获取到 Collector Agent gRPC Server 集群地址时，参见 <a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/?self">《SkyWalking 源码分析 —— Collector Naming Server 命名服务》</a> 。</li><li>第 101 至 106 行：<strong>随机选择</strong>准备链接的 Collector Agent gRPC Server 。</li><li>第 107 至 113 行：创建 Channel 并进行连接。此处主要是 gRPC 的 API 使用，不熟悉的胖友，请 Google 下进行了解了解。</li><li>第 115 至 117 行：连接<strong>成功</strong>，标记 <code>reconnect = false</code> ，这样，下次执行 <code>#run()</code> 方法不会重连。而后，调用 <a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/GRPCChannelManager.java#L160" rel="external nofollow noopener noreferrer" target="_blank"><code>#notify(GRPCChannelStatus.CONNECTED)</code></a> 方法，通知监听器连接成功。</li><li>第 118 至 121 行：连接<strong>成功</strong>，不标记 <code>reconnect</code> ，这样，下次执行 <code>#run()</code> 方法会继续重连。而后，调用 <a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/GRPCChannelManager.java#L160" rel="external nofollow noopener noreferrer" target="_blank"><code>#notify(GRPCChannelStatus.DISCONNECT)</code></a> 方法，通知监听器连接处于断开状态。</li><li>第 124 至 126 行：连接<strong>异常</strong>，不标记 <code>reconnect</code> ，这样，下次执行 <code>#run()</code> 方法会继续重连。而后，调用 <a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/GRPCChannelManager.java#L160" rel="external nofollow noopener noreferrer" target="_blank"><code>#notify(GRPCChannelStatus.DISCONNECT)</code></a> 方法，通知监听器连接处于断开状态。</li></ul><p>实际使用中，Channel 可能因为各种原因断开，那么 GRPCChannelManager 是怎么检测的呢？在使用 Channel 的<strong>其他服务</strong>，当使用 Channel 时发生异常，调用 <a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/GRPCChannelManager.java#L149" rel="external nofollow noopener noreferrer" target="_blank"><code>#reportError(Throwable)</code></a> 方法，判断是否为网络异常( <a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/GRPCChannelManager.java#L176" rel="external nofollow noopener noreferrer" target="_blank"><code>#isNetworkError(Throwable)</code></a> ) 。若是，标记 <code>reconnect = true</code> ，等待后台进行重连。</p><h1 id="3-GRPCChannelListener"><a href="#3-GRPCChannelListener" class="headerlink" title="3. GRPCChannelListener"></a>3. GRPCChannelListener</h1><p><code>org.skywalking.apm.agent.core.remote.GRPCChannelListener</code> ，gRPC Channel 的监听器<strong>接口</strong>，定义了 <a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/GRPCChannelListener.java#L33" rel="external nofollow noopener noreferrer" target="_blank"><code>#statusChanged(GRPCChannelStatus)</code></a> ，通知 gRPC Channel 状态变更。</p><p>GRPCChannelListener 实现类如下图，后续文章会详细解析。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_20/03.png" alt=""></p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>“水”文一篇，哈哈哈。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_20/04.png" alt=""></p><p>胖友，分享一波朋友圈可好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/agent-remote-manager/&quot;&gt;http://www.iocoder.cn/SkyWalking/agent-remote-manager/&lt;/a&gt; 「芋道源
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— DataCarrier 异步处理库</title>
    <link href="http://www.iocoder.cn/SkyWalking/data-carrier/"/>
    <id>http://www.iocoder.cn/SkyWalking/data-carrier/</id>
    <published>2020-09-14T16:00:00.000Z</published>
    <updated>2017-12-25T12:46:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/data-carrier/">http://www.iocoder.cn/SkyWalking/data-carrier/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/data-carrier/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/data-carrier/">2. buffer</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/data-carrier/">2.1 Buffer</a></li><li><a href="http://www.iocoder.cn/SkyWalking/data-carrier/">2.2 Channels</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/data-carrier/">3. partition</a></li><li><a href="http://www.iocoder.cn/SkyWalking/data-carrier/">4. consumer</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/data-carrier/">4.1 IConsumer</a></li><li><a href="http://www.iocoder.cn/SkyWalking/data-carrier/">4.2 ConsumerThread</a></li><li><a href="http://www.iocoder.cn/SkyWalking/data-carrier/">4.3 ConsumerPool</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/data-carrier/">4. DataCarrier</a></li><li><a href="http://www.iocoder.cn/SkyWalking/data-carrier/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>SkyWalking DataCarrier 异步处理库</strong>。</p><p>基于生产者消费者的模式，大体结构如下图：<img src="http://www.iocoder.cn/images/SkyWalking/2020_09_15/01.png" alt=""></p><ul><li>实际项目中，没有 Producer 这个类。所以本文提到的 Producer ，更多的是一种<strong>角色</strong>。</li></ul><p>下面我们来看看整体的项目结构，如下图所示 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_09_15/02.png" alt=""></p><h1 id="2-buffer"><a href="#2-buffer" class="headerlink" title="2. buffer"></a>2. buffer</h1><p><code>org.skywalking.apm.commons.datacarrier.buffer</code> 包，主要包含 Channels 、Buffer 两个类。Channels 是 Buffer 数组的封装。</p><h2 id="2-1-Buffer"><a href="#2-1-Buffer" class="headerlink" title="2.1 Buffer"></a>2.1 Buffer</h2><p><code>org.skywalking.apm.commons.datacarrier.buffer.Buffer</code> ，缓存区。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/buffer/Buffer.java#L35" rel="external nofollow noopener noreferrer" target="_blank"><code>buffer</code></a> 属性，缓冲数组。Producer 保存的数据到 <code>buffer</code> 里。</li><li><a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/buffer/Buffer.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>strategy</code></a> ，缓冲策略( <a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/buffer/BufferStrategy.java#L26" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.commons.datacarrier.buffer.BufferStrategy</code></a> ) 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/buffer/Buffer.java#L43" rel="external nofollow noopener noreferrer" target="_blank"><code>index</code></a> 属性，递增位置( <a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/common/AtomicRangeInteger.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.commons.datacarrier.common.AtomicRangeInteger</code></a> )。</li></ul><p>Buffer 在保存数据时，把 <code>buffer</code> 作为一个 “<strong>环</strong>“，使用 <code>index</code> 记录最后存储的位置，不断向下，<strong>循环</strong>存储到 <code>buffer</code> 中。通过这样的方式，带来良好的存储性能，避免扩容问题。But ，存储会存在冲突的问题：<code>buffer</code> 写入位置，暂未被消费，已经存在值。此时，根据不同的 BufferStrategy 进行处理。整体流程见 <a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/buffer/Buffer.java#L61" rel="external nofollow noopener noreferrer" target="_blank"><code>#save(data)</code></a> 方法。</p><p>当 Buffer 被 Consumer 消费时，被调用 <a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/buffer/Buffer.java#L88" rel="external nofollow noopener noreferrer" target="_blank"><code>#obtain(start, end)</code></a> 方法，获得数据并清空。为什么会带 <code>start</code> 、<code>end</code> 方法参数呢？下文揭晓答案。</p><h2 id="2-2-Channels"><a href="#2-2-Channels" class="headerlink" title="2.2 Channels"></a>2.2 Channels</h2><p><code>org.skywalking.apm.commons.datacarrier.buffer.Channels</code> ，内嵌<strong>多个</strong> Buffer 的通道。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/buffer/Channels.java#L37" rel="external nofollow noopener noreferrer" target="_blank"><code>bufferChannels</code></a> 属性，Buffer 数组。</li><li><a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/buffer/Channels.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>dataPartitioner</code></a> 属性，数据分区( <a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/partition/IDataPartitioner.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.commons.datacarrier.partition.IDataPartitioner</code></a> )。</li><li><a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/buffer/Buffer.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>strategy</code></a> 属性，缓冲策略( <a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/buffer/Channels.java#L42" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.commons.datacarrier.buffer.BufferStrategy</code></a> ) 。</li></ul><p>Channels 在保存数据时，相比 Buffer ，从 <code>buffer</code> 变成了多 <code>buffer</code> ，因此需要先选一个 <code>buffer</code> 。通过使用不同的 IDataPartitioner 实现类，进行 Buffer 的选择。当缓冲策略为 <code>BufferStrategy.IF_POSSIBLE</code> 时，根据 IDataPartitioner 定义的重试次数，进行多次保存数据直到成功。整体流程见 <a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/buffer/Channels.java#L62" rel="external nofollow noopener noreferrer" target="_blank"><code>#save(data)</code></a> 方法。</p><h1 id="3-partition"><a href="#3-partition" class="headerlink" title="3. partition"></a>3. partition</h1><p><a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/partition/IDataPartitioner.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.commons.datacarrier.partition.IDataPartitioner</code></a> ，数据分配者<strong>接口</strong>。定义了如下方法：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/partition/IDataPartitioner.java#L37" rel="external nofollow noopener noreferrer" target="_blank"><code>#partition(total, data)</code></a> <strong>接口</strong>方法，获得数据被分配的分区位置。</li><li><a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/partition/IDataPartitioner.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#maxRetryCount()</code></a> <strong>接口</strong>方法，获得最大重试次数。</li></ul><p>IDataPartitioner 目前有两个子类实现：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/partition/ProducerThreadPartitioner.java" rel="external nofollow noopener noreferrer" target="_blank">ProducerThreadPartitioner</a> ，基于线程编号分配策略的数据分配者实现类。</li><li><a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/partition/SimpleRollingPartitioner.java" rel="external nofollow noopener noreferrer" target="_blank">SimpleRollingPartitioner</a> ，基于顺序分配策略的数据分配者实现类。</li></ul><h1 id="4-consumer"><a href="#4-consumer" class="headerlink" title="4. consumer"></a>4. consumer</h1><p><code>org.skywalking.apm.commons.datacarrier.consumer</code> 包，主要包含 ConsumerPool 、ConsumerThread 、IConsumer 三个类。</p><ul><li>ConsumerThread 使用 IConsumer ，消费数据</li><li>ConsumerPool 是 ConsumerThread 的线程池封装</li></ul><h2 id="4-1-IConsumer"><a href="#4-1-IConsumer" class="headerlink" title="4.1 IConsumer"></a>4.1 IConsumer</h2><p><code>org.skywalking.apm.commons.datacarrier.consumer.IConsumer</code> ，消费者接口。定义了如下方法：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/IConsumer.java#L33" rel="external nofollow noopener noreferrer" target="_blank"><code>#init()</code></a> <strong>接口</strong>方法，初始化消费者。</li><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/IConsumer.java#L40" rel="external nofollow noopener noreferrer" target="_blank"><code>#consume(List&lt;T&gt;)</code></a> <strong>接口</strong>方法，批量消费消息。</li><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/IConsumer.java#L48" rel="external nofollow noopener noreferrer" target="_blank"><code>#onError(List&lt;T&gt;, Throwable)</code></a> <strong>接口</strong>方法，处理当消费发生异常。</li><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/IConsumer.java#L53" rel="external nofollow noopener noreferrer" target="_blank"><code>#onExit()</code></a> <strong>接口</strong>方法，处理当消费结束。此处的结束时，ConsumerThread 关闭。</li></ul><p>我们在使用时，自定义 Consumer 类，实现 IConsumer 接口。例如：<a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteClient.java#L93" rel="external nofollow noopener noreferrer" target="_blank">RemoteMessageConsumer</a> 。</p><h2 id="4-2-ConsumerThread"><a href="#4-2-ConsumerThread" class="headerlink" title="4.2 ConsumerThread"></a>4.2 ConsumerThread</h2><p><code>org.skywalking.apm.commons.datacarrier.consumer.ConsumerThread</code> ，继承 <code>java.lang.Thread</code> ，消费线程。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/ConsumerThread.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><code>running</code></a> 属性，是否运行中。</li><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/ConsumerThread.java#L40" rel="external nofollow noopener noreferrer" target="_blank"><code>consumer</code></a> 属性，消费者对象。</li><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/ConsumerThread.java#L44" rel="external nofollow noopener noreferrer" target="_blank"><code>dataSources</code></a> 属性，消费消息的数据源( <a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/ConsumerThread.java#L139" rel="external nofollow noopener noreferrer" target="_blank">DataSource</a> )数组。一个 ConsumerThread ，可以消费多个 Buffer ，并且单个 Buffer 消费的分区范围可配置，即一个 Buffer 可以被多个 ConsumerThread 同时无冲突的消费。在 <a href="#">「4.3 ConsumerPool」</a> 详细解析 ConsumerThread 分配 Buffer 的方式。<ul><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/ConsumerThread.java#L60" rel="external nofollow noopener noreferrer" target="_blank"><code>#addDataSource(sourceBuffer, start, end)</code></a> 方法，添加 Buffer 部分范围。</li><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/ConsumerThread.java#L69" rel="external nofollow noopener noreferrer" target="_blank"><code>#addDataSource(sourceBuffer)</code></a> 方法，添加 Buffer 全部范围。</li></ul></li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/ConsumerThread.java#L74" rel="external nofollow noopener noreferrer" target="_blank"><code>#run()</code></a> <strong>实现</strong>方法，<strong>不断</strong>、<strong>批量</strong>的消费数据。代码如下：</p><ul><li>第 78 至 88 行：<strong>不断</strong>消费，直到线程关闭( <a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/ConsumerThread.java#L130" rel="external nofollow noopener noreferrer" target="_blank"><code>#shutdown()</code></a> )。<ul><li>第 80 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/ConsumerThread.java#L103" rel="external nofollow noopener noreferrer" target="_blank"><code>#consume()</code></a> 方法，<strong>批量</strong>消费数据。</li><li>第 82 至 87 行：当未消费到数据，说明 <code>dataSources</code> 为空，等待 20 ms ，避免 CPU 空跑。</li></ul></li><li>第 93 行：当线程关闭，调用 <code>#consume()</code> 方法，消费完 <code>dataSources</code> 剩余的数据。</li><li>第 95 行：调用 <code>IConsumer#onExit()</code> 方法，处理当消费结束。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/ConsumerThread.java#L103" rel="external nofollow noopener noreferrer" target="_blank"><code>#consume()</code></a> 方法，<strong>批量</strong>消费数据。代码如下：</p><ul><li>第 107 至 117 行：从 <code>dataSources</code> 中，获取要消费的数据。</li><li>第 120 至 126 行：当有数据可消费时，调用 <code>IConsumer#consume(List&lt;T&gt;)</code> 方法。当消费发生异常时，调用 <code>IConsumer#onError(List&lt;T&gt;, Throwable)</code> 方法。</li><li>第 127 行：返回是否有消费数据。</li></ul><h2 id="4-3-ConsumerPool"><a href="#4-3-ConsumerPool" class="headerlink" title="4.3 ConsumerPool"></a>4.3 ConsumerPool</h2><p><code>org.skywalking.apm.commons.datacarrier.consumer.ConsumerPool</code> ，消费者池，提供了对 Channels 启动<strong>指定数量</strong>的 ConsumerThread 进行消费。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/ConsumerPool.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>running</code></a> 属性，是否运行中。</li><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/ConsumerPool.java#L43" rel="external nofollow noopener noreferrer" target="_blank"><code>consumerThreads</code></a> 属性，ConsumerThread 数组，通过构造方法的 <code>num</code> 参数进行指定。</li><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/ConsumerPool.java#L47" rel="external nofollow noopener noreferrer" target="_blank"><code>channels</code></a> 属性，<strong>数据</strong>通道。</li><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/ConsumerPool.java#L51" rel="external nofollow noopener noreferrer" target="_blank"><code>lock</code></a> 属性，锁。保证 ConsumerPool 启动或关闭时的线程安全。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/ConsumerPool.java#L96" rel="external nofollow noopener noreferrer" target="_blank"><code>#begin()</code></a> 方法，启动 ConsumerPool ，进行数据消费。代码如下：</p><ul><li>第 97 至 99 行：正在运行中，直接返回。</li><li>第 101 行：获得锁。</li><li>第 104 行：调用 <code>#allocateBuffer2Thread()</code> 方法，将 <code>channels</code> 的<strong>多个</strong> Buffer ，分配给 <code>consumerThreads</code> 的<strong>多个</strong> ConsumerThread。</li><li>第 107 至 109 行：启动每个 ConsumerThread ，开始消费。</li><li>第 112 行：标记正在运行中。</li><li>第 114 行：释放锁。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/ConsumerPool.java#L166" rel="external nofollow noopener noreferrer" target="_blank"><code>close()</code></a> 方法，关闭 ConsumerPool 。代码如下：</p><ul><li>第 168 行：获得锁。</li><li>第 169 行：标记不在运行中。</li><li>第 170 至 172 行：关闭每个 ConsumerThread ，结束消费。</li><li>第 174 行：释放锁。</li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/ConsumerPool.java#L122" rel="external nofollow noopener noreferrer" target="_blank"><code>#allocateBuffer2Thread()</code></a> 方法，将 <code>channels</code> 的<strong>多个</strong> Buffer ，分配给 <code>consumerThreads</code> 的<strong>多个</strong> ConsumerThread。一共会有三种情况：</p><ul><li><p>Buffer 数量<strong>等于</strong> ConsumerThread 数量，这个十分好分配，一比一。</p></li><li><p>Buffer 数量<strong>大于</strong> ConsumerThread 数量，那么按照 Buffer 数量 <code>%</code> ConsumerThread 数量进行分组，分配给 ConsumerThread ，如下图所示：<img src="http://www.iocoder.cn/images/SkyWalking/2020_09_15/03.png" alt=""></p></li><li><p>Buffer 数量<strong>大于</strong> ConsumerThread 数量，那么按照 ConsumerThread 数量 <code>%</code> Buffer 数量进行分组，分配给 Buffer 。其中，一个 Buffer 会被<strong>均分</strong>给多个 ConsumerThread ，如下图所示：<img src="http://www.iocoder.cn/images/SkyWalking/2020_09_15/04.png" alt=""></p><ul><li>这个就是为什么 Buffer 里面，提供了 <a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/buffer/Buffer.java#L88" rel="external nofollow noopener noreferrer" target="_blank"><code>Buffer#obtain(start, end)</code></a> 方法的原因。</li></ul></li></ul><h1 id="4-DataCarrier"><a href="#4-DataCarrier" class="headerlink" title="4. DataCarrier"></a>4. DataCarrier</h1><p><code>org.skywalking.apm.commons.datacarrier.DataCarrier</code> ，DataCarrier 异步处理库的<strong>入口程序</strong>。通过创建 DataCarrier 对象，使用<strong>生产者消费者的模式</strong>，执行异步执行逻辑。</p><p><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/DataCarrier.java#L53" rel="external nofollow noopener noreferrer" target="_blank">构造方法</a> ，代码如下：</p><ul><li><p><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/DataCarrier.java#L47" rel="external nofollow noopener noreferrer" target="_blank"><code>channels</code></a> 属性，<strong>数据</strong>通道。在构造方法中，我们可以看到默认使用 SimpleRollingPartitioner 作为数据分区分配者，使用 <code>BufferStrategy.BLOCKING</code> 作为缓冲策略。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/DataCarrier.java#L66" rel="external nofollow noopener noreferrer" target="_blank"><code>#setPartitioner(IDataPartitioner)</code></a> 方法，设置数据分区分配者。</li><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/DataCarrier.java#L77" rel="external nofollow noopener noreferrer" target="_blank"><code>#setBufferStrategy(BufferStrategy)</code></a> 方法，设置缓冲策略。</li></ul></li><li><p><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/DataCarrier.java#L53" rel="external nofollow noopener noreferrer" target="_blank"><code>channelSize</code></a> 方法参数，通道大小。</p></li><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/DataCarrier.java#L53" rel="external nofollow noopener noreferrer" target="_blank"><code>bufferSize</code></a> 方法参数，缓冲区大小。</li></ul><p><strong>设置消费者和消费线程数量</strong>：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/DataCarrier.java#L107" rel="external nofollow noopener noreferrer" target="_blank"><code>#consume(Class&lt;? extends IConsumer&lt;T&gt;&gt;, num)</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/DataCarrier.java#L124" rel="external nofollow noopener noreferrer" target="_blank"><code>#consume(IConsumer&lt;T&gt;, num)</code></a></li></ul><p><strong>生产消息</strong></p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/DataCarrier.java#L88" rel="external nofollow noopener noreferrer" target="_blank"><code>#produce(data)</code></a></li></ul><p><strong>关闭消费</strong></p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/DataCarrier.java#L138" rel="external nofollow noopener noreferrer" target="_blank"><code>#shutdownConsumers()</code></a></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>本文的图，画的真难看，来自自己的吐槽，哈哈哈。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_15/05.png" alt=""></p><p>胖友，分享一波朋友圈可好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/data-carrier/&quot;&gt;http://www.iocoder.cn/SkyWalking/data-carrier/&lt;/a&gt; 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector Remote 远程通信服务</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-remote-module/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-remote-module/</id>
    <published>2020-09-09T16:00:00.000Z</published>
    <updated>2017-12-25T12:45:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">http://www.iocoder.cn/SkyWalking/collector-remote-module/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">2. collector-remote-define</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">2.1 RemoteModule</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">2.2 RemoteSenderService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">2.3 RemoteClientService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">2.4 RemoteClient</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">2.5 CommonRemoteDataRegisterService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">2.6 RemoteSerializeService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">2.7 RemoteSerializeService</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">3. collector-remote-grpc-provider</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">3.1 RemoteModuleGRPCProvider</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">3.2 GRPCRemoteSenderService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">3.3 GRPCRemoteClientService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">3.4 GRPCRemoteClient</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">3.5 RemoteCommonServiceHandler</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">3.6 GRPCRemoteSerializeService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">3.7 GRPCRemoteDeserializeService</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">4. collector-remote-grpc-provider</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>SkyWalking Collector Remote 远程通信服务</strong>。该服务用于 Collector 集群内部通信。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_10/04.png" alt=""></p><p>目前集群内部通信的目的，跨节点的流式处理。Remote Module <strong>应用</strong>在 SkyWalking 架构图如下位置( <strong>红框</strong> ) ：</p><blockquote><p>FROM <a href="https://github.com/apache/incubating-skywalking" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubating-skywalking</a><br><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_10/01.jpeg" alt=""></p></blockquote><p>下面我们来看看整体的项目结构，如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_10/02.png" alt=""></p><ul><li><code>collector-remote-define</code> ：定义远程通信接口。</li><li><code>collector-remote-kafka-provider</code> ：基于 Kafka 的远程通信实现。<em>目前暂未完成</em>。</li><li><code>collector-remote-grpc-provider</code> ：基于 <a href="https://grpc.io/" rel="external nofollow noopener noreferrer" target="_blank">Google gRPC</a> 的远程通信实现。<strong>生产环境目前使用</strong></li></ul><p>下面，我们从<strong>接口到实现</strong>的顺序进行分享。</p><h1 id="2-collector-remote-define"><a href="#2-collector-remote-define" class="headerlink" title="2. collector-remote-define"></a>2. collector-remote-define</h1><p><code>collector-remote-define</code> ：定义远程通信接口。项目结构如下 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_10/03.png" alt=""></p><p>整体流程如下图：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_10/05.png" alt=""></p><p>我们按照整个流程的处理顺序，逐个解析涉及到的类与接口。</p><h2 id="2-1-RemoteModule"><a href="#2-1-RemoteModule" class="headerlink" title="2.1 RemoteModule"></a>2.1 RemoteModule</h2><p><code>org.skywalking.apm.collector.remote.RemoteModule</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java" rel="external nofollow noopener noreferrer" target="_blank">Module</a> 抽象类，远程通信 Module 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/RemoteModule.java#L34" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回模块名为 <code>&quot;remote&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/RemoteModule.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>#services()</code></a> <strong>实现</strong>方法，返回 Service 类名：RemoteSenderService 、RemoteDataRegisterService 。</p><h2 id="2-2-RemoteSenderService"><a href="#2-2-RemoteSenderService" class="headerlink" title="2.2 RemoteSenderService"></a>2.2 RemoteSenderService</h2><p><code>org.skywalking.apm.collector.remote.service.RemoteSenderService</code> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> 接口，远程发送服务<strong>接口</strong>，定义了 <a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/RemoteSenderService.java#L40" rel="external nofollow noopener noreferrer" target="_blank"><code>#send(graphId, nodeId, data, selector)</code></a> <strong>接口</strong>方法，调用 RemoteClient ，发送数据。</p><ul><li><code>graphId</code> 方法参数，Graph 编号。通过 <code>graphId</code> ，可以查找到对应的 Graph 对象。<ul><li>Graph 在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（一）》「2. apm-collector-core/graph」</a> 有详细解析。</li></ul></li><li><code>nodeId</code> 方法参数，Worker 编号。通过 <code>workerId</code> ，可以查找在 Graph 对象中的 Worker 对象，从而 Graph 中的流式处理。<ul><li>Worker 在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（一）》「3. apm-collector-stream」</a> 有详细解析。</li></ul></li><li><code>data</code> 方法参数，Data 数据对象。例如，流式处理的具体数据对象。<ul><li>Data 在 <a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">《SkyWalking 源码分析 —— Collector Storage 存储组件》「2. apm-collector-core」</a> 有详细解析。</li></ul></li><li><code>selector</code> 方法参数，<a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/Selector.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.remote.service.Selector</code></a> 选择器对象。根据 Selector 对象，使用对应的<strong>负载均衡</strong>策略，选择集群内的 Collector 节点，发送数据。</li><li><a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/RemoteSenderService.java#L45" rel="external nofollow noopener noreferrer" target="_blank">RemoteSenderService.Mode</a> 返回值，发送模式分成 <code>Remote</code> 和 <code>Local</code> 两种方式。前者，发送数据到远程的 Collector 节点；后者，发送数据到本地，即本地处理，参见 <a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/RemoteWorkerRef.java#L58" rel="external nofollow noopener noreferrer" target="_blank"><code>RemoteWorkerRef#in(message)</code></a> 方法。</li></ul><h2 id="2-3-RemoteClientService"><a href="#2-3-RemoteClientService" class="headerlink" title="2.3 RemoteClientService"></a>2.3 RemoteClientService</h2><p><code>org.skywalking.apm.collector.remote.service.RemoteClientService</code> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> 接口，远程客户端服务<strong>接口</strong>，定义了 <a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/RemoteClientService.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>#create(host, port, channelSize, bufferSize)</code></a> <strong>接口</strong>方法，创建 RemoteClient 对象。</p><h2 id="2-4-RemoteClient"><a href="#2-4-RemoteClient" class="headerlink" title="2.4 RemoteClient"></a>2.4 RemoteClient</h2><p><code>org.skywalking.apm.collector.remote.service.RemoteClient</code> ，继承 <code>java.lang.Comparable</code> 接口，远程客户端<strong>接口</strong>。定义了如下接口方法：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/RemoteClient.java#L42" rel="external nofollow noopener noreferrer" target="_blank"><code>#push(graphId, nodeId, data, selector)</code></a> <strong>接口</strong>方法，发送数据。</li><li><a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/RemoteClient.java#L33" rel="external nofollow noopener noreferrer" target="_blank"><code>#getAddress()</code></a> <strong>接口</strong>方法，返回客户端连接的远程 Collector 地址。</li><li><a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/RemoteClient.java#L44" rel="external nofollow noopener noreferrer" target="_blank"><code>#equals(address)</code></a> <strong>接口</strong>方法，判断 RemoteClient 是否连接了指定的地址。</li></ul><h2 id="2-5-CommonRemoteDataRegisterService"><a href="#2-5-CommonRemoteDataRegisterService" class="headerlink" title="2.5 CommonRemoteDataRegisterService"></a>2.5 CommonRemoteDataRegisterService</h2><p>在说 CommonRemoteDataRegisterService 之前，首先来说下 CommonRemoteDataRegisterService 的意图。</p><p>在上文中，我们可以看到发送给 Collector 是 Data 对象，而 <a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/Data.java" rel="external nofollow noopener noreferrer" target="_blank">Data</a> 是数据的<strong>抽象类</strong>，在具体反序列化 Data 对象之前，程序是无法得知它是 Data 的哪个实现对象。这个时候，我们可以给 Data 对象的每个实现类，生成一个对应的<strong>数据协议编号</strong>。</p><ul><li>在发送数据之前，序列化 Data 对象时，增加该 Data 对应的协议编号，一起发送。</li><li>在接收数据之后，反序列化数据时，根据协议编号，创建 Data 对应的实现类对象。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/CommonRemoteDataRegisterService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.remote.service.CommonRemoteDataRegisterService</code></a> ，通用远程数据注册服务。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/CommonRemoteDataRegisterService.java#L40" rel="external nofollow noopener noreferrer" target="_blank"><code>id</code></a> 属性，数据协议自增编号。</li><li><a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/CommonRemoteDataRegisterService.java#L44" rel="external nofollow noopener noreferrer" target="_blank"><code>dataClassMapping</code></a> 属性，数据类型( Class&lt;? extends Data&gt; )与<strong>数据协议编号</strong>的映射。</li><li><a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/CommonRemoteDataRegisterService.java#L48" rel="external nofollow noopener noreferrer" target="_blank"><code>dataInstanceCreatorMapping</code></a> 属性，<strong>数据协议编号</strong>与数据对象创建器( RemoteDataInstanceCreator )的映射。</li></ul><h3 id="2-5-1-RemoteDataRegisterService"><a href="#2-5-1-RemoteDataRegisterService" class="headerlink" title="2.5.1 RemoteDataRegisterService"></a>2.5.1 RemoteDataRegisterService</h3><p><code>org.skywalking.apm.collector.remote.service.RemoteDataRegisterService</code> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> 接口，远程客户端服务<strong>接口</strong>，定义了 <a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/RemoteDataRegisterService.java#L37" rel="external nofollow noopener noreferrer" target="_blank"><code>#register(Class&lt;? extends Data&gt;, RemoteDataInstanceCreator)</code></a> <strong>接口</strong>方法，注册数据类型对应的远程数据创建器( <a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/RemoteDataRegisterService.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>RemoteDataRegisterService.RemoteDataInstanceCreator</code></a> )对象。</p><p>CommonRemoteDataRegisterService 实现了 RemoteDataRegisterService 接口，<a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/CommonRemoteDataRegisterService.java#L56" rel="external nofollow noopener noreferrer" target="_blank"><code>#register(Class&lt;? extends Data&gt;, RemoteDataInstanceCreator)</code></a> <strong>实现</strong>方法。</p><p>另外，<a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/AgentStreamRemoteDataRegister.java#L42" rel="external nofollow noopener noreferrer" target="_blank">AgentStreamRemoteDataRegister</a> 会调用 <a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/RemoteDataRegisterService.java#L37" rel="external nofollow noopener noreferrer" target="_blank"><code>RemoteDataRegisterService#register(Class&lt;? extends Data&gt;, RemoteDataInstanceCreator)</code></a> 方法，注册每个数据类型的 RemoteDataInstanceCreator 对象。注意，例如 <code>Application::new</code> 是 RemoteDataInstanceCreator 的<strong>匿名实现类</strong>。</p><h3 id="2-5-2-RemoteDataIDGetter"><a href="#2-5-2-RemoteDataIDGetter" class="headerlink" title="2.5.2 RemoteDataIDGetter"></a>2.5.2 RemoteDataIDGetter</h3><p><code>org.skywalking.apm.collector.remote.service.RemoteDataIDGetter</code> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> 接口，远程数据协议编号获取器<strong>接口</strong>，定义了 <a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/RemoteDataIDGetter.java#L37" rel="external nofollow noopener noreferrer" target="_blank"><code>#getRemoteDataId(Class&lt;? extends Data&gt;)</code></a> <strong>接口</strong>方法，根据数据类型获取数据协议编号。</p><p>CommonRemoteDataRegisterService 实现了 RemoteDataIDGetter 接口，<a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/CommonRemoteDataRegisterService.java#L67" rel="external nofollow noopener noreferrer" target="_blank"><code>#getRemoteDataId(Class&lt;? extends Data&gt;)</code></a> <strong>实现</strong>方法。</p><h3 id="2-5-3-RemoteDataInstanceCreatorGetter"><a href="#2-5-3-RemoteDataInstanceCreatorGetter" class="headerlink" title="2.5.3 RemoteDataInstanceCreatorGetter"></a>2.5.3 RemoteDataInstanceCreatorGetter</h3><p><code>org.skywalking.apm.collector.remote.service.RemoteDataInstanceCreatorGetter</code> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> 接口，远程数据创建器的获取器<strong>接口</strong>，定义了 <a href="https://github.com/YunaiV/skywalking/blob/f70019926200139f9fe235ade9aaf7724ab72c8b/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/RemoteDataInstanceCreatorGetter.java#L35" rel="external nofollow noopener noreferrer" target="_blank"><code>#getInstanceCreator(remoteDataId</code></a> <strong>接口</strong>方法，根据数据协议编号获得远程数据创建器( RemoteDataInstanceCreator )。</p><p>CommonRemoteDataRegisterService 实现了 RemoteDataInstanceCreatorGetter 接口，<a href="https://github.com/YunaiV/skywalking/blob/f70019926200139f9fe235ade9aaf7724ab72c8b/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/CommonRemoteDataRegisterService.java#L75" rel="external nofollow noopener noreferrer" target="_blank"><code>#getInstanceCreator(remoteDataId)</code></a> <strong>实现</strong>方法。</p><h2 id="2-6-RemoteSerializeService"><a href="#2-6-RemoteSerializeService" class="headerlink" title="2.6 RemoteSerializeService"></a>2.6 RemoteSerializeService</h2><p><code>org.skywalking.apm.collector.remote.service.RemoteSerializeService</code> ，远程通信序列化服务<strong>接口</strong>，定义了 <a href="https://github.com/YunaiV/skywalking/blob/f70019926200139f9fe235ade9aaf7724ab72c8b/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/RemoteSerializeService.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><code>#serialize(Data)</code></a> <strong>接口</strong>方法，序列化数据，生成 Builder 对象。</p><h2 id="2-7-RemoteSerializeService"><a href="#2-7-RemoteSerializeService" class="headerlink" title="2.7 RemoteSerializeService"></a>2.7 RemoteSerializeService</h2><p><code>org.skywalking.apm.collector.remote.service.RemoteDeserializeService</code> ，远程通信序反列化服务<strong>接口</strong>，定义了 <a href="https://github.com/YunaiV/skywalking/blob/f70019926200139f9fe235ade9aaf7724ab72c8b/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/RemoteDeserializeService.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><code>#deserialize(RemoteData, Data)</code></a> <strong>接口</strong>方法，反序列化传输数据。</p><h1 id="3-collector-remote-grpc-provider"><a href="#3-collector-remote-grpc-provider" class="headerlink" title="3. collector-remote-grpc-provider"></a>3. collector-remote-grpc-provider</h1><p><code>collector-remote-grpc-provider</code> ，基于 <a href="https://grpc.io/" rel="external nofollow noopener noreferrer" target="_blank">Google gRPC</a> 的远程通信实现。</p><p>项目结构如下 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_09_10/06.png" alt=""></p><p><strong>默认配置</strong>，在 <a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-core/src/main/resources/application-default.yml#L14" rel="external nofollow noopener noreferrer" target="_blank"><code>application-default.yml</code></a> <strong>已经</strong>配置如下：</p><figure class="highlight"><table><tr><td class="code"><pre><div class="line">remote:</div><div class="line">  gRPC:</div><div class="line">    host: localhost</div><div class="line">    port: 11800</div></pre></td></tr></table></figure><h2 id="3-1-RemoteModuleGRPCProvider"><a href="#3-1-RemoteModuleGRPCProvider" class="headerlink" title="3.1 RemoteModuleGRPCProvider"></a>3.1 RemoteModuleGRPCProvider</h2><p><a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/RemoteModuleGRPCProvider.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.remote.grpc.RemoteModuleGRPCProvider</code></a> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java" rel="external nofollow noopener noreferrer" target="_blank">ModuleProvider</a> <strong>抽象类</strong>，基于 gRPC 的组件服务提供者实现类。</p><p><a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/RemoteModuleGRPCProvider.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回组件服务提供者名为 <code>&quot;gRPC&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/RemoteModuleGRPCProvider.java#L42" rel="external nofollow noopener noreferrer" target="_blank"><code>module()</code></a> <strong>实现</strong>方法，返回组件类为 RemoteModule 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/RemoteModuleGRPCProvider.java#L81" rel="external nofollow noopener noreferrer" target="_blank"><code>#requiredModules()</code></a> <strong>实现</strong>方法，返回依赖组件为 <code>cluster</code> 、<code>gRPC_manager</code> 。</p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/RemoteModuleGRPCProvider.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#prepare(Properties)</code></a> <strong>实现</strong>方法，执行准备阶段逻辑。</p><ul><li>第 53 至 56 行 ：创建 CommonRemoteDataRegisterService 、GRPCRemoteSenderService 对象，并调用 <code>#registerServiceImplementation()</code> <strong>父类</strong>方法，注册到 <code>services</code> 。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/RemoteModuleGRPCProvider.java#L59" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> <strong>实现</strong>方法，执行启动阶段逻辑。</p><ul><li>Server 相关<ul><li>第 65 行：创建 gRPC Server 对象。 </li><li>第 67 行：注册 RemoteCommonServiceHandler 对象到 gRPC Server 上，用于接收 gRPC 请求后的处理。</li><li><a href="http://www.iocoder.cn/SkyWalking/collector-server-component/?self">《SkyWalking 源码分析 —— Collector Server Component 服务器组件》「3. gRPC 实现」</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-grpc-server-module/?self">《SkyWalking 源码分析 —— Collector gRPC Server Manager》</a></li></ul></li><li>注册发现相关<ul><li>第 70 至 71 行：创建 <a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/RemoteModuleGRPCRegistration.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.remote.grpc.RemoteModuleGRPCRegistration</code></a> 对象，将自己注册到集群管理。这样，自己可以被 Collector 集群节点发现，从而被调用。</li><li>第 73 至 74 行：注册 GRPCRemoteSenderService 对象到集群管理。这样，自己可以监听到 Collector 集群节点的加入或离开，从而调用。</li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/?self">《SkyWalking 源码分析 —— Collector Cluster 集群管理》</a> </li></ul></li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/RemoteModuleGRPCProvider.java#L77" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyAfterCompleted()</code></a> <strong>实现</strong>方法，方法为空。</p><h2 id="3-2-GRPCRemoteSenderService"><a href="#3-2-GRPCRemoteSenderService" class="headerlink" title="3.2 GRPCRemoteSenderService"></a>3.2 GRPCRemoteSenderService</h2><p><code>org.skywalking.apm.collector.remote.grpc.service.GRPCRemoteSenderService</code> ，继承 ClusterModuleListener 抽象类，实现 RemoteSenderService 接口，基于 gPRC 的远程发送服务实现类。</p><h3 id="3-2-1-注册发现"><a href="#3-2-1-注册发现" class="headerlink" title="3.2.1 注册发现"></a>3.2.1 注册发现</h3><p>通过继承 ClusterModuleListener 抽象类，实现了监听 Collector 集群节点的加入或离开。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteSenderService.java#L51" rel="external nofollow noopener noreferrer" target="_blank"><code>remoteClients</code></a> 属性，连接 Collector 集群节点的客户端数组。每个 Collector 集群节点，对应一个客户端。</li><li><a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteSenderService.java#L96" rel="external nofollow noopener noreferrer" target="_blank"><code>#path()</code></a> <strong>实现</strong>方法，返回监听的目录 <code>&quot;/&quot; + RemoteModule.NAME + &quot;/&quot; + RemoteModuleGRPCProvider.NAME</code> 。Collector 集群中，每个节点的 Remote Server 都会注册到该目录下。</li><li><a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteSenderService.java#L100" rel="external nofollow noopener noreferrer" target="_blank"><code>#serverJoinNotify(serverAddress)</code></a> <strong>实现</strong>方法，当新的节点加入，<strong>创建</strong>新的客户端连接。</li><li><a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteSenderService.java#L114" rel="external nofollow noopener noreferrer" target="_blank"><code>#serverQuitNotify(serverAddress)</code></a> <strong>实现</strong>方法，当老的节点离开，<strong>移除</strong>对应的客户端连接。</li></ul><h2 id="3-2-2-负载均衡"><a href="#3-2-2-负载均衡" class="headerlink" title="3.2.2 负载均衡"></a>3.2.2 负载均衡</h2><p>RemoteModuleGRPCProvider 基于不同的选择器 ( <a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/Selector.java#L26" rel="external nofollow noopener noreferrer" target="_blank">Selector</a> ) ，提供不同的客户端选择( <a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/selector/RemoteClientSelector.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.remote.grpc.service.selector.RemoteClientSelector</code></a> )实现 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_09_10/07.png" alt=""></p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteSenderService.java#L53" rel="external nofollow noopener noreferrer" target="_blank"><code>hashCodeSelector</code></a> 属性，<a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/selector/HashCodeSelector.java" rel="external nofollow noopener noreferrer" target="_blank">HashCodeSelector</a> ，基于数据的哈希码。</li><li><a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteSenderService.java#L54" rel="external nofollow noopener noreferrer" target="_blank"><code>foreverFirstSelector</code></a> 属性，<a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/selector/ForeverFirstSelector.java" rel="external nofollow noopener noreferrer" target="_blank">ForeverFirstSelector</a> ，基于客户端数组的顺序，选择第一个。</li><li><a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteSenderService.java#L55" rel="external nofollow noopener noreferrer" target="_blank"><code>rollingSelector</code></a> 属性，<a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/selector/RollingSelector.java" rel="external nofollow noopener noreferrer" target="_blank">RollingSelector</a> ，基于客户端数组的顺序，顺序向下选择。</li><li><a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteSenderService.java#L59" rel="external nofollow noopener noreferrer" target="_blank"><code>#send(graphId, nodeId, data, selector)</code></a> 方法，代码如下：<ul><li>第 63 、66 、69 行：根据选择器，调用 <code>RemoteClientSelector#select(clients, data)</code> 方法，选择客户端。</li><li>第 64 、67 、70 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteSenderService.java#L75" rel="external nofollow noopener noreferrer" target="_blank"><code>#sendToRemoteWhenNotSelf(remoteClient, graphId, nodeId, data)</code></a> 方法，发送请求数据。<ul><li>第 76 至 77 行：当选择的客户端连接的是本地时，不发送数据，交给本地处理，参见 <a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/RemoteWorkerRef.java#L58" rel="external nofollow noopener noreferrer" target="_blank"><code>RemoteWorkerRef#in(message)</code></a> 方法。</li><li>第 78 至 81 行：当选择的客户端连接的是远程时，调用 <code>RemoteClient#push(graphId, nodeId, data)</code> 方法，发送数据。</li></ul></li></ul></li></ul><h2 id="3-3-GRPCRemoteClientService"><a href="#3-3-GRPCRemoteClientService" class="headerlink" title="3.3 GRPCRemoteClientService"></a>3.3 GRPCRemoteClientService</h2><p><code>org.skywalking.apm.collector.remote.grpc.service.GRPCRemoteClientService</code> ，实现 RemoteClientService <strong>接口</strong>，基于 gRPC 的远程客户端服务实现类。</p><p><a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteClientService.java#L44" rel="external nofollow noopener noreferrer" target="_blank"><code>#create(host, port, channelSize, bufferSize)</code></a> <strong>实现</strong>方法，创建 GRPCRemoteClient 对象。</p><h2 id="3-4-GRPCRemoteClient"><a href="#3-4-GRPCRemoteClient" class="headerlink" title="3.4 GRPCRemoteClient"></a>3.4 GRPCRemoteClient</h2><blockquote><p>友情提示：本小节会涉及较多 gRPC 相关的知识，建议不熟悉的胖友自己 Google ，补充下姿势。</p></blockquote><p><code>org.skywalking.apm.collector.remote.grpc.service.GRPCRemoteClient</code> ，实现 RemoteClient <strong>接口</strong>，基于 gRPC 的远程客户端实现类。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/4cb80651dee25e985f974d691467a0a53d7dfbe9/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteClient.java#L48" rel="external nofollow noopener noreferrer" target="_blank"><code>client</code></a> 属性，GRPCClient 对象。相比来说，GRPCRemoteClient 偏业务的封装，内部调用 GRPCClient 对象。</li><li><a href="https://github.com/YunaiV/skywalking/blob/4cb80651dee25e985f974d691467a0a53d7dfbe9/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteClient.java#L52" rel="external nofollow noopener noreferrer" target="_blank"><code>carrier</code></a> 属性，DataCarrier 对象，本地消息队列。GRPCRemoteClient 在被调用发送数据时，先提交到本地队列，异步消费进行发送到远程 Collector 节点。DataCarrier 在 <a href="http://www.iocoder.cn/SkyWalking/data-carrier/?self">《SkyWalking 源码分析 —— DataCarrier 异步处理库》</a> 详细解析。<ul><li>第 63 行：调用 <code>DataCarrier#consume(IConsumer, num)</code> 方法，设置消费者为 RemoteMessageConsumer 对象。</li></ul></li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/4cb80651dee25e985f974d691467a0a53d7dfbe9/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteClient.java#L70" rel="external nofollow noopener noreferrer" target="_blank"><code>#push(graphId, nodeId, data)</code></a> <strong>实现</strong>方法，<strong>异步</strong>发送消息到远程 Collector 。</p><ul><li>第 73 行：调用 <code>RemoteDataIDGetter#getRemoteDataId(Class&lt;? extends Data&gt;)</code> 方法，获得<strong>数据协议编号</strong>。</li><li>第 76 至 80 行：创建传输数据( RemoteMessage.Builder ) 对象。RemoteMessage 通过 <a href="https://github.com/google/protobuf" rel="external nofollow noopener noreferrer" target="_blank">Protobuf</a> 创建定义，如下图所示：<img src="http://www.iocoder.cn/images/SkyWalking/2020_09_10/08.png" alt=""></li><li>第 83 行：调用 <code>DataCarrier#produce(data)</code> 方法，发送数据到本地队列。 </li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/4cb80651dee25e985f974d691467a0a53d7dfbe9/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteClient.java#L93" rel="external nofollow noopener noreferrer" target="_blank">RemoteMessageConsumer</a> ，<strong>批量</strong>消费本地队列的数据，逐条发送数据到远程 Collector 节点。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/4cb80651dee25e985f974d691467a0a53d7dfbe9/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteClient.java#L98" rel="external nofollow noopener noreferrer" target="_blank"><code>#consume(List&lt;RemoteMessage&gt;)</code></a> <strong>实现</strong>方法，代码如下：<ul><li>第 100 行：创建 <a href="https://github.com/YunaiV/skywalking/blob/4cb80651dee25e985f974d691467a0a53d7dfbe9/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteClient.java#L118" rel="external nofollow noopener noreferrer" target="_blank">StreamObserver</a> 对象。StreamObserver 主要是 gPRC 相关的 API 的调用。</li><li>第 101 至 103 行：调用 <code>io.grpc.stub.StreamObserver#onNext(RemoteMessage)</code> 方法，逐条发送数据。</li><li>第 106 行：调用 <code>io.grpc.stub.StreamObserver#onCompleted()</code> 方法，全部请求数据发送<strong>完成</strong>。</li></ul></li></ul><h2 id="3-5-RemoteCommonServiceHandler"><a href="#3-5-RemoteCommonServiceHandler" class="headerlink" title="3.5 RemoteCommonServiceHandler"></a>3.5 RemoteCommonServiceHandler</h2><p><code>org.skywalking.apm.collector.remote.grpc.handler.RemoteCommonServiceHandler</code> ，实现 <code>org.skywalking.apm.collector.server.grpc.GRPCHandler</code> 接口，继承 RemoteCommonServiceGrpc.RemoteCommonServiceImplBase <strong>抽象类</strong>，远程通信通用逻辑处理器。</p><p>其中，RemoteCommonServiceGrpc.RemoteCommonServiceImplBase 在 <code>RemoteCommonService.proto</code> 文件的定义如下图：<img src="http://www.iocoder.cn/images/SkyWalking/2020_09_10/09.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/ece7d2e156d4434edcc6ef08a5ed79e2a7b39fa1/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/handler/RemoteCommonServiceHandler.java#L55" rel="external nofollow noopener noreferrer" target="_blank"><code>#call(StreamObserver&lt;Empty&gt;)</code></a> <strong>实现</strong>方法，代码如下：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/ece7d2e156d4434edcc6ef08a5ed79e2a7b39fa1/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/handler/RemoteCommonServiceHandler.java#L57" rel="external nofollow noopener noreferrer" target="_blank"><code>#onNext(RemoteMessage)</code></a> 方法，处理每一条消息，代码如下：<ul><li>第 65 行：调用 <code>RemoteDataInstanceCreatorGetter#getInstanceCreator(remoteDataId)</code> 方法，获得<strong>数据协议编号</strong>对应的 RemoteDataInstanceCreator 对象。然后，调用 <code>RemoteDataInstanceCreator#createInstance(id)</code> 方法，创建<strong>数据协议编号</strong>对应的 Data 实现类对应的对象。</li><li>第 70 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/ece7d2e156d4434edcc6ef08a5ed79e2a7b39fa1/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/GraphManager.java#L60" rel="external nofollow noopener noreferrer" target="_blank"><code>GraphManager#findGraph(graphId)</code></a> 方法，获得 <code>graphId</code> 对应的 Graph 对象。然后，调动 <a href="https://github.com/YunaiV/skywalking/blob/ece7d2e156d4434edcc6ef08a5ed79e2a7b39fa1/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/GraphNodeFinder.java#L52" rel="external nofollow noopener noreferrer" target="_blank"><code>GraphNodeFinder#findNext(nodeId)</code></a> 方法，获得 Next 对象。</li><li>第 71 行：调用 <code>Next#execute(Data)</code> 方法，继续流式处理。</li></ul></li></ul><h2 id="3-6-GRPCRemoteSerializeService"><a href="#3-6-GRPCRemoteSerializeService" class="headerlink" title="3.6 GRPCRemoteSerializeService"></a>3.6 GRPCRemoteSerializeService</h2><p><a href="https://github.com/YunaiV/skywalking/blob/ece7d2e156d4434edcc6ef08a5ed79e2a7b39fa1/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteSerializeService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.remote.grpc.service.GRPCRemoteSerializeService</code></a> ，实现 RemoteSerializeService 接口，基于 gRPC 的远程通信序列化服务实现类。</p><h2 id="3-7-GRPCRemoteDeserializeService"><a href="#3-7-GRPCRemoteDeserializeService" class="headerlink" title="3.7 GRPCRemoteDeserializeService"></a>3.7 GRPCRemoteDeserializeService</h2><p><a href="https://github.com/YunaiV/skywalking/blob/ece7d2e156d4434edcc6ef08a5ed79e2a7b39fa1/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteDeserializeService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.remote.grpc.service.GRPCRemoteDeserializeService</code></a> ，实现 GRPCRemoteDeserializeService 接口，基于 gRPC 的远程通信反序列化服务实现类。</p><h1 id="4-collector-remote-grpc-provider"><a href="#4-collector-remote-grpc-provider" class="headerlink" title="4. collector-remote-grpc-provider"></a>4. collector-remote-grpc-provider</h1><p><code>collector-remote-kafka-provider</code> ：基于 Kafka 的远程通信实现。</p><p><em>目前暂未完成</em>。</p><p>TODO 【4005】collector-remote-grpc-provider</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>写的有丢丢烦躁，不清晰或者错误的地方，胖友望见谅。</p><p>欢迎微信我一起交流。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_10/10.png" alt=""></p><p>胖友，分享一波朋友圈可好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-remote-module/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-remote-module/&lt;/a
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector Cache 缓存组件</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-cache-module/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-cache-module/</id>
    <published>2020-09-04T16:00:00.000Z</published>
    <updated>2017-12-24T03:14:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-cache-module/">http://www.iocoder.cn/SkyWalking/collector-cache-module/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-cache-module/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cache-module/">2. collector-cache-define</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-cache-module/">2.1 CacheModule</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cache-module/">2.2 ApplicationCacheService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cache-module/">2.3 InstanceCacheService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cache-module/">2.4 ServiceNameCacheService</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cache-module/">3. collector-cache-guava-provider</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-cache-module/">3.1 CacheModuleGuavaProvider</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cache-module/">3.2 ApplicationCacheGuavaService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cache-module/">3.3 InstanceCacheGuavaService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cache-module/">3.4 ServiceNameCacheGuavaService</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cache-module/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>SkyWalking Collector Cache Module</strong>，缓存组件。该组件用于缓存 Application 、Instance 、ServiceName 等<strong>常用</strong>且<strong>不变</strong>的数据，以提升性能。</p><blockquote><p>友情提示：本文内容较为简单，胖友可快速阅读。</p></blockquote><p>Cache Module 在 SkyWalking 架构图处于如下位置( <strong>红框</strong> ) ：</p><blockquote><p>FROM <a href="https://github.com/apache/incubating-skywalking" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubating-skywalking</a><br><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_05/01.jpeg" alt=""></p></blockquote><p>下面我们来看看整体的项目结构，如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_05/02.png" alt=""></p><ul><li><code>collector-cache-define</code> ：定义缓存组件接口。</li><li><code>collector-cache-guava-provider</code> ：基于 <a href="https://github.com/google/guava" rel="external nofollow noopener noreferrer" target="_blank">Google Guava</a> 的缓存组件实现。</li></ul><p>下面，我们从<strong>接口到实现</strong>的顺序进行分享。</p><h1 id="2-collector-cache-define"><a href="#2-collector-cache-define" class="headerlink" title="2. collector-cache-define"></a>2. collector-cache-define</h1><p><code>collector-cache-define</code> ：定义队列组件接口。项目结构如下 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_05/03.png" alt=""></p><h2 id="2-1-CacheModule"><a href="#2-1-CacheModule" class="headerlink" title="2.1 CacheModule"></a>2.1 CacheModule</h2><p><code>org.skywalking.apm.collector.cache.CacheModule</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java" rel="external nofollow noopener noreferrer" target="_blank">Module</a> 抽象类，缓存 Module 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ed68f92bf1f5ac397c0bb0a5cc23fa4f3e3c32d1/apm-collector/apm-collector-cache/collector-cache-define/src/main/java/org/skywalking/apm/collector/cache/CacheModule.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回模块名为 <code>&quot;cache&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ed68f92bf1f5ac397c0bb0a5cc23fa4f3e3c32d1/apm-collector/apm-collector-cache/collector-cache-define/src/main/java/org/skywalking/apm/collector/cache/CacheModule.java#L40" rel="external nofollow noopener noreferrer" target="_blank"><code>#services()</code></a> <strong>实现</strong>方法，返回 Service 类名：ApplicationCacheService 、InstanceCacheService 、ServiceIdCacheService 、ServiceNameCacheService 。</p><h2 id="2-2-ApplicationCacheService"><a href="#2-2-ApplicationCacheService" class="headerlink" title="2.2 ApplicationCacheService"></a>2.2 ApplicationCacheService</h2><p><a href="https://github.com/YunaiV/skywalking/blob/ed68f92bf1f5ac397c0bb0a5cc23fa4f3e3c32d1/apm-collector/apm-collector-cache/collector-cache-define/src/main/java/org/skywalking/apm/collector/cache/service/ApplicationCacheService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.cache.service.ApplicationCacheService</code></a> ，应用数据缓存服务<strong>接口</strong>。</p><ul><li>Table ：<a href="https://github.com/YunaiV/skywalking/blob/ed68f92bf1f5ac397c0bb0a5cc23fa4f3e3c32d1/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/register/ApplicationTable.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.register.ApplicationTable</code></a></li><li>Data ：<a href="https://github.com/YunaiV/skywalking/blob/ed68f92bf1f5ac397c0bb0a5cc23fa4f3e3c32d1/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/register/Application.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.register.Application</code></a></li></ul><h2 id="2-3-InstanceCacheService"><a href="#2-3-InstanceCacheService" class="headerlink" title="2.3 InstanceCacheService"></a>2.3 InstanceCacheService</h2><p><a href="https://github.com/YunaiV/skywalking/blob/a1667a9ecf4eecf77cc2390f0af709c3b1bb7e4b/apm-collector/apm-collector-cache/collector-cache-define/src/main/java/org/skywalking/apm/collector/cache/service/InstanceCacheService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.cache.service.InstanceCacheService</code></a> ，应用实例数据缓存服务<strong>接口</strong>。</p><ul><li>Table ：<a href="https://github.com/YunaiV/skywalking/blob/a1667a9ecf4eecf77cc2390f0af709c3b1bb7e4b/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/register/InstanceTable.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.register.InstanceTable</code></a></li><li>Data ：<a href="https://github.com/YunaiV/skywalking/blob/a1667a9ecf4eecf77cc2390f0af709c3b1bb7e4b/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/register/Instance.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.register.Instance</code></a></li></ul><h2 id="2-4-ServiceNameCacheService"><a href="#2-4-ServiceNameCacheService" class="headerlink" title="2.4 ServiceNameCacheService"></a>2.4 ServiceNameCacheService</h2><p><a href="https://github.com/YunaiV/skywalking/blob/a859f4751203d73f10f30bb7c9cf2adfdecf955c/apm-collector/apm-collector-cache/collector-cache-define/src/main/java/org/skywalking/apm/collector/cache/service/ServiceNameCacheService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.cache.service.ServiceNameCacheService</code></a> ，服务名数据缓存服务<strong>接口</strong>。<br><a href="https://github.com/YunaiV/skywalking/blob/a859f4751203d73f10f30bb7c9cf2adfdecf955c/apm-collector/apm-collector-cache/collector-cache-define/src/main/java/org/skywalking/apm/collector/cache/service/ServiceIdCacheService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.cache.service.ServiceIdCacheService</code></a> ，服务编号数据缓存服务<strong>接口</strong>。</p><ul><li>Table ：<a href="https://github.com/YunaiV/skywalking/blob/a859f4751203d73f10f30bb7c9cf2adfdecf955c/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/register/ServiceNameTable.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.register.ServiceNameTable</code></a></li><li>Data ：<a href="https://github.com/YunaiV/skywalking/blob/a859f4751203d73f10f30bb7c9cf2adfdecf955c/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/register/ServiceName.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.register.ServiceName</code></a></li></ul><h1 id="3-collector-cache-guava-provider"><a href="#3-collector-cache-guava-provider" class="headerlink" title="3. collector-cache-guava-provider"></a>3. collector-cache-guava-provider</h1><p><code>collector-cache-guava-provider</code> ，基于 <a href="https://github.com/google/guava" rel="external nofollow noopener noreferrer" target="_blank">Google Guava</a> 的缓存组件实现。</p><p>项目结构如下 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_09_05/04.png" alt=""></p><p><strong>默认配置</strong>，在 <a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-core/src/main/resources/application-default.yml#L5" rel="external nofollow noopener noreferrer" target="_blank"><code>application-default.yml</code></a> <strong>已经</strong>配置如下：</p><figure class="highlight"><table><tr><td class="code"><pre><div class="line">cache:</div><div class="line">  guava:</div></pre></td></tr></table></figure><h2 id="3-1-CacheModuleGuavaProvider"><a href="#3-1-CacheModuleGuavaProvider" class="headerlink" title="3.1 CacheModuleGuavaProvider"></a>3.1 CacheModuleGuavaProvider</h2><p><code>org.skywalking.apm.collector.cache.guava.CacheModuleGuavaProvider</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java" rel="external nofollow noopener noreferrer" target="_blank">ModuleProvider</a> <strong>抽象类</strong>，基于 Guava 的缓存组件服务提供者。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ed68f92bf1f5ac397c0bb0a5cc23fa4f3e3c32d1/apm-collector/apm-collector-cache/collector-cache-guava-provider/src/main/java/org/skywalking/apm/collector/cache/guava/CacheModuleGuavaProvider.java#L44" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回组件服务提供者名为 <code>&quot;guava&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ed68f92bf1f5ac397c0bb0a5cc23fa4f3e3c32d1/apm-collector/apm-collector-cache/collector-cache-guava-provider/src/main/java/org/skywalking/apm/collector/cache/guava/CacheModuleGuavaProvider.java#L48" rel="external nofollow noopener noreferrer" target="_blank"><code>module()</code></a> <strong>实现</strong>方法，返回组件类为 CacheModule 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ed68f92bf1f5ac397c0bb0a5cc23fa4f3e3c32d1/apm-collector/apm-collector-cache/collector-cache-guava-provider/src/main/java/org/skywalking/apm/collector/cache/guava/CacheModuleGuavaProvider.java#L66" rel="external nofollow noopener noreferrer" target="_blank"><code>#requiredModules()</code></a> <strong>实现</strong>方法，返回依赖组件为空。</p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/ed68f92bf1f5ac397c0bb0a5cc23fa4f3e3c32d1/apm-collector/apm-collector-cache/collector-cache-guava-provider/src/main/java/org/skywalking/apm/collector/cache/guava/CacheModuleGuavaProvider.java#L52" rel="external nofollow noopener noreferrer" target="_blank"><code>#prepare(Properties)</code></a> <strong>实现</strong>方法，执行准备阶段逻辑。</p><ul><li>第 44 行 ：创建 ApplicationCacheGuavaService 、InstanceCacheGuavaService 、ServiceIdCacheGuavaService 、ServiceNameCacheGuavaService 对象，并调用 <code>#registerServiceImplementation()</code> <strong>父类</strong>方法，注册到 <code>services</code> 。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/ed68f92bf1f5ac397c0bb0a5cc23fa4f3e3c32d1/apm-collector/apm-collector-cache/collector-cache-guava-provider/src/main/java/org/skywalking/apm/collector/cache/guava/CacheModuleGuavaProvider.java#L59" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> <strong>实现</strong>方法，方法为空。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ed68f92bf1f5ac397c0bb0a5cc23fa4f3e3c32d1/apm-collector/apm-collector-cache/collector-cache-guava-provider/src/main/java/org/skywalking/apm/collector/cache/guava/CacheModuleGuavaProvider.java#L62" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyAfterCompleted()</code></a> <strong>实现</strong>方法，方法为空。</p><h2 id="3-2-ApplicationCacheGuavaService"><a href="#3-2-ApplicationCacheGuavaService" class="headerlink" title="3.2 ApplicationCacheGuavaService"></a>3.2 ApplicationCacheGuavaService</h2><p><a href="https://github.com/YunaiV/skywalking/blob/ed68f92bf1f5ac397c0bb0a5cc23fa4f3e3c32d1/apm-collector/apm-collector-cache/collector-cache-guava-provider/src/main/java/org/skywalking/apm/collector/cache/guava/service/ApplicationCacheGuavaService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.cache.guava.service.ApplicationCacheGuavaService</code></a> ，实现 ApplicationCacheService 接口，基于 Guava 的应用数据缓存服务<strong>实现类</strong>。</p><ul><li>EsDAO ：<a href="https://github.com/YunaiV/skywalking/blob/ed68f92bf1f5ac397c0bb0a5cc23fa4f3e3c32d1/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/ApplicationEsCacheDAO.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.es.dao.ApplicationEsCacheDAO</code></a></li></ul><h2 id="3-3-InstanceCacheGuavaService"><a href="#3-3-InstanceCacheGuavaService" class="headerlink" title="3.3 InstanceCacheGuavaService"></a>3.3 InstanceCacheGuavaService</h2><p><a href="https://github.com/YunaiV/skywalking/blob/a1667a9ecf4eecf77cc2390f0af709c3b1bb7e4b/apm-collector/apm-collector-cache/collector-cache-guava-provider/src/main/java/org/skywalking/apm/collector/cache/guava/service/InstanceCacheGuavaService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.cache.guava.service.InstanceCacheGuavaService</code></a> ，实现 InstanceCacheService 接口，基于 Guava 的应用实例数据缓存服务<strong>实现类</strong>。</p><ul><li>EsDAO ：<a href="https://github.com/YunaiV/skywalking/blob/a1667a9ecf4eecf77cc2390f0af709c3b1bb7e4b/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/InstanceEsCacheDAO.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.es.dao.InstanceEsCacheDAO</code></a></li></ul><h2 id="3-4-ServiceNameCacheGuavaService"><a href="#3-4-ServiceNameCacheGuavaService" class="headerlink" title="3.4 ServiceNameCacheGuavaService"></a>3.4 ServiceNameCacheGuavaService</h2><p><a href="https://github.com/YunaiV/skywalking/blob/a859f4751203d73f10f30bb7c9cf2adfdecf955c/apm-collector/apm-collector-cache/collector-cache-guava-provider/src/main/java/org/skywalking/apm/collector/cache/guava/service/ServiceIdCacheGuavaService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.cache.guava.service.ServiceNameCacheGuavaService</code></a> ，实现 ServiceNameCacheService 接口，基于 Guava 的服务名数据缓存服务<strong>实现类</strong>。<br><a href="https://github.com/YunaiV/skywalking/blob/a859f4751203d73f10f30bb7c9cf2adfdecf955c/apm-collector/apm-collector-cache/collector-cache-guava-provider/src/main/java/org/skywalking/apm/collector/cache/guava/service/ServiceNameCacheGuavaService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.cache.guava.service.ServiceIdCacheGuavaService</code></a> ，实现 ServiceNameCacheService 接口，基于 Guava 的服务编号数据缓存服务<strong>实现类</strong>。</p><ul><li>EsDAO ：<a href="https://github.com/YunaiV/skywalking/blob/a859f4751203d73f10f30bb7c9cf2adfdecf955c/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/ServiceNameEsCacheDAO.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.es.dao.ServiceNameEsCacheDAO</code></a></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>真的是一篇水文，都写的无从下手，只好罗列了相关的类。见谅。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_05/05.png" alt=""></p><p>胖友，分享一波朋友圈可好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-cache-module/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-cache-module/&lt;/a&gt; 
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（二）</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-streaming-second/</id>
    <published>2020-08-31T16:00:00.000Z</published>
    <updated>2017-12-23T23:23:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">http://www.iocoder.cn/SkyWalking/collector-streaming-second/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">2. Data</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">2.1 Collection</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">2.2 DataCollection</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">2.3 Window</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">2.4 DataCache</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">3. AggregationWorker</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">4. PersistenceWorker</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">4.1 WorkerCreateListener</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">4.2 PersistenceTimer</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文接 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（一）》</a> ，主要分享 <strong>Collector Streaming 流式处理的第二部分</strong>。主要包含如下部分：<img src="http://www.iocoder.cn/images/SkyWalking/2020_09_01/01.png" alt=""></p><ul><li>AggregationWorker ：聚合处理数据，后提交 Data 到 Next 节点们处理。</li><li>PersistenceWorker ：聚合处理数据，后存储 Data 。</li></ul><h1 id="2-Data"><a href="#2-Data" class="headerlink" title="2. Data"></a>2. Data</h1><p>AggregationWorker 和 PersistenceWorker ，都先<strong>聚合</strong>处理数据，在进行各自的后续处理。那么聚合处理的数据结果，需要有<strong>容器</strong>进行缓存暂存：</p><ul><li><code>org.skywalking.apm.collector.core.cache</code> ：接口</li><li><code>org.skywalking.apm.collector.stream.worker.impl.data</code> ：实现</li></ul><p>类图如下：<img src="http://www.iocoder.cn/images/SkyWalking/2020_09_01/02.png" alt=""></p><ul><li>Collection ：数据采集，提供有读、写<strong>两个状态</strong>的数据容器。</li><li>Window ：窗口( 😈这个解释怪怪的 )，内有<strong>两个 Collection</strong>。<ul><li>一个 Collection ，负责写入<strong>数据</strong>数据</li><li>一个 Collection ，负责读出<strong>处理</strong>数据</li><li>当写的 Collection <strong>符合处理的条件</strong>，读写 Collection 切换</li></ul></li></ul><h2 id="2-1-Collection"><a href="#2-1-Collection" class="headerlink" title="2.1 Collection"></a>2.1 Collection</h2><p><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Collection.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.core.cache.Collection</code></a> ，数据采集<strong>接口</strong>。</p><ul><li>数据相关 ：<code>#collection()</code> / <code>#size()</code> / <code>#clear()</code></li><li>读相关 ：<code>#reading()</code> / <code>#isReading()</code> / <code>#finishReading()</code></li><li>写相关 ：<code>#writing()</code> / <code>#isWriting()</code> / <code>#finishWriting()</code></li></ul><h2 id="2-2-DataCollection"><a href="#2-2-DataCollection" class="headerlink" title="2.2 DataCollection"></a>2.2 DataCollection</h2><p><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/data/DataCollection.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.stream.worker.impl.data.DataCollection</code></a> ，实现 Collection 接口，数据采集实现类，使用 <a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/data/DataCollection.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>Map&lt;String, Data&gt;</code></a> 作为数据容器。</p><h2 id="2-3-Window"><a href="#2-3-Window" class="headerlink" title="2.3 Window"></a>2.3 Window</h2><p><code>org.skywalking.apm.collector.core.cache.Window</code> ，窗口<strong>抽象类</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L50" rel="external nofollow noopener noreferrer" target="_blank">构造方法</a> ，代码如下：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L44" rel="external nofollow noopener noreferrer" target="_blank"><code>windowDataA</code></a> 属性，窗口数据A 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L48" rel="external nofollow noopener noreferrer" target="_blank"><code>windowDataB</code></a> 属性，窗口数据B 。</li><li>通过 <a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L61" rel="external nofollow noopener noreferrer" target="_blank"><code>#collectionInstance()</code></a> <strong>抽象</strong>方法，创建窗口数据( Collection )对象。</li><li><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>pointer</code></a> 属性，数据指向 <code>windowDataA</code> 或 <code>windowDataA</code>。<ul><li><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L111" rel="external nofollow noopener noreferrer" target="_blank"><code>#getCurrent()</code></a> 方法，获得<strong>现</strong>数据指向，即 <code>pointer</code> 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L118" rel="external nofollow noopener noreferrer" target="_blank"><code>#getLast()</code></a> 方法，获得<strong>原</strong>数据指向，即<strong>非</strong> <code>pointer</code> 。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L33" rel="external nofollow noopener noreferrer" target="_blank"><code>windowSwitch</code></a> 属性，窗口切换计数。</li></ul><hr><p><strong>切换 Collection 相关</strong>，方法如下：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L68" rel="external nofollow noopener noreferrer" target="_blank"><code>#trySwitchPointer()</code></a> 方法，返回是否可以切换 Collection 。可以切换需要满足如下条件：<ul><li>只有<strong>一个调用方</strong>申请切换，通过 <code>windowSwitch</code> 属性进行计数。</li><li><strong>原</strong>数据指向<strong>不处于正在读取状态</strong>。如果切换，一边读一边写，可能会有并发问题。</li><li>无论是否可以切换 Collection ，需要调用 <a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L75" rel="external nofollow noopener noreferrer" target="_blank"><code>#trySwitchPointerFinally()</code></a> 方法，<strong>释放</strong> <code>windowSwitch</code> 的计数。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L82" rel="external nofollow noopener noreferrer" target="_blank"><code>#switchPointer()</code></a> 方法，切换数据指向，并标记<strong>原</strong>数据指向的 Collection <strong>正在读取中</strong>。</li><li><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L129" rel="external nofollow noopener noreferrer" target="_blank"><code>#finishReadingLast()</code></a> 方法，清空<strong>原</strong>数据指向的 Collection 数据，并标记<strong>原</strong>数据指向的 Collection <strong>完成读取</strong>( <strong>不在正在读取中</strong> )。</li></ul><hr><p><strong>写 Collection 相关</strong>，方法如下：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L98" rel="external nofollow noopener noreferrer" target="_blank"><code>#getCurrentAndWriting()</code></a> 方法，获得<strong>现</strong>数据指向，并标记<strong>正在写入中</strong>。通过<strong>正在写入</strong>标记，切换 Collection 完成后，可以判断该 Collection 正在写入中，<strong>若是，等待不在写入中，开始数据读取并处理</strong>。</li></ul><h2 id="2-4-DataCache"><a href="#2-4-DataCache" class="headerlink" title="2.4 DataCache"></a>2.4 DataCache</h2><p><code>org.skywalking.apm.collector.stream.worker.impl.data.DataCache</code> ，实现 Window 抽象类，数据缓存。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/e6e1a7899e7b0e674a61f323447d4b66cffa8136/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/data/DataCache.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><code>#collectionInstance()</code></a> <strong>实现</strong>方法，创建 DataCollection 对象。</li><li><a href="https://github.com/YunaiV/skywalking/blob/e6e1a7899e7b0e674a61f323447d4b66cffa8136/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/data/DataCache.java#L82" rel="external nofollow noopener noreferrer" target="_blank"><code>#currentCollectionSize()</code></a> 方法，获得当前数据指向( 写入 Collection )的数据数量。</li></ul><hr><p><strong>写 Collection 相关</strong>，方法如下：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/e6e1a7899e7b0e674a61f323447d4b66cffa8136/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/data/DataCache.java#L73" rel="external nofollow noopener noreferrer" target="_blank"><code>#writing()</code></a> 方法，调用 <code>#getCurrentAndWriting()</code> 方法，开始写入。即，获得<strong>现</strong>数据指向，并标记<strong>正在写入中</strong>。<ul><li><a href="https://github.com/YunaiV/skywalking/blob/e6e1a7899e7b0e674a61f323447d4b66cffa8136/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/data/DataCache.java#L34" rel="external nofollow noopener noreferrer" target="_blank"><code>lockedDataCollection</code></a> 属性，写入的窗口数据。</li><li><a href="https://github.com/YunaiV/skywalking/blob/e6e1a7899e7b0e674a61f323447d4b66cffa8136/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/data/DataCache.java#L66" rel="external nofollow noopener noreferrer" target="_blank"><code>#put(id, data)</code></a> 方法，向 <code>lockedDataCollection</code> 属性，写入 Data 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/e6e1a7899e7b0e674a61f323447d4b66cffa8136/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/data/DataCache.java#L56" rel="external nofollow noopener noreferrer" target="_blank"><code>#get(id)</code></a> 方法，向 <code>lockedDataCollection</code> 属性，根据 ID 获得 Data 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/e6e1a7899e7b0e674a61f323447d4b66cffa8136/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/data/DataCache.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#containsKey(id)</code></a> 方法，向 <code>lockedDataCollection</code> 属性，根据 ID 判断 Data 是否存在 。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/e6e1a7899e7b0e674a61f323447d4b66cffa8136/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/data/DataCache.java#L89" rel="external nofollow noopener noreferrer" target="_blank"><code>#finishWriting()</code></a> 方法，完成写入。即，标记 <code>lockedDataCollection</code> <strong>不在正在写入中</strong>。</li></ul><h1 id="3-AggregationWorker"><a href="#3-AggregationWorker" class="headerlink" title="3. AggregationWorker"></a>3. AggregationWorker</h1><p><code>org.skywalking.apm.collector.stream.worker.impl.AggregationWorker</code> ，实现 AbstractLocalAsyncWorker 抽象类，<strong>异步聚合</strong> Worker，负责聚合处理数据，后提交 Data 到 Next 节点们处理。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ccd030f6b449954fccc7be4e19c15290e8affc77/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/AggregationWorker.java#L47" rel="external nofollow noopener noreferrer" target="_blank"><strong>构造方法</strong></a> ，代码如下：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/ccd030f6b449954fccc7be4e19c15290e8affc77/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/AggregationWorker.java#L41" rel="external nofollow noopener noreferrer" target="_blank"><code>dataCache</code></a> 属性，数据缓存。</li><li><a href="https://github.com/YunaiV/skywalking/blob/ccd030f6b449954fccc7be4e19c15290e8affc77/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/AggregationWorker.java#L45" rel="external nofollow noopener noreferrer" target="_blank"><code>messageNum</code></a> 属性，消息计数。当超过一定数量( 目前是 100 )，重置计数归零。</li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/ccd030f6b449954fccc7be4e19c15290e8affc77/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/AggregationWorker.java#L52" rel="external nofollow noopener noreferrer" target="_blank"><code>#onWork(message)</code></a> <strong>实现</strong>方法，聚合处理数据，当满足条件时，提交 Data 到 Next 节点们处理。</p><ul><li>第 53 行：<code>messageNum</code> 计数增加。</li><li>第 56 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/ccd030f6b449954fccc7be4e19c15290e8affc77/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/AggregationWorker.java#L97" rel="external nofollow noopener noreferrer" target="_blank"><code>#aggregate(message)</code></a> 方法，聚合消息到数据。</li><li>第 59 至 62 行：<code>messageNum &gt;= 100</code> 时，调用 <a href="https://github.com/YunaiV/skywalking/blob/ccd030f6b449954fccc7be4e19c15290e8affc77/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/AggregationWorker.java#L70" rel="external nofollow noopener noreferrer" target="_blank"><code>#sendToNext()</code></a> ，提交缓存数据的<strong>读 Collection 的数据</strong>给 Next 节点们继续处理。</li><li>第 65 至 67 行：<code>messageNum.endOfBatch == true</code> 时，当消息是批处理的最后一条时，调用 <a href="https://github.com/YunaiV/skywalking/blob/ccd030f6b449954fccc7be4e19c15290e8affc77/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/AggregationWorker.java#L70" rel="external nofollow noopener noreferrer" target="_blank"><code>#sendToNext()</code></a> ，提交缓存数据的<strong>读 Collection 的数据</strong>给 Next 节点们继续处理。</li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/ccd030f6b449954fccc7be4e19c15290e8affc77/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/AggregationWorker.java#L70" rel="external nofollow noopener noreferrer" target="_blank"><code>#sendToNext()</code></a> 方法，提交缓存数据的<strong>读 Collection 的数据</strong>给 Next 节点们继续处理。</p><ul><li>第 72 行：<strong>直接</strong>调用 <code>Window#switchPointer()</code> 方法，切换数据指针，并标记<strong>原</strong>指向正在读取中。这里并未先调用 <code>Window#trySwitchPointer()</code> 方法，<strong>是否会有并发问题</strong>？目前这里是<strong>异步单线程</strong>，所以不会有问题，参见 <a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/?self">《SkyWalking 源码分析 —— Collector Queue 队列组件》</a> 。另外，在 <a href="#">「4. PersistenceWorker」</a> 会看到并发的情况处理。</li><li>第 74 至 80 行：等待<strong>原</strong>指向不在读取中。</li><li>第 82 至 85 行：提交数据给 Next 节点们继续处理。</li><li>第 87 行：标记<strong>原</strong>指向完成读取。</li></ul><h1 id="4-PersistenceWorker"><a href="#4-PersistenceWorker" class="headerlink" title="4. PersistenceWorker"></a>4. PersistenceWorker</h1><p><code>org.skywalking.apm.collector.stream.worker.impl.PersistenceWorker</code> ，实现 AbstractLocalAsyncWorker 抽象类，<strong>异步批量存储</strong> Worker，负责聚合处理数据，后存储 Data 。</p><p>考虑到需要保证存储的时效性，PersistenceWorker 使用 PersistenceTimer ，定时存储 Data ，在 <a href="#">「4.2 PersistenceWorker」</a> 详细解析。</p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/ccd030f6b449954fccc7be4e19c15290e8affc77/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/AggregationWorker.java#L47" rel="external nofollow noopener noreferrer" target="_blank"><strong>构造方法</strong></a> ，代码如下：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/bf563461e75b6717d7b4589d7c3f579acf305541/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/PersistenceWorker.java#L49" rel="external nofollow noopener noreferrer" target="_blank"><code>dataCache</code></a> 属性，数据缓存。</li><li><a href="https://github.com/YunaiV/skywalking/blob/bf563461e75b6717d7b4589d7c3f579acf305541/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/PersistenceWorker.java#L53" rel="external nofollow noopener noreferrer" target="_blank"><code>batchDAO</code></a> 属性，批量操作 DAO ，在 <a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/?self">《SkyWalking 源码分析 —— Collector Storage 存储组件》</a> 有详细解析。</li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/bf563461e75b6717d7b4589d7c3f579acf305541/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/PersistenceWorker.java#L186" rel="external nofollow noopener noreferrer" target="_blank"><code>#needMergeDBData()</code></a> <strong>抽象</strong>方法，存储时，是否需要合并数据。一些 Data 只有新增操作，没有更新操作。</p><p><a href="https://github.com/YunaiV/skywalking/blob/bf563461e75b6717d7b4589d7c3f579acf305541/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/PersistenceWorker.java#L181" rel="external nofollow noopener noreferrer" target="_blank"><code>#persistenceDAO()</code></a> <strong>抽象</strong>方法，获得 Data 对应的持久化 DAO 接口的<strong>实现类</strong>对象。</p><p>上述两个<strong>抽象</strong>方法，用于 <a href="https://github.com/YunaiV/skywalking/blob/bf563461e75b6717d7b4589d7c3f579acf305541/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/PersistenceWorker.java#L121" rel="external nofollow noopener noreferrer" target="_blank"><code>#prepareBatch(dataMap)</code></a> 方法，生成批量操作对象数组，最终调用 <code>IBatchDAO#batchPersistence(List&lt;?&gt;)</code> 方法，通过执行批量操作对象数组，实现批量持久化数据，在 <a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/?self">《SkyWalking 源码分析 —— Collector Storage 存储组件》</a> 有详细解析。</p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/bf563461e75b6717d7b4589d7c3f579acf305541/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/PersistenceWorker.java#L71" rel="external nofollow noopener noreferrer" target="_blank"><code>#onWork(message)</code></a> <strong>实现</strong>方法，当满足条件时存储 Data ，而后聚合数据。这点和 AggregationWorker 相反的，因为要考虑并发问题。代码如下：</p><ul><li>第 72 行：调用 <code>DataCache#currentCollectionSize()</code> 方法，获得当前写入 Collection 的数据数量，判断是否超过 5000 。<ul><li>第 75 行：调用 <code>DataCache#trySwitchPointer()</code> 方法，<strong>判断</strong>是否可以切换 Collection 。通过该判断，保证和 PersistenceTimer 一起时，不会出现<strong>并发问题</strong>。</li><li>第 77 行：调用 <code>Window#switchPointer()</code> 方法，切换数据指针，并标记<strong>原</strong>指向正在读取中。</li><li>第 80 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/bf563461e75b6717d7b4589d7c3f579acf305541/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/PersistenceWorker.java#L100" rel="external nofollow noopener noreferrer" target="_blank"><code>#buildBatchCollection()</code></a> 方法，创建批量操作对象数组。该方法和 <code>AggregationWorker#sendToNext()</code> 方法<strong>基本类似</strong>。</li><li>第 83 行：调用 <code>IBatchDAO#batchPersistence(List&lt;?&gt;)</code> 方法，通过执行批量操作对象数组，实现批量持久化数据。</li><li>第 86 行：调用 <code>DataCache#trySwitchPointerFinally()</code> 方法，<strong>释放</strong> <code>DataCache.windowSwitch</code> 的计数。</li></ul></li><li>第 91 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/bf563461e75b6717d7b4589d7c3f579acf305541/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/PersistenceWorker.java#L164" rel="external nofollow noopener noreferrer" target="_blank"><code>#aggregate(message)</code></a> 方法，聚合数据。该方法和 <code>AggregationWorker#aggregate(message)</code> 方法<strong>基本相似</strong>。</li></ul><h2 id="4-1-WorkerCreateListener"><a href="#4-1-WorkerCreateListener" class="headerlink" title="4.1 WorkerCreateListener"></a>4.1 WorkerCreateListener</h2><p><code>org.skywalking.apm.collector.stream.worker.base.WorkerCreateListener</code> ，Worker 创建监听器。</p><p>Worker 在创建时，会调用 <a href="https://github.com/YunaiV/skywalking/blob/bf563461e75b6717d7b4589d7c3f579acf305541/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/WorkerCreateListener.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><code>WorkerCreateListener#addWorker</code></a> 方法，记录所有的 PersistenceWorker 对象。</p><p><strong>记录下来有什么用呢</strong>？在 <a href="https://github.com/YunaiV/skywalking/blob/bf563461e75b6717d7b4589d7c3f579acf305541/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/AgentStreamBootStartup.java#L47" rel="external nofollow noopener noreferrer" target="_blank">AgentStreamBootStartup</a> 启动时，创建 PersistenceTimer 对象，并将 WorkerCreateListener 记录的 PersistenceWorker 对象集合<strong>传递</strong>给 PersistenceTimer 对象。这样，PersistenceTimer 能够”<strong>访问</strong>“到 PersistenceWorker 对象们的 DataCache ，<strong>定时</strong>存储数据。</p><h2 id="4-2-PersistenceTimer"><a href="#4-2-PersistenceTimer" class="headerlink" title="4.2 PersistenceTimer"></a>4.2 PersistenceTimer</h2><p><code>org.skywalking.apm.collector.stream.timer.PersistenceTimer</code> ，持久化定时任务，负责<strong>定时</strong>、<strong>批量</strong>存储 PersistenceWorker 缓存的数据。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ec95c9966b7e013c8a44ea2e0f748ad339363ce3/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/timer/PersistenceTimer.java#L43" rel="external nofollow noopener noreferrer" target="_blank"><code>#start(IBatchDAO, List&lt;PersistenceWorker&gt;)</code></a> 方法，创建延迟 1 秒，每 1 秒执行一次 <code>#extractDataAndSave()</code> 方法的定时任务，用于<strong>定时</strong>、<strong>批量</strong>存储 PersistenceWorker 缓存的数据。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ec95c9966b7e013c8a44ea2e0f748ad339363ce3/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/timer/PersistenceTimer.java#L52" rel="external nofollow noopener noreferrer" target="_blank"><code>#extractDataAndSave(IBatchDAO, List&lt;PersistenceWorker&gt;)</code></a> 方法，代码如下：</p><ul><li><p>第 55 至 68 行：获得所有 PersistenceWorker 读 Collection 缓存的数据。</p><ul><li>第 60 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/ec95c9966b7e013c8a44ea2e0f748ad339363ce3/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/PersistenceWorker.java#L61" rel="external nofollow noopener noreferrer" target="_blank"><code>PersistenceWorker#flushAndSwitch()</code></a> 切换数据指针，即切换读写 Collection 。</li><li>第 62 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/ec95c9966b7e013c8a44ea2e0f748ad339363ce3/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/PersistenceWorker.java#L100" rel="external nofollow noopener noreferrer" target="_blank"><code>PersistenceWorker#buildBatchCollection()</code></a> 方法，创建批量操作对象数组。</li><li><strong>怎么保证并发安全</strong>？通过 <code>Window#trySwitchPointer()</code> 方法，保证读 Collection <strong>正在被读取中</strong>时，PersistenceWorker 和 PersistenceTimer 有且仅有一个切换队列，读取数据。当读取完成后，调用 <code>Window#finishReadingLast()</code> 方法，清空原数据指向，并标记原数据指向完成正在读取中。</li></ul></li><li><p>第 71 行：调用 <code>IBatchDAO#batchPersistence(List&lt;?&gt;)</code> 方法，执行批量操作，进行存储。</p></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>呼呼，终于把流式处理给写完了，如果写的不详细或者不合适的，胖友看到麻烦告知笔者，谢谢。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_01/03.png" alt=""></p><p>胖友，分享一波朋友圈可好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-streaming-second/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-streaming-seco
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（一）</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-streaming-first/</id>
    <published>2020-08-24T16:00:00.000Z</published>
    <updated>2017-12-25T04:34:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/">http://www.iocoder.cn/SkyWalking/collector-streaming-first/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/">2. apm-collector-core/graph</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/">2.1 Graph 创建</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/">2.2 Graph 启动</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/">3. apm-collector-stream</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/">3.1 WayToNode 实现类</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/">3.2 NodeProcessor 实现类</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Collector Streaming 流式处理</strong>。主要包含如下部分：</p><ul><li><p><code>apm-collector-core</code> 模块的 <code>graph</code> 包，提供<strong>最精简</strong>、<strong>单节点</strong>的流式处理的封装。如下图所示：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/01.png" alt=""></p></li><li><p><code>apm-collector-stream</code> 模块，在 <code>graph</code> 包的基础上，提供<strong>异步</strong>、<strong>跨节点</strong>等等的流式处理的封装。如下图所示：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/02.png" alt=""></p></li></ul><blockquote><p>免打脸大保健：笔者对流式处理非常不了解，本文可能是一本正经的胡说八道。考虑到笔者是靠脸吃饭（颜值我只服我红雷哥），所以读者老爷请爱护下笔者。</p></blockquote><p>Collector Streaming 在 SkyWalking 架构图处于如下位置( <strong>红框</strong> ) ：</p><blockquote><p>FROM <a href="https://github.com/apache/incubating-skywalking" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubating-skywalking</a><br><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/03.jpeg" alt=""></p></blockquote><p>OK，下面来一本正经的代码走起！</p><h1 id="2-apm-collector-core-graph"><a href="#2-apm-collector-core-graph" class="headerlink" title="2. apm-collector-core/graph"></a>2. apm-collector-core/graph</h1><p>整体类图如下：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/04.png" alt=""></p><p>看起来略复杂，不要方，我们先来看一个流式大数据处理框架 Apache Storm 的说明：</p><blockquote><p>FROM <a href="http://www.csdn.net/article/2015-03-09/2824135" rel="external nofollow noopener noreferrer" target="_blank">《流式大数据处理的三种框架：Storm，Spark和Samza》</a><br>在 <a href="https://storm.apache.org/" rel="external nofollow noopener noreferrer" target="_blank">Storm</a> 中，先要设计一个用于实时计算的图状结构，我们称之为拓扑（topology）。这个拓扑将会被提交给集群，由集群中的主控节点（master node）分发代码，将任务分配给工作节点（worker node）执行。</p></blockquote><ul><li>Graph ：定义了一个<strong>数据</strong>在<strong>各个</strong> Node 的处理拓扑图。</li><li>WayToNode ：提交<strong>数据</strong>给 Node 的<strong>方式</strong>。</li><li>Node ：节点，包含一个 NodeProcessor 和 一个 Next 。 <ul><li>NodeProcessor ：Node 处理器，处理<strong>数据</strong>。</li><li>Next ：包含 WayToNode 数组，即 Node 提交<strong>数据</strong>给 Next 的 Node <strong>数组</strong>的<strong>方式</strong>。</li></ul></li></ul><p>整体交互流程如下：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/05.png" alt=""></p><ul><li><strong>粉色</strong>箭头：当数据进来时，提交给 Grpah 。按照定义的拓扑图，使用 NodeWay 提交给 Node ，NodeProcessor 进行处理。</li><li><strong>蓝色</strong>箭头：当 NodeProcessor 处理完成后，Next <strong>逐个</strong>使用 NodeWay <strong>数组</strong>提交给下面的 Node ，继续处理。<ul><li>ps ：<strong>注意</strong>，这块流程，根据不同的 NodeProcessor 的实现类会有不同，<strong>蓝色</strong>箭头的过程，只是<strong>其中的一种</strong>，下面会详细解析。</li></ul></li></ul><p>整体顺序图如下：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/06.png" alt=""></p><ul><li>DirectWay 是 WayToNode <strong>接口</strong>的一种实现，正如其名，<strong>直接</strong>提交数据给 Node 。在 <a href="#">「3. apm-collector-stream」</a> 会看到其他实现，例如提交到其他服务器节点的 Node，从而实现跨服务器节点的流式处理。</li><li>AbstractWorker 在 <code>apm-collector-stream</code> 模块，是 NodeProcessor <strong>接口</strong>的一种实现，处理提交给 Node 的数据。在 <code>#onWork(message)</code> <strong>抽象</strong>方法里，子类可以实现该方法，根据自身需求，是否调用 <code>#onNext(message)</code> 方法，Next 逐个使用 NodeWay 数组提交给下面的 Node ，继续处理。</li></ul><hr><p>下面，我们来详细分别看看如下逻辑的详细代码实现：</p><ul><li>Graph 创建</li><li>Graph 启动</li></ul><h2 id="2-1-Graph-创建"><a href="#2-1-Graph-创建" class="headerlink" title="2.1 Graph 创建"></a>2.1 Graph 创建</h2><p>创建 Graph 的顺序图如下：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/07.png" alt=""></p><ul><li>第一步，调用 <code>GraphManager#createIfAbsent(graphId, input)</code> 方法( <code>input</code> 参数没用 )，创建一个 Graph 对象。</li><li>第二步，调用 <code>Graph#addNode(WayToNode)</code> 方法，创建该 Graph 的<strong>首个</strong> Node 对象。</li><li>第三步，调用 <code>Node#addNext(WayToNode)</code> 方法，创建该 Node 的下一个 Node 对象。</li></ul><p>如下是 <code>collector-agent-stream-provider</code> 模块，<code>TraceStreamGraph#createServiceReferenceGraph()</code> 方法的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createServiceReferenceGraph</span><span class="params">()</span> </span>&#123;</div><div class="line">    QueueCreatorService&lt;ServiceReference&gt; queueCreatorService = moduleManager.find(QueueModule.NAME).getService(QueueCreatorService.class);</div><div class="line">    RemoteSenderService remoteSenderService = moduleManager.find(RemoteModule.NAME).getService(RemoteSenderService.class);</div><div class="line"></div><div class="line">    Graph&lt;ServiceReference&gt; graph = GraphManager.INSTANCE.createIfAbsent(SERVICE_REFERENCE_GRAPH_ID, ServiceReference.class);</div><div class="line">    graph.addNode(<span class="keyword">new</span> ServiceReferenceAggregationWorker.Factory(moduleManager, queueCreatorService).create(workerCreateListener))</div><div class="line">        .addNext(<span class="keyword">new</span> ServiceReferenceRemoteWorker.Factory(moduleManager, remoteSenderService, SERVICE_REFERENCE_GRAPH_ID).create(workerCreateListener))</div><div class="line">        .addNext(<span class="keyword">new</span> ServiceReferencePersistenceWorker.Factory(moduleManager, queueCreatorService).create(workerCreateListener));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>让我们来看看每个方法的具体代码实现。</p><hr><p><strong>第一步</strong></p><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/GraphManager.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>GraphManager#createIfAbsent(graphId, input)</code></a> 方法，创建一个 Graph 对象，并添加到 Graph 映射。代码如下：</p><ul><li><code>INSTANCE</code> 属性，单例。</li><li><code>allGraphs</code> 属性，Graph 映射。其中映射的 KEY 为<strong>每个</strong> Graph 全局唯一编号。在 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/graph/JvmMetricStreamGraph.java" rel="external nofollow noopener noreferrer" target="_blank">JvmMetricStreamGraph</a> 、<a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/graph/RegisterStreamGraph.java" rel="external nofollow noopener noreferrer" target="_blank">RegisterStreamGraph</a> 、<a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/graph/TraceStreamGraph.java" rel="external nofollow noopener noreferrer" target="_blank">TraceStreamGraph</a> 类中，枚举了实际使用的 Graph 编号们。</li><li>第 50 至 58 行：当 Graph 映射里不存在指定 Graph 编号时，创建 Graph 对象，并返回。</li></ul><hr><p><strong>第二步</strong></p><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/Graph.java#L56" rel="external nofollow noopener noreferrer" target="_blank"><code>Graph#addNode(WayToNode)</code></a> 方法，创建该 Graph 的<strong>首个</strong> Node 对象。代码如下：</p><ul><li><code>id</code> 属性，Graph 编号。</li><li><code>entryWay</code>，<strong>首个</strong>提交数据给 Node 的方式。</li><li>第 58 行 ：将方法参数 <code>entryWay</code> 赋值给 <code>this.entryWay</code> 属性。在下分享的 <code>Graph#start(input)</code> 方法里，我们会看到这是 Graph 启动的入口，<strong>首个</strong>提交给 Node 的方式。</li><li>第 60 至 62 行 ：调用 <code>WayToNode#buildDestination(Graph)</code> 方法，创建 Node 对象，并<strong>返回该 Node</strong> 。在上文中，我们已经说过创建的 Node 对象，为该 Graph 的<strong>首个</strong> Node 。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/WayToNode.java#L41" rel="external nofollow noopener noreferrer" target="_blank"><code>WayToNode#buildDestination()</code></a> 方法，创建该 <strong>WayToNode</strong> 的 Node 对象。代码如下：</p><ul><li><code>destination</code> 属性，目标 Node 。即该 WayToNode 提交<strong>数据</strong>到的 Node 。</li><li><code>destinationHandler</code> 属性，目标 Node 的处理器。见 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/WayToNode.java#L47" rel="external nofollow noopener noreferrer" target="_blank"><code>#out(INPUT)</code></a> 方法。</li><li>第 42 行：创建 Node 对象。<ul><li>目前，<code>destinationHandler</code> 属性，除了用于创建 Node 对象，无其他用途。</li></ul></li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/Node.java#L40" rel="external nofollow noopener noreferrer" target="_blank">Node <code>构造方法</code></a> 方法，代码如下：</p><ul><li><code>nodeProcessor</code> 属性，节点处理器。</li><li><code>next</code> 属性，包含 WayToNode 数组，即 Node 提交数据给 Next 的 Node 数组的方式。</li><li>第 44 行：调用 <code>Graph#checkForNewNode(Node)</code> 方法，校验 Node 的 NodeProcessor 在其 Graph 里，<strong>编号唯一</strong>。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/Graph.java#L71" rel="external nofollow noopener noreferrer" target="_blank"><code>Graph#checkForNewNode(Node)</code></a> 方法，校验 Node 的 NodeProcessor 在 Graph 里，<strong>编号唯一</strong>，代码如下：</p><ul><li><code>nodeIndex</code> 属性，处理器编号与 Node 的映射。其中映射的 KEY 为 <code>NodeProcessor#id()</code> 。 </li><li>第 72 至 78 行：校验 Node 的 NodeProcessor 在 Graph 里，<strong>编号唯一</strong>。</li></ul><hr><p><strong>第三步</strong></p><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/Node.java#L51" rel="external nofollow noopener noreferrer" target="_blank"><code>Node#addNext(WayToNode)</code></a> 方法，创建该 Node 的下一个 Node 对象。代码如下：</p><ul><li>第 54 行：调用 <code>WayToNode#buildDestination(Graph)</code> 方法，创建该 Node 的下面的 Node 对象。</li><li>第 56 行：添加创建的 Node 对象到 <code>next</code> 属性。</li><li>第 58 行：返回创建的 Node 对象。</li></ul><h2 id="2-2-Graph-启动"><a href="#2-2-Graph-启动" class="headerlink" title="2.2 Graph 启动"></a>2.2 Graph 启动</h2><p>创建 Graph 的顺序图如下：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/08.png" alt=""></p><table><thead><tr><th>数据流向</th><th>FROM</th><th>TO</th><th>逻辑</th></tr></thead><tbody><tr><td>第一步</td><td>Graph</td><td>WayToNode</td><td></td></tr><tr><td>第二步</td><td>WayToNode</td><td>Node</td><td></td></tr><tr><td>第三步</td><td>Node</td><td>NodeProcessor</td><td></td></tr><tr><td>第四步</td><td>NodeProcessor</td><td>Next</td><td>根据具体实现，若到 Next ，重复第一步</td></tr></tbody></table><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/09.png" alt=""></p><hr><p><strong>第一步</strong></p><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/Graph.java#L48" rel="external nofollow noopener noreferrer" target="_blank"><code>Graph#start(input)</code></a> 方法，启动 Graph ，处理数据。代码如下：</p><ul><li>第 49 行：调用 <code>WayToNode#in(input)</code> 方法，输入数据给 WayToNode 。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/WayToNode.java#L45" rel="external nofollow noopener noreferrer" target="_blank"><code>WayToNode#in(input)</code></a> <strong>抽象</strong>方法，以 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/DirectWay.java#L29" rel="external nofollow noopener noreferrer" target="_blank"><code>DirectWay#in(input)</code></a> <strong>实现</strong>方法举例子，代码如下：</p><ul><li>第 30 行：调用 <code>super#out(input)</code> 方法，<strong>直接</strong>输出数据，调用 <code>Node#execute(input)</code> 方法，提交数据给 Node ，进行处理。</li></ul><hr><p><strong>第二步</strong></p><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/Node.java#L62" rel="external nofollow noopener noreferrer" target="_blank"><code>Node#execute</code></a> 方法，调用 <code>NodeProcessor#process(input, next)</code> 方法，处理数据。</p><hr><p><strong>第三步</strong></p><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/NodeProcessor.java#L34" rel="external nofollow noopener noreferrer" target="_blank"><code>NodeProcessor#process(input, next)</code></a> <strong>接口</strong>方法，以 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/AbstractWorker.java#L62" rel="external nofollow noopener noreferrer" target="_blank"><code>AbstractWorker#process(input, next)</code></a> <strong>实现</strong>方法举例子，代码如下：</p><ul><li>第 64 行：将方法参数 <code>next</code> 赋值给 <code>this.next</code> 属性。<code>this.next</code> 属性，用于封装的 <code>#onNext(OUTPUT)</code> 方法，提交数据给当前 Node 的 Next ( 下面的 Node 们 )继续处理数据。</li><li>第 67 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/AbstractWorker.java#L60" rel="external nofollow noopener noreferrer" target="_blank"><code>#onWork</code></a> <strong>抽象</strong>方法，处理数据。当 AbstractWorker <strong>抽象类</strong>的实现类需要继续讲数据提交给 Next 时，需要在 <code>#onWork</code> 方法里，调用 <code>#onNext(OUTPUT)</code> 方法，例如 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationRegisterRemoteWorker.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>ApplicationRegisterRemoteWorker#onWork(Application)</code></a> 。</li></ul><hr><p><strong>第四步</strong></p><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/Next.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>Next#execute(INPUT)</code></a> 方法，<strong>循环</strong> WayToNode 数组，输入数据给 WayNode ，相当于”<strong>重回</strong>“【第一步】。</p><h1 id="3-apm-collector-stream"><a href="#3-apm-collector-stream" class="headerlink" title="3. apm-collector-stream"></a>3. apm-collector-stream</h1><p>在文章的开头，我们提到了 <code>apm-collector-stream</code> 模块，在 <code>graph</code> 包的基础上，提供<strong>异步</strong>、<strong>跨节点</strong>等等的流式处理的封装。主要在 WayToNode 、NodeProcessor 的实现类上做文章。</p><h2 id="3-1-WayToNode-实现类"><a href="#3-1-WayToNode-实现类" class="headerlink" title="3.1 WayToNode 实现类"></a>3.1 WayToNode 实现类</h2><p>整体类图如下：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/10.png" alt=""></p><h3 id="3-1-1-WorkerRef"><a href="#3-1-1-WorkerRef" class="headerlink" title="3.1.1 WorkerRef"></a>3.1.1 WorkerRef</h3><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/WorkerRef.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.stream.worker.base.WorkerRef</code></a> ，Worker 引用<strong>抽象类</strong>。</p><p>在 <code>apm-collector-stream</code> 模块里，我们会发现类的命名从 Node / NodeProcessor 转向了 Worker ？<strong>这是为什么呢</strong>？关于这一点，我们特意<del>采访</del>( 请教 )了官方大佬。</p><blockquote><p>Worker 更具业务含义<br>Node / Processor 更偏技术含义</p></blockquote><p>目前，WorkerRef 无具体的方法。</p><h3 id="3-1-2-LocalAsyncWorkerRef"><a href="#3-1-2-LocalAsyncWorkerRef" class="headerlink" title="3.1.2 LocalAsyncWorkerRef"></a>3.1.2 LocalAsyncWorkerRef</h3><p><code>org.skywalking.apm.collector.stream.worker.base.LocalAsyncWorkerRef</code> ，异步 Worker 引用<strong>实现类</strong>，提供了<strong>异步</strong>的流式处理封装。</p><p>我们回到 <a href="#">「2.2 Graph 创建」</a> 的【第一步】。</p><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/LocalAsyncWorkerRef.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>LocalAsyncWorkerRef#in(INPUT)</code></a> 方法，代码如下：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/LocalAsyncWorkerRef.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><code>queueEventHandler</code></a> 属性，队列事件处理器。在 <a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/?self">《SkyWalking 源码分析 —— Collector Queue 队列组件》</a> 我们会详细解析它的代码实现，这里只简单介绍下。</li><li>第 47 行：将输入的数据，作为”<strong>事件</strong>“，提交到队列事件处理器中，不再执行后续逻辑。此后，队列事件处理器，会在<strong>后台</strong>处理到该”<strong>事件</strong>“( 数据 )，回调 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/LocalAsyncWorkerRef.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>LocalAsyncWorkerRef#execute</code></a> 方法，从而提交数据到 Worker ( Node )。详细参见 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-queue/collector-queue-disruptor-provider/src/main/java/org/skywalking/apm/collector/queue/disruptor/base/DisruptorEventHandler.java#L54" rel="external nofollow noopener noreferrer" target="_blank">DisruptorEventHandler#onEvent(…)</a> 方法。</li></ul><p><strong>那么为什么会回调呢</strong>？LocalAsyncWorkerRef 实现了 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-queue/collector-queue-define/src/main/java/org/skywalking/apm/collector/queue/base/QueueExecutor.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.queue.base.QueueExecutor</code></a> 接口，它自身被设置到 QueueEventHandler 中， 作为”<strong>事件</strong>“的执行器。</p><p>整体流程如下：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/11.png" alt=""></p><h3 id="3-1-3-RemoteWorkerRef"><a href="#3-1-3-RemoteWorkerRef" class="headerlink" title="3.1.3 RemoteWorkerRef"></a>3.1.3 RemoteWorkerRef</h3><p><code>org.skywalking.apm.collector.stream.worker.base.RemoteWorkerRef</code> ，远程 Worker 引用<strong>实现类</strong>，提供了<strong>远程跨节点</strong>的流式处理的封装。</p><p>我们再回到 <a href="#">「2.2 Graph 创建」</a> 的【第一步】。</p><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/RemoteWorkerRef.java#L53" rel="external nofollow noopener noreferrer" target="_blank"><code>RemoteWorkerRef#in(INPUT)</code></a> 方法，代码如下：</p><ul><li><code>remoteSenderService</code> 属性，远程发送服务。在 <a href="http://www.iocoder.cn/SkyWalking/collector-remote-module?self">《SkyWalking 源码分析 —— Collector Remote 远程通信服务》「3.2 GRPCRemoteSenderService」</a> 我们会详细解析它的代码实现，这里只简单介绍下。</li><li><code>remoteWorker</code> 属性，远程 Worker 。在下文会详细分享它的实现。</li><li>第 56 行：调用 <code>RemoteSenderService#send(...)</code> 方法，根据远程 Worker 的 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/Selector.java" rel="external nofollow noopener noreferrer" target="_blank">Selector 选择器</a>，选择一个 Worker 进行发送。</li><li>第 58 至 60 行：当选择的 Worker 为本地模式( <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/RemoteSenderService.java#L36" rel="external nofollow noopener noreferrer" target="_blank">Mode</a> )时，调用 <code>#out(INPUT)</code> 方法，提交数据到本地的 Worker ( Node )。</li></ul><h2 id="3-2-NodeProcessor-实现类"><a href="#3-2-NodeProcessor-实现类" class="headerlink" title="3.2 NodeProcessor 实现类"></a>3.2 NodeProcessor 实现类</h2><p>整体类图如下：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/12.png" alt=""></p><ul><li><a href="todo"><code>org.skywalking.apm.collector.stream.worker.base.Provider</code></a> ，Worker 供应者<strong>接口</strong>，用于创建 Worker 和 WorkerRef 对象的<strong>工厂</strong>。</li></ul><h3 id="3-2-1-AbstractWorker"><a href="#3-2-1-AbstractWorker" class="headerlink" title="3.2.1 AbstractWorker"></a>3.2.1 AbstractWorker</h3><p>AbstractWorker 的代码实现，在 <a href="#">「2.2 Graph 启动」</a> 已经详细解析。</p><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/AbstractWorkerProvider.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.stream.worker.base.AbstractWorkerProvider</code></a> ，Worker 供应者<strong>抽象类</strong>，定义了 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/AbstractWorkerProvider.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#workerInstance(ModuleManager)</code></a> <strong>抽象</strong>方法，用于创建 Worker 对象。</p><h3 id="3-2-2-AbstractLocalAsyncWorker"><a href="#3-2-2-AbstractLocalAsyncWorker" class="headerlink" title="3.2.2 AbstractLocalAsyncWorker"></a>3.2.2 AbstractLocalAsyncWorker</h3><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/AbstractLocalAsyncWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.stream.worker.base.AbstractLocalAsyncWorker</code></a> ，异步 Worker <strong>抽象类</strong>。</p><p>目前，AbstractLocalAsyncWorker 无具体的方法。</p><p>实际使用时，继承 AbstractLocalAsyncWorker 类，实现 <code>#work(INPUT)</code> 方法，例如：<a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationRegisterSerialWorker.java#L56" rel="external nofollow noopener noreferrer" target="_blank">ApplicationRegisterSerialWorker</a> 。</p><hr><p><code>org.skywalking.apm.collector.stream.worker.base.AbstractLocalAsyncWorkerProvider</code> ，LocalAsyncWorker 供应者<strong>抽象类</strong>。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/AbstractLocalAsyncWorkerProvider.java#L35" rel="external nofollow noopener noreferrer" target="_blank"><code>queueCreatorService</code></a> 属性，队列创建服务，用于创建 QueueEventHandler 对象。</li><li><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/AbstractLocalAsyncWorkerProvider.java#L40" rel="external nofollow noopener noreferrer" target="_blank"><code>#queueSize()</code></a> <strong>抽象</strong>方法，声明队列大小。</li><li><a href=""><code>#create(WorkerCreateListener)</code></a> <strong>实现</strong>方法，创建 AbstractLocalAsyncWorker 和 LocalAsyncWorkerRef 对象。<ul><li>第 51 行：创建 AbstractLocalAsyncWorker <strong>实现类</strong>的对象。参见 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationRegisterSerialWorker.java#L90" rel="external nofollow noopener noreferrer" target="_blank">ApplicationRegisterSerialWorker.Factory#workerInstance(ModuleManager)</a> 方法。</li><li>第 54 行：添加 AbstractLocalAsyncWorker 到 WorkerCreateListener ( Worker 创建监听器 )。WorkerCreateListener 在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（二）》「4.1 WorkerCreateListener」</a> 详细解析。</li><li>第 57 行：创建 LocalAsyncWorkerRef 对象。</li><li>第 60 行：调用 <code>QueueCreatorService#create(...)</code> 方法，创建 QueueEventHandler 对象，<strong>并设置 LocalAsyncWorkerRef 作为它的执行器</strong>。</li><li>第 63 行：设置 LocalAsyncWorkerRef 的 QueueEventHandler 属性。</li></ul></li></ul><h3 id="3-2-3-AbstractRemoteWorker"><a href="#3-2-3-AbstractRemoteWorker" class="headerlink" title="3.2.3 AbstractRemoteWorker"></a>3.2.3 AbstractRemoteWorker</h3><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/AbstractRemoteWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.stream.worker.base.AbstractRemoteWorker</code></a> ，远程 Worker <strong>抽象类</strong>，定义了 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/AbstractRemoteWorker.java#L45" rel="external nofollow noopener noreferrer" target="_blank"><code>#selector()</code></a> <strong>抽象</strong>方法，获得选择器。RemoteSenderService 根据选择器，调用 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/selector/RemoteClientSelector.java#L31" rel="external nofollow noopener noreferrer" target="_blank"><code>RemoteClientSelector#select(...)</code></a> 方法，选择好远程节点，而后进行发送数据。</p><p>实际使用时，继承 AbstractLocalAsyncWorker 类，实现 <code>#work(INPUT)</code> 方法，例如：<a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationRegisterRemoteWorker.java" rel="external nofollow noopener noreferrer" target="_blank">ApplicationRegisterRemoteWorker</a> 。</p><hr><p><code>org.skywalking.apm.collector.stream.worker.base.AbstractRemoteWorkerProvider</code> ，AbstractRemoteWorker 供应者<strong>抽象类</strong>。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/AbstractRemoteWorkerProvider.java#L40" rel="external nofollow noopener noreferrer" target="_blank"><code>remoteSenderService</code></a> 属性，远程发送服务。</li><li><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/AbstractRemoteWorkerProvider.java#L56" rel="external nofollow noopener noreferrer" target="_blank"><code>#create(WorkerCreateListener)</code></a> <strong>实现</strong>方法，创建 AbstractRemoteWorker 和 RemoteWorkerRef 对象。<ul><li>第 58 行：创建 AbstractRemoteWorker <strong>实现类</strong>的对象。参见 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationRegisterRemoteWorker.java#L61" rel="external nofollow noopener noreferrer" target="_blank">ApplicationRegisterRemoteWorker.Factory#workerInstance(ModuleManager)</a> 方法。</li><li>第 61 行：添加 AbstractLocalAsyncWorker 到 WorkerCreateListener ( Worker 创建监听器 )。WorkerCreateListener 在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（二）》「4.1 WorkerCreateListener」</a> 详细解析。</li><li>第 64 行：创建 RemoteWorkerRef 对象。</li></ul></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>呼呼，蛮嗨皮的。卡了一个周末，差点又堕落了。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/13.png" alt=""></p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-streaming-first/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-streaming-first
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector Storage 存储组件</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-storage-module/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-storage-module/</id>
    <published>2020-08-19T16:00:00.000Z</published>
    <updated>2017-12-23T23:29:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">http://www.iocoder.cn/SkyWalking/collector-storage-module/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">2. apm-collector-core</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">2.1 Table</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">2.2 TableDefine</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">2.3 Data</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">3. collector-storage-define</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">3.1 StorageModule</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">3.2 table 包</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">3.3 StorageInstaller</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">3.4 dao 包</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">4. collector-storage-h2-provider</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">5. collector-storage-es-provider</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">5.1 StorageModuleEsProvider</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">5.2 define 包</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">5.3 dao 包</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">5.4 DataTTLKeeperTimer</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>SkyWalking Collector Storage 存储组件</strong>。顾名思义，负责将调用链路、应用、应用实例等等信息存储到存储器，例如，ES 、H2 。</p><blockquote><p>友情提示：建议先阅读 <a href="http://www.iocoder.cn/SkyWalking/collector-init/?self">《SkyWalking 源码分析 —— Collector 初始化》</a> ，以了解 Collector 组件体系。</p><p>FROM <a href="https://github.com/apache/incubating-skywalking" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubating-skywalking</a><br><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_20/01.jpeg" alt=""></p></blockquote><p>下面我们来看看整体的项目结构，如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_20/02.png" alt=""></p><ul><li><code>apm-collector-core</code> 的 <code>data</code> 和 <code>define</code> <strong>包</strong> ：数据的抽象。 </li><li><code>collector-storage-define</code> ：定义存储组件接口。</li><li><code>collector-storage-h2-provider</code> ：基于 H2 的 存储组件实现。<strong>该实现是单机版，建议仅用于 SkyWalking 快速上手，生产环境不建议使用</strong>。</li><li><code>collector-storage-es-provider</code> ：基于 Elasticsearch 的集群管理实现。<strong>生产环境推荐使用</strong>。</li></ul><p>下面，我们从<strong>接口到实现</strong>的顺序进行分享。</p><h1 id="2-apm-collector-core"><a href="#2-apm-collector-core" class="headerlink" title="2. apm-collector-core"></a>2. apm-collector-core</h1><p><code>apm-collector-core</code> 的 <code>data</code> 和 <code>define</code> <strong>包</strong>，如下图所示：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_20/03.png" alt=""></p><p>我们对类进行梳理分类，如下图：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_20/04.png" alt=""></p><ul><li>Table ：Data 和 TableDefine 之间的桥梁，每个 Table 定义了该表的<strong>表名</strong>，<strong>字段名们</strong>。</li><li>TableDefine ：Table 的详细定义，包括<strong>表名</strong>，<strong>字段定义</strong>( ColumnDefine )们。在下文中，<a href="https://github.com/apache/incubator-skywalking/blob/15328202b8b7df89a609885d9110361ff29ce668/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/apache/skywalking/apm/collector/storage/StorageInstaller.java" rel="external nofollow noopener noreferrer" target="_blank">StorageInstaller</a> 会基于 TableDefine 初始化表的相关信息。</li><li>Data ：数据，包括<strong>一条</strong>数据的数据值们和数据字段( Column )们。在下文中，<a href="https://github.com/apache/incubator-skywalking/blob/15328202b8b7df89a609885d9110361ff29ce668/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/apache/skywalking/apm/collector/storage/base/dao/DAO.java" rel="external nofollow noopener noreferrer" target="_blank">Dao</a> 会存储 Data 到存储器中。另外，在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（一）》</a> 中，我们也会看到对 Data 的流式处理<strong>通用</strong>封装。</li></ul><h2 id="2-1-Table"><a href="#2-1-Table" class="headerlink" title="2.1 Table"></a>2.1 Table</h2><p><a href="https://github.com/YunaiV/skywalking/blob/beebd8f8f419ca0b25dc086c71a9b1c580a083d4/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/CommonTable.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.core.data.CommonTable</code></a> ，通用表。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/beebd8f8f419ca0b25dc086c71a9b1c580a083d4/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/CommonTable.java#L33" rel="external nofollow noopener noreferrer" target="_blank"><code>TABLE_TYPE</code></a> <strong>静态</strong>属性，表类型。目前只有 ES 存储组件使用到，下文详细解析。</li><li><a href="https://github.com/YunaiV/skywalking/blob/beebd8f8f419ca0b25dc086c71a9b1c580a083d4/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/CommonTable.java#L37" rel="external nofollow noopener noreferrer" target="_blank"><code>COLUMN_</code></a> 前缀的<strong>静态</strong>属性，通用的字段名。</li></ul><p>在 <code>collector-storage-define</code> 的 <a href="https://github.com/YunaiV/skywalking/tree/beebd8f8f419ca0b25dc086c71a9b1c580a083d4/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table" rel="external nofollow noopener noreferrer" target="_blank"><code>table</code></a> <strong>包</strong>下，我们可以看到所有 Table 类，以 <code>&quot;Table&quot;</code> 结尾。每个 Table 的表名，在每个实现类里，例如 <a href="https://github.com/YunaiV/skywalking/blob/beebd8f8f419ca0b25dc086c71a9b1c580a083d4/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/register/ApplicationTable.java" rel="external nofollow noopener noreferrer" target="_blank">ApplicationTable</a> 。</p><h2 id="2-2-TableDefine"><a href="#2-2-TableDefine" class="headerlink" title="2.2 TableDefine"></a>2.2 TableDefine</h2><p><code>org.skywalking.apm.collector.core.data.TableDefine</code> ，表定义<strong>抽象类</strong>。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/beebd8f8f419ca0b25dc086c71a9b1c580a083d4/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/TableDefine.java#L34" rel="external nofollow noopener noreferrer" target="_blank"><code>name</code></a> 属性，表名。</li><li><a href="https://github.com/YunaiV/skywalking/blob/beebd8f8f419ca0b25dc086c71a9b1c580a083d4/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/TableDefine.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>columnDefines</code></a> 属性，ColumnDefine数组。</li><li><a href="https://github.com/YunaiV/skywalking/blob/578ea4f66f11bdfe5dcda25f574a1ed57ca47d24/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/TableDefine.java#L48" rel="external nofollow noopener noreferrer" target="_blank"><code>#initialize()</code></a> <strong>抽象</strong>方法，初始化表定义。例如：<a href="https://github.com/YunaiV/skywalking/blob/578ea4f66f11bdfe5dcda25f574a1ed57ca47d24/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/define/ApplicationEsTableDefine.java#L38" rel="external nofollow noopener noreferrer" target="_blank">ApplicationEsTableDefine</a> 。</li></ul><p>不同的存储组件实现，有不同的 TableDefine 实现类，如下图：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_20/05.png" alt=""></p><ul><li><p>ElasticSearchTableDefine ：基于 Elasticsearch 的表定义<strong>抽象类</strong>，在 <code>collector-storage-es-provider</code> 的 <a href="https://github.com/YunaiV/skywalking/tree/beebd8f8f419ca0b25dc086c71a9b1c580a083d4/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/define" rel="external nofollow noopener noreferrer" target="_blank"><code>define</code></a> <strong>包</strong>下，我们可以看到<strong>所有</strong> ES 的 TableDefine 类。</p></li><li><p>H2TableDefine ：基于 H2 的表定义<strong>抽象类</strong>，在 <code>collector-storage-h2-provider</code> 的 <a href="https://github.com/YunaiV/skywalking/tree/beebd8f8f419ca0b25dc086c71a9b1c580a083d4/apm-collector/apm-collector-storage/collector-storage-h2-provider/src/main/java/org/skywalking/apm/collector/storage/h2/define" rel="external nofollow noopener noreferrer" target="_blank"><code>define</code></a> <strong>包</strong>下，我们可以看到<strong>所有</strong> H2 的 TableDefine 类。</p></li></ul><h3 id="2-2-1-ColumnDefine"><a href="#2-2-1-ColumnDefine" class="headerlink" title="2.2.1 ColumnDefine"></a>2.2.1 ColumnDefine</h3><p> <a href="https://github.com/YunaiV/skywalking/blob/beebd8f8f419ca0b25dc086c71a9b1c580a083d4/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/ColumnDefine.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.core.data.ColumnDefine</code></a> ，字段定义<strong>抽象类</strong>。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/beebd8f8f419ca0b25dc086c71a9b1c580a083d4/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/ColumnDefine.java#L31" rel="external nofollow noopener noreferrer" target="_blank"><code>name</code></a> 属性，字段名。</li><li><a href="https://github.com/YunaiV/skywalking/blob/beebd8f8f419ca0b25dc086c71a9b1c580a083d4/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/ColumnDefine.java#L35" rel="external nofollow noopener noreferrer" target="_blank"><code>type</code></a> 属性，字段类型。</li></ul><p>在 <code>collector-storage-xxx-provider</code> 模块中，H2ColumnDefine 、ElasticSearchColumnDefine 实现 ColumnDefine 。</p><h3 id="2-2-2-Loader"><a href="#2-2-2-Loader" class="headerlink" title="2.2.2 Loader"></a>2.2.2 Loader</h3><p>涉及到的类如下图所示：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_20/06.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/0aa5e6a49c1f29b43824ebabf6bb7d76b80e3eb7/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/StorageDefineLoader.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.core.data.StorageDefineLoader</code></a> ，调用 <a href="https://github.com/YunaiV/skywalking/blob/0aa5e6a49c1f29b43824ebabf6bb7d76b80e3eb7/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/define/DefinitionLoader.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.core.define.DefinitionLoader</code></a> ，从 <a href="https://github.com/YunaiV/skywalking/blob/0aa5e6a49c1f29b43824ebabf6bb7d76b80e3eb7/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/StorageDefinitionFile.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.core.data.StorageDefinitionFile</code></a> 中，加载 TableDefine 实现类数组。</p><p>另外，在 <code>collector-storage-es-provider</code> 和 <code>collector-storage-h2-provider</code> 里都有 <code>storage.define</code> 文件，如下图：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_20/07.png" alt=""></p><ul><li>StorageDefinitionFile 声明了读取该文件。</li><li><strong>注意</strong>，DefinitionLoader 在加载时，两个文件都会被读取，最终在 <code>StorageInstaller#defineFilter(List&lt;TableDefine&gt;)</code> 方法，进行过滤。</li></ul><p>代码比较简单，中文注释已加，胖友自己阅读理解下。</p><h2 id="2-3-Data"><a href="#2-3-Data" class="headerlink" title="2.3 Data"></a>2.3 Data</h2><p><code>org.skywalking.apm.collector.core.data.Data</code>  ，数据<strong>抽象类</strong>。</p><ul><li><a href=""><code>dataXXX</code></a> <strong>前缀</strong>的属性，字段值们。<ul><li><a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/Data.java#L30" rel="external nofollow noopener noreferrer" target="_blank"><code>dataStrings</code></a> 属性的第一位，是 <strong>ID</strong> 属性。参见 <a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/Data.java#L51" rel="external nofollow noopener noreferrer" target="_blank"><strong>构造方法</strong></a>的【第 51 行】 或者 <a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/Data.java#L142" rel="external nofollow noopener noreferrer" target="_blank"><code>#setId(id)</code></a> 方法。</li></ul></li><li><a href=""><code>xxxColumns</code></a> <strong>后缀</strong>的属性，字段( Column )们。</li><li>通过上述两种属性 + 自身类，可以确定一条数据记录的表、字段类型、字段名、字段值。</li><li><strong>继承</strong> <a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/EndOfBatchQueueMessage.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.core.data.EndOfBatchQueueMessage</code></a> ，带是否消息批处理的最后一条标记的<strong>消息抽象类</strong>，<a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/EndOfBatchQueueMessage.java#L31" rel="external nofollow noopener noreferrer" target="_blank"><code>endOfBatch</code></a> 属性，在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（二）》「3. AggregationWorker」</a> 详细解析。<ul><li><strong>继承</strong> <a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/AbstractHashMessage.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.core.data.AbstractHashMessage</code></a> ，带哈希码的<strong>消息抽象类</strong>，<a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/AbstractHashMessage.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>hashCode</code></a> 属性，在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（二）》「3. AggregationWorker」</a> 详细解析。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/Data.java#L154" rel="external nofollow noopener noreferrer" target="_blank"><code>#mergeData(Data)</code></a> 方法，合并传入的数据到自身。该方法被 <a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/AggregationWorker.java#L94" rel="external nofollow noopener noreferrer" target="_blank"><code>AggregationWorker#aggregate(message)</code></a> 调用，在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（二）》「3. AggregationWorker」</a> 详细解析。</li></ul><p>在 <code>collector-storage-define</code> 的 <a href="https://github.com/YunaiV/skywalking/tree/beebd8f8f419ca0b25dc086c71a9b1c580a083d4/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table" rel="external nofollow noopener noreferrer" target="_blank"><code>table</code></a> <strong>包</strong>下，我们可以看到所有 Data 类，<strong>非</strong> <code>&quot;Table&quot;</code> 结尾，例如 <a href="https://github.com/YunaiV/skywalking/blob/beebd8f8f419ca0b25dc086c71a9b1c580a083d4/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/register/Application.java" rel="external nofollow noopener noreferrer" target="_blank">Application</a> 。</p><h3 id="2-3-1-Column"><a href="#2-3-1-Column" class="headerlink" title="2.3.1 Column"></a>2.3.1 Column</h3><p><a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/Column.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.core.data.Column</code></a> ，字段。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/Column.java#L31" rel="external nofollow noopener noreferrer" target="_blank"><code>name</code></a> 属性，字段名。</li><li><a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/Column.java#L35" rel="external nofollow noopener noreferrer" target="_blank"><code>operation</code></a> 属性，操作( Operation )。</li></ul><h3 id="2-3-2-Operation"><a href="#2-3-2-Operation" class="headerlink" title="2.3.2 Operation"></a>2.3.2 Operation</h3><p><a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/Operation.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.core.data.Operation</code></a> ，操作<strong>接口</strong>。用于两个值之间的操作，例如，相加等等。目前实现类有：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/operator/AddOperation.java" rel="external nofollow noopener noreferrer" target="_blank">AddOperation</a> ：值相加操作。</li><li><a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/operator/CoverOperation.java" rel="external nofollow noopener noreferrer" target="_blank">CoverOperation</a> ：值覆盖操作，即以新值为返回。</li><li><a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/operator/NonOperation.java" rel="external nofollow noopener noreferrer" target="_blank">NonOperation</a> ：空操作，即以老值为返回。</li></ul><h1 id="3-collector-storage-define"><a href="#3-collector-storage-define" class="headerlink" title="3. collector-storage-define"></a>3. collector-storage-define</h1><p><code>collector-cluster-define</code> ：定义存储组件接口。项目结构如下 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_20/08.png" alt=""></p><h2 id="3-1-StorageModule"><a href="#3-1-StorageModule" class="headerlink" title="3.1 StorageModule"></a>3.1 StorageModule</h2><p><code>org.skywalking.apm.collector.storage.StorageModule</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java" rel="external nofollow noopener noreferrer" target="_blank">Module</a> 抽象类，集群管理 Module 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/StorageModule.java#L67" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回模块名为 <code>&quot;storage&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/StorageModule.java#L71" rel="external nofollow noopener noreferrer" target="_blank"><code>#services()</code></a> <strong>实现</strong>方法，返回 Service 类名：在 <a href="https://github.com/YunaiV/skywalking/tree/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/dao" rel="external nofollow noopener noreferrer" target="_blank">org.skywalking.apm.collector.storage.dao</a> <strong>包</strong>下的所有类 和 IBatchDAO。</p><h2 id="3-2-table-包"><a href="#3-2-table-包" class="headerlink" title="3.2 table 包"></a>3.2 table 包</h2><p>在 <a href="https://github.com/YunaiV/skywalking/tree/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table</code></a> 包下，定义了存储模块所有的 Table 和 Data 实现类。</p><h2 id="3-3-StorageInstaller"><a href="#3-3-StorageInstaller" class="headerlink" title="3.3 StorageInstaller"></a>3.3 StorageInstaller</h2><p><code>org.skywalking.apm.collector.storage.StorageInstaller</code> ，存储安装器<strong>抽象类</strong>，基于 TableDefine ，初始化存储组件的表。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/2b700457124e7d4f788343d8bcd9a03d2e273aca/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/StorageInstaller.java#L71" rel="external nofollow noopener noreferrer" target="_blank"><code>#defineFilter(List&lt;TableDefine&gt;)</code></a> <strong>抽象</strong>方法，过滤 TableDefine 数组中，非自身需要的。例如说，ElasticSearchStorageInstaller 过滤后，只保留 ElasticSearchTableDefine 对象。</li><li><a href="https://github.com/YunaiV/skywalking/blob/2b700457124e7d4f788343d8bcd9a03d2e273aca/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/StorageInstaller.java#L81" rel="external nofollow noopener noreferrer" target="_blank"><code>#isExists(Client, TableDefine)</code></a> <strong>抽象</strong>方法，判断表是否存在。</li><li><a href="https://github.com/YunaiV/skywalking/blob/2b700457124e7d4f788343d8bcd9a03d2e273aca/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/StorageInstaller.java#L81" rel="external nofollow noopener noreferrer" target="_blank"><code>#deleteTable(Client, TableDefine)</code></a> <strong>抽象</strong>方法，删除表。</li><li><a href="https://github.com/YunaiV/skywalking/blob/2b700457124e7d4f788343d8bcd9a03d2e273aca/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/StorageInstaller.java#L81" rel="external nofollow noopener noreferrer" target="_blank"><code>#createTable(Client, TableDefine)</code></a> <strong>抽象</strong>方法，创建表。</li><li><a href="https://github.com/YunaiV/skywalking/blob/2b700457124e7d4f788343d8bcd9a03d2e273aca/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/StorageInstaller.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>#install(Client)</code></a> 方法，基于 TableDefine ，初始化存储组件的表。<ul><li>该方法会被 StorageModuleH2Provider 或 StorageModuleEsProvider 启动时调用。</li></ul></li></ul><h2 id="3-4-dao-包"><a href="#3-4-dao-包" class="headerlink" title="3.4 dao 包"></a>3.4 dao 包</h2><p>在 <code>collector-storage-define</code> 项目结构图，我们看到一共有<strong>两</strong>个 <code>bao</code> 包：</p><ul><li><code>org.skywalking.apm.collector.storage.base.dao</code> ，<strong>系统</strong>的 DAO 接口。</li><li><code>org.skywalking.apm.collector.storage.dao</code> ，<strong>业务</strong>的 DAO 接口。<ul><li><strong>继承</strong>系统的 DAO 接口。</li><li>被 <code>collector-storage-xxx-provider</code> 的 <code>dao</code> 包<strong>实现</strong>。</li></ul></li></ul><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_20/09.png" alt=""></p><h3 id="3-4-1-系统-DAO"><a href="#3-4-1-系统-DAO" class="headerlink" title="3.4.1 系统 DAO"></a>3.4.1 系统 DAO</h3><p><a href="https://github.com/YunaiV/skywalking/blob/2b700457124e7d4f788343d8bcd9a03d2e273aca/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/base/dao/DAO.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.base.dao.DAO</code></a> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> 接口，DAO <strong>接口</strong>。</p><p>无任何方法。</p><h4 id="3-4-1-1-AbstractDAO"><a href="#3-4-1-1-AbstractDAO" class="headerlink" title="3.4.1.1 AbstractDAO"></a>3.4.1.1 AbstractDAO</h4><p><a href="https://github.com/YunaiV/skywalking/blob/2b700457124e7d4f788343d8bcd9a03d2e273aca/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/base/dao/AbstractDAO.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.base.dao.AbstractDAO</code></a> ，实现 DAO 接口，DAO 抽象基类。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/2b700457124e7d4f788343d8bcd9a03d2e273aca/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/base/dao/AbstractDAO.java#L33" rel="external nofollow noopener noreferrer" target="_blank"><code>client</code></a> 属性，数据操作客户端。例如，H2Client 、ElasticSearchClient 。</li></ul><p>在 <code>collector-storage-xxx-provider</code> 模块中，H2DAO 、EsDAO 实现 AbstractDAO 。</p><h4 id="3-4-1-2-IPersistenceDAO"><a href="#3-4-1-2-IPersistenceDAO" class="headerlink" title="3.4.1.2 IPersistenceDAO"></a>3.4.1.2 IPersistenceDAO</h4><p><code>org.skywalking.apm.collector.storage.base.dao.IPersistenceDAO</code> ，实现 DAO 接口，持久化 DAO <strong>接口</strong>，定义了 Data 的增删改查操作。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/2b700457124e7d4f788343d8bcd9a03d2e273aca/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/base/dao/IPersistenceDAO.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>#get(id)</code></a> <strong>接口</strong>方法，根据 ID 查询一条 Data 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/2b700457124e7d4f788343d8bcd9a03d2e273aca/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/base/dao/IPersistenceDAO.java#L68" rel="external nofollow noopener noreferrer" target="_blank"><code>#deleteHistory(startTimestamp, endTimestamp)</code></a> <strong>接口</strong>方法，删除时间范围内的 Data 们。</li><li><a href="https://github.com/YunaiV/skywalking/blob/2b700457124e7d4f788343d8bcd9a03d2e273aca/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/base/dao/IPersistenceDAO.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>#prepareBatchInsert(data)</code></a> <strong>接口</strong>方法，准备批量插入操作对象。例如：<a href="https://github.com/YunaiV/skywalking/blob/2b700457124e7d4f788343d8bcd9a03d2e273aca/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/CpuMetricEsPersistenceDAO.java" rel="external nofollow noopener noreferrer" target="_blank"><code>CpuMetricEsPersistenceDAO#prepareBatchInsert(CpuMetric)</code></a> 方法，返回的是 <code>org.elasticsearch.action.index.IndexRequestBuilder</code> 对象。注意：<ul><li>该方法不会发起具体的 DAO 操作，仅仅是创建插入操作对象，最终的执行在 <code>IBatchDAO#batchPersistence(List&lt;?&gt;)</code>。</li><li>该方法创建的是批量插入操作对象们中的一个。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/2b700457124e7d4f788343d8bcd9a03d2e273aca/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/base/dao/IPersistenceDAO.java#L60" rel="external nofollow noopener noreferrer" target="_blank"><code>#prepareBatchUpdate(data)</code></a> <strong>接口</strong>方法，准备批量更新操作对象。类似 <code>#prepareBatchInsert(data)</code> 方法。</li></ul><h4 id="3-4-1-3-IBatchDAO"><a href="#3-4-1-3-IBatchDAO" class="headerlink" title="3.4.1.3 IBatchDAO"></a>3.4.1.3 IBatchDAO</h4><p><code>org.skywalking.apm.collector.storage.base.dao.IBatchDAO</code> ，实现 DAO 接口，批量操作 DAO <strong>接口</strong>。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/2b700457124e7d4f788343d8bcd9a03d2e273aca/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/base/dao/IBatchDAO.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>#batchPersistence(List&lt;?&gt; batchCollection)</code></a> <strong>接口</strong>方法，通过执行批量操作对象数组，实现批量持久化数据。<ul><li><code>batchCollection</code> <strong>方法参数</strong>，通过 <code>IPersistenceDAO#prepareBatchInsert</code> 或 <code>IPersistenceDAO#prepareBatchUpdate</code> 方法，生成<strong>每个</strong>操作数组元素。</li><li>该方法会被 <code>PersistenceTimer#extractDataAndSave(...)</code> 或 <code>PersistenceWorker#onWork(...)</code> 方法调用，在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（二）》「4. PersistenceWorker」</a> 详细解析。</li></ul></li></ul><p>在 <code>collector-storage-xxx-provider</code> 模块中，BatchH2DAO 、BatchEsDAO 实现 IBatchDAO 。</p><h3 id="3-4-2-业务-DAO"><a href="#3-4-2-业务-DAO" class="headerlink" title="3.4.2 业务 DAO"></a>3.4.2 业务 DAO</h3><p>在 <a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/StorageModule.java#L71" rel="external nofollow noopener noreferrer" target="_blank"><code>StorageModule#services()</code></a> 方法里，我们可以看到，业务 DAO 按照<strong>用途</strong>可以拆分成<strong>四种</strong>：</p><ul><li>Cache ：缓存应用、应用实例、服务名</li><li>Register ：注册应用、应用实例、服务名</li><li>Persistence ：持久化，实际可以理解成批量持久化</li><li>UI ：SkyWaling UI 查询使用。</li></ul><p>那么整理如下：</p><table><thead><tr><th>Package</th><th>Data</th><th>Cache / Register</th><th>Persistence</th><th>UI</th><th>关联文章</th></tr></thead><tbody><tr><td>register</td><td>Application</td><td>√</td><td></td><td></td><td></td></tr><tr><td>register</td><td>Instance</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>register</td><td>ServiceName</td><td>√</td><td></td><td></td><td></td></tr><tr><td>jvm</td><td>CpuMetric</td><td></td><td>√</td><td>√</td><td></td></tr><tr><td>jvm</td><td>CMetric</td><td></td><td>√</td><td>√</td><td></td></tr><tr><td>jvm</td><td>MemoryMetric</td><td></td><td>√</td><td>√</td><td></td></tr><tr><td>jvm</td><td>MemoryPoolMetric</td><td></td><td>√</td><td>√</td><td></td></tr><tr><td>global</td><td>GlobalTrace</td><td></td><td>√</td><td>√</td><td></td></tr><tr><td>instance</td><td>InstPerformance</td><td></td><td>√</td><td>√</td><td></td></tr><tr><td>node</td><td>NodeComponent</td><td></td><td>√</td><td>√</td><td></td></tr><tr><td>node</td><td>NodeMapping</td><td></td><td>√</td><td>√</td><td></td></tr><tr><td>noderef</td><td>NodeReference</td><td></td><td>√</td><td>√</td><td></td></tr><tr><td>segment</td><td>SegmentCost</td><td></td><td>√</td><td>√</td><td></td></tr><tr><td>segment</td><td>Segment</td><td></td><td>√</td><td>√</td><td></td></tr><tr><td>service</td><td>ServiceEntry</td><td></td><td>√</td><td>√</td><td></td></tr><tr><td>serviceref</td><td>ServiceReference</td><td></td><td>√</td><td>√</td></tr></tbody></table><h1 id="4-collector-storage-h2-provider"><a href="#4-collector-storage-h2-provider" class="headerlink" title="4. collector-storage-h2-provider"></a>4. collector-storage-h2-provider</h1><p><code>collector-storage-h2-provider</code> ，基于 H2 的存储组件实现。项目结构如下 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_20/12.png" alt=""></p><p><strong>该实现是单机版，建议仅用于 SkyWalking 快速上手，生产环境不建议使用</strong>。</p><p>由于生产环境主要使用 ES 的存储组件实现，所以本文暂不解析相关实现，感兴趣的胖友自己嗨起来。</p><h1 id="5-collector-storage-es-provider"><a href="#5-collector-storage-es-provider" class="headerlink" title="5. collector-storage-es-provider"></a>5. collector-storage-es-provider</h1><p><code>collector-storage-es-provider</code> ，基于 ES 的存储组件实现。项目结构如下 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_20/10.png" alt=""></p><p>实际使用时，通过 <code>application.yml</code> 配置如下：</p><figure class="highlight"><table><tr><td class="code"><pre><div class="line">storage:</div><div class="line">  elasticsearch:</div><div class="line">    cluster_name: elasticsearch</div><div class="line">    cluster_transport_sniffer: true</div><div class="line">    cluster_nodes: 127.0.0.1:9300</div><div class="line">    index_shards_number: 2</div><div class="line">    index_replicas_number: 0</div><div class="line">    ttl: 7</div></pre></td></tr></table></figure><ul><li>生产环境下，推荐 Elasticsearch 配置成集群。</li><li><code>cluster_name</code> 、<code>cluster_transport_sniffer</code> 、<code>cluster_nodes</code> 、<code>index_shards_number</code> 、<code>index_replicas_number</code> 参数，Elasticsearch 相关参数。</li><li><code>ttl</code> ：保留 N 天内的数据。超过 N 天的数据，将被自动滚动删除。<ul><li>该功能目前版本<strong>暂未发布</strong>，需要等到 5.0 版本后。</li></ul></li><li><a href="https://github.com/apache/incubator-skywalking/blob/master/docs/cn/Deploy-collector-in-cluster-mode-CN.md" rel="external nofollow noopener noreferrer" target="_blank">《部署集群collector》</a></li></ul><h2 id="5-1-StorageModuleEsProvider"><a href="#5-1-StorageModuleEsProvider" class="headerlink" title="5.1 StorageModuleEsProvider"></a>5.1 StorageModuleEsProvider</h2><p><code>org.skywalking.apm.collector.storage.es.StorageModuleEsProvider</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java" rel="external nofollow noopener noreferrer" target="_blank">ModuleProvider</a> <strong>抽象类</strong>，基于 ES 的存储组件服务提供者。</p><p><a href="https://github.com/YunaiV/skywalking/blob/7eecc004e69685fe6f5ce3b3dc4822475d6aa713/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/StorageModuleEsProvider.java#L62" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回组件服务提供者名为 <code>&quot;elasticsearch&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/7eecc004e69685fe6f5ce3b3dc4822475d6aa713/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/StorageModuleEsProvider.java#L66" rel="external nofollow noopener noreferrer" target="_blank"><code>module()</code></a> <strong>实现</strong>方法，返回组件类为 StorageModule 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/7eecc004e69685fe6f5ce3b3dc4822475d6aa713/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/StorageModuleEsProvider.java#L119" rel="external nofollow noopener noreferrer" target="_blank"><code>#requiredModules()</code></a> <strong>实现</strong>方法，返回依赖组件为 <code>&quot;cluster&quot;</code> 。</p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/7eecc004e69685fe6f5ce3b3dc4822475d6aa713/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/StorageModuleEsProvider.java#L70" rel="external nofollow noopener noreferrer" target="_blank"><code>#prepare(Properties)</code></a> <strong>实现</strong>方法，执行准备阶段逻辑。</p><ul><li>第 71 至 75 行 ：创建 <a href="https://github.com/YunaiV/skywalking/blob/7eecc004e69685fe6f5ce3b3dc4822475d6aa713/apm-collector/apm-collector-component/client-component/src/main/java/org/skywalking/apm/collector/client/elasticsearch/ElasticSearchClient.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.client.elasticsearch.ElasticSearchClient</code></a> 对象。</li><li>第 77 至 82 行 ：创建 DAO 对象们，并调用 <code>#registerServiceImplementation()</code> <strong>父类</strong>方法，注册到 <code>services</code> 。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/7eecc004e69685fe6f5ce3b3dc4822475d6aa713/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/StorageModuleEsProvider.java#L85" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> <strong>实现</strong>方法，执行启动阶段逻辑。</p><ul><li>第 90 行 ：调用 <code>ElasticSearchClient#initialize()</code> 方法，初始化 ZookeeperClient 。</li><li>第 93 至 94 行 ：创建 ElasticSearchStorageInstaller 对象，初始化存储组件的表。在 <a href="#">「5.2.4 ElasticSearchStorageInstaller」</a> 详细解析。</li><li>第 100 至 102 行 ：创建 <a href="https://github.com/YunaiV/skywalking/blob/7eecc004e69685fe6f5ce3b3dc4822475d6aa713/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/StorageModuleEsRegistration.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.es.StorageModuleEsRegistration</code></a> 对象，并注册信息到集群管理。在 <a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/?self">《SkyWalking 源码分析 —— Collector Cluster 集群管理》</a> 有详细解析。</li><li>第 105 至 107 行 ：创建 <a href="https://github.com/YunaiV/skywalking/blob/7eecc004e69685fe6f5ce3b3dc4822475d6aa713/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/StorageModuleEsNamingListener.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.es.StorageModuleEsNamingListener</code></a> 对象，并注册信息到集群管理。在 <a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/?self">《SkyWalking 源码分析 —— Collector Cluster 集群管理》</a> 有详细解析。</li><li>第 110 至 111 行 ：创建 DataTTLKeeperTimer 对象。在 <a href="#">「5.4 DataTTLKeeperTimer」</a> 详细解析。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/7eecc004e69685fe6f5ce3b3dc4822475d6aa713/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/StorageModuleEsProvider.java#L114" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyAfterCompleted()</code></a> <strong>实现</strong>方法，执行启动完成逻辑。</p><ul><li>第 115 行 ：调用 <code>DataTTLKeeperTimer#start()</code> 方法，启动 DataTTLKeeperTimer 。在本文 <a href="#">「5.4 DataTTLKeeperTimer」</a> 详细解析。</li></ul><h2 id="5-2-define-包"><a href="#5-2-define-包" class="headerlink" title="5.2 define 包"></a>5.2 define 包</h2><p>在 <code>collector-storage-es-provider</code> 项目结构图，我们看到一共有<strong>两</strong>个 <code>define</code> 包：</p><ul><li><code>org.skywalking.apm.collector.storage.es.base.define</code> ，<strong>系统</strong>的 TableDefine 抽象类。</li><li><code>org.skywalking.apm.collector.storage.es.define</code> ，<strong>业务</strong>的 TableDefine 实现类。<ul><li><strong>继承</strong>系统的 TableDefine 抽象类。</li></ul></li></ul><h3 id="5-2-1-ElasticSearchTableDefine"><a href="#5-2-1-ElasticSearchTableDefine" class="headerlink" title="5.2.1 ElasticSearchTableDefine"></a>5.2.1 ElasticSearchTableDefine</h3><p><code>org.skywalking.apm.collector.storage.es.base.define.ElasticSearchTableDefine</code> ，实现 TableDefine 接口，基于 Elasticsearch 的表定义<strong>抽象类</strong>。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/7a4a409e266b953e523dca14a7ba88af07039f57/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/base/define/ElasticSearchTableDefine.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>#type()</code></a> 方法，文档元数据 <code>_type</code> 字段，参见  <a href="http://geosmart.github.io/2016/07/22/Elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#type" rel="external nofollow noopener noreferrer" target="_blank">《Elasticsearch学习笔记》「_type」</a> 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/7a4a409e266b953e523dca14a7ba88af07039f57/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/base/define/ElasticSearchTableDefine.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#refreshInterval()</code></a> <strong>抽象</strong>方法，文档索引刷新频率，参见 <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/near-real-time.html#refresh-api" rel="external nofollow noopener noreferrer" target="_blank">《Elasticsearch: 权威指南 » 基础入门 » 分片内部原理 » 近实时搜索》「refresh API」</a>。</li></ul><h3 id="5-2-2-ElasticSearchColumnDefine"><a href="#5-2-2-ElasticSearchColumnDefine" class="headerlink" title="5.2.2 ElasticSearchColumnDefine"></a>5.2.2 ElasticSearchColumnDefine</h3><p><code>org.skywalking.apm.collector.storage.es.base.define.ElasticSearchColumnDefine</code> ，实现 ColumnDefine 抽象类，基于 ES 的字段定义。</p><ul><li><a href="https://github.com/peng-yongsheng/incubator-skywalking/blob/89c601ba386d30acb04b3713a90b52e6c0d501d8/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/apache/skywalking/apm/collector/storage/es/base/define/ElasticSearchColumnDefine.java#L32" rel="external nofollow noopener noreferrer" target="_blank">Type</a> <strong>枚举</strong>类：枚举 ES 字段类型。</li></ul><h3 id="5-2-3-业务-TableDefine-实现类"><a href="#5-2-3-业务-TableDefine-实现类" class="headerlink" title="5.2.3 业务 TableDefine 实现类"></a>5.2.3 业务 TableDefine 实现类</h3><p>在 <a href="https://github.com/peng-yongsheng/incubator-skywalking/tree/89c601ba386d30acb04b3713a90b52e6c0d501d8/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/apache/skywalking/apm/collector/storage/es/define" rel="external nofollow noopener noreferrer" target="_blank"><code>org.apache.skywalking.apm.collector.storage.es.define</code></a> <strong>包</strong>里，我们可以看到，<strong>所有</strong>基于 ES 的业务 TableDefine 实现类。例如：<a href="https://github.com/peng-yongsheng/incubator-skywalking/blob/89c601ba386d30acb04b3713a90b52e6c0d501d8/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/apache/skywalking/apm/collector/storage/es/define/ApplicationEsTableDefine.java" rel="external nofollow noopener noreferrer" target="_blank">ApplicationEsTableDefine</a> 。</p><p>整体 <code>#refreshInterval()</code> 方法返回的结果如下：</p><ul><li>1 s<ul><li>CpuMetricEsTableDefine</li><li>GCMetricEsTableDefine</li><li>MemoryMetricEsTableDefine</li><li>MemoryPoolMetricEsTableDefine</li></ul></li><li>2 s<ul><li>InstPerformanceEsTableDefine </li><li>NodeComponentEsTableDefine</li><li>NodeMappingEsTableDefine</li><li>NodeReferenceEsTableDefine</li><li>ServiceEntryEsTableDefine</li><li>ServiceReferenceEsTableDefine</li></ul></li><li>2 s &amp;&amp; <a href="https://static.javadoc.io/org.elasticsearch/elasticsearch/5.0.0/org/elasticsearch/action/support/WriteRequest.RefreshPolicy.html#IMMEDIATE" rel="external nofollow noopener noreferrer" target="_blank">WriteRequest.RefreshPolicy.IMMEDIATE</a><ul><li>【WriteRequest.RefreshPolicy.IMMEDIATE】参见 <a href="https://github.com/YunaiV/skywalking/blob/6f925c180fbd1bb543fbf5bbf6fafe118f031d11/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/ApplicationEsRegisterDAO.java#L60" rel="external nofollow noopener noreferrer" target="_blank"><code>ApplicationEsRegisterDAO#save(Application)</code></a> 方法</li><li>ApplicationEsTableDefine</li><li>InstanceEsTableDefine</li><li>ServiceNameEsTableDefine</li></ul></li><li>5 s<ul><li>GlobalTraceEsTableDefine</li><li>SegmentCostEsTableDefine</li></ul></li><li>10 s<ul><li>SegmentEsTableDefine</li></ul></li></ul><h3 id="5-2-4-ElasticSearchStorageInstaller"><a href="#5-2-4-ElasticSearchStorageInstaller" class="headerlink" title="5.2.4 ElasticSearchStorageInstaller"></a>5.2.4 ElasticSearchStorageInstaller</h3><blockquote><p>友情提示：ElasticSearchStorageInstaller 主要是对 Elasticsearch Java API 的使用，所以不熟悉的胖友，可以 Google 下。</p></blockquote><p><code>org.skywalking.apm.collector.storage.es.base.define.ElasticSearchStorageInstaller</code> ，实现 StorageInstaller 抽象类， 基于 ES 存储安装器实现类。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/222024defff2d1a7647dbeb5811cad146c49a604/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/base/define/ElasticSearchStorageInstaller.java#L53" rel="external nofollow noopener noreferrer" target="_blank"><code>#defineFilter(List&lt;TableDefine&gt;)</code></a> <strong>实现</strong>方法，过滤数组中，非 ElasticSearchTableDefine 的元素。</li><li><a href="https://github.com/YunaiV/skywalking/blob/222024defff2d1a7647dbeb5811cad146c49a604/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/base/define/ElasticSearchStorageInstaller.java#L63" rel="external nofollow noopener noreferrer" target="_blank"><code>#createTable(Client, TableDefine)</code></a> <strong>实现</strong>方法，创建 Elasticsearch 索引。<ul><li>文档数据结构如下：<ul><li><code>_id</code> ：数据编号，String 类型。</li><li><code>_type</code> ：<code>&quot;type&quot;</code> 。</li><li><code>_index</code> ：TableDefine 定义的<strong>表名</strong>。</li><li><code>source</code>  ：Data 数据。</li></ul></li><li>了解 Elasticsearch 的胖友可能有和笔者一样的疑惑，网络上很多文章把 <code>_index</code> 类比成关系数据库的 DB ，<code>_type</code> 类比成关系数据库的 Table ，和 SkyWalking 目前使用的方式<strong>不一致</strong>？<ul><li>SkyWalking <a href="https://github.com/peng-yongsheng" rel="external nofollow noopener noreferrer" target="_blank">彭勇升</a> ：<code>_index</code>和 <code>_type</code> 是 ES 特有的，考虑其他数据库接入，所以没有用他这个特性。</li><li>SkyWalking QQ交流群( 392443393 ) ，<a href="#">小心</a> 群友 ：<code>_type</code> 本来就没做物理隔离，Lucene 层面也不存在，ES 6.x 已经废弃了。</li><li><a href="https://elasticsearch.cn/article/158" rel="external nofollow noopener noreferrer" target="_blank">《Elasticsearch 6.0 将移除 Type》</a></li></ul></li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/222024defff2d1a7647dbeb5811cad146c49a604/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/base/define/ElasticSearchStorageInstaller.java#L131" rel="external nofollow noopener noreferrer" target="_blank"><code>#deleteTable(Client, TableDefine)</code></a> <strong>实现</strong>方法，删除 Elasticsearch 索引。</li><li><a href="https://github.com/YunaiV/skywalking/blob/222024defff2d1a7647dbeb5811cad146c49a604/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/base/define/ElasticSearchStorageInstaller.java#L141" rel="external nofollow noopener noreferrer" target="_blank"><code>#isExists(Client, TableDefine)</code></a> <strong>实现</strong>方法，判断 Elasticsearch 索引是否存在。</li><li>在方法里，笔者添加了一些 API 的说明，不熟悉的胖友，可以仔细阅读理解。</li></ul><h2 id="5-3-dao-包"><a href="#5-3-dao-包" class="headerlink" title="5.3 dao 包"></a>5.3 dao 包</h2><p>在 <code>collector-storage-es-provider</code> 项目结构图，我们看到一共有<strong>两</strong>个 <code>dao</code> 包：</p><ul><li><code>org.skywalking.apm.collector.storage.es.base.dao</code> ，<strong>系统</strong>的 DAO 抽象类。</li><li><code>org.skywalking.apm.collector.storage.es.dao</code> ，<strong>业务</strong>的 DAO 实现类。<ul><li><strong>继承</strong>系统的 DAO 抽象类。</li></ul></li></ul><h3 id="5-3-1-EsDAO"><a href="#5-3-1-EsDAO" class="headerlink" title="5.3.1 EsDAO"></a>5.3.1 EsDAO</h3><p><code>org.skywalking.apm.collector.storage.es.base.dao.EsDAO</code> ，实现 AbstractDAO 抽象类，基于 ES 的 DAO <strong>抽象类</strong>。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/6f925c180fbd1bb543fbf5bbf6fafe118f031d11/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/base/dao/EsDAO.java#L49" rel="external nofollow noopener noreferrer" target="_blank"><code>#getMaxId(indexName, columnName)</code></a> 方法，获得索引名的指定字段的<strong>最大值</strong>。</li><li><a href="https://github.com/YunaiV/skywalking/blob/6f925c180fbd1bb543fbf5bbf6fafe118f031d11/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/base/dao/EsDAO.java#L75" rel="external nofollow noopener noreferrer" target="_blank"><code>#getMinId(indexName, columnName)</code></a> 方法，获得索引名的指定字段的<strong>最小值</strong>。</li></ul><h3 id="5-3-2-BatchEsDAO"><a href="#5-3-2-BatchEsDAO" class="headerlink" title="5.3.2 BatchEsDAO"></a>5.3.2 BatchEsDAO</h3><p><code>org.skywalking.apm.collector.storage.es.base.dao.BatchEsDAO</code> ，实现 IBatchDAO 接口，继承 EsDAO 抽象类，基于 ES 批量操作 DAO 实现类。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/6f925c180fbd1bb543fbf5bbf6fafe118f031d11/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/base/dao/BatchEsDAO.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#batchPersistence(List&lt;?&gt;)</code></a> <strong>实现</strong>方法，将 <code>org.elasticsearch.action.index.IndexRequestBuilder</code> 和 <code>org.elasticsearch.action.index.UpdateRequestBuilder</code> 数组，创建成 <code>org.elasticsearch.action.bulk.BulkRequestBuilder</code> 对象，批量持久化。<ul><li>IndexRequestBuilder 和 UpdateRequestBuilder 的创建，在 <a href="#">「5.3.3 业务 DAO 实现类」</a> 会看到。</li></ul></li></ul><h3 id="5-3-3-业务-DAO-实现类"><a href="#5-3-3-业务-DAO-实现类" class="headerlink" title="5.3.3 业务 DAO 实现类"></a>5.3.3 业务 DAO 实现类</h3><p>在 <a href="https://github.com/YunaiV/skywalking/tree/6f925c180fbd1bb543fbf5bbf6fafe118f031d11/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao" rel="external nofollow noopener noreferrer" target="_blank"><code>org.apache.skywalking.apm.collector.storage.es.dao</code></a> <strong>包</strong>里，我们可以看到，<strong>所有</strong>基于 ES 的业务 DAO 实现类。</p><p>实现代码易懂，胖友可以自己阅读。良心如我们，按照 DAO 的业务用途，推荐例子如下：</p><ul><li>Cache ：<a href="https://github.com/YunaiV/skywalking/blob/6f925c180fbd1bb543fbf5bbf6fafe118f031d11/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/ApplicationEsCacheDAO.java" rel="external nofollow noopener noreferrer" target="_blank">ApplicationEsCacheDAO</a></li><li>Register ：<a href="https://github.com/YunaiV/skywalking/blob/6f925c180fbd1bb543fbf5bbf6fafe118f031d11/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/ApplicationEsRegisterDAO.java" rel="external nofollow noopener noreferrer" target="_blank">ApplicationEsRegisterDAO</a> </li><li>Persistence ：<a href="https://github.com/YunaiV/skywalking/blob/6f925c180fbd1bb543fbf5bbf6fafe118f031d11/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/SegmentEsPersistenceDAO.java" rel="external nofollow noopener noreferrer" target="_blank">SegmentEsPersistenceDAO</a><ul><li>此处可见 IndexRequestBuilder 和 UpdateRequestBuilder 的创建。</li></ul></li><li>UI ：<a href="https://github.com/YunaiV/skywalking/blob/6f925c180fbd1bb543fbf5bbf6fafe118f031d11/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/SegmentEsUIDAO.java" rel="external nofollow noopener noreferrer" target="_blank">SegmentEsUIDAO</a> </li></ul><h2 id="5-4-DataTTLKeeperTimer"><a href="#5-4-DataTTLKeeperTimer" class="headerlink" title="5.4 DataTTLKeeperTimer"></a>5.4 DataTTLKeeperTimer</h2><p><code>org.skywalking.apm.collector.storage.es.DataTTLKeeperTimer</code> ，过期数据删除<strong>定时器</strong>。通过该定时器，只保留 N 天内的数据。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/efe2967813b706ae97901d7620fef9d7f975e745/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/DataTTLKeeperTimer.java#L47" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> 方法，启动定时任务。<ul><li>第 49 行：创建延迟 1 小时，每 8 小时执行一次 <code>#delete()</code> 方法的定时任务。目前该行代码被注释，胖友可以等待 SkyWallking 5.0 版本的发布。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/efe2967813b706ae97901d7620fef9d7f975e745/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/DataTTLKeeperTimer.java#L53" rel="external nofollow noopener noreferrer" target="_blank"><code>#delete()</code></a> 方法，删除过期数据。<ul><li>第 54 至 66 行：计算删除的开始与结束时间，即指定时间的<strong>前一天</strong>。例如，2017-12-23 执行时，删除 2017-12-16 那天的数据。</li><li>第 69 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/efe2967813b706ae97901d7620fef9d7f975e745/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/DataTTLKeeperTimer.java#L73" rel="external nofollow noopener noreferrer" target="_blank"><code>#deleteJVMRelatedData(startTimestamp, endTimestamp)</code></a> 方法，删除 JVM 相关的数据。</li><li>第 70 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/efe2967813b706ae97901d7620fef9d7f975e745/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/DataTTLKeeperTimer.java#L87" rel="external nofollow noopener noreferrer" target="_blank"><code>#deleteTraceRelatedData(startTimestamp, endTimestamp)</code></a> 方法，删除 Trace 相关的数据。</li></ul></li></ul><p>如下是<strong>不会删除</strong>的数据的表：</p><ul><li>Application</li><li>Instance</li><li>ServiceName</li><li>ServiceEntry</li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>😈 有种自己把简单的东西写的太复杂了，悲伤。</p><p>胖友望见谅。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_20/11.png" alt=""></p><p>胖友，分享一波朋友圈可好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-storage-module/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-storage-module/&lt;
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector Queue 队列组件</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-queue-module/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-queue-module/</id>
    <published>2020-08-14T16:00:00.000Z</published>
    <updated>2017-12-24T01:26:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/">http://www.iocoder.cn/SkyWalking/collector-queue-module/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/">2. collector-queue-define</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/">2.1 QueueModule</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/">2.2 QueueCreatorService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/">2.3 MessageHolder</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/">2.4 QueueEventHandler</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/">2.5 DaemonThreadFactory</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/">3. collector-queue-disruptor-provider</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/">3.1 QueueModuleDisruptorProvider</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/">2.2 DisruptorQueueCreatorService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/">3.3 DisruptorEventHandler</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/">4. collector-queue-datacarrier-provider</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>SkyWalking Collector Queue Module</strong>，队列组件。该组件被 Collector Streaming Module 流式处理使用，提供<strong>异步</strong>执行的特性。</p><blockquote><p>友情提示：建议先阅读 <a href="http://www.iocoder.cn/SkyWalking/collector-init/?self">《SkyWalking 源码分析 —— Collector 初始化》</a> ，以了解 Collector 组件体系。</p></blockquote><p>Cluster Module 在 SkyWalking 架构图处于如下位置( <strong>红框</strong> ) ：</p><blockquote><p>FROM <a href="https://github.com/apache/incubating-skywalking" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubating-skywalking</a><br><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_15/01.jpeg" alt=""></p></blockquote><p>下面我们来看看整体的项目结构，如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_15/02.png" alt=""></p><ul><li><code>collector-queue-define</code> ：定义队列组件接口。</li><li><code>collector-queue-datacarrier-provider</code> ：基于 <a href="https://github.com/YunaiV/skywalking/tree/master/apm-commons/apm-datacarrier" rel="external nofollow noopener noreferrer" target="_blank">apm-datacarrier</a> 的队列组件实现。<em>目前暂未完成</em>。</li><li><code>collector-queue-zookeeper-provider</code> ：基于 <a href="https://github.com/LMAX-Exchange/disruptor" rel="external nofollow noopener noreferrer" target="_blank">Disruptor</a> 的队列组件实现。</li></ul><p>下面，我们从<strong>接口到实现</strong>的顺序进行分享。</p><h1 id="2-collector-queue-define"><a href="#2-collector-queue-define" class="headerlink" title="2. collector-queue-define"></a>2. collector-queue-define</h1><p><code>collector-queue-define</code> ：定义队列组件接口。项目结构如下 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_15/03.png" alt=""></p><h2 id="2-1-QueueModule"><a href="#2-1-QueueModule" class="headerlink" title="2.1 QueueModule"></a>2.1 QueueModule</h2><p><code>org.skywalking.apm.collector.queue.QueueModule</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java" rel="external nofollow noopener noreferrer" target="_blank">Module</a> 抽象类，队列 Module 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-define/src/main/java/org/skywalking/apm/collector/queue/QueueModule.java#L33" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回模块名为 <code>&quot;queue&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-define/src/main/java/org/skywalking/apm/collector/queue/QueueModule.java#L37" rel="external nofollow noopener noreferrer" target="_blank"><code>#services()</code></a> <strong>实现</strong>方法，返回 Service 类名：QueueCreatorService 。</p><h2 id="2-2-QueueCreatorService"><a href="#2-2-QueueCreatorService" class="headerlink" title="2.2 QueueCreatorService"></a>2.2 QueueCreatorService</h2><p><code>org.skywalking.apm.collector.queue.service.QueueCreatorService</code> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> 接口，队列创建服务<strong>接口</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-define/src/main/java/org/skywalking/apm/collector/queue/service/QueueCreatorService.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>#create(queueSize, executor)</code></a> <strong>接口</strong>方法，创建队列处理器。</p><ul><li>一般情况下，实现该接口方法，调用 <a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-define/src/main/java/org/skywalking/apm/collector/queue/base/QueueCreator.java#L35" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.queue.base.QueueCreator#create(queueSize, executor)</code></a> 方法，创建队列处理器。</li></ul><h2 id="2-3-MessageHolder"><a href="#2-3-MessageHolder" class="headerlink" title="2.3 MessageHolder"></a>2.3 MessageHolder</h2><p><code>org.skywalking.apm.collector.queue.base.MessageHolder</code> ，消息持有者。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-define/src/main/java/org/skywalking/apm/collector/queue/base/MessageHolder.java#L33" rel="external nofollow noopener noreferrer" target="_blank"><code>message</code></a> 属性，持有的消息。</li><li><a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-define/src/main/java/org/skywalking/apm/collector/queue/base/MessageHolder.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#reset()</code></a> 方法，<strong>清空</strong>消息。为什么会有这个方法，下文胖友会看到。</li></ul><h2 id="2-4-QueueEventHandler"><a href="#2-4-QueueEventHandler" class="headerlink" title="2.4 QueueEventHandler"></a>2.4 QueueEventHandler</h2><p><a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-define/src/main/java/org/skywalking/apm/collector/queue/base/QueueEventHandler.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.queue.base.QueueEventHandler</code></a>，队列处理器<strong>接口</strong>。它定义了 <a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-define/src/main/java/org/skywalking/apm/collector/queue/base/QueueEventHandler.java#L33" rel="external nofollow noopener noreferrer" target="_blank"><code>#tell(message)</code></a> <strong>接口</strong>方法，输入消息给自己。最终，QueueEventHandler 会”<strong>提交</strong>“消息给 <a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-define/src/main/java/org/skywalking/apm/collector/queue/base/QueueExecutor.java#L28" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.queue.base.QueueExecutor</code></a>，执行处理该消息。</p><p>LocalAsyncWorkerRef 实现 QueueEventHandler 接口，在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（一）》「3.1.2 LocalAsyncWorkerRef」</a> 有详细解析。</p><h2 id="2-5-DaemonThreadFactory"><a href="#2-5-DaemonThreadFactory" class="headerlink" title="2.5 DaemonThreadFactory"></a>2.5 DaemonThreadFactory</h2><p><a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-define/src/main/java/org/skywalking/apm/collector/queue/base/DaemonThreadFactory.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.queue.base.DaemonThreadFactory</code></a>，守护进程线程<strong>工厂</strong>，被用于创建消息处理器的线程。</p><h1 id="3-collector-queue-disruptor-provider"><a href="#3-collector-queue-disruptor-provider" class="headerlink" title="3. collector-queue-disruptor-provider"></a>3. collector-queue-disruptor-provider</h1><p><code>collector-queue-disruptor-provider</code> ，基于 <a href="https://github.com/LMAX-Exchange/disruptor" rel="external nofollow noopener noreferrer" target="_blank">Disruptor</a> 的队列组件实现。</p><p>项目结构如下 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_15/04.png" alt=""></p><p><strong>默认配置</strong>，在 <a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-core/src/main/resources/application-default.yml#L7" rel="external nofollow noopener noreferrer" target="_blank"><code>application-default.yml</code></a> <strong>已经</strong>配置如下：</p><figure class="highlight"><table><tr><td class="code"><pre><div class="line">queue:</div><div class="line">  disruptor:</div></pre></td></tr></table></figure><h2 id="3-1-QueueModuleDisruptorProvider"><a href="#3-1-QueueModuleDisruptorProvider" class="headerlink" title="3.1 QueueModuleDisruptorProvider"></a>3.1 QueueModuleDisruptorProvider</h2><p><code>org.skywalking.apm.collector.queue.disruptor.CQueueModuleDisruptorProvider</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java" rel="external nofollow noopener noreferrer" target="_blank">ModuleProvider</a> <strong>抽象类</strong>，基于 Disruptor 的队列服务提供者。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-disruptor-provider/src/main/java/org/skywalking/apm/collector/queue/disruptor/QueueModuleDisruptorProvider.java#L35" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回组件服务提供者名为 <code>&quot;disruptor&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-disruptor-provider/src/main/java/org/skywalking/apm/collector/queue/disruptor/QueueModuleDisruptorProvider.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>module()</code></a> <strong>实现</strong>方法，返回组件类为 QueueModule 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-disruptor-provider/src/main/java/org/skywalking/apm/collector/queue/disruptor/QueueModuleDisruptorProvider.java#L55" rel="external nofollow noopener noreferrer" target="_blank"><code>#requiredModules()</code></a> <strong>实现</strong>方法，返回依赖组件为空。</p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-disruptor-provider/src/main/java/org/skywalking/apm/collector/queue/disruptor/QueueModuleDisruptorProvider.java#L43" rel="external nofollow noopener noreferrer" target="_blank"><code>#prepare(Properties)</code></a> <strong>实现</strong>方法，执行准备阶段逻辑。</p><ul><li>第 44 行 ：创建 DisruptorQueueCreatorService 对象，并调用 <code>#registerServiceImplementation()</code> <strong>父类</strong>方法，注册到 <code>services</code> 。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-disruptor-provider/src/main/java/org/skywalking/apm/collector/queue/disruptor/QueueModuleDisruptorProvider.java#L47" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> <strong>实现</strong>方法，方法为空。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-disruptor-provider/src/main/java/org/skywalking/apm/collector/queue/disruptor/QueueModuleDisruptorProvider.java#L51" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyAfterCompleted()</code></a> <strong>实现</strong>方法，方法为空。</p><h2 id="2-2-DisruptorQueueCreatorService"><a href="#2-2-DisruptorQueueCreatorService" class="headerlink" title="2.2 DisruptorQueueCreatorService"></a>2.2 DisruptorQueueCreatorService</h2><p><code>org.skywalking.apm.collector.queue.disruptor.service.DisruptorQueueCreatorService</code> ，实现 QueueCreatorService <strong>接口</strong>，基于 Disruptor 的队列创建服务<strong>实现类</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-disruptor-provider/src/main/java/org/skywalking/apm/collector/queue/disruptor/service/DisruptorQueueCreatorService.java#L42" rel="external nofollow noopener noreferrer" target="_blank"><code>#create(queueSize, executor)</code></a> <strong>实现</strong>方法，调用 <code>DisruptorQueueCreator#register(queueSize, executor)</code> 方法，创建队列处理器。</p><h3 id="3-2-1-DisruptorQueueCreator"><a href="#3-2-1-DisruptorQueueCreator" class="headerlink" title="3.2.1 DisruptorQueueCreator"></a>3.2.1 DisruptorQueueCreator</h3><blockquote><p>友情提示：如果胖友对 Disruptor 暂时不了解，建议先使用 Disruptor 写个小 Demo 。</p><p>如下是笔者阅读的文章：  </p><ul><li><a href="http://colobu.com/2014/08/01/3-steps-to-create-a-disruptor-application/" rel="external nofollow noopener noreferrer" target="_blank">《三步创建Disruptor应用》</a></li><li><a href="http://ifeve.com/disruptor-getting-started/" rel="external nofollow noopener noreferrer" target="_blank">《Disruptor入门》</a></li><li><a href="http://ifeve.com/dissecting-disruptor-whats-so-special/" rel="external nofollow noopener noreferrer" target="_blank">《剖析Disruptor:为什么会这么快？（一）Ringbuffer的特别之处》</a> </li></ul></blockquote><p><code>org.skywalking.apm.collector.queue.disruptor.base.DisruptorQueueCreator</code> ，实现 QueueCreator <strong>接口</strong>，基于 Disruptor 的队列创建器<strong>实现类</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-disruptor-provider/src/main/java/org/skywalking/apm/collector/queue/disruptor/base/DisruptorQueueCreator.java#L41" rel="external nofollow noopener noreferrer" target="_blank"><code>#create(queueSize, executor)</code></a> <strong>实现</strong>方法，代码如下：</p><ul><li>第 42 至 45 行：<strong>校验</strong>队列大小为 2 的指数，否则创建 Disruptor 对象会报 <code>&quot;bufferSize must be a power of 2&quot;</code> 的异常，参见 <a href="https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/AbstractSequencer.java#L50" rel="external nofollow noopener noreferrer" target="_blank">AbstractSequencer</a> 的代码。</li><li>第 49 行：<strong>创建</strong> Disruptor 对象。<ul><li><a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-disruptor-provider/src/main/java/org/skywalking/apm/collector/queue/disruptor/base/MessageHolderFactory.java#L29" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.queue.disruptor.base.MessageHolderFactory</code></a> ，MessageHolder <strong>工厂</strong>。</li></ul></li><li>第 51 至 64 行：设置 Disruptor 对象的<strong>默认异常处理器</strong>。</li><li>第 67 至 70 行：创建 DisruptorEventHandler 对象，并设置为 Disruptor 对象的<strong>事件处理器</strong>。</li><li>第 74 行：<strong>启动</strong> Disruptor 对象。</li></ul><p><strong>为什么 Disruptor 要求队列大小为 2 的指数呢</strong>？如下是相关资料，感兴趣的同学可以看看( 可跳过 )：</p><ul><li>FROM <a href="https://zh.wikipedia.org/wiki/%E7%92%B0%E5%BD%A2%E7%B7%A9%E8%A1%9D%E5%8D%80#Linux.E5.86.85.E6.A0.B8.E7.9A.84kfifo" rel="external nofollow noopener noreferrer" target="_blank">《环形缓冲器》</a></li></ul><blockquote><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_15/05.png" alt=""></p></blockquote><ul><li><code>SingleProducerSequencer#hasAvailableCapacity(requiredCapacity)</code> 方法，代码如下：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_15/06.png" alt=""></li></ul><h2 id="3-3-DisruptorEventHandler"><a href="#3-3-DisruptorEventHandler" class="headerlink" title="3.3 DisruptorEventHandler"></a>3.3 DisruptorEventHandler</h2><p><code>org.skywalking.apm.collector.queue.disruptor.base.DisruptorEventHandler</code> ，基于 Disruptor 的队列处理器<strong>实现类</strong>。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/0feb6bce291fa945eff5bf52100c82c960851143/apm-collector/apm-collector-queue/collector-queue-disruptor-provider/src/main/java/org/skywalking/apm/collector/queue/disruptor/base/DisruptorEventHandler.java#L43" rel="external nofollow noopener noreferrer" target="_blank"><code>ringBuffer</code></a> 属性，Disruptor RingBuffer 对象。</li><li><a href="https://github.com/YunaiV/skywalking/blob/0feb6bce291fa945eff5bf52100c82c960851143/apm-collector/apm-collector-queue/c方法参数ollector-queue-disruptor-provider/src/main/java/org/skywalking/apm/collector/queue/disruptor/base/DisruptorEventHandler.java#L47" rel="external nofollow noopener noreferrer" target="_blank"><code>executor</code></a> 属性，执行器。</li><li>实现 <code>org.skywalking.apm.collector.queue.base.QueueEventHandler</code> <strong>接口</strong> 的 <a href="https://github.com/YunaiV/skywalking/blob/0feb6bce291fa945eff5bf52100c82c960851143/apm-collector/apm-collector-queue/collector-queue-disruptor-provider/src/main/java/org/skywalking/apm/collector/queue/disruptor/base/DisruptorEventHandler.java#L80" rel="external nofollow noopener noreferrer" target="_blank"><code>#tell(message)</code></a> 接口方法，标准的 Disruptor 发布事件的代码。</li><li>实现 <a href="https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/EventHandler.java" rel="external nofollow noopener noreferrer" target="_blank"><code>com.lmax.disruptor.EventHandler</code></a> 的 <a href="https://github.com/YunaiV/skywalking/blob/0feb6bce291fa945eff5bf52100c82c960851143/apm-collector/apm-collector-queue/collector-queue-disruptor-provider/src/main/java/org/skywalking/apm/collector/queue/disruptor/base/DisruptorEventHandler.java#L62" rel="external nofollow noopener noreferrer" target="_blank"><code>#onEvent(event, sequence, endOfBatch)</code></a> 接口方法，代码如下：<ul><li><code>endOfBatch</code> <strong>方法参数</strong>，标记该事件( 消息 )是否是 Disruptor <strong>每次批处理</strong>的最后一个事件。胖友可以参见 <a href="https://stackoverflow.com/questions/33716825/lmax-disruptor-what-determines-the-batch-size" rel="external nofollow noopener noreferrer" target="_blank">《LMAX Disruptor - what determines the batch size?》</a> 这篇文章，自己搭建一个 Demo 理解下该参数。</li><li>第 66 行：调用 <code>MessageHolder#reset()</code> 方法，清空消息，因为在 Disruptor RingBuffer 里，事件( 消息 )对象是<strong>重用</strong>的，虽然后续发布事件( 消息 )可以进行<strong>覆盖</strong>，考虑到安全性进行清空。</li><li>第 69 行：设置消息为该批量的结尾( 最后一条 )。<strong>为什么</strong>？在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（二）》「3. AggregationWorker」</a> 揭晓答案。</li><li>第 72 行：调用 <code>QueueExecutor#execute(message)</code> 方法，执行处理消息。</li></ul></li></ul><h1 id="4-collector-queue-datacarrier-provider"><a href="#4-collector-queue-datacarrier-provider" class="headerlink" title="4. collector-queue-datacarrier-provider"></a>4. collector-queue-datacarrier-provider</h1><p><code>collector-queue-datacarrier-provider</code> ：基于 <a href="https://github.com/YunaiV/skywalking/tree/master/apm-commons/apm-datacarrier" rel="external nofollow noopener noreferrer" target="_blank">apm-datacarrier</a> 的队列组件实现。</p><p><em>目前暂未完成</em>。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>在地铁里，夹缝中写代码( 😈 当然有座位 )。</p><p>不容易，回家看《蜘蛛侠》。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_15/07.png" alt=""></p><p>胖友，分享一波朋友圈可好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-queue-module/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-queue-module/&lt;/a&gt; 
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector Naming Server 命名服务</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-naming-server/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-naming-server/</id>
    <published>2020-08-09T16:00:00.000Z</published>
    <updated>2017-12-15T11:36:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/">http://www.iocoder.cn/SkyWalking/collector-naming-server/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/">2. Collector Naming Server</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/">2.1 NamingModule</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/">2.2 NamingModuleJettyProvider</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/">2.3 NamingHandlerRegisterService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/">2.4 配置文件</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/">3. CollectorDiscoveryService</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/">3.1 CollectorDiscoveryService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/">3.2 配置文件</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Collector Naming Server 命名服务</strong>。主要包含如下部分：</p><ul><li>Collector Naming Server 提供 Http 两个接口，提供 Agent <strong>分别</strong>查询 Collector Agent Jetty Server 、Collector Agent gRPC Server 集群。</li><li>Collector Agent Jetty Server 、Collector Agent gRPC Server 集群内部的注册与发现。</li></ul><blockquote><p>友情提示，建议胖友已经读过 <a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module//?self">《SkyWalking 源码分析 —— Collector Server Component 服务器组件》</a> 、<a href="http://www.iocoder.cn/SkyWalking/collector-server-component/?self">《SkyWalking 源码分析 —— Collector Server Component 服务器组件》</a></p></blockquote><p>Collector Agent Server ( 包括 Jetty 和 gRPC )，提供上传调用链路，JVM Metric 等等 API 给 Agent 调用。<br>Agent 通过 Collector Naming Server 调用 Collector Agent Server 的 API ，查询 Collector Agent Server <strong>最新</strong>的集群地址。</p><p>Naming Server 在 SkyWalking 架构图处于如下位置( <strong>红框</strong> ) ：</p><blockquote><p>FROM <a href="https://github.com/apache/incubating-skywalking" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubating-skywalking</a><br><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_10/01.jpeg" alt=""></p></blockquote><p>下面我们来看看整体的项目结构，如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_10/02.png" alt=""></p><h1 id="2-Collector-Naming-Server"><a href="#2-Collector-Naming-Server" class="headerlink" title="2. Collector Naming Server"></a>2. Collector Naming Server</h1><p>Collector Naming Server 通过 <code>apm-collector-naming</code> 项目实现，其中：</p><ul><li><code>collector-naming-define</code> 项目：定义了 Naming Server 的接口。</li><li><code>collector-naming-jetty-provider</code> 项目：基于 Jetty Server 的 Naming Server 实现。</li></ul><h2 id="2-1-NamingModule"><a href="#2-1-NamingModule" class="headerlink" title="2.1 NamingModule"></a>2.1 NamingModule</h2><p><code>org.skywalking.apm.collector.cluster.ClusterModule</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java" rel="external nofollow noopener noreferrer" target="_blank">Module</a> 抽象类，集群管理 Module 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-naming/collector-naming-define/src/main/java/org/skywalking/apm/collector/naming/NamingModule.java#L34" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回模块名为 <code>&quot;naming&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-naming/collector-naming-define/src/main/java/org/skywalking/apm/collector/naming/NamingModule.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>#services()</code></a> <strong>实现</strong>方法，返回 Service 类名：NamingHandlerRegisterService 。</p><h2 id="2-2-NamingModuleJettyProvider"><a href="#2-2-NamingModuleJettyProvider" class="headerlink" title="2.2 NamingModuleJettyProvider"></a>2.2 NamingModuleJettyProvider</h2><p><code>org.skywalking.apm.collector.naming.jetty.NamingModuleJettyProvider</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java" rel="external nofollow noopener noreferrer" target="_blank">ModuleProvider</a> <strong>抽象类</strong>，基于 Jetty 的命名组件服务提供者实现类。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-naming/collector-naming-jetty-provider/src/main/java/org/skywalking/apm/collector/naming/jetty/NamingModuleJettyProvider.java#L44" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回组件服务提供者名为 <code>&quot;jetty&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-naming/collector-naming-jetty-provider/src/main/java/org/skywalking/apm/collector/naming/jetty/NamingModuleJettyProvider.java#L48" rel="external nofollow noopener noreferrer" target="_blank"><code>module()</code></a> <strong>实现</strong>方法，返回组件类为 NamingModule 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterModuleZookeeperProvider.java#L94" rel="external nofollow noopener noreferrer" target="_blank"><code>#requiredModules()</code></a> <strong>实现</strong>方法，返回依赖组件为 ClusterModule 、JettyManagerModule。</p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterModuleZookeeperProvider.java#L52" rel="external nofollow noopener noreferrer" target="_blank"><code>#prepare(Properties)</code></a> <strong>实现</strong>方法，执行准备阶段逻辑。</p><ul><li>第 55 行 ：创建 ZookeeperModuleListenerService / NamingJettyHandlerRegisterService 对象，并调用 <code>#registerServiceImplementation()</code> <strong>父类</strong>方法，注册到 <code>services</code> 。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-naming/collector-naming-jetty-provider/src/main/java/org/skywalking/apm/collector/naming/jetty/NamingModuleJettyProvider.java#L58" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> <strong>实现</strong>方法，执行启动阶段逻辑。</p><ul><li>第 65 行 ：调用 <code>JettyManagerService#createIfAbsent(host, port, contextPath)</code> 方法，创建 Jetty Server ，<strong>此时不会启动 Jetty Server</strong>。在 <code>JettyManagerProvider#notifyAfterCompleted()</code> 方法，统一启动所有 Jetty Server，在 <a href="http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/?self">《SkyWalking 源码分析 —— Collector Jetty Server Manager》「3. JettyManagerProvider」</a> 有详细解析。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-naming/collector-naming-jetty-provider/src/main/java/org/skywalking/apm/collector/naming/jetty/NamingModuleJettyProvider.java#L68" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyAfterCompleted()</code></a> <strong>实现</strong>方法，执行启动完成逻辑。目前是个空方法。</p><h2 id="2-3-NamingHandlerRegisterService"><a href="#2-3-NamingHandlerRegisterService" class="headerlink" title="2.3 NamingHandlerRegisterService"></a>2.3 NamingHandlerRegisterService</h2><p><code>org.skywalking.apm.collector.naming.service.NamingHandlerRegisterService</code> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> 接口，命名处理器注册服务<strong>接口</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-naming/collector-naming-define/src/main/java/org/skywalking/apm/collector/naming/service/NamingHandlerRegisterService.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><code>#register(ServerHandler)</code></a> <strong>接口</strong>方法，注册 Server 请求处理器。Collector Agent Server 会调用该方法，将其实现的 用于 Naming 的 ServerHandler 进行注册。如下图所示：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_10/03.png" alt=""></p><h3 id="2-3-1-NamingJettyHandlerRegisterService"><a href="#2-3-1-NamingJettyHandlerRegisterService" class="headerlink" title="2.3.1 NamingJettyHandlerRegisterService"></a>2.3.1 NamingJettyHandlerRegisterService</h3><p><code>org.skywalking.apm.collector.naming.jetty.service.service.NamingJettyHandlerRegisterService</code> ，基于 Jetty 的命名处理器注册服务<strong>实现类</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-naming/collector-naming-jetty-provider/src/main/java/org/skywalking/apm/collector/naming/jetty/service/NamingJettyHandlerRegisterService.java#L48" rel="external nofollow noopener noreferrer" target="_blank"><code>#register(moduleName, providerName, registration)</code></a> <strong>实现</strong>方法，调用 <code>JettyManagerService#addHandler(path, registration)</code> 方法，注册 Jetty Server 请求处理器。</p><h3 id="2-3-2-AgentJettyNamingHandler"><a href="#2-3-2-AgentJettyNamingHandler" class="headerlink" title="2.3.2 AgentJettyNamingHandler"></a>2.3.2 AgentJettyNamingHandler</h3><p><code>org.skywalking.apm.collector.agent.jetty.handler.naming.AgentJettyNamingHandler</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyHandler.java" rel="external nofollow noopener noreferrer" target="_blank">JettyHandler</a> <strong>抽象类</strong>，Collector Agent Jetty Server 实现的命名处理器。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-agent-jetty/collector-agent-jetty-provider/src/main/java/org/skywalking/apm/collector/agent/jetty/handler/naming/AgentJettyNamingHandler.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>#pathSpec()</code></a> <strong>实现</strong>方法，获得请求路径为 <code>&quot;/agent/jetty&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-agent-jetty/collector-agent-jetty-provider/src/main/java/org/skywalking/apm/collector/agent/jetty/handler/naming/AgentJettyNamingHandler.java#L43" rel="external nofollow noopener noreferrer" target="_blank"><code>#doGet()</code></a> <strong>实现</strong>方法，调用 <code>AgentJettyNamingListener#getAddresses()</code> 方法，获得 Collector Agent Jetty Server 集群地址。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-agent-jetty/collector-agent-jetty-provider/src/main/java/org/skywalking/apm/collector/agent/jetty/handler/naming/AgentJettyNamingListener.java#L28" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.jetty.handler.naming.AgentJettyNamingListener</code></a> 基于 Collector Cluster 组件，<strong>实现了集群地址变化的发现</strong>，在 <a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/?self">《SkyWalking 源码分析 —— Collector Cluster 集群管理》</a> 有详细解析。</li></ul><h3 id="2-3-3-AgentGRPCNamingHandler"><a href="#2-3-3-AgentGRPCNamingHandler" class="headerlink" title="2.3.3 AgentGRPCNamingHandler"></a>2.3.3 AgentGRPCNamingHandler</h3><p><code>org.skywalking.apm.collector.agent.grpc.handler.naming.AgentGRPCNamingHandler</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyHandler.java" rel="external nofollow noopener noreferrer" target="_blank">JettyHandler</a> <strong>抽象类</strong>，Collector Agent gRPC Server 实现的命名处理器。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ac6c98c1732d6aa62b9d244369478654411ac203/apm-collector/apm-collector-agent-grpc/collector-agent-grpc-provider/src/main/java/org/skywalking/apm/collector/agent/grpc/handler/naming/AgentGRPCNamingHandler.java#L42" rel="external nofollow noopener noreferrer" target="_blank"><code>#pathSpec()</code></a> <strong>实现</strong>方法，获得请求路径为 <code>&quot;/agent/gRPC&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ac6c98c1732d6aa62b9d244369478654411ac203/apm-collector/apm-collector-agent-grpc/collector-agent-grpc-provider/src/main/java/org/skywalking/apm/collector/agent/grpc/handler/naming/AgentGRPCNamingHandler.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#doGet()</code></a> <strong>实现</strong>方法，调用 <code>AgentGRPCNamingListener#getAddresses()</code> 方法，获得 Collector Agent gRPC Server 集群地址。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/ac6c98c1732d6aa62b9d244369478654411ac203/apm-collector/apm-collector-agent-grpc/collector-agent-grpc-provider/src/main/java/org/skywalking/apm/collector/agent/grpc/handler/naming/AgentGRPCNamingListener.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.grpc.handler.naming.AgentGRPCNamingListener</code></a> 基于 Collector Cluster 组件，<strong>实现了集群地址变化的发现</strong>，在 <a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/?self">《SkyWalking 源码分析 —— Collector Cluster 集群管理》</a> 有详细解析。</li></ul><h2 id="2-4-配置文件"><a href="#2-4-配置文件" class="headerlink" title="2.4 配置文件"></a>2.4 配置文件</h2><p>配置文件如下 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_10/02.png" alt=""></p><ul><li>配置 Naming Server 启动在 10800 端口。</li><li>Naming Server <strong>内嵌</strong>在 Collector Server 。通过启动多个 Collector Server 节点，形成 Naming Server 集群。Agent 配置多个 Naming Server 地址。</li></ul><h1 id="3-CollectorDiscoveryService"><a href="#3-CollectorDiscoveryService" class="headerlink" title="3. CollectorDiscoveryService"></a>3. CollectorDiscoveryService</h1><p><code>org.skywalking.apm.agent.core.remote.CollectorDiscoveryService</code> ， 实现 Agent 的 <a href="https://github.com/YunaiV/skywalking/blob/ac6c98c1732d6aa62b9d244369478654411ac203/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/boot/BootService.java" rel="external nofollow noopener noreferrer" target="_blank">BootService</a> <strong>接口</strong>，Collector Agent Server 地址<strong>发现</strong>服务。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ac6c98c1732d6aa62b9d244369478654411ac203/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/CollectorDiscoveryService.java#L45" rel="external nofollow noopener noreferrer" target="_blank"><code>#boot()</code></a> <strong>实现</strong>方法，调用 <code>ScheduledExecutorService#scheduleAtFixedRate(...)</code> 方法，创建定时任务。该定时任务<strong>无初始化延迟</strong>，每 <code>Config.Collector.DISCOVERY_CHECK_INTERVAL</code> ( 默认：60 s ) 执行一次。</p><ul><li>DiscoveryRestServiceClient 实现 <code>java.lang.Runnable</code> <strong>接口</strong>，即创建的任务。</li></ul><h2 id="3-1-CollectorDiscoveryService"><a href="#3-1-CollectorDiscoveryService" class="headerlink" title="3.1 CollectorDiscoveryService"></a>3.1 CollectorDiscoveryService</h2><p><code>org.skywalking.apm.agent.core.remote.CollectorDiscoveryService</code> ，实现 <code>java.lang.Runnable</code> <strong>接口</strong>，Collector 服务发现客户端，基于 <strong>Rest</strong> 方式通信。</p><p><a href="https://github.com/YunaiV/skywalking/blob/e30787c3a7ce91ae6314003cd488e71c1a534d7c/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/DiscoveryRestServiceClient.java#L61" rel="external nofollow noopener noreferrer" target="_blank"><strong>构造方法</strong></a> ，首先随机选择一个 Collector Naming Server ，用于下面 <code>#findServerList()</code> 方法，首次获取 Collector Agent Server 集群地址。</p><p><a href="https://github.com/YunaiV/skywalking/blob/e30787c3a7ce91ae6314003cd488e71c1a534d7c/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/DiscoveryRestServiceClient.java#L76" rel="external nofollow noopener noreferrer" target="_blank"><code>#run()</code></a> <strong>实现</strong>方法，调用 <code>#findServerList()</code> 方法，获取 Collector Agent Server 集群地址。</p><p><a href="https://github.com/YunaiV/skywalking/blob/e30787c3a7ce91ae6314003cd488e71c1a534d7c/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/DiscoveryRestServiceClient.java#L84" rel="external nofollow noopener noreferrer" target="_blank"><code>#findServerList()</code></a> 方法，获取 Collector Agent Server 集群地址。</p><ul><li>第 85 行 ：创建 <code>org.apache.http.impl.client.CloseableHttpClient</code> 对象。目前使用 HttpClient <code>4.5.3</code> 版本。</li><li>第 87 行 ：调用 <a href="https://github.com/YunaiV/skywalking/blob/e30787c3a7ce91ae6314003cd488e71c1a534d7c/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/DiscoveryRestServiceClient.java#L142" rel="external nofollow noopener noreferrer" target="_blank"><code>#buildGet()</code></a> 方法，创建 <code>org.apache.http.client.methods.HttpGet</code> 对象。目前 Agent 查询的是 Collector Agent gRPC Server 集群地址，因为 gRPC 的性能相比 HTTP 更优秀。</li><li>第 89 行 ：向 Collector Naming Server 发起请求。</li><li>第 90 至 93 行 ：当响应状态码非 <code>200</code> 时，调用 <code>#findBackupServer()</code> 方法，<strong>顺序</strong>选择 Collector Naming Server 列表的下一个。<strong>注意</strong>，此时不会再发起请求，需要等下一次执行。</li><li>第 95 至 111 行 ：处理响应结果，若 Collector Agent gRPC Server 集群地址发生变化，进行更新到 <code>RemoteDownstreamConfig.Collector.GRPC_SERVERS</code> 。</li><li>第 114 至 117 行 ：请求发生异常，调用 <code>#findBackupServer()</code> 方法，<strong>顺序</strong>选择 Collector Naming Server 列表的下一个。</li><li>第 119 行 ：调用 <code>CloseableHttpClient#close()</code> 方法，进行关闭。</li></ul><h2 id="3-2-配置文件"><a href="#3-2-配置文件" class="headerlink" title="3.2 配置文件"></a>3.2 配置文件</h2><p>配置文件如下 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_10/05.png" alt=""></p><ul><li>生产环境使用时，<strong>推荐</strong> Agent 配置多个 Naming Server 地址。</li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>2017.12.15 归途 从北京回上海。</p><p>突然有种感觉，获得像包方便面，快捷而不营养。</p><p>有点”丧”。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_10/06.png" alt=""></p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-naming-server/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-naming-server/&lt;/a
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector gRPC Server Manager</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-grpc-server-module/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-grpc-server-module/</id>
    <published>2020-08-04T16:00:00.000Z</published>
    <updated>2017-12-14T16:41:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-grpc-server-module/">http://www.iocoder.cn/SkyWalking/collector-grpc-server-module/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-grpc-server-module/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-grpc-server-module/">2. GRPCManagerModule</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-grpc-server-module/">3. GRPCManagerProvider</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-grpc-server-module/">4. GRPCManagerService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-grpc-server-module/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Collector gRPC Server Manager</strong>。Collector 通过该管理器，管理启动的多个 gRPC Server，例如 Agent gRPC Server、Remote gRPC Server 。<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_05/02.png" alt=""></p><blockquote><p>友情提示：建议胖友已经读过 <a href="http://www.iocoder.cn/SkyWalking/collector-server-component/?self">《SkyWalking 源码分析 —— Collector Server Component 服务器组件》</a></p><p>另外，本文和 <a href="http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/?self">《SkyWalking 源码分析 —— Collector Jetty Server Manager》</a> 相似度 99%</p></blockquote><p>gRPC Server Manager 在 SkyWalking 架构图处于如下位置( <strong>红框</strong> ) ：</p><blockquote><p>FROM <a href="https://github.com/apache/incubating-skywalking" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubating-skywalking</a><br><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_05/01.jpeg" alt=""></p></blockquote><p>下面我们来看看整体的项目结构，如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_05/03.png" alt=""></p><p>😈 代码量非常少，考虑到这是个单独的项目，所以单独成文。</p><h1 id="2-GRPCManagerModule"><a href="#2-GRPCManagerModule" class="headerlink" title="2. GRPCManagerModule"></a>2. GRPCManagerModule</h1><p><code>org.skywalking.apm.collector.grpc.manager.GRPCManagerModule</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java" rel="external nofollow noopener noreferrer" target="_blank">Module</a> 抽象类，gRPC Server 管理器 Module 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/621598af465bfcefee3432c2ef80aff25a33f1bf/apm-collector/apm-collector-grpc-manager/collector-grpc-manager-define/src/main/java/org/skywalking/apm/collector/grpc/manager/GRPCManagerModule.java#L33" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回模块名为 <code>&quot;gRPC_manager&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/621598af465bfcefee3432c2ef80aff25a33f1bf/apm-collector/apm-collector-grpc-manager/collector-grpc-manager-define/src/main/java/org/skywalking/apm/collector/grpc/manager/GRPCManagerModule.java#L37" rel="external nofollow noopener noreferrer" target="_blank"><code>#services()</code></a> <strong>实现</strong>方法，返回 Service 类名：GRPCManagerService 。</p><h1 id="3-GRPCManagerProvider"><a href="#3-GRPCManagerProvider" class="headerlink" title="3. GRPCManagerProvider"></a>3. GRPCManagerProvider</h1><p><code>org.skywalking.apm.collector.grpc.manager.GRPCManagerProvider</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java" rel="external nofollow noopener noreferrer" target="_blank">ModuleProvider</a> <strong>抽象类</strong>，gRPC Server 管理器组件服务提供者。</p><p><a href="https://github.com/YunaiV/skywalking/blob/f9de7bf75f62c16fd05cc0d1beb8f5b756108ec3/apm-collector/apm-collector-grpc-manager/collector-grpc-manager-provider/src/main/java/org/skywalking/apm/collector/grpc/manager/GRPCManagerProvider.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回组件服务提供者名为 <code>&quot;gRPC&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/f9de7bf75f62c16fd05cc0d1beb8f5b756108ec3/apm-collector/apm-collector-grpc-manager/collector-grpc-manager-provider/src/main/java/org/skywalking/apm/collector/grpc/manager/GRPCManagerProvider.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>module()</code></a> <strong>实现</strong>方法，返回组件类为 GRPCManagerModule 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/f9de7bf75f62c16fd05cc0d1beb8f5b756108ec3/apm-collector/apm-collector-grpc-manager/collector-grpc-manager-provider/src/main/java/org/skywalking/apm/collector/grpc/manager/GRPCManagerProvider.java#L72" rel="external nofollow noopener noreferrer" target="_blank"><code>#requiredModules()</code></a> <strong>实现</strong>方法，返回依赖组件为空。</p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/f9de7bf75f62c16fd05cc0d1beb8f5b756108ec3/apm-collector/apm-collector-grpc-manager/collector-grpc-manager-provider/src/main/java/org/skywalking/apm/collector/grpc/manager/GRPCManagerProvider.java#L54" rel="external nofollow noopener noreferrer" target="_blank"><code>#prepare(Properties)</code></a> <strong>实现</strong>方法，执行准备阶段逻辑。</p><ul><li>第 55 行 ：创建 GRPCManagerServiceImpl 对象，并调用 <code>#registerServiceImplementation(...)</code> <strong>父类</strong>方法，注册到 <code>services</code> 。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/f9de7bf75f62c16fd05cc0d1beb8f5b756108ec3/apm-collector/apm-collector-grpc-manager/collector-grpc-manager-provider/src/main/java/org/skywalking/apm/collector/grpc/manager/GRPCManagerProvider.java#L58" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> <strong>实现</strong>方法，执行启动阶段逻辑。目前是个<strong>空方法</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/f9de7bf75f62c16fd05cc0d1beb8f5b756108ec3/apm-collector/apm-collector-grpc-manager/collector-grpc-manager-provider/src/main/java/org/skywalking/apm/collector/grpc/manager/GRPCManagerProvider.java#L62" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyAfterCompleted()</code></a> <strong>实现</strong>方法，执行启动完成逻辑。</p><ul><li>第 63 至 69 行 ：遍历注册的服务器列表，逐个调用 <code>GRPCServer#start()</code> 方法，进行启动。</li></ul><h1 id="4-GRPCManagerService"><a href="#4-GRPCManagerService" class="headerlink" title="4. GRPCManagerService"></a>4. GRPCManagerService</h1><p><code>org.skywalking.apm.collector.grpc.manager.service.GRPCManagerService</code> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> <strong>接口</strong>，gRPC Server 管理器服务<strong>接口</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/48f76a555c043fee2932230077a8112d4888d10f/apm-collector/apm-collector-grpc-manager/collector-grpc-manager-define/src/main/java/org/skywalking/apm/collector/grpc/manager/service/GRPCManagerService.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>#createIfAbsent(host, port)</code></a> <strong>接口</strong>方法，创建 gRPC Server ，若不存在。</p><p><strong>怎么没有类似 JettyManagerService 的 <code>#addHandler(...)</code> 方法</strong>？目前是调用方直接调用 <code>#createIfAbsent(host, port)</code> 方法，获得 gRPC Server 后，后调用 <code>Server#addHandler(ServerHandler)</code> 方法。例如：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/9c586ca730cc89d4d5ad6b4294f2779a23925a8c/apm-collector/apm-collector-agent-grpc/collector-agent-grpc-provider/src/main/java/org/skywalking/apm/collector/agent/grpc/AgentModuleGRPCProvider.java#L72" rel="external nofollow noopener noreferrer" target="_blank"><code>AgentModuleGRPCProvider#start(Properties)</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/9c586ca730cc89d4d5ad6b4294f2779a23925a8c/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/RemoteModuleGRPCProvider.java#L61" rel="external nofollow noopener noreferrer" target="_blank"><code>RemoteModuleGRPCProvider#start(Properties)</code></a></li></ul><h2 id="4-1-GRPCManagerServiceImpl"><a href="#4-1-GRPCManagerServiceImpl" class="headerlink" title="4.1 GRPCManagerServiceImpl"></a>4.1 GRPCManagerServiceImpl</h2><p><code>org.skywalking.apm.collector.grpc.manager.service.GRPCManagerServiceImpl</code> ，gRPC Server 管理器服务<strong>实现类</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/9c586ca730cc89d4d5ad6b4294f2779a23925a8c/apm-collector/apm-collector-grpc-manager/collector-grpc-manager-provider/src/main/java/org/skywalking/apm/collector/grpc/manager/service/GRPCManagerServiceImpl.java#L44" rel="external nofollow noopener noreferrer" target="_blank"><strong>构造方法</strong></a> ，使用来自 GRPCManagerProvider 的 <code>servers</code> 服务器数组。<strong>这是为什么 GRPCManagerProvider 没有对 <code>servers</code> 做新增操作，结果里面有数据的原因</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/9c586ca730cc89d4d5ad6b4294f2779a23925a8c/apm-collector/apm-collector-grpc-manager/collector-grpc-manager-provider/src/main/java/org/skywalking/apm/collector/grpc/manager/service/GRPCManagerServiceImpl.java#L48" rel="external nofollow noopener noreferrer" target="_blank"><code>#createIfAbsent(host, port)</code></a> <strong>实现</strong>方法，创建 gRPC Server ，若不存在。判断方式为 <code>host + port</code> 为唯一。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>呵呵哒的一篇，嘿嘿。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_05/04.png" alt=""></p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-grpc-server-module/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-grpc-server-
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector Jetty Server Manager</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/</id>
    <published>2020-07-31T16:00:00.000Z</published>
    <updated>2017-12-14T16:30:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/">http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/">2. JettyManagerModule</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/">3. JettyManagerProvider</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/">4. JettyManagerService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Collector Jetty Server Manager</strong>。Collector 通过该管理器，管理启动的多个 Jetty Server，例如 Agent Jetty Server、Naming Jetty Server、UI Jetty Server。<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_01/02.png" alt=""></p><blockquote><p>友情提示：建议胖友已经读过 <a href="http://www.iocoder.cn/SkyWalking/collector-server-component/?self">《SkyWalking 源码分析 —— Collector Server Component 服务器组件》</a></p></blockquote><p>Jetty Server Manager 在 SkyWalking 架构图处于如下位置( <strong>红框</strong> ) ：</p><blockquote><p>FROM <a href="https://github.com/apache/incubating-skywalking" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubating-skywalking</a><br><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_01/01.jpeg" alt=""></p></blockquote><p>下面我们来看看整体的项目结构，如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_01/03.png" alt=""></p><p>😈 代码量非常少，考虑到这是个单独的项目，所以单独成文。</p><h1 id="2-JettyManagerModule"><a href="#2-JettyManagerModule" class="headerlink" title="2. JettyManagerModule"></a>2. JettyManagerModule</h1><p><code>org.skywalking.apm.collector.jetty.manager.JettyManagerModule</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java" rel="external nofollow noopener noreferrer" target="_blank">Module</a> 抽象类，Jetty 管理器 Module 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/39ee2260b8463316550c52276109a5af917e34e8/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-define/src/main/java/org/skywalking/apm/collector/jetty/manager/JettyManagerModule.java#L33" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回模块名为 <code>&quot;jetty_manager&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/39ee2260b8463316550c52276109a5af917e34e8/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-define/src/main/java/org/skywalking/apm/collector/jetty/manager/JettyManagerModule.java#L37" rel="external nofollow noopener noreferrer" target="_blank"><code>#services()</code></a> <strong>实现</strong>方法，返回 Service 类名：JettyManagerService 。</p><h1 id="3-JettyManagerProvider"><a href="#3-JettyManagerProvider" class="headerlink" title="3. JettyManagerProvider"></a>3. JettyManagerProvider</h1><p><code>org.skywalking.apm.collector.jetty.manager.JettyManagerProvider</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java" rel="external nofollow noopener noreferrer" target="_blank">ModuleProvider</a> <strong>抽象类</strong>，Jetty 管理器组件服务提供者。</p><p><a href="https://github.com/YunaiV/skywalking/blob/39ee2260b8463316550c52276109a5af917e34e8/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-provider/src/main/java/org/skywalking/apm/collector/jetty/manager/JettyManagerProvider.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回组件服务提供者名为 <code>&quot;jetty&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/39ee2260b8463316550c52276109a5af917e34e8/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-provider/src/main/java/org/skywalking/apm/collector/jetty/manager/JettyManagerProvider.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>module()</code></a> <strong>实现</strong>方法，返回组件类为 JettyManagerModule 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/39ee2260b8463316550c52276109a5af917e34e8/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-provider/src/main/java/org/skywalking/apm/collector/jetty/manager/JettyManagerProvider.java#L72" rel="external nofollow noopener noreferrer" target="_blank"><code>#requiredModules()</code></a> <strong>实现</strong>方法，返回依赖组件为空。</p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/39ee2260b8463316550c52276109a5af917e34e8/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-provider/src/main/java/org/skywalking/apm/collector/jetty/manager/JettyManagerProvider.java#L54" rel="external nofollow noopener noreferrer" target="_blank"><code>#prepare(Properties)</code></a> <strong>实现</strong>方法，执行准备阶段逻辑。</p><ul><li>第 55 行 ：创建 JettyManagerServiceImpl 对象，并调用 <code>#registerServiceImplementation(...)</code> <strong>父类</strong>方法，注册到 <code>services</code> 。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/39ee2260b8463316550c52276109a5af917e34e8/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-provider/src/main/java/org/skywalking/apm/collector/jetty/manager/JettyManagerProvider.java#L58" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> <strong>实现</strong>方法，执行启动阶段逻辑。目前是个<strong>空方法</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/39ee2260b8463316550c52276109a5af917e34e8/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-provider/src/main/java/org/skywalking/apm/collector/jetty/manager/JettyManagerProvider.java#L61" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyAfterCompleted()</code></a> <strong>实现</strong>方法，执行启动完成逻辑。</p><ul><li>第 63 至 69 行 ：遍历注册的服务器列表，逐个调用 <code>JettyServer#start()</code> 方法，进行启动。</li></ul><h1 id="4-JettyManagerService"><a href="#4-JettyManagerService" class="headerlink" title="4. JettyManagerService"></a>4. JettyManagerService</h1><p><code>org.skywalking.apm.collector.jetty.manager.service.JettyManagerService</code> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> <strong>接口</strong>，Jetty 管理器服务<strong>接口</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/71993b1790b29df66644334dcfe1796e889ddc9b/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-define/src/main/java/org/skywalking/apm/collector/jetty/manager/service/JettyManagerService.java#L40" rel="external nofollow noopener noreferrer" target="_blank"><code>#createIfAbsent(host, port, contextPath)</code></a> <strong>接口</strong>方法，创建 Jetty Server ，若不存在。</p><p><a href="https://github.com/YunaiV/skywalking/blob/71993b1790b29df66644334dcfe1796e889ddc9b/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-define/src/main/java/org/skywalking/apm/collector/jetty/manager/service/JettyManagerService.java#L49" rel="external nofollow noopener noreferrer" target="_blank"><code>#addHandler(host, port, serverHandler)</code></a> <strong>接口</strong>方法，添加 Jetty Server 请求处理器。</p><h2 id="4-1-JettyManagerServiceImpl"><a href="#4-1-JettyManagerServiceImpl" class="headerlink" title="4.1 JettyManagerServiceImpl"></a>4.1 JettyManagerServiceImpl</h2><p><code>org.skywalking.apm.collector.jetty.manager.service.JettyManagerServiceImpl</code> ，Jetty 管理器服务<strong>实现类</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/21a84f89165f74c7fe702650ff4d12db5a9613e4/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-provider/src/main/java/org/skywalking/apm/collector/jetty/manager/service/JettyManagerServiceImpl.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><strong>构造方法</strong></a> ，使用来自 JettyManagerProvider 的 <code>servers</code> 服务器数组。<strong>这是为什么 JettyManagerProvider 没有对 <code>servers</code> 做新增操作，结果里面有数据的原因</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/21a84f89165f74c7fe702650ff4d12db5a9613e4/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-provider/src/main/java/org/skywalking/apm/collector/jetty/manager/service/JettyManagerServiceImpl.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>#createIfAbsent(host, port, contextPath)</code></a> <strong>实现</strong>方法，创建 Jetty Server ，若不存在。判断方式为 <code>host + port</code> 为唯一。</p><p><a href="https://github.com/YunaiV/skywalking/blob/21a84f89165f74c7fe702650ff4d12db5a9613e4/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-provider/src/main/java/org/skywalking/apm/collector/jetty/manager/service/JettyManagerServiceImpl.java#L66" rel="external nofollow noopener noreferrer" target="_blank"><code>#addHandler(host, port, serverHandler)</code></a> <strong>实现</strong>方法，添加 Jetty Server 请求处理器。判断方式为 <code>host + port</code> 为唯一。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>呵呵哒的一篇，嘿嘿。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_01/04.png" alt=""></p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-jetty-serve
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector Server Component 服务器组件</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-server-component/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-server-component/</id>
    <published>2020-07-27T16:00:00.000Z</published>
    <updated>2017-12-14T14:44:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">http://www.iocoder.cn/SkyWalking/collector-server-component/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">2. 接口</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">2.1 Server</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">2.2 ServerHandler</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">3. gRPC 实现</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">3.1 GRPCServer</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">3.2 GRPCHandler</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">4. Jetty 实现</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">3.1 JettyServer</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">3.2 JettyHandler</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>SkyWalking Collector Server Component 服务器组件</strong>。Collector 通过服务器，提供 API 接口给调用方，例如 Agent 、WebUI 。</p><p>Server Component 在 SkyWalking 架构图处于如下位置( <strong>红框</strong> ) ：</p><blockquote><p>FROM <a href="https://github.com/apache/incubating-skywalking" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubating-skywalking</a><br><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_25/01.jpeg" alt=""></p></blockquote><p>下面我们来看看整体的项目结构，如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_28/02.png" alt=""></p><p>OK，我们从<strong>接口到实现</strong>的顺序进行分享。</p><h1 id="2-接口"><a href="#2-接口" class="headerlink" title="2. 接口"></a>2. 接口</h1><h2 id="2-1-Server"><a href="#2-1-Server" class="headerlink" title="2.1 Server"></a>2.1 Server</h2><p><code>org.skywalking.apm.collector.server.Server</code> ，服务器<strong>接口</strong>。其实现子类，如下类图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_28/03.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/Server.java#L31" rel="external nofollow noopener noreferrer" target="_blank"><code>#hostPort()</code></a> <strong>接口</strong>方法，获得服务器地址。<br><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/Server.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><code>#serverClassify()</code></a> <strong>接口</strong>方法，获得服务器分类。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/Server.java#L43" rel="external nofollow noopener noreferrer" target="_blank"><code>#initialize()</code></a> <strong>接口</strong>方法，初始化服务器。<br><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/Server.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> <strong>接口</strong>方法，启动服务器。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/Server.java#L57" rel="external nofollow noopener noreferrer" target="_blank"><code>#addHandler()</code></a> <strong>接口</strong>方法，添加请求处理器( ServerHandler )</p><h2 id="2-2-ServerHandler"><a href="#2-2-ServerHandler" class="headerlink" title="2.2 ServerHandler"></a>2.2 ServerHandler</h2><p><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/ServerHandler.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.server.ServerHandler</code></a> ，服务器处理器<strong>接口</strong>。其实现子类，如下类图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_28/04.png" alt=""></p><p>ServerHandler 无任何接口方法。</p><p>一个 ServerHandler 对应一个请求的处理。</p><h1 id="3-gRPC-实现"><a href="#3-gRPC-实现" class="headerlink" title="3. gRPC 实现"></a>3. gRPC 实现</h1><h2 id="3-1-GRPCServer"><a href="#3-1-GRPCServer" class="headerlink" title="3.1 GRPCServer"></a>3.1 GRPCServer</h2><p><code>org.skywalking.apm.collector.server.grpc.GRPCServer</code> ，基于 gRPC 的服务器实现。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/grpc/GRPCServer.java#L47" rel="external nofollow noopener noreferrer" target="_blank"><code>#hostPort()</code></a> <strong>实现</strong>方法，获得服务器地址。<br><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/grpc/GRPCServer.java#L51" rel="external nofollow noopener noreferrer" target="_blank"><code>#serverClassify()</code></a> <strong>实现</strong>方法，获得服务器分类为 <code>&quot;Google-RPC&quot;</code>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/grpc/GRPCServer.java#L55" rel="external nofollow noopener noreferrer" target="_blank"><code>#initialize()</code></a> <strong>实现</strong>方法，调用 <code>io.grpc.netty.NettyServerBuilder#forAddress(address)</code> 方法，NettyServerBuilder 。此处，服务器并未创建与启动。<br><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/grpc/GRPCServer.java#L61" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> <strong>实现</strong>方法，创建 <code>io.grpc.Server</code> 对象，并启动服务器。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/grpc/GRPCServer.java#L70" rel="external nofollow noopener noreferrer" target="_blank"><code>#addHandler(handler)</code></a> <strong>实现</strong>方法，调用 <code>NettyServerBuilder#addService(...)</code> 方法，添加 gRPC 请求处理器( GRPCHandler )。</p><p>目前，GRPCServer 使用在 <a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-agent-grpc/collector-agent-grpc-provider/" rel="external nofollow noopener noreferrer" target="_blank"><code>collector-agent-grpc-provider</code></a> / <a href="https://github.com/YunaiV/skywalking/tree/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-remote/collector-remote-grpc-provider" rel="external nofollow noopener noreferrer" target="_blank"><code>collector-remote-grpc-provider</code></a> 项目。</p><h2 id="3-2-GRPCHandler"><a href="#3-2-GRPCHandler" class="headerlink" title="3.2 GRPCHandler"></a>3.2 GRPCHandler</h2><p><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/ServerHandler.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.server.grpc.GRPCHandler</code></a> ，gRPC 请求处理器<strong>接口</strong>。其实现子类，如下类图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_28/05.png" alt=""></p><p>GRPCHandler 无任何接口方法。</p><h1 id="4-Jetty-实现"><a href="#4-Jetty-实现" class="headerlink" title="4. Jetty 实现"></a>4. Jetty 实现</h1><h2 id="3-1-JettyServer"><a href="#3-1-JettyServer" class="headerlink" title="3.1 JettyServer"></a>3.1 JettyServer</h2><p><code>org.skywalking.apm.collector.server.jetty.JettyServer</code> ，基于 Jetty 的服务器实现。</p><p><a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyServer.java#L52" rel="external nofollow noopener noreferrer" target="_blank"><code>#hostPort()</code></a> <strong>实现</strong>方法，获得服务器地址。<br><a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyServer.java#L56" rel="external nofollow noopener noreferrer" target="_blank"><code>#serverClassify()</code></a> <strong>实现</strong>方法，获得服务器分类为 <code>&quot;Jetty&quot;</code>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyServer.java#L60" rel="external nofollow noopener noreferrer" target="_blank"><code>#initialize()</code></a> <strong>实现</strong>方法，创建 <code>org.eclipse.jetty.server.Server</code> 和 <code>org.eclipse.jetty.servle.ServletContextHandler</code> 对象。此处，服务器并未启动。<br><a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyServer.java#L80" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> <strong>实现</strong>方法，启动服务器。</p><p><a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyServer.java#L72" rel="external nofollow noopener noreferrer" target="_blank"><code>#addHandler(handler)</code></a> <strong>实现</strong>方法，使用 ServerHandler 创建 <code>org.eclipse.jetty.servlet.ServletHolder</code> 对象，并调用 <code>ServletContextHandler#addServlet(servlet, pathSpec)</code> 方法进行添加。</p><p>目前，JettyServer 使用在 <a href="https://github.com/YunaiV/skywalking/tree/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-agent-jetty/collector-agent-jetty-provider" rel="external nofollow noopener noreferrer" target="_blank"><code>collector-agent-jetty-provider</code></a> / <a href="https://github.com/YunaiV/skywalking/tree/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-ui/collector-ui-jetty-provider" rel="external nofollow noopener noreferrer" target="_blank"><code>collector-ui-jetty-provider</code></a> 项目。</p><h2 id="3-2-JettyHandler"><a href="#3-2-JettyHandler" class="headerlink" title="3.2 JettyHandler"></a>3.2 JettyHandler</h2><p><code>org.skywalking.apm.collector.server.jetty.JettyHandler</code> ，继承 <code>javax.servlet.http.HttpServlet</code> <strong>抽象类</strong>，Jetty 请求处理。</p><p><a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyHandler.java#L43" rel="external nofollow noopener noreferrer" target="_blank"><code>#pathSpec()</code></a> <strong>抽象</strong>方法，请求路径定义。</p><p><a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyHandler.java#L61" rel="external nofollow noopener noreferrer" target="_blank"><code>#doGet(HttpServletRequest)</code></a> <strong>抽象</strong>方法，处理 Get 请求，并返回 <code>com.google.gson.JsonElement</code> 对象。</p><ul><li>该抽象方法会被 <a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyHandler.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#doGet(HttpServletRequest, HttpServletResponse)</code></a> 方法调用。<ul><li>成功时，调用 <a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyHandler.java#L174" rel="external nofollow noopener noreferrer" target="_blank"><code>#reply(HttpServletResponse, JsonElement)</code></a> 方法，返回 JSON 。</li><li>错误时，调用 <a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyHandler.java#L195" rel="external nofollow noopener noreferrer" target="_blank"><code>#replyError(HttpServletResponse, errorMessage, status)</code></a> 方法，返回 JSON 。</li></ul></li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyHandler.java#L79" rel="external nofollow noopener noreferrer" target="_blank"><code>#doPost(HttpServletRequest)</code></a> <strong>抽象</strong>方法，处理 Post 请求，并返回 <code>com.google.gson.JsonElement</code> 对象。</p><ul><li>该抽象方法会被 <a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyHandler.java#L64" rel="external nofollow noopener noreferrer" target="_blank"><code>#doPost(HttpServletRequest, HttpServletResponse)</code></a> 方法调用。</li></ul><p><strong>HttpServlet 所有方法被重写，并标记 <code>final</code> 修饰符，不允许子类重写</strong>。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>又双叒叕成功更新了一篇水文。😜</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_28/06.png" alt=""></p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-server-component/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-server-compone
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector Client Component 客户端组件</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-client-component/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-client-component/</id>
    <published>2020-07-24T16:00:00.000Z</published>
    <updated>2017-12-14T14:44:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-client-component/">http://www.iocoder.cn/SkyWalking/collector-client-component/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-client-component/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-client-component/">2. Client</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-client-component/">3. ElasticSearchClient</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-client-component/">4. GRPCClient</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-client-component/">5. H2Client</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-client-component/">6. RedisClient</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-client-component/">7. ZookeeperClient</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-client-component/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>SkyWalking Collector Client Component 客户端组件</strong>。Collector 通过客户端，和其他服务进行通信，例如 Elastic Search 、Zookeeper 、H2 等等。</p><p>Client Component 在 SkyWalking 架构图处于如下位置( <strong>红框</strong> ) ：</p><blockquote><p>FROM <a href="https://github.com/apache/incubating-skywalking" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubating-skywalking</a><br><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_25/01.jpeg" alt=""></p></blockquote><p>下面我们来看看整体的项目结构，如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_25/02.png" alt=""></p><p>OK，我们从<strong>接口到实现</strong>的顺序进行分享。</p><h1 id="2-Client"><a href="#2-Client" class="headerlink" title="2. Client"></a>2. Client</h1><p><a href="https://github.com/YunaiV/skywalking/blob/c546a9a4d4588d99bf532da519ae721ef60b918e/apm-collector/apm-collector-component/client-component/src/main/java/org/skywalking/apm/collector/client/Client.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.client.Client</code></a> ，客户端<strong>接口</strong>。其定义接口方法如下：</p><ul><li><code>#initialize()</code> 方法，初始化客户端。</li><li><code>#shutdown()</code> 方法，关闭客户端。</li></ul><p>Client 的实现类，如下类图：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_25/03.png" alt=""></p><h1 id="3-ElasticSearchClient"><a href="#3-ElasticSearchClient" class="headerlink" title="3. ElasticSearchClient"></a>3. ElasticSearchClient</h1><p><a href="https://github.com/YunaiV/skywalking/blob/001f700612ad52bc1eb1a278bc0e2ff9e5330df8/apm-collector/apm-collector-component/client-component/src/main/java/org/skywalking/apm/collector/client/elasticsearch/ElasticSearchClient.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.client.elasticsearch.ElasticSearchClient</code></a> ，Elastic Search 客户端。 </p><p>基于 <code>org.elasticsearch.client.transport</code> 的 <code>5.5.0</code> 版本，封装 SkyWalking 需要的 Elastic Search 操作。目前用于 <a href="https://github.com/YunaiV/skywalking/blob/001f700612ad52bc1eb1a278bc0e2ff9e5330df8/apm-collector/apm-collector-storage/collector-storage-es-provider" rel="external nofollow noopener noreferrer" target="_blank"><code>collector-storage-es-provider</code></a> 模块。</p><h1 id="4-GRPCClient"><a href="#4-GRPCClient" class="headerlink" title="4. GRPCClient"></a>4. GRPCClient</h1><p><a href="https://github.com/YunaiV/skywalking/blob/001f700612ad52bc1eb1a278bc0e2ff9e5330df8/apm-collector/apm-collector-component/client-component/src/main/java/org/skywalking/apm/collector/client/grpc/GRPCClient.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.client.grpc.GRPCClient</code></a> ，gRPC 客户端。</p><p>基于 <code>io.grpc.grpc-core</code> 的 <code>1.8.0</code> 版本，封装 SkyWalking 需要的 gRPC 操作。目前用于 <a href="https://github.com/YunaiV/skywalking/tree/001f700612ad52bc1eb1a278bc0e2ff9e5330df8/apm-collector/apm-collector-remote/collector-remote-grpc-provider" rel="external nofollow noopener noreferrer" target="_blank"><code>collector-remote-grpc-provider</code></a> 模块。 </p><h1 id="5-H2Client"><a href="#5-H2Client" class="headerlink" title="5. H2Client"></a>5. H2Client</h1><p><a href="https://github.com/YunaiV/skywalking/blob/001f700612ad52bc1eb1a278bc0e2ff9e5330df8/apm-collector/apm-collector-component/client-component/src/main/java/org/skywalking/apm/collector/client/h2/H2Client.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.client.h2.H2Client</code></a> ，H2 数据库客户端。</p><p>基于 <code>com.h2database.h2</code> 的 <code>1.4.196</code> 版本，封装 SkyWalking 需要的 H2 数据库操作。目前用于 <a href="https://github.com/YunaiV/skywalking/tree/001f700612ad52bc1eb1a278bc0e2ff9e5330df8/apm-collector/apm-collector-storage/collector-storage-h2-provider" rel="external nofollow noopener noreferrer" target="_blank"><code>collector-storage-h2-provider</code></a> / <a href="https://github.com/YunaiV/skywalking/tree/001f700612ad52bc1eb1a278bc0e2ff9e5330df8/apm-collector/apm-collector-cluster/collector-cluster-standalone-provider" rel="external nofollow noopener noreferrer" target="_blank"><code>collector-cluster-standalone-provider</code></a> 模块。</p><h1 id="6-RedisClient"><a href="#6-RedisClient" class="headerlink" title="6. RedisClient"></a>6. RedisClient</h1><p><a href="https://github.com/YunaiV/skywalking/blob/001f700612ad52bc1eb1a278bc0e2ff9e5330df8/apm-collector/apm-collector-component/client-component/src/main/java/org/skywalking/apm/collector/client/redis/RedisClient.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.client.redis.RedisClient</code></a> ，Redis 客户端。</p><p>基于 <code>redis.clients.jedis</code> 的 <code>2.9.0</code> 版本，封装 SkyWalking 需要的 Reids 操作。预计未来用于 <a href="https://github.com/YunaiV/skywalking/tree/001f700612ad52bc1eb1a278bc0e2ff9e5330df8/apm-collector/apm-collector-cluster/collector-cluster-redis-provider" rel="external nofollow noopener noreferrer" target="_blank"><code>collector-cluster-redis-provider</code></a> 模块。</p><h1 id="7-ZookeeperClient"><a href="#7-ZookeeperClient" class="headerlink" title="7. ZookeeperClient"></a>7. ZookeeperClient</h1><p><a href="https://github.com/YunaiV/skywalking/blob/001f700612ad52bc1eb1a278bc0e2ff9e5330df8/apm-collector/apm-collector-component/client-component/src/main/java/org/skywalking/apm/collector/client/zookeeper/ZookeeperClient.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.client.zookeeper.ZookeeperClient</code></a> ，Zookeeper 客户端。</p><p>基于 <code>org.apache.zookeeper.zookeeper</code> 的 <code>3.4.10</code> 版本，封装 SkyWalking 需要的 Zookeeper 操作。预计未来用于 <a href="https://github.com/YunaiV/skywalking/tree/001f700612ad52bc1eb1a278bc0e2ff9e5330df8/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider" rel="external nofollow noopener noreferrer" target="_blank"><code>collector-cluster-zookeeper-provider</code></a> 模块。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>哈哈哈，是不是看的很有成就感( 笔者又在水更了 )。</p><p>不要方，下面还有一篇水更。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_25/04.png" alt=""></p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-client-component/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-client-compone
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector Cluster 集群管理</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-cluster-module/</id>
    <published>2020-07-19T16:00:00.000Z</published>
    <updated>2017-12-25T04:31:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">http://www.iocoder.cn/SkyWalking/collector-cluster-module/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">2. collector-cluster-define</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">2.1 ClusterModule</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">2.2 ModuleRegisterService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">2.3 ModuleListenerService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">2.4 DataMonitor</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">3. collector-cluster-zookeeper-provider</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">3.1 ClusterModuleZookeeperProvider</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">3.2 ZookeeperModuleRegisterService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">3.3 ZookeeperModuleListenerService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">3.4 ClusterZKDataMonitor</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">3.5 ZookeeperClient</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">4. collector-cluster-standalone-provider</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">5. collector-cluster-redis-provider</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>SkyWalking Collector Cluster Module</strong>，负责集群的管理，即 Collector 节点的注册于发现。</p><blockquote><p>友情提示：建议先阅读 <a href="http://www.iocoder.cn/SkyWalking/collector-init/?self">《SkyWalking 源码分析 —— Collector 初始化》</a> ，以了解 Collector 组件体系。</p></blockquote><p>Cluster Module 在 SkyWalking 架构图处于如下位置( <strong>红框</strong> ) ：</p><blockquote><p>FROM <a href="https://github.com/apache/incubating-skywalking" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubating-skywalking</a><br><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_20/01.jpeg" alt=""></p></blockquote><p>下面我们来看看整体的项目结构，如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_20/02.png" alt=""></p><ul><li><code>collector-cluster-define</code> ：定义集群管理接口。</li><li><code>collector-cluster-standalone-provider</code> ：基于 H2 的 集群管理实现。<strong>该实现是单机版，建议仅用于 SkyWalking 快速上手，生产环境不建议使用</strong>。</li><li><code>collector-cluster-redis-provider</code> ：基于 Redis 的集群管理实现。<em>目前暂未完成</em>。</li><li><code>collector-cluster-zookeeper-provider</code> ：基于 Zookeeper 的集群管理实现。<strong>生产环境推荐使用</strong></li></ul><p>下面，我们从<strong>接口到实现</strong>的顺序进行分享。</p><h1 id="2-collector-cluster-define"><a href="#2-collector-cluster-define" class="headerlink" title="2. collector-cluster-define"></a>2. collector-cluster-define</h1><p><code>collector-cluster-define</code> ：定义集群管理接口。项目结构如下 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_20/03.png" alt=""></p><ul><li><p>交互如下图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_20/04.png" alt=""></p></li><li><p>ModuleListenerService 暴露给其他 Module 注册监听器 ( ClusterModuleListener ) 到 DataMonitor 。</p></li><li>ModuleRegisterService 暴露给其他 Module 注册组件登记( ModuleRegistration ) 到 DataMonitor 。</li><li>通过实现 DataMonitor 接口，基于不同的存储器实现注册发现。</li></ul><h2 id="2-1-ClusterModule"><a href="#2-1-ClusterModule" class="headerlink" title="2.1 ClusterModule"></a>2.1 ClusterModule</h2><p><code>org.skywalking.apm.collector.cluster.ClusterModule</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java" rel="external nofollow noopener noreferrer" target="_blank">Module</a> 抽象类，集群管理 Module 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/ClusterModule.java#L33" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回模块名为 <code>&quot;cluster&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/ClusterModule.java#L37" rel="external nofollow noopener noreferrer" target="_blank"><code>#services()</code></a> <strong>实现</strong>方法，返回 Service 类名：ModuleListenerService / ModuleRegisterService 。</p><h2 id="2-2-ModuleRegisterService"><a href="#2-2-ModuleRegisterService" class="headerlink" title="2.2 ModuleRegisterService"></a>2.2 ModuleRegisterService</h2><p><code>org.skywalking.apm.collector.cluster.service.ModuleRegisterService</code> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> 接口，模块注册服务<strong>接口</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/service/ModuleRegisterService.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>#register(moduleName, providerName, registration)</code></a> <strong>接口</strong>方法，注册模块注册信息。一般情况下，实现该接口方法，调用 <code>DataMonitor#register(path, registration)</code> 方法。</p><h3 id="2-2-1-ModuleRegistration"><a href="#2-2-1-ModuleRegistration" class="headerlink" title="2.2.1 ModuleRegistration"></a>2.2.1 ModuleRegistration</h3><p><code>org.skywalking.apm.collector.cluster.ModuleRegistration</code> ，模块注册信息<strong>抽象类</strong>。不同 Module 通过实现 ModuleRegistration ，将它们注册到 ModuleRegisterService。目前子类如下 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_20/05.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/ModuleRegistration.java" rel="external nofollow noopener noreferrer" target="_blank"><code>#buildValue()</code></a> <strong>抽象</strong>方法，获得模块注册信息( <a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/ModuleRegistration.java#L30" rel="external nofollow noopener noreferrer" target="_blank">Value</a> )。</p><h2 id="2-3-ModuleListenerService"><a href="#2-3-ModuleListenerService" class="headerlink" title="2.3 ModuleListenerService"></a>2.3 ModuleListenerService</h2><p><code>org.skywalking.apm.collector.cluster.service.ModuleListenerService</code> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> 接口，注册监听器服务<strong>接口</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/service/ModuleListenerService.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><code>#addListener(listener)</code></a> <strong>接口</strong>方法，添加监听器。一般情况下，实现该接口方法，调用 <code>DataMonitor#addListener(listener)</code> 方法。</p><h3 id="2-3-1-ClusterModuleListener"><a href="#2-3-1-ClusterModuleListener" class="headerlink" title="2.3.1 ClusterModuleListener"></a>2.3.1 ClusterModuleListener</h3><p><code>org.skywalking.apm.collector.cluster.ClusterModuleListener</code> ，集群组件监听器<strong>抽象类</strong>。目前子类如下 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_20/11.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/ClusterModuleListener.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><strong>构造方法</strong></a>，创建地址数组( <code>addresses</code> )。该数组的读写方法如下：</p><ul><li><code>#addAddress(address)</code></li><li><code>#removeAddress(address)</code></li><li><code>#getAddresses()</code></li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/ClusterModuleListener.java#L43" rel="external nofollow noopener noreferrer" target="_blank"><code>#path()</code></a> <strong>抽象</strong>方法，返回路径。该路径即为 ClusterModuleListener 监听的<strong>“事件”</strong>。多个 Collector 节点的相同 Module ，<strong>通过路径分组形成集群</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/ClusterModuleListener.java#L62" rel="external nofollow noopener noreferrer" target="_blank"><code>#serverJoinNotify(serverAddress)</code></a> / <a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/ClusterModuleListener.java#L69" rel="external nofollow noopener noreferrer" target="_blank"><code>#serverQuitNotify(serverAddress)</code></a> <strong>抽象</strong>方法，通知服务的加入 / 下线。目前只有 GRPCRemoteSenderService <strong>真正</strong>( 其它都是空方法 )实现该方法，在 <a href="http://www.iocoder.cn/SkyWalking/collector-remote-module">《SkyWalking 源码分析 —— Collector Remote 远程通信服务》「3.2 GRPCRemoteSenderService」</a> 详细解析。</p><h2 id="2-4-DataMonitor"><a href="#2-4-DataMonitor" class="headerlink" title="2.4 DataMonitor"></a>2.4 DataMonitor</h2><p><code>org.skywalking.apm.collector.cluster.DataMonitor</code> ，数据监<strong>视</strong>器<strong>接口</strong>。通过实现 DataMonitor 接口，基于不同的存储器实现注册发现。目前子类如下 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_20/06.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/DataMonitor.java#L40" rel="external nofollow noopener noreferrer" target="_blank"><code>#register(path, registration)</code></a> <strong>接口</strong>方法，注册模块注册信息。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/DataMonitor.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>#addListener(ClusterModuleListener)</code></a> <strong>接口</strong>方法，添加监听器。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/DataMonitor.java#L42" rel="external nofollow noopener noreferrer" target="_blank"><code>#getListener(path)</code></a> <strong>接口</strong>方法，获得监听<strong>指定路径</strong>的监听器。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/DataMonitor.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><code>#setClient(Client)</code></a> <strong>接口</strong>方法，设置 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-component/client-component/src/main/java/org/skywalking/apm/collector/client/Client.java" rel="external nofollow noopener noreferrer" target="_blank">Client</a> 。在 <a href="https://github.com/YunaiV/skywalking/tree/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-component/client-component/src/main/java/org/skywalking/apm/collector/client" rel="external nofollow noopener noreferrer" target="_blank"><code>client-component</code></a> 有 ZookeeperClient / H2Client / ElasticSearchClient 等多种实现。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/DataMonitor.java#L34" rel="external nofollow noopener noreferrer" target="_blank"><code>BASE_CATALOG</code></a> 属性，基础目录为 <code>&quot;/skywalking&quot;</code> 。例如说，在 Zookeeper 为根节点的路径。</li><li><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/DataMonitor.java#L44" rel="external nofollow noopener noreferrer" target="_blank"><code>#createPath(path)</code></a> <strong>接口</strong>方法，使用 Client 创建路径。</li><li><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/DataMonitor.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#setData(path)</code></a> <strong>接口</strong>方法，使用 Client 设置路径的值。</li></ul><h1 id="3-collector-cluster-zookeeper-provider"><a href="#3-collector-cluster-zookeeper-provider" class="headerlink" title="3. collector-cluster-zookeeper-provider"></a>3. collector-cluster-zookeeper-provider</h1><p><code>collector-cluster-zookeeper-provider</code> ，基于 Zookeeper 的集群管理实现。项目结构如下 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_20/07.png" alt=""></p><p>实际使用时，通过 <code>application.yml</code> 配置如下：</p><figure class="highlight"><table><tr><td class="code"><pre><div class="line">cluster:</div><div class="line">  zookeeper:</div><div class="line">    hostPort: localhost:2181</div><div class="line">    sessionTimeout: 100000</div></pre></td></tr></table></figure><ul><li>生产环境下，推荐 Zookeeper 配置成集群。</li></ul><h2 id="3-1-ClusterModuleZookeeperProvider"><a href="#3-1-ClusterModuleZookeeperProvider" class="headerlink" title="3.1 ClusterModuleZookeeperProvider"></a>3.1 ClusterModuleZookeeperProvider</h2><p><code>org.skywalking.apm.collector.cluster.zookeeper.ClusterModuleZookeeperProvider</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java" rel="external nofollow noopener noreferrer" target="_blank">ModuleProvider</a> <strong>抽象类</strong>，基于 Zookeeper 的集群管理服务提供者。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterModuleZookeeperProvider.java#L53" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回组件服务提供者名为 <code>&quot;zookeeper&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterModuleZookeeperProvider.java#L57" rel="external nofollow noopener noreferrer" target="_blank"><code>module()</code></a> <strong>实现</strong>方法，返回组件类为 ClusterModule 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterModuleZookeeperProvider.java#L94" rel="external nofollow noopener noreferrer" target="_blank"><code>#requiredModules()</code></a> <strong>实现</strong>方法，返回依赖组件为空。</p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterModuleZookeeperProvider.java#L61" rel="external nofollow noopener noreferrer" target="_blank"><code>#prepare(Properties)</code></a> <strong>实现</strong>方法，执行准备阶段逻辑。</p><ul><li>第 63 行 ：创建 ClusterZKDataMonitor 对象。</li><li>第 69 行 ：创建 ZookeeperClient 对象。<strong>注意，此时并未连接 Zookeeper</strong> 。</li><li>第 71 至 73 行 ：创建 ZookeeperModuleListenerService / ZookeeperModuleRegisterService 对象，并调用 <code>#registerServiceImplementation()</code> <strong>父类</strong>方法，注册到 <code>services</code> 。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterModuleZookeeperProvider.java#L76" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> <strong>实现</strong>方法，执行启动阶段逻辑。</p><ul><li>第 79 行 ：调用 <code>ZookeeperClient#initialize()</code> 方法，初始化 ZookeeperClient ，<strong>此时会连接 Zookeeper</strong>。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterModuleZookeeperProvider.java#L85" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyAfterCompleted()</code></a> <strong>实现</strong>方法，执行启动完成逻辑。</p><ul><li>第 88 行 ：调用 <code>ClusterZKDataMonitor#start()</code> 方法，启动 ClusterZKDataMonitor 。在本文 <a href="#">「3.4 ClusterZKDataMonitor」</a> 详细解析。</li></ul><h2 id="3-2-ZookeeperModuleRegisterService"><a href="#3-2-ZookeeperModuleRegisterService" class="headerlink" title="3.2 ZookeeperModuleRegisterService"></a>3.2 ZookeeperModuleRegisterService</h2><p><code>org.skywalking.apm.collector.cluster.zookeeper.service.ZookeeperModuleRegisterService</code> ，基于 Zookeeper 的模块注册服务<strong>实现类</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/service/ZookeeperModuleRegisterService.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>#register(moduleName, providerName, registration)</code></a> <strong>实现</strong>方法，调用 <code>ClusterZKDataMonitor#register(path, registration)</code> 方法，注册模块注册信息。</p><h2 id="3-3-ZookeeperModuleListenerService"><a href="#3-3-ZookeeperModuleListenerService" class="headerlink" title="3.3 ZookeeperModuleListenerService"></a>3.3 ZookeeperModuleListenerService</h2><p><code>org.skywalking.apm.collector.cluster.zookeeper.service.ZookeeperModuleListenerService</code> ，基于 Zookeeper 的注册监听器服务<strong>实现类</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/service/ZookeeperModuleListenerService.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>#addListener(ClusterModuleListener)</code></a> <strong>实现</strong>方法，调用 <code>ClusterZKDataMonitor#addListener(ClusterModuleListener)</code> 方法，注册模块注册信息。</p><h2 id="3-4-ClusterZKDataMonitor"><a href="#3-4-ClusterZKDataMonitor" class="headerlink" title="3.4 ClusterZKDataMonitor"></a>3.4 ClusterZKDataMonitor</h2><p><code>org.skywalking.apm.collector.cluster.zookeeper.ClusterZKDataMonitor</code> ，基于 Zookeeper 的数据监视器<strong>实现类</strong>。</p><p>在看具体代码实现之前，我们先来看看 Zookeeper 是如何存储数据的，如下图所示 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_20/08.png" alt=""></p><ul><li>紫色部分，通过调用 <a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterZKDataMonitor.java#L172" rel="external nofollow noopener noreferrer" target="_blank"><code>#createPath(path)</code></a> 方法，顺着路径，逐层创建<strong>持久</strong>节点。</li><li>黄色部分，通过调用 <a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterZKDataMonitor.java#L184" rel="external nofollow noopener noreferrer" target="_blank"><code>#setData(path)</code></a> 方法，创建<strong>临时</strong>节点，设置 Collector 模块地址。若 Collector 集群有 N 个节点，则此处会有 N 个<strong>临时</strong>节点。</li><li><p>打开 <code>zkClient.sh</code> ，我们来看一个例子 ：</p>  <figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 1] ls /skywalking</div><div class="line">[remote, ui, agent_jetty, agent_gRPC]</div><div class="line"></div><div class="line">[zk: localhost:2181(CONNECTED) 2] ls /skywalking/ui</div><div class="line">[jetty]</div><div class="line"></div><div class="line">[zk: localhost:2181(CONNECTED) 3] ls /skywalking/ui/jetty</div><div class="line">[localhost:12800]</div><div class="line"></div><div class="line">[zk: localhost:2181(CONNECTED) 4] get /skywalking/ui/jetty/localhost:12800</div><div class="line">/</div><div class="line">cZxid = 0x24</div><div class="line">ctime = Thu Dec 14 16:05:25 CST 2017</div><div class="line">mZxid = 0x24</div><div class="line">mtime = Thu Dec 14 16:05:25 CST 2017</div><div class="line">pZxid = 0x24</div><div class="line">cversion = 0</div><div class="line">dataVersion = 0</div><div class="line">aclVersion = 0</div><div class="line">ephemeralOwner = 0x16052d8b9f40006</div><div class="line">dataLength = 1</div><div class="line">numChildren = 0</div></pre></td></tr></table></figure></li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterZKDataMonitor.java#L163" rel="external nofollow noopener noreferrer" target="_blank"><code>#register(path, registration)</code></a> <strong>实现</strong>方法，添加到组件注册信息集合( <code>registrations</code> )。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterZKDataMonitor.java#L123" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> 方法，启动 ClusterZKDataMonitor ，将组件注册信息( <code>registrations</code> ) 写到 Zookeeper 中。</p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterZKDataMonitor.java#L157" rel="external nofollow noopener noreferrer" target="_blank"><code>#addListener(listener)</code></a> <strong>实现</strong>方法，添加到监听器集合( <code>listeners</code> )。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterZKDataMonitor.java#L123" rel="external nofollow noopener noreferrer" target="_blank"><code>#process(WatchedEvent)</code></a> <strong>实现</strong>方法，处理有 Collector 节点的组件加入或下线。总体逻辑是，从 Zookeeper 获取变更的路径下的地址数组，和本地的地址( <code>ClusterModuleListener.addresses</code> )比较，处理加入或移除逻辑的地址。</p><ul><li>ClusterZKDataMonitor 实现 <code>org.apache.zookeeper.Watcher</code> <strong>接口</strong>，所以实现该方法。</li><li>该方法是 <code>synchronized</code> 方法，以保证不会出现并发问题。</li></ul><h2 id="3-5-ZookeeperClient"><a href="#3-5-ZookeeperClient" class="headerlink" title="3.5 ZookeeperClient"></a>3.5 ZookeeperClient</h2><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-component/client-component/src/main/java/org/skywalking/apm/collector/client/zookeeper/ZookeeperClient.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.client.zookeeper.ZookeeperClient</code></a> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-component/client-component/src/main/java/org/skywalking/apm/collector/client/Client.java" rel="external nofollow noopener noreferrer" target="_blank">Client</a> <strong>接口</strong>，Zookeeper 客户端。</p><p>代码比较简单，胖友自己阅读理解。</p><h1 id="4-collector-cluster-standalone-provider"><a href="#4-collector-cluster-standalone-provider" class="headerlink" title="4. collector-cluster-standalone-provider"></a>4. collector-cluster-standalone-provider</h1><p><code>collector-cluster-standalone-provider.ClusterStandaloneDataMonitor</code> ，基于 H2 的 集群管理实现。<strong>该实现是单机版，建议仅用于 SkyWalking 快速上手，生产环境不建议使用</strong>。项目结构如下 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_20/09.png" alt=""></p><p>大体实现和 <code>collector-cluster-zookeeper-provider</code> 差不多，差异在对 DataMonitor 的实现类 ClusterStandaloneDataMonitor 上。</p><p>在 ClusterStandaloneDataMonitor 里，实际并未使用 H2Client ，而是基于内存，胖友可以自己查看下。</p><h1 id="5-collector-cluster-redis-provider"><a href="#5-collector-cluster-redis-provider" class="headerlink" title="5. collector-cluster-redis-provider"></a>5. collector-cluster-redis-provider</h1><p><code>collector-cluster-redis-provider</code> ：基于 Redis 的集群管理实现。<em>目前暂未完成</em>。</p><p>【TODO 4003】等实现后来写写，基于 Redis Pub Sub 保证实时性</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>有一种硬生生把很简单的东西，写的很复杂的感觉。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_20/10.png" alt=""></p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-cluster-module/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-cluster-module/&lt;
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector 初始化</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-init/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-init/</id>
    <published>2020-07-14T16:00:00.000Z</published>
    <updated>2017-12-25T05:23:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-init/">http://www.iocoder.cn/SkyWalking/collector-init/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-init/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-init/">2. CollectorBootStartUp</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-init/">2. ApplicationConfigLoader</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-init/">3. ModuleManager</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-init/">3.1 Module</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-init/">3.2 ModuleProvider</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-init/">3.3 Service</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-init/">3.4 BootstrapFlow</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-init/">4. Module 实现类简介</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>SkyWalking Collector 启动初始化的过程</strong>。在分享的过程中，我们会<strong>简单</strong>介绍 Collector 每个模块及其用途。</p><p>ps ：Collector 是 SkyWalking 的 Server 端。整体如下图 ：</p><blockquote><p>FROM <a href="https://github.com/apache/incubating-skywalking" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubating-skywalking</a><br><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/01.png" alt=""></p></blockquote><h1 id="2-CollectorBootStartUp"><a href="#2-CollectorBootStartUp" class="headerlink" title="2. CollectorBootStartUp"></a>2. CollectorBootStartUp</h1><p><code>org.skywalking.apm.collector.boot.CollectorBootStartUp</code> ，在 <code>apm-sniffer/apm-agent</code> Maven 模块项目里，SkyWalking Collector <strong>启动入口</strong>。 </p><p><a href="https://github.com/YunaiV/skywalking/blob/c633c1f0e143d1df2457926ab239350a642f7be2/apm-collector/apm-collector-boot/src/main/java/org/skywalking/apm/collector/boot/CollectorBootStartUp.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>#main(args)</code></a> 方法，启动 Collector ，代码如下 ：</p><ul><li>第 45 行 ：调用 <code>ApplicationConfiguration#load()</code> 方法，加载 Collector <strong>配置</strong>。</li><li>第 47 行 ：调用 <code>ModuleManager#init(...)</code> 方法，初始化 Collector <strong>组件</strong>们。</li><li>第 60 行 ：调用 <code>Thread#sleep(60000)</code> 方法，等待 Collector 内嵌的 Jetty Server 启动完成。</li></ul><h1 id="2-ApplicationConfigLoader"><a href="#2-ApplicationConfigLoader" class="headerlink" title="2. ApplicationConfigLoader"></a>2. ApplicationConfigLoader</h1><p><code>org.skywalking.apm.collector.boot.config.ApplicationConfigLoader</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/c633c1f0e143d1df2457926ab239350a642f7be2/apm-collector/apm-collector-boot/src/main/java/org/skywalking/apm/collector/boot/config/ConfigLoader.java#L24" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.boot.config.ConfigLoader</code></a> 接口，Collector 配置( <a href="https://github.com/YunaiV/skywalking/blob/c633c1f0e143d1df2457926ab239350a642f7be2/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ApplicationConfiguration.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.core.module.ApplicationConfiguration</code></a> )加载器。</p><p>在看具体代码实现之前，我们先了解下 ApplicationConfiguration 整体类结构。如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/02.png" alt=""></p><ul><li>Collector 使用组件管理器( ModuleManager )，管理<strong>多个</strong>组件( <a href="https://github.com/YunaiV/skywalking/blob/c633c1f0e143d1df2457926ab239350a642f7be2/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java" rel="external nofollow noopener noreferrer" target="_blank">Module</a> )。<ul><li>一个组件有多种组件服务提供者( <a href="https://github.com/YunaiV/skywalking/blob/c633c1f0e143d1df2457926ab239350a642f7be2/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java" rel="external nofollow noopener noreferrer" target="_blank">ModuleProvider</a> )，<strong>同时</strong>一个组件只允许使用<strong>一个</strong>组件服务提供者。这块下面会有代码解析说明。</li></ul></li><li>Collector 使用一个应用配置类( <a href="https://github.com/YunaiV/skywalking/blob/c633c1f0e143d1df2457926ab239350a642f7be2/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ApplicationConfiguration.java" rel="external nofollow noopener noreferrer" target="_blank">ApplicationConfiguration</a> )。<ul><li>一个应用配置类包含多个组件配置类( <a href="https://github.com/YunaiV/skywalking/blob/c633c1f0e143d1df2457926ab239350a642f7be2/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ApplicationConfiguration.java#L62" rel="external nofollow noopener noreferrer" target="_blank">ModuleConfiguration</a> )。每个组件对应一个组件配置类。</li><li>一个组件配置类包含多个组件服务提供者配置( <a href="https://github.com/YunaiV/skywalking/blob/c633c1f0e143d1df2457926ab239350a642f7be2/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ApplicationConfiguration.java#L93" rel="external nofollow noopener noreferrer" target="_blank">ProviderConfiguration</a> )。每个组件服务提供者对应一个组件配置类。<strong>注意</strong>：因为一个组件只允许<strong>同时</strong>使用<strong>一个</strong>组件服务提供者，所以一个组件配置类<strong>只设置</strong>一个组件服务提供者配置。</li></ul></li><li>整个配置文件，对应应用配置类。<strong>绿框</strong>部分，对应一个组件配置类。<strong>红框</strong>部分，对应一个组件服务提供者配置类。</li></ul><p>下面，我们来看看 <a href="https://github.com/YunaiV/skywalking/blob/c633c1f0e143d1df2457926ab239350a642f7be2/apm-collector/apm-collector-boot/src/main/java/org/skywalking/apm/collector/boot/config/ApplicationConfigLoader.java#L43" rel="external nofollow noopener noreferrer" target="_blank"><code>ApplicationConfigLoader#load()</code></a> 方法，代码如下 ：</p><ul><li>第 47 行 ：调用 <code>#loadConfig()</code> 方法，从 <code>apm-collector-core</code> 的 <a href="https://github.com/YunaiV/skywalking/blob/c633c1f0e143d1df2457926ab239350a642f7be2/apm-collector/apm-collector-core/src/main/resources/application-default.yml" rel="external nofollow noopener noreferrer" target="_blank"><code>application.yml</code></a> 加载自定义配置。</li><li>第 49 行 ：调用 <code>#loadDefaultConfig()</code> 方法，从 <code>apm-collector-core</code> 的 <a href="https://github.com/YunaiV/skywalking/blob/c633c1f0e143d1df2457926ab239350a642f7be2/apm-collector/apm-collector-core/src/main/resources/application-default.yml" rel="external nofollow noopener noreferrer" target="_blank"><code>application-default.yml</code></a> 加载默认配置。</li><li>两个方法逻辑基本一致，已经添加代码注释，胖友自己阅读理解。</li></ul><h1 id="3-ModuleManager"><a href="#3-ModuleManager" class="headerlink" title="3. ModuleManager"></a>3. ModuleManager</h1><p><code>org.skywalking.apm.collector.core.module.ModuleManager</code> ，组件管理器，负责组件的管理与初始化。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ff055ee52da855ef6cc8bfdfae7c2758ae3c61cd/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleManager.java#L49" rel="external nofollow noopener noreferrer" target="_blank"><code>#init()</code></a> 方法，初始化组件们，代码如下 ：</p><ul><li><p>第 51 至 53 行 ：调用 <code>java.util.ServiceLoader#load(Module.class)</code> 方法，加载所有 Module 实现类的实例数组。ServiceManager 基于 SPI (Service Provider Interface) 机制，在每个 <code>apm-collector-xxx-define</code> 项目的 <code>/resources/META-INF.services/org.skywalking.apm.collector.core.module.Module</code> 文件里，定义了该项目 Module 的实现类。如果胖友对 SPI 机制不熟悉，可以看下如下文章 ：</p><ul><li><a href="http://www.jianshu.com/p/32d3e108f30a" rel="external nofollow noopener noreferrer" target="_blank">《SPI 和 ServiceLoader》</a> </li><li><a href="http://www.jianshu.com/p/46aa69643c97" rel="external nofollow noopener noreferrer" target="_blank">《跟我学Dubbo系列之Java SPI机制简介》</a> </li></ul></li><li><p>第 55 至 75 行 ：遍历所有 Module 实现类的实例数组，创建<strong>在配置中</strong>的 Module 实现类的实例，并执行 Module 准备阶段的逻辑，后添加到加载的组件实例的映射( <code>loadedModules</code> )。</p><ul><li>第 59 至 67 行 ：创建 Module 对象。</li><li>第 69 行 ：调用 <code>Module#prepare(...)</code> 方法，执行 Module 准备阶段的逻辑。在改方法内部，会创建 Module 对应的 ModuleProvider 。在 <a href="#">「3.1 Module」</a> 详细解析。</li><li>第 71 行 ：添加到 <code>loadedModules</code> 。</li></ul></li><li>第 77 至 80 行 ：校验<strong>在配置中</strong>的 Module 实现类的实例都创建了，否则抛出异常。</li><li>第 84 行 ：调用 <code>BootstrapFlow#start(...)</code> 方法，执行 Module 启动逻辑。<a href="#">「3.4 BootstrapFlow」</a> 详细解析。</li><li>第 86 行 ：调用 <code>BootstrapFlow#notifyAfterCompleted()</code> 方法，执行 Module 启动完成，通知 ModuleProvider 。<a href="#">「3.4 BootstrapFlow」</a> 详细解析。</li><li>总的来说，Module 初始化的过程，可以理解成三个阶段，如下图所示 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/03.png" alt=""></li></ul><h2 id="3-1-Module"><a href="#3-1-Module" class="headerlink" title="3.1 Module"></a>3.1 Module</h2><p><code>org.skywalking.apm.collector.core.module.Module</code> ，组件<strong>抽象类</strong>。通过实现 Module 抽象类，实现不同功能的组件。目前 Collector 的 Module 实现类如下图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/04.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/204a9e658dd95cc8ee5d4e65d7ca1ed58f3a71da/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>抽象</strong>方法，获得组件名。目前组件名有 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/05.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/204a9e658dd95cc8ee5d4e65d7ca1ed58f3a71da/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java#L110" rel="external nofollow noopener noreferrer" target="_blank"><code>#providers()</code></a> 方法，获得 ModuleProvider 数组。实际上，一个 Module <strong>同时</strong>只能有一个 ModuleProvider ，参见 <a href="https://github.com/YunaiV/skywalking/blob/204a9e658dd95cc8ee5d4e65d7ca1ed58f3a71da/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java#L114" rel="external nofollow noopener noreferrer" target="_blank"><code>#provider()</code></a> 方法。</p><p><a href="https://github.com/YunaiV/skywalking/blob/204a9e658dd95cc8ee5d4e65d7ca1ed58f3a71da/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java#L55" rel="external nofollow noopener noreferrer" target="_blank"><code>#services()</code></a> <strong>抽象</strong>方法，获得 Service <strong>类</strong>数组。具体 Service <strong>对象</strong>，在 ModuleProvider 对象里获取，参见 <a href="https://github.com/YunaiV/skywalking/blob/204a9e658dd95cc8ee5d4e65d7ca1ed58f3a71da/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java#L122" rel="external nofollow noopener noreferrer" target="_blank"><code>#getService(serviceType)</code></a> 方法。</p><p><a href="https://github.com/YunaiV/skywalking/blob/204a9e658dd95cc8ee5d4e65d7ca1ed58f3a71da/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java#L66" rel="external nofollow noopener noreferrer" target="_blank"><code>#prepare(...)</code></a> 方法，执行 Module <strong>准备阶段</strong>的逻辑，代码如下 ：</p><ul><li>第 69 行 ：调用 <code>java.util.ServiceLoader#load(ModuleProvider.class)</code> 方法，加载所有 ModuleProvider 实现类的实例数组。ServiceManager 基于 SPI (Service Provider Interface) 机制，在每个 <code>apm-collector-xxx-yyy-provider</code> 项目的 <code>/resources/META-INF.services/org.skywalking.apm.collector.core.module.ModuleProvider</code> 文件里，定义了该项目 ModuleProvider 的实现类。</li><li>第 72 至 93 行 ：遍历所有 ModuleProvider 实现类的实例数组，创建<strong>在配置中</strong>的 ModuleProvider 实现类的实例，后添加到加载的组件服务提供者实例的映射( <code>loadedProviders</code> )。</li><li>第 95 至 98 行 ：校验有 ModuleProvider 初始化，否则抛出异常。</li><li>第 100 至 104 行 ：调用 <code>ModuleProvider#prepare(...)</code>  方法，执行 ModuleProvider 准备阶段的逻辑。在改方法内部，会创建 ModuleProvider 对应的 Service 。在 <a href="#">「3.2 ModuleProvider」</a> 详细解析。</li></ul><h2 id="3-2-ModuleProvider"><a href="#3-2-ModuleProvider" class="headerlink" title="3.2 ModuleProvider"></a>3.2 ModuleProvider</h2><p><code>org.skywalking.apm.collector.core.module.ModuleProvider</code> ，组件服务提供者<strong>抽象类</strong>。通过实现 ModuleProvider 抽象类，实现不同功能的组件服务提供者。目前 Collector 的 ModuleProvider 实现类如下图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/06.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java#L64" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>抽象</strong>方法，获得组件服务提供者名。目前组件服务提供者名有 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/07.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java#L69" rel="external nofollow noopener noreferrer" target="_blank"><code>#module()</code></a> <strong>抽象</strong>方法，获得 ModuleProvider 对应的 Module <strong>类</strong>。注意，ModuleProvider 的名字可以重复，例如上图的 <code>jetty</code> ，通过对应的 Module <strong>类</strong>来区分。</p><p><a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java#L95" rel="external nofollow noopener noreferrer" target="_blank"><code>#requiredModules()</code></a> <strong>抽象</strong>方法，获得 ModuleProvider 依赖的 Module <strong>名字</strong>数组。</p><p>———- Service 相关方法 Begin ———-</p><p><a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java#L103" rel="external nofollow noopener noreferrer" target="_blank"><code>#registerServiceImplementation(Class&lt;? extends Service&gt;, Service)</code></a> 方法，注册 Service 对象。一个 ModuleProvider 可以有 0 到 N 个 Service 对象。</p><p><a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java#L133" rel="external nofollow noopener noreferrer" target="_blank"><code>#getService(Class&lt;T&gt;)</code></a> 方法，获得 Service 对象。</p><p><a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java#L118" rel="external nofollow noopener noreferrer" target="_blank"><code>#requiredCheck(...)</code></a> 方法，<strong>校验</strong> ModuleProvider 包含的 Service 们都创建成功。</p><ul><li><strong>方法参数</strong>，从 <code>Module#services()</code> 方法获得。</li><li>该方法会被 <code>BootstrapFlow#start()</code> 方法调用，在 <a href="#">「3.4 BootstrapFlow」</a> 详细解析。</li></ul><p>———- Service 相关方法 End ———-</p><p><a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java#L76" rel="external nofollow noopener noreferrer" target="_blank"><code>#prepare(Properties)</code></a> <strong>抽象</strong>方法，执行 ModuleProvider 准备阶段的逻辑：Service 的创建，私有变量的创建等等。例如，<a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-storage/collector-storage-h2-provider/src/main/java/org/skywalking/apm/collector/storage/h2/StorageModuleH2Provider.java#L123" rel="external nofollow noopener noreferrer" target="_blank"><code>StorageModuleH2Provider#prepare(Properties)</code></a> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java#L83" rel="external nofollow noopener noreferrer" target="_blank"><code>#start(Properties)</code></a> <strong>抽象</strong>方法，执行 ModuleProvider 启动阶段的逻辑：私有变量的初始化等等。例如，<a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-storage/collector-storage-h2-provider/src/main/java/org/skywalking/apm/collector/storage/h2/StorageModuleH2Provider.java#L136" rel="external nofollow noopener noreferrer" target="_blank"><code>StorageModuleH2Provider#start(Properties)</code></a> 。</p><ul><li>该方法会被 <code>BootstrapFlow#start()</code> 方法调用，在 <a href="#">「3.4 BootstrapFlow」</a> 详细解析。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java#L90" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyAfterCompleted()</code></a> <strong>抽象</strong>方法，执行 ModuleProvider 启动完成阶段的逻辑：私有变量的初始化等等。例如，<a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/StorageModuleEsProvider.java#L170" rel="external nofollow noopener noreferrer" target="_blank"><code>StorageModuleEsProvider#notifyAfterCompleted(Properties)</code></a> 。</p><ul><li>该方法会被 <code>BootstrapFlow#notifyAfterCompleted()</code> 方法调用，在 <a href="#">「3.4 BootstrapFlow」</a> 详细解析。</li></ul><h2 id="3-3-Service"><a href="#3-3-Service" class="headerlink" title="3.3 Service"></a>3.3 Service</h2><p><code>org.skywalking.apm.collector.core.module.Service</code> ，服务<strong>接口</strong>。通过实现 Service 接口，实现不同功能的服务。目前 Collector 的 Service 实现类如下图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/08.png" alt=""></p><p>这里有一点要注意下，实际上 Module 是与 Service <strong>“直接”</strong> 一对多的关系。中间 有一层 ModuleProvider 存在的原因是，相同 Module 可以有多种 ModuleProvider 实现，而 ModuleProvider 提供提供相同功能的 Service ，但是实现不同。</p><p>以 <code>apm-collector-storage</code> 举例子，如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/09.png" alt=""></p><ul><li>StorageModuleEsProvider / StorageModuleH2Provider 分别基于 ES / H2 实现，其提供存储相同数据的不同实现。例如 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/10.png" alt=""></li></ul><p>一般 <code>collector-xxx-define</code> 的 <code>service</code> 包下，会定义当前模块提供的 Service 接口，如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/12.png" alt=""></p><p>这也是为什么有 <code>Module#services()</code> 和 <code>#requiredCheck(Class&lt;? extends Service&gt;[])</code> 这样的方法涉及的原因。</p><p>另外，如下是 Service 接口的解释：</p><blockquote><p>The <code>Service</code> implementation is a service provided by its own modules.  </p><p>And every {@link ModuleProvider} must provide all the given services of the {@link Module}.</p></blockquote><h2 id="3-4-BootstrapFlow"><a href="#3-4-BootstrapFlow" class="headerlink" title="3.4 BootstrapFlow"></a>3.4 BootstrapFlow</h2><p><a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/BootstrapFlow.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.core.module.BootstrapFlow</code></a>，组件启动流程。</p><p>BootstrapFlow <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/BootstrapFlow.java#L42" rel="external nofollow noopener noreferrer" target="_blank"><strong>构造方法</strong></a>，调用 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/BootstrapFlow.java#L86" rel="external nofollow noopener noreferrer" target="_blank"><code>#makeSequence()</code></a> 方法，获得 ModuleProvider 启动顺序，这个是该类的<strong>重点</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/BootstrapFlow.java#L51" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> 方法，执行 Module 启动逻辑。</p><ul><li>第 54 至 63 行 ：校验<strong>依赖</strong> Module 已经都存在。</li><li>第 67 行 ：校验 ModuleProvider 包含的 Service 们都<strong>创建成功</strong>。</li><li>第 70 行 ：调用 <code>ModuleProvider#start(...)</code> 方法，执行 ModuleProvider 启动阶段逻辑。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/BootstrapFlow.java#L74" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyAfterCompleted()</code></a> 方法，调用 <code>ModuleProvider#notifyAfterCompleted()</code> 方法，执行 ModuleProvider 启动完成阶段的逻辑。</p><h1 id="4-Module-实现类简介"><a href="#4-Module-实现类简介" class="headerlink" title="4. Module 实现类简介"></a>4. Module 实现类简介</h1><p><img src="https://camo.githubusercontent.com/2a00cb347f6a7d7afb8faef8d8b0f2a0d3215d9d/68747470733a2f2f736b7977616c6b696e67746573742e6769746875622e696f2f706167652d7265736f75726365732f332e322e352532625f6172636869746563747572652e6a7067" alt=""></p><ul><li>Naming Module ：<a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/?self">《SkyWalking 源码分析 —— Collector Naming Server 命名服务》</a></li><li>UI Module ：</li><li>Queue Module ：<a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/?self">《SkyWalking 源码分析 —— Collector Queue 队列组件》</a></li><li>Cache Module ：<a href="http://www.iocoder.cn/SkyWalking/collector-cache-module/?self">《SkyWalking 源码分析 —— Collector Cache 缓存组件》</a></li><li>Cluster Module ：<a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/?self">《SkyWalking 源码分析 —— Collector Cluster 集群管理》</a></li><li>Component Libraries ：<a href="http://www.iocoder.cn/SkyWalking/collector-client-component/?self">《SkyWalking 源码分析 —— Collector Client Component 客户端组件》</a> 、<a href="http://www.iocoder.cn/SkyWalking/collector-server-component/?self">《SkyWalking 源码分析 —— Collector Server Component 服务器组件》</a></li><li>Core ：<ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/?self">《SkyWalking 源码分析 —— Collector Storage 存储组件》「2. apm-collector-core」</a> </li><li><a href="http://www.iocoder.cn/SkyWalking/collector-init/?self">《SkyWalking 源码分析 —— Collector 初始化》「3. ModuleManager」</a></li></ul></li><li>Storage Module ：<a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/?self">《SkyWalking 源码分析 —— Collector Storage 存储组件》</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（一）》「2. apm-collector-core/graph」</a> </li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（二）》「2. Data」</a> </li></ul></li><li>Agent Module ：TODO</li><li>Jetty Manager Module ：<a href="http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/?self">《SkyWalking 源码分析 —— Collector Jetty Server Manager》</a></li><li>gRPC Manager Module ：<a href="http://www.iocoder.cn/SkyWalking/collector-grpc-server-module/?self">《SkyWalking 源码分析 —— Collector gRPC Server Manager》</a></li><li>Agent Streaming Computing ：<ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（一）》「2. apm-collector-core/graph」</a> </li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（二）》「2. Data」</a> </li><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/?self">《SkyWalking 源码分析 —— Collector Remote 远程通信服务》</a></li></ul></li><li>Baseline Module ：todo</li><li>Alerting Module ：todo</li></ul><p>TODO 【4001】Module 实现文章链接 </p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>可能要进入特别忙碌的一段时间，不确定 SkyWalking 文章后续的更新频率。</p><p>继续加油。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/11.png" alt=""></p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-init/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-init/&lt;/a&gt; 「芋道源码」欢迎转载，保留摘要，
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Agent 插件体系</title>
    <link href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/"/>
    <id>http://www.iocoder.cn/SkyWalking/agent-plugin-system/</id>
    <published>2020-07-09T16:00:00.000Z</published>
    <updated>2017-12-12T09:06:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">http://www.iocoder.cn/SkyWalking/agent-plugin-system/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">2. 插件的加载</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">2.1 AgentClassLoader</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">2.2 PluginResourcesResolver</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">2.3 PluginCfg</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">2.4 AbstractClassEnhancePluginDefine</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">2.5 小结</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">3. 插件的匹配</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">3.1 InstrumentDebuggingClass</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">3.2 ClassMatch</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">3.3 PluginFinder</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">4. 插件的拦截</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">4.1 ClassEnhancePluginDefine</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">4.2 InterceptPoint</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">4.3 Interceptor</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">4.4 Inter</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">4.5 小结</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>SkyWalking Agent 插件体系</strong>。主要涉及三个流程 ：</p><ul><li>插件的加载</li><li>插件的匹配</li><li>插件的拦截</li></ul><p>可能看起来有点抽象，不太容易理解。淡定，我们每个小章节进行解析。</p><p>本文涉及到的类主要在 <a href="https://github.com/YunaiV/skywalking/tree/3de8a6c15d07aa3b2c3b4e732e6654fc87c4e70e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin</code></a> 包里，如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/01.png" alt=""></p><p>每个流程会涉及到较多的类，我们会贯穿着解析代码实现。</p><h1 id="2-插件的加载"><a href="#2-插件的加载" class="headerlink" title="2. 插件的加载"></a>2. 插件的加载</h1><p>在 <a href="http://www.iocoder.cn/SkyWalking/agent-init/?self">《SkyWalking 源码分析 —— Agent 初始化》</a> 一文中，Agent 初始化时，调用 <code>PluginBootstrap#loadPlugins()</code> 方法，加载所有的插件。整体流程如下图 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/03.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/130f0a5a3438663b393e53ba2cca02a8d13c258a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginBootstrap.java#L45" rel="external nofollow noopener noreferrer" target="_blank"><code>PluginBootstrap#loadPlugins()</code></a> 方法，代码如下 ：</p><ul><li>第 47 行 ：调用 <code>AgentClassLoader#initDefaultLoader()</code> 方法，初始化 AgentClassLoader 。在本文 <a href="#">「2.1 AgentClassLoader」</a> 详细解析。</li><li>第 50 至 56 行 ：获得插件<strong>定义路径</strong>数组。在本文 <a href="#">「2.2 PluginResourcesResolver」</a> 详细解析。</li><li>第 59 至 66 行 ：获得插件<strong>定义</strong>( <a href="https://github.com/OpenSkywalking/skywalking/blob/b16d23c1484bec941367d6b36fa932b8ace40971/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginDefine.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.PluginDefine</code></a> )数组。在本文 <a href="#">「2.3 PluginCfg」</a> 详细解析。</li><li>第 69 至 82 行 ：创建<strong>类增强插件定义</strong>( <a href="https://github.com/OpenSkywalking/skywalking/blob/b16d23c1484bec941367d6b36fa932b8ace40971/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/AbstractClassEnhancePluginDefine.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.AbstractClassEnhancePluginDefine</code></a> )对象数组。不同插件通过实现 AbstractClassEnhancePluginDefine <strong>抽象类</strong>，定义不同框架的<strong>切面</strong>，<strong>记录调用链路</strong>。在本文 <a href="#">「2.4 AbstractClassEnhancePluginDefine」</a> 简单解析。</li></ul><h2 id="2-1-AgentClassLoader"><a href="#2-1-AgentClassLoader" class="headerlink" title="2.1 AgentClassLoader"></a>2.1 AgentClassLoader</h2><p><code>org.skywalking.apm.agent.core.plugin.loader.AgentClassLoader</code> ，继承 <code>java.lang.ClassLoader</code> ，Agent 类加载器。</p><p><strong>为什么实现自定义的 ClassLoader</strong> ？应用<strong>透明</strong>接入 SkyWalking ，不会<strong>显示</strong>导入 SkyWalking 的插件依赖。通过实现自定义的 ClassLoader ，从插件 Jar 中查找相关类。例如说，从 <code>apm-dubbo-plugin-3.2.6-2017.jar</code> 查找 <code>org.skywalking.apm.plugin.dubbo.DubboInstrumentation</code> 。</p><hr><p>AgentClassLoader <strong>构造方法</strong>，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AgentClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * The default class loader for the agent.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AgentClassLoader DEFAULT_LOADER;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * classpath</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> List&lt;File&gt; classpath;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Jar 数组</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> List&lt;Jar&gt; allJars;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Jar 读取时的锁</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> ReentrantLock jarScanLock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AgentClassLoader</span><span class="params">(ClassLoader parent)</span> <span class="keyword">throws</span> AgentPackageNotFoundException </span>&#123;</div><div class="line">        <span class="keyword">super</span>(parent);</div><div class="line">        File agentDictionary = AgentPackagePath.getPath();</div><div class="line">        classpath = <span class="keyword">new</span> LinkedList&lt;File&gt;();</div><div class="line">        classpath.add(<span class="keyword">new</span> File(agentDictionary, <span class="string">"plugins"</span>));</div><div class="line">        classpath.add(<span class="keyword">new</span> File(agentDictionary, <span class="string">"activations"</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>DEFAULT_LOADER</code> <strong>静态</strong>属性，默认单例。通过 <a href="https://github.com/YunaiV/skywalking/blob/3de8a6c15d07aa3b2c3b4e732e6654fc87c4e70e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/loader/AgentClassLoader.java#L56" rel="external nofollow noopener noreferrer" target="_blank"><code>#getDefault()</code></a> 方法，可以获取到它。</li><li><code>classpath</code> 属性，Java 类所在的目录。在构造方法中，我们可以看到 <code>${AGENT_PACKAGE_PATH}/plugins</code> / <code>${AGENT_PACKAGE_PATH}/activations</code> 添加到 <code>classpath</code> 。在 <a href="https://github.com/YunaiV/skywalking/blob/3de8a6c15d07aa3b2c3b4e732e6654fc87c4e70e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/loader/AgentClassLoader.java#L163" rel="external nofollow noopener noreferrer" target="_blank"><code>#getAllJars()</code></a>  方法中，加载该目录下的 Jar 中的 Class 文件。</li><li><code>allJars</code> 属性，Jar 数组。</li><li><code>jarScanLock</code> 属性，Jar 读取时的<strong>锁</strong>。</li></ul><hr><p><code>#initDefaultLoader()</code> <strong>静态</strong>方法，初始化<strong>默认</strong>的 AgentClassLoader ，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AgentClassLoader <span class="title">initDefaultLoader</span><span class="params">()</span> <span class="keyword">throws</span> AgentPackageNotFoundException </span>&#123;</div><div class="line">    DEFAULT_LOADER = <span class="keyword">new</span> AgentClassLoader(PluginBootstrap.class.getClassLoader());</div><div class="line">    <span class="keyword">return</span> getDefault();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>使用 <code>org.skywalking.apm.agent.core.plugin.PluginBootstrap</code> 的类加载器作为 AgentClassLoader 的<strong>父类加载器</strong>。</li></ul><hr><p>如下方法已经添加相关中文注释，胖友请自行阅读理解 ：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/778093d38a0a820b90092c2ed77a08e3393169eb/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/loader/AgentClassLoader.java#L132" rel="external nofollow noopener noreferrer" target="_blank"><code>#findResource(name)</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/778093d38a0a820b90092c2ed77a08e3393169eb/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/loader/AgentClassLoader.java#L150" rel="external nofollow noopener noreferrer" target="_blank"><code>#findResources(String name)</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/778093d38a0a820b90092c2ed77a08e3393169eb/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/loader/AgentClassLoader.java#L182" rel="external nofollow noopener noreferrer" target="_blank"><code>#getAllJars()</code></a></li></ul><p>在 ClassLoader 加载资源( 例如，类 )，会调用 <code>#findResource(name)</code> / <code>#findResources(name)</code> 方法。</p><h2 id="2-2-PluginResourcesResolver"><a href="#2-2-PluginResourcesResolver" class="headerlink" title="2.2 PluginResourcesResolver"></a>2.2 PluginResourcesResolver</h2><p><code>org.skywalking.apm.agent.core.plugin.PluginResourcesResolver</code> ，插件资源解析器，读取所有插件的定义文件。插件定义文件必须以 <code>skywalking-plugin.def</code> <strong>命名</strong>，例如 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/02.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/d4a6ba291419ab90379a3d1c423b747f682f857f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginResourcesResolver.java#L45" rel="external nofollow noopener noreferrer" target="_blank"><code>#getResources()</code></a> 方法，获得插件定义路径数组，代码如下 ：</p><ul><li>第 50 行 ：使用 AgentClassLoader 获得所有 <code>skywalking-plugin.def</code> 的路径。</li></ul><h2 id="2-3-PluginCfg"><a href="#2-3-PluginCfg" class="headerlink" title="2.3 PluginCfg"></a>2.3 PluginCfg</h2><p><code>org.skywalking.apm.agent.core.plugin.PluginCfg</code> ，插件定义配置，读取 <code>skywalking-plugin.def</code> 文件，生成插件定义( <a href="https://github.com/YunaiV/skywalking/blob/43241fff19e17f19b918c96ffd588787f8f05519/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginDefine.java#L27" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.PluginDefinie</code></a> )数组。</p><p><a href="https://github.com/YunaiV/skywalking/blob/43241fff19e17f19b918c96ffd588787f8f05519/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginCfg.java#L55" rel="external nofollow noopener noreferrer" target="_blank"><code>#load(InputStream)</code></a> 方法，读取 <code>skywalking-plugin.def</code> 文件，添加到 <code>pluginClassList</code> 。如下是 <code>apm-springmvc-annotation-4.x-plugin-3.2.6-2017.jar</code> 插件的定义文件 ：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">spring-mvc-annotation-4.x=org.skywalking.apm.plugin.spring.mvc.v4.define.ControllerInstrumentation</div><div class="line">spring-mvc-annotation-4.x=org.skywalking.apm.plugin.spring.mvc.v4.define.RestControllerInstrumentation</div><div class="line">spring-mvc-annotation-4.x=org.skywalking.apm.plugin.spring.mvc.v4.define.HandlerMethodInstrumentation</div><div class="line">spring-mvc-annotation-4.x=org.skywalking.apm.plugin.spring.mvc.v4.define.InvocableHandlerInstrumentation</div></pre></td></tr></table></figure><h2 id="2-4-AbstractClassEnhancePluginDefine"><a href="#2-4-AbstractClassEnhancePluginDefine" class="headerlink" title="2.4 AbstractClassEnhancePluginDefine"></a>2.4 AbstractClassEnhancePluginDefine</h2><p><code>org.skywalking.apm.agent.core.plugin.AbstractClassEnhancePluginDefine</code> ，类增强插件定义<strong>抽象基类</strong>。不同插件通过实现 AbstractClassEnhancePluginDefine <strong>抽象类</strong>，定义不同框架的<strong>切面</strong>，<strong>记录调用链路</strong>。以 Spring 插件为例子，如下是相关类图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_05/06.png" alt=""></p><p>PluginDefine 对象的 <code>defineClass</code> 属性，即对应不同插件对AbstractClassEnhancePluginDefine 的<strong>实现类</strong>。所以在 <a href="https://github.com/YunaiV/skywalking/blob/130f0a5a3438663b393e53ba2cca02a8d13c258a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginBootstrap.java#L45" rel="external nofollow noopener noreferrer" target="_blank"><code>PluginBootstrap#loadPlugins()</code></a> 方法的【<strong>第 74 行</strong>】，我们看到通过该属性，创建创建<strong>类增强插件定义</strong>对象。</p><h2 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h2><p>胖友，回过头，在看一下流程图，理解理解。</p><h1 id="3-插件的匹配"><a href="#3-插件的匹配" class="headerlink" title="3. 插件的匹配"></a>3. 插件的匹配</h1><p>在 <a href="http://www.iocoder.cn/SkyWalking/agent-init/?self">《SkyWalking 源码分析 —— Agent 初始化》</a> 一文，我们提到，SkyWalking Agent 基于 <strong>JavaAgent</strong> 机制，实现应用<strong>透明</strong>接入 SkyWalking 。下面笔者默认胖友已经对 JavaAgent 机制已经有一定的了解。如果胖友暂时不了解，建议先阅读如下文章 ：</p><ul><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html" rel="external nofollow noopener noreferrer" target="_blank">《Instrumentation 新功能》</a></li><li><a href="http://www.infoq.com/cn/articles/javaagent-illustrated" rel="external nofollow noopener noreferrer" target="_blank">《JVM源码分析之javaagent原理完全解读》</a></li></ul><blockquote><p>友情提示 ：建议自己手撸一个简单的 JavaAgent ，更容易理解 SkyWalking Agent 。 </p><p>笔者练手的 JavaAgent 项目地址 ：<a href="https://github.com/YunaiV/learning/tree/master/javaagent01" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/YunaiV/learning/tree/master/javaagent01</a></p></blockquote><p>通过 JavaAgent 机制，我们可以在 <code>#premain(String, Instrumentation)</code> 方法里，调用 <code>Instrumentation#addTransformer(ClassFileTransformer)</code> 方法，向 Instrumentation 注册 <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/instrument/ClassFileTransformer.html" rel="external nofollow noopener noreferrer" target="_blank"><code>java.lang.instrument.ClassFileTransformer</code></a> 对象，可以修改 Java 类的二进制，从而<strong>动态</strong>修改 Java 类的代码实现。</p><p>如果胖友使用过 AOP 实现切面记录日志，那么就很容易理解，SkyWalking 通过这样的方式，使用不同框架定义<strong>方法切面</strong>，从而在在切面<strong>记录调用链路</strong>。</p><hr><p>直接修改 Java 类的二进制，是非常繁杂的。因此，SkyWalking 引入了 <a href="https://github.com/raphw/byte-buddy" rel="external nofollow noopener noreferrer" target="_blank"><code>byte-buddy</code></a> 。</p><blockquote><p><code>byte-buddy</code> 是一个代码生成和操作库，用于在 Java 应用程序<br>运行时创建和修改 Java 类，而徐无需编译器的帮助。</p><p>除了参与 Java 类库一起提供代码生成工具外，<code>byte-buddy</code> 允许创建任意类，并不限于实现用于创建运行时代理的接口。  </p><p>此外，<code>byte-buddy</code> 提供了一个方便的 API ，用于 Java Agent 或在构建过程中更改类。</p></blockquote><p>下面笔者默认胖友已经对 <code>byte-buddy</code> 有一定的了解。如果胖友暂不了解，建议先阅读如下文章 ：</p><ul><li><a href="http://www.jianshu.com/p/fe1448bf7d31" rel="external nofollow noopener noreferrer" target="_blank">《Java字节码3-使用ByteBuddy实现一个Java-Agent》</a></li><li><a href="https://notes.diguage.com/byte-buddy-tutorial/" rel="external nofollow noopener noreferrer" target="_blank">《Byte Buddy 教程》</a></li><li><a href="https://www.infoq.com/articles/Easily-Create-Java-Agents-with-ByteBuddy" rel="external nofollow noopener noreferrer" target="_blank">《Easily Create Java Agents with Byte Buddy》</a></li><li><a href="http://www.kailing.pub/article/index/arcid/178.html" rel="external nofollow noopener noreferrer" target="_blank">《skywalking源码分析之javaAgent工具ByteBuddy的应用》</a> 搜索 “BYTE BUDDY应用” 部分</li></ul><blockquote><p>友情提示 ：建议自己简单使用下 <code>byte-buddy</code> ，更容易理解 SkyWalking Agent 。 </p><p>笔者练手的 <code>byte-buddy</code> 项目地址 ：<a href="https://github.com/YunaiV/learning/tree/master/bytebuddy" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/YunaiV/learning/tree/master/bytebuddy</a></p></blockquote><hr><p>下面，让我们打开 <a href="https://github.com/YunaiV/skywalking/blob/b68162306b4db7adfd4a2c2891a205b7085f38f0/apm-sniffer/apm-agent/src/main/java/org/skywalking/apm/agent/SkyWalkingAgent.java#L79" rel="external nofollow noopener noreferrer" target="_blank"><code>SkyWalkingAgent#premain(String, Instrumentation)</code></a> 方法，从【第 79 行】代码开始看 ：</p><ul><li>第 79 至 104 行 ：创建 <a href="https://github.com/raphw/byte-buddy/blob/188366ace6e16ec167a00b144c9048d78495165f/byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java" rel="external nofollow noopener noreferrer" target="_blank"><code>net.bytebuddy.agent.builder.AgentBuilder</code></a> 对象，并设置相关属性。<ul><li>AgentBuilder ，提供便利的 API ，创建 Java Agent 。</li><li>第 79 行 ：调用 <code>AgentBuilder#type(ElementMatcher)</code> 方法，实现 <a href="https://github.com/raphw/byte-buddy/blob/188366ace6e16ec167a00b144c9048d78495165f/byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ElementMatcher.java#L13" rel="external nofollow noopener noreferrer" target="_blank"><code>net.bytebuddy.matcher.ElementMatcher</code></a> 接口，设置需要拦截的类。<code>PluginFinder#buildMatch()</code> 方法，在本文 <a href="#">「3.3 PluginFinder」</a> 详细解析。</li><li>第 79 至 104 行 ：调用 <code>AgentBuilder#transform(Transformer)</code> 方法，设置 Java 类的修改逻辑。<ul><li>第 84 行 ：调用 <code>PluginFinder#find(TypeDescription, ClassLoader)</code> 方法，获得<strong>匹配</strong>的 AbstractClassEnhancePluginDefine 数组。因为在【<strong>第 79 行</strong>】的代码，设置了<strong>所有</strong>插件需要拦截的类，所以此处需要匹配<strong>该类对应</strong>的 AbstractClassEnhancePluginDefine 数组。<code>PluginFinder#find(TypeDescription, ClassLoader)</code> 方法，在本文 <a href="#">「3.3 PluginFinder」</a> 详细解析。</li><li>第 85 行 ：判断匹配的 AbstractClassEnhancePluginDefine 数组大于零。从目前的代码看下来，此处属于<strong>防御性编程</strong>，在【<strong>第 79 行</strong>】的代码保证一定能匹配到 AbstractClassEnhancePluginDefine 。</li><li>第 86 至 100 行 ：循环匹配到 AbstractClassEnhancePluginDefine 数组，调用 <code>AbstractClassEnhancePluginDefine#define(...)</code> 方法，设置 <a href="https://github.com/raphw/byte-buddy/blob/188366ace6e16ec167a00b144c9048d78495165f/byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java" rel="external nofollow noopener noreferrer" target="_blank"><code>net.bytebuddy.dynamic.DynamicType.Builder</code></a> 对象。通过该对象，定义<strong>如何拦截</strong>需要修改的 Java 类。在 <code>AbstractClassEnhancePluginDefine#define(...)</code> 方法的内部，会调用 <a href="https://github.com/raphw/byte-buddy/blob/188366ace6e16ec167a00b144c9048d78495165f/byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java#L1512" rel="external nofollow noopener noreferrer" target="_blank"><code>net.bytebuddy.dynamic.DynamicType.ImplementationDefinition#intercept(Implementation)</code></a> 方法，本文 <a href="#">「4. 插件的拦截」</a> 也会详细解析。</li><li>第 91 行 ：为什么会出现返回为<strong>空</strong>的情况呢？同一个框架在不同的<strong>大</strong>版本，使用的方式相同，但是实现的代码却不尽相同。举个例子，SpringMVC 3 和 SpringMVC 4 ，<strong>都</strong>有 <code>@RequestMapping</code> 注解定义 URL ，所以【<strong>第 84 行</strong>】会匹配到 <code>AbstractSpring3Instrumentation</code> / <code>AbstractSpring4Instrumentation</code> <strong>两个</strong>。当应用使用的是 Spring MVC 4 时，调用 <code>AbstractSpring3Instrumentation#define(...)</code> 方法会返回空，而调用 <code>AbstractSpring4Instrumentation#define(...)</code> 方法会有返回值。这是如何实现的呢？本文 <a href="#">「4. 插件的拦截」</a> 也会详细解析。</li></ul></li></ul></li><li>第 105 至 134 行 ：调用 <a href="https://github.com/raphw/byte-buddy/blob/188366ace6e16ec167a00b144c9048d78495165f/byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java#L114" rel="external nofollow noopener noreferrer" target="_blank"><code>AgentBuilder#with(Listener)</code></a> 方法，添加监听器。<ul><li><code>#onTransformation(...)</code> 方法，当 Java 类的修改<strong>成功</strong>，进行调用。</li><li><code>#onError(...)</code> 方法，当 Java 类的修改<strong>失败</strong>，进行调用。InstrumentDebuggingClass 在本文 <a href="#">「3.1 InstrumentDebuggingClass」</a> 详细解析。</li></ul></li><li>第 135 行 ：调用 <a href="https://github.com/raphw/byte-buddy/blob/master/byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java#L620" rel="external nofollow noopener noreferrer" target="_blank"><code>AgentBuilder#installOn(Instrumentation)</code></a> 方法，根据<strong>上面</strong> AgentBuilder 设置的属性，创建 <a href="https://github.com/raphw/byte-buddy/blob/188366ace6e16ec167a00b144c9048d78495165f/byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/ResettableClassFileTransformer.java" rel="external nofollow noopener noreferrer" target="_blank"><code>net.bytebuddy.agent.builder.ResettableClassFileTransformer</code></a> 对象，配置到 Instrumentation 对象上。在 <code>AgentBuilder#installOn(Instrumentation)</code> 方法的内部，会调用 <code>Instrumentation#addTransformer(ClassFileTransformer)</code> 方法。</li></ul><hr><p>😈 这个方法信息量比较大，笔者对 <code>byte-buddy</code> 不是很熟悉，花费了较多时间梳理与理解。建议，如果胖友此处不是理解的很清晰，可以阅读完全文，在回过头再捋一捋这块的代码实现。</p><h2 id="3-1-InstrumentDebuggingClass"><a href="#3-1-InstrumentDebuggingClass" class="headerlink" title="3.1 InstrumentDebuggingClass"></a>3.1 InstrumentDebuggingClass</h2><p><code>org.skywalking.apm.agent.InstrumentDebuggingClass</code> ，Instrument 调试类，用于将被 JavaAgent 修改的<strong>所有</strong>类存储到 <code>${JAVA_AGENT_PACKAGE}/debugger</code> 目录下。需要配置 <code>agent.is_open_debugging_class = true</code> ，效果如下图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/04.png" alt=""></p><p>代码比较简单，胖友点击 <a href="https://github.com/YunaiV/skywalking/blob/b68162306b4db7adfd4a2c2891a205b7085f38f0/apm-sniffer/apm-agent/src/main/java/org/skywalking/apm/agent/InstrumentDebuggingClass.java" rel="external nofollow noopener noreferrer" target="_blank">InstrumentDebuggingClass</a> 理解。</p><h2 id="3-2-ClassMatch"><a href="#3-2-ClassMatch" class="headerlink" title="3.2 ClassMatch"></a>3.2 ClassMatch</h2><p>在分享本节相关内容之前，我们先来看下 <code>bytebuddy</code> 的 <a href="https://github.com/raphw/byte-buddy/tree/188366ace6e16ec167a00b144c9048d78495165f/byte-buddy-dep/src/main/java/net/bytebuddy/matcher" rel="external nofollow noopener noreferrer" target="_blank"><code>net.bytebuddy.matcher</code></a> 模块。该模块提供了各种灵活的匹配方法。那么 SkyWalking 为什么实现自己的 <a href="https://github.com/YunaiV/skywalking/tree/43241fff19e17f19b918c96ffd588787f8f05519/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/match" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.match</code></a> 模块？笔者认为，仅定位于<strong>类级别的匹配</strong>，更常用而又精简的 API 。</p><hr><p><code>org.skywalking.apm.agent.core.plugin.match.ClassMatch</code> ，类匹配<strong>接口</strong>。目前子类如下 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/05.png" alt=""></p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/b68162306b4db7adfd4a2c2891a205b7085f38f0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/match/NameMatch.java#L28" rel="external nofollow noopener noreferrer" target="_blank">NameMatch</a> ：基于<strong>完整的类名</strong>进行匹配，例如：<code>&quot;com.alibaba.dubbo.monitor.support.MonitorFilter&quot;</code> 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/b68162306b4db7adfd4a2c2891a205b7085f38f0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/match/IndirectMatch.java" rel="external nofollow noopener noreferrer" target="_blank">IndirectMatch</a> ：<strong>间接</strong>匹配<strong>接口</strong>。相比 NameMatch 来说，确实比较 “委婉” 🙂 。<ul><li><a href="https://github.com/YunaiV/skywalking/blob/b68162306b4db7adfd4a2c2891a205b7085f38f0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/match/ClassAnnotationMatch.java" rel="external nofollow noopener noreferrer" target="_blank">ClassAnnotationMatch</a> ：基于<strong>类注解</strong>进行匹配，可设置<strong>同时</strong>匹配多个。例如：<code>&quot;@RequestMapping&quot;</code>。</li><li><a href="https://github.com/YunaiV/skywalking/blob/b68162306b4db7adfd4a2c2891a205b7085f38f0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/match/HierarchyMatch.java" rel="external nofollow noopener noreferrer" target="_blank">HierarchyMatch</a> ：基于<strong>父类 / 接口</strong>进行匹配，可设置<strong>同时</strong>匹配多个。</li><li><a href="https://github.com/YunaiV/skywalking/blob/b68162306b4db7adfd4a2c2891a205b7085f38f0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/match/MethodAnnotationMatch.java" rel="external nofollow noopener noreferrer" target="_blank">MethodAnnotationMatch</a> ：基于<strong>方法注解</strong>进行匹配，可设置<strong>同时</strong>匹配多个。目前项目里主要用于匹配方法上的  <a href="https://github.com/OpenSkywalking/skywalking/blob/8d9820322bdfc956d9d4f0d04f55ce985926cfae/apm-application-toolkit/apm-toolkit-trace/src/main/java/org/apache/skywalking/apm/toolkit/trace/Trace.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.toolkit.trace.@Trace</code></a> 注解。</li></ul></li></ul><p>每个类已经添加详细的代码注释，胖友喜欢哪个点哪个哟。</p><h2 id="3-3-PluginFinder"><a href="#3-3-PluginFinder" class="headerlink" title="3.3 PluginFinder"></a>3.3 PluginFinder</h2><p><code>org.skywalking.apm.agent.core.plugin.PluginFinder</code> ，插件发现者。其提供 <a href="https://github.com/YunaiV/skywalking/blob/09c654af33081e56547cb8b3b9e0c8525ddce32f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginFinder.java#L80" rel="external nofollow noopener noreferrer" target="_blank"><code>#find(...)</code></a> 方法，获得<strong>类增强插件定义</strong>( <a href="https://github.com/OpenSkywalking/skywalking/blob/b16d23c1484bec941367d6b36fa932b8ace40971/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/AbstractClassEnhancePluginDefine.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.AbstractClassEnhancePluginDefine</code></a> )对象。</p><p>PluginFinder <strong><a href="https://github.com/YunaiV/skywalking/blob/09c654af33081e56547cb8b3b9e0c8525ddce32f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginFinder.java#L56" rel="external nofollow noopener noreferrer" target="_blank">构造方法</a></strong>，代码如下 ：</p><ul><li>第 57 至 77 行 ：循环 AbstractClassEnhancePluginDefine 对象数组，添加到 <code>nameMatchDefine</code> / <code>signatureMatchDefine</code> 属性，方便 <code>#find(...)</code> 方法查找 AbstractClassEnhancePluginDefine 对象。<ul><li>第 65 至 72 行 ：处理 NameMatch 为匹配的 AbstractClassEnhancePluginDefine 对象，添加到 <code>nameMatchDefine</code>  属性。</li><li>第 74 至 76 行 ：处理<strong>非</strong> NameMatch 为匹配的 AbstractClassEnhancePluginDefine 对象，添加到 <code>signatureMatchDefine</code> 属性。</li></ul></li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/b68162306b4db7adfd4a2c2891a205b7085f38f0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginFinder.java#L89" rel="external nofollow noopener noreferrer" target="_blank"><code>#find(...)</code></a> 方法，获得<strong>类增强插件定义</strong>( <a href="https://github.com/OpenSkywalking/skywalking/blob/b16d23c1484bec941367d6b36fa932b8ace40971/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/AbstractClassEnhancePluginDefine.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.AbstractClassEnhancePluginDefine</code></a> )对象，代码如下 ：</p><ul><li>第 92 至 96 行 ：以 <code>nameMatchDefine</code> 属性来匹配 AbstractClassEnhancePluginDefine 对象。</li><li>第 98 至 104 行 ：以 <code>signatureMatchDefine</code> 属性来匹配 AbstractClassEnhancePluginDefine 对象。在这个过程中，会调用 <code>IndirectMatch#isMatch(TypeDescription)</code> 方法，进行匹配。</li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/b68162306b4db7adfd4a2c2891a205b7085f38f0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginFinder.java#L116" rel="external nofollow noopener noreferrer" target="_blank"><code>#buildMatch()</code></a> 方法，获得全部插件的类匹配，多个插件的类匹配条件以 <code>or</code> 分隔，代码如下 ：</p><ul><li>第 117 至 123 行 ：以 <code>nameMatchDefine</code> 属性来匹配。</li><li>第 124 至 132 行 ：以 <code>signatureMatchDefine</code> 属性来匹配。</li><li><strong>实际上，该方法和 <code>#find(...)</code> 方法逻辑是一致的</strong>。</li></ul><h1 id="4-插件的拦截"><a href="#4-插件的拦截" class="headerlink" title="4. 插件的拦截"></a>4. 插件的拦截</h1><p>在上文中，我们已经提到，SkyWalking 通过 JavaAgent 机制，对需要拦截的类的方法，使用 <code>byte-buddy</code> <strong>动态</strong>修改 Java 类的二进制，从而进行方法切面拦截，记录调用链路。</p><p>看具体的代码实现之前，想一下<strong>拦截</strong>会涉及到哪些元素 ：</p><ul><li>拦截切面 InterceptPoint</li><li>拦截器 Interceptor</li><li>拦截类的定义 Define ：一个类有哪些拦截切面及对应的拦截器</li></ul><p>下面，我们来看看本小节会涉及到的类。如图所示：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/06.png" alt=""></p><p>看起来类比想象的多？梳理之，结果如图 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/07.png" alt=""></p><ul><li>根据方法类型的不同，使用不同 ClassEnhancePluginDefine 的实现类。其中，构造方法和静态方法使用相同的实现类。</li><li><p>相比上面提到<strong>拦截</strong>会涉及到的元素，多了一个 <strong>Inter</strong> ？如下是官方的说明 ：</p><blockquote><p>In this class, it provide a bridge between <code>byte-buddy</code> and <code>sky-walking</code> plugin.</p></blockquote></li></ul><h2 id="4-1-ClassEnhancePluginDefine"><a href="#4-1-ClassEnhancePluginDefine" class="headerlink" title="4.1 ClassEnhancePluginDefine"></a>4.1 ClassEnhancePluginDefine</h2><p>整体类图如下：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/08.png" alt=""></p><ul><li>AbstractClassEnhancePluginDefine ：SkyWalking 类增强插件定义<strong>抽象基类</strong>。</li><li>ClassEnhancePluginDefine ：SkyWalking 类增强插件定义<strong>抽象类</strong>。</li><li>从 UML 图中的方法，我们可以看出，AbstractClassEnhancePluginDefine 注重在<strong>定义</strong>( Define )，ClassEnhancePluginDefine 注重在<strong>增强</strong>( Enhance )。</li></ul><p>整体流程如下 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/09.png" alt=""></p><p>OK ，下面我们开始看看代码是如何实现的。</p><h3 id="4-1-1-AbstractClassEnhancePluginDefine"><a href="#4-1-1-AbstractClassEnhancePluginDefine" class="headerlink" title="4.1.1 AbstractClassEnhancePluginDefine"></a>4.1.1 AbstractClassEnhancePluginDefine</h3><p><code>org.skywalking.apm.agent.core.plugin.AbstractClassEnhancePluginDefine</code> ，SkyWalking 类增强插件定义<strong>抽象基类</strong>。它注重在<strong>定义</strong>( Define )的抽象与实现。</p><p><a href="https://github.com/YunaiV/skywalking/blob/30683167c79c71ad088666c587a05c6d9f0daf3f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/AbstractClassEnhancePluginDefine.java#L93" rel="external nofollow noopener noreferrer" target="_blank"><code>#enhanceClass()</code></a> <strong>抽象</strong>方法，定义了类匹配( ClassMatch ) 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/30683167c79c71ad088666c587a05c6d9f0daf3f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/AbstractClassEnhancePluginDefine.java#L105" rel="external nofollow noopener noreferrer" target="_blank"><code>#witnessClasses()</code></a> 方法，见证类列表。当且仅当应用存在见证类列表，插件才生效。<strong>什么意思</strong>？让我们看看这种情况：一个<strong>类库</strong>存在两个发布的版本( 如 <code>1.0</code> 和 <code>2.0</code> )，其中包括<strong>相同</strong>的目标类，但不同的方法或不同的方法参数列表。所以我们需要根据库的不同版本使用插件的不同版本。然而版本显然不是一个选项，这时需要使用见证类列表，判断出当前引用类库的发布版本。</p><ul><li>举个实际的例子，SpringMVC 3 和 SpringMVC 4 ，<strong>都</strong>有 <code>@RequestMapping</code> 注解定义 URL 。<ul><li>通过判断存在 <code>org.springframework.web.servlet.view.xslt.AbstractXsltView</code> 类，应用使用 SpringMVC 3 ，使用 <code>apm-springmvc-annotation-3.x-plugin.jar</code> 。</li><li>通过判断存在 <code>org.springframework.web.servlet.tags.ArgumentTag</code> 类，应用使用 SpringMVC 4 ，使用 <code>apm-springmvc-annotation-4.x-plugin.jar</code> 。</li></ul></li><li><strong>另外</strong>，该方法返回<strong>空数组</strong>。即默认情况，插件生效，无需见证类列表。</li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/30683167c79c71ad088666c587a05c6d9f0daf3f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/AbstractClassEnhancePluginDefine.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#define(...)</code></a> 方法，设置 <a href="https://github.com/raphw/byte-buddy/blob/188366ace6e16ec167a00b144c9048d78495165f/byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java" rel="external nofollow noopener noreferrer" target="_blank"><code>net.bytebuddy.dynamic.DynamicType.Builder</code></a> 对象。通过该对象，定义<strong>如何拦截</strong>需要修改的目标 Java 类(方法的 <code>transformClassName</code> 参数)。代码如下 ：</p><ul><li>第 57 至 70 行 ：判断见证类列表是否都存在。若不存在，则插件不生效。<ul><li><a href="https://github.com/YunaiV/skywalking/blob/30683167c79c71ad088666c587a05c6d9f0daf3f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/WitnessClassFinder.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.WitnessClassFinder</code></a> ，已经添加完整注释，胖友点击查看。</li></ul></li><li>第 72 至 76 行 ：调用 <code>#enhance(...)</code> <strong>抽象</strong>方法，使用拦截器增强目标类。</li></ul><h3 id="4-1-2-ClassEnhancePluginDefine"><a href="#4-1-2-ClassEnhancePluginDefine" class="headerlink" title="4.1.2 ClassEnhancePluginDefine"></a>4.1.2 ClassEnhancePluginDefine</h3><p><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.ClassEnhancePluginDefine</code> ，SkyWalking 类增强插件定义<strong>抽象类</strong>。它注重在<strong>增强</strong>( Enhance )的抽象与实现。包括如下 ：</p><ul><li>静态方法、构造方法、实例方法的<strong>增强</strong></li><li>静态方法、构造方法、实例方法的<strong>拦截切面</strong></li></ul><hr><p>拦截切面，在 <a href="#">「4.2 InterceptPoint」</a> 有相关解析。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/ClassEnhancePluginDefine.java#L248" rel="external nofollow noopener noreferrer" target="_blank"><code>#getStaticMethodsInterceptPoints()</code></a> <strong>抽象</strong>方法，获得 StaticMethodsInterceptPoint <strong>数组</strong>。<br><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/ClassEnhancePluginDefine.java#L185" rel="external nofollow noopener noreferrer" target="_blank"><code>#getConstructorsInterceptPoints()</code></a> <strong>抽象</strong>方法，获得 ConstructorInterceptPoint <strong>数组</strong>。<br><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/ClassEnhancePluginDefine.java#L192" rel="external nofollow noopener noreferrer" target="_blank"><code>#getInstanceMethodsInterceptPoints()</code></a> <strong>抽象</strong>方法，获得 InstanceMethodsInterceptPoint <strong>数组</strong>。</p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/ClassEnhancePluginDefine.java#L67" rel="external nofollow noopener noreferrer" target="_blank"><code>#enhance(...)</code></a> 方法，增强静态方法、构造方法、实例方法。</p><h4 id="4-1-2-1-增强静态方法"><a href="#4-1-2-1-增强静态方法" class="headerlink" title="4.1.2.1 增强静态方法"></a>4.1.2.1 增强静态方法</h4><p>调用 <a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/ClassEnhancePluginDefine.java#L203" rel="external nofollow noopener noreferrer" target="_blank"><code>#enhanceClass(...)</code></a> 方法，增强静态方法，代码如下 ：</p><ul><li>第 206 至 210 行 ：调用 <code>#getStaticMethodsInterceptPoints()</code> 方法，获得 StaticMethodsInterceptPoint 数组。若为<strong>空</strong>，不进行增强。</li><li>第 212 至 238 行 ：<strong>遍历</strong> StaticMethodsInterceptPoint 数组，逐个增强StaticMethodsInterceptPoint 对应的静态方法。<ul><li>第 214 至 218 行 ：获得拦截器的<strong>类名</strong>。拦截器的实例，在 <strong>Inter 类</strong>里获取。</li><li>第 221 至 229 行 ：当 <code>StaticMethodsInterceptPoint#isOverrideArgs()</code> 方法返回 <code>true</code> 时，使用 StaticMethodsInterWithOverrideArgs 处理拦截逻辑。在 <a href="#">「4.4.3 静态方法 Inter」</a> 详细解析。</li><li>第 230 至 236 行 ：当 <code>StaticMethodsInterceptPoint#isOverrideArgs()</code> 方法返回 <code>false</code> 时，使用 StaticMethodsInter 处理拦截逻辑，在 <a href="#">「4.4.3 静态方法 Inter」</a> 详细解析。</li></ul></li></ul><h4 id="4-1-2-2-增强构造方法和实例方法"><a href="#4-1-2-2-增强构造方法和实例方法" class="headerlink" title="4.1.2.2 增强构造方法和实例方法"></a>4.1.2.2 增强构造方法和实例方法</h4><p>调用 <a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/ClassEnhancePluginDefine.java#L89" rel="external nofollow noopener noreferrer" target="_blank"><code>#enhanceInstance()</code></a> 方法，增强构造方法和实例方法，代码如下 ：</p><ul><li>第 92 至 110 行 ：调用 <code>#getConstructorsInterceptPoints()</code> / <code>#getInstanceMethodsInterceptPoints()</code>  方法，获得 ConstructorInterceptPoint / InstanceMethodsInterceptPoint 数组。若<strong>都</strong>为<strong>空</strong>，不进行增强。</li><li>第 112 至 128 行 ：使用 <code>byte-buddy</code> ，为目标 Java 类<strong>“自动”</strong>实现 <a href="https://github.com/OpenSkywalking/skywalking/blob/15328202b8b7df89a609885d9110361ff29ce668/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/plugin/interceptor/enhance/EnhancedInstance.java#L25" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.EnhancedInstance</code></a> 接口。这样，目标 Java 类就有一个私有变量，拦截器在执行过程中，可以存储状态到该私有变量。这里如果暂时不理解<strong>没关系</strong>，后面分享每个插件的实现时，会有实际的例子，更易懂。</li><li>———- 构造方法 ———-</li><li>第 130 至 143 行 ：<strong>遍历</strong> ConstructorInterceptPoint 数组，逐个增强 ConstructorInterceptPoint 对应的构造方法。使用 ConstructorInter 处理拦截逻辑，在 <a href="#">「4.4.1 构造方法 Inter」</a> 详细解析。</li><li>———- 实例方法 ———-</li><li>第 145 至 175 行 ：<strong>遍历</strong> InstanceMethodsInterceptPoint 数组，逐个增强 InstanceMethodsInterceptPoint 对应的静态方法。<ul><li>第 151 至 154 行 ：获得拦截器的<strong>类名</strong>。拦截器的实例，在 <strong>Inter 类</strong>里获取。</li><li>第 156 至 165 行 ：当 <code>InstanceMethodsInterceptPoint#isOverrideArgs()</code> 方法返回 <code>true</code> 时，使用 InstMethodsInterWithOverrideArgs 处理拦截逻辑。在 <a href="#">「4.4.2 实例方法 Inter」</a> 详细解析。</li><li>第 166 至 173 行 ：当 <code>InstanceMethodsInterceptPoint#isOverrideArgs()</code> 方法返回 <code>false</code> 时，使用 InstMethodsInter 处理拦截逻辑，在 <a href="#">「4.4.2 实例方法 Inter」</a> 详细解析。</li></ul></li></ul><h3 id="4-1-3-ClassStaticMethodsEnhancePluginDefine"><a href="#4-1-3-ClassStaticMethodsEnhancePluginDefine" class="headerlink" title="4.1.3 ClassStaticMethodsEnhancePluginDefine"></a>4.1.3 ClassStaticMethodsEnhancePluginDefine</h3><p><a href="https://github.com/YunaiV/skywalking/blob/c7c800bba485dcb9d532d6cb5686df273ae53d6d/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/ClassStaticMethodsEnhancePluginDefine.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.ClassStaticMethodsEnhancePluginDefine</code></a> ，类<strong>增强静态方法</strong>的插件定义<strong>抽象类</strong>，和本文 <a href="#">「4.1.2.1 增强静态方法」</a> 对应。</p><p>实现 <code>#getConstructorsInterceptPoints()</code> / <code>#getInstanceMethodsInterceptPoints()</code> <strong>抽象</strong>方法，返回空，表示不增强构造方法和实例方法。<strong>即只增强静态方法</strong>。</p><h3 id="4-1-4-ClassInstanceMethodsEnhancePluginDefine"><a href="#4-1-4-ClassInstanceMethodsEnhancePluginDefine" class="headerlink" title="4.1.4 ClassInstanceMethodsEnhancePluginDefine"></a>4.1.4 ClassInstanceMethodsEnhancePluginDefine</h3><p><a href="https://github.com/YunaiV/skywalking/blob/c7c800bba485dcb9d532d6cb5686df273ae53d6d/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/ClassInstanceMethodsEnhancePluginDefine.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.ClassInstanceMethodsEnhancePluginDefine</code></a> ，类<strong>增强构造方法和实例方法</strong>的插件定义<strong>抽象类</strong>，和本文 <a href="#">「4.1.2.2 增强构造方法和实例方法」</a> 对应。</p><p>实现 <code>#getStaticMethodsInterceptPoints()</code> <strong>抽象</strong>方法，返回空，表示不增强静态方法。<strong>即只增强构造方法和实例方法</strong>。</p><h2 id="4-2-InterceptPoint"><a href="#4-2-InterceptPoint" class="headerlink" title="4.2 InterceptPoint"></a>4.2 InterceptPoint</h2><table><thead><tr><th>InterceptPoint</th><th>方法类型</th><th>方法匹配</th><th>拦截器</th><th><code>#isOverrideArgs()</code></th></tr></thead><tbody><tr><td>StaticMethodsInterceptPoint</td><td>静态方法</td><td><code>#getMethodsMatcher()</code></td><td><code>#getMethodsInterceptor()</code></td><td>有</td></tr><tr><td>ConstructorInterceptPoint</td><td>构造方法</td><td><code>#getConstructorMatcher()</code></td><td><code>#getConstructorInterceptor()</code></td><td>无</td></tr><tr><td>InstanceMethodsInterceptPoint</td><td>实例方法</td><td><code>#getMethodsMatcher()</code></td><td><code>#getMethodsInterceptor()</code></td><td>有</td></tr></tbody></table><p>XXXInterceptPoint <strong>接口</strong>，对应一个 <code>net.bytebuddy.matcher.ElementMatcher</code>  和一个拦截器。</p><p>代码比较简单，胖友自己查看。</p><h2 id="4-3-Interceptor"><a href="#4-3-Interceptor" class="headerlink" title="4.3 Interceptor"></a>4.3 Interceptor</h2><p>在开始分享 <strong>Inter</strong> 之前，我们先来看看 Interceptor 相关接口。如下图所见：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/10.png" alt=""></p><ul><li>InstanceConstructorInterceptor ，构造方法拦截器<strong>接口</strong>。</li><li><em>AroundInterceptor</em><ul><li>StaticMethodsAroundInterceptor ，静态方法拦截器<strong>接口</strong>。</li><li>InstanceMethodsAroundInterceptor ，实例方法拦截器<strong>接口</strong>。</li><li>接口方法基本一致，下面 Inter 逻辑也基本一致。</li></ul></li></ul><p>在 <a href="#">「4. 2 InterceptPoint」</a> 里，我们看到 <code>#getXXXInterceptor()</code> 方法返回的拦截器类名，需要通过 <a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/loader/InterceptorInstanceLoader.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.loader.InterceptorInstanceLoader</code></a> 加载与创建拦截器实例。</p><h2 id="4-4-Inter"><a href="#4-4-Inter" class="headerlink" title="4.4 Inter"></a>4.4 Inter</h2><p>我们先来看 Inter 的定义 ：</p><blockquote><p>In this class, it provide a bridge between byte-buddy and sky-walking plugin.</p></blockquote><p>根据方法类型，将 Inter 整理如下 ：</p><table><thead><tr><th>方法类型</th><th></th><th></th></tr></thead><tbody><tr><td>构造方法</td><td>ConstructorInter</td><td></td></tr><tr><td>实例方法</td><td>InstMethodsInter</td><td>InstMethodsInterWithOverrideArgs</td></tr><tr><td>静态方法</td><td>StaticMethodsInter</td><td>StaticMethodsInterWithOverrideArgs</td></tr></tbody></table><h3 id="4-4-1-构造方法-Inter"><a href="#4-4-1-构造方法-Inter" class="headerlink" title="4.4.1 构造方法 Inter"></a>4.4.1 构造方法 Inter</h3><p><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/ConstructorInter.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.ConstructorInter</code></a> ，构造方法 Inter 。</p><p>ConstructorInter <a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/ConstructorInter.java#L52" rel="external nofollow noopener noreferrer" target="_blank"><strong>构造方法</strong></a>，调用 <code>InterceptorInstanceLoader#load(String, classLoader)</code> 方法，加载构造方法拦截器。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/ConstructorInter.java#L68" rel="external nofollow noopener noreferrer" target="_blank"><code>#intercept(Object)</code></a> 方法，<strong>在构造方法执行完成后进行拦截</strong>，调用 <code>InstanceConstructorInterceptor#onConstruct(...)</code> 方法。</p><p><strong>为什么没有 ConstructorInterWithOverrideArgs</strong>？<code>InstanceConstructorInterceptor#onConstruct(...)</code> 方法，是<strong>在构造方法执行完成后进行调用拦截</strong>，OverrideArgs 用于在调用方法之前，<strong>改变传入方法的参数</strong>。所以，在此处暂时没这块需要，因而没有 ConstructorInterWithOverrideArgs 。</p><h3 id="4-4-2-实例方法-Inter"><a href="#4-4-2-实例方法-Inter" class="headerlink" title="4.4.2 实例方法 Inter"></a>4.4.2 实例方法 Inter</h3><p><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/InstMethodsInter.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.InstMethodsInter</code></a> ，实例方法 Inter 。</p><p>ConstructorInter <a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/InstMethodsInter.java#L51" rel="external nofollow noopener noreferrer" target="_blank"><strong>构造方法</strong></a>，调用 <code>InterceptorInstanceLoader#load(String, classLoader)</code> 方法，加载实例方法拦截器。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/InstMethodsInter.java#L72" rel="external nofollow noopener noreferrer" target="_blank"><code>#intercept(...)</code></a> 方法，<strong>Before-After</strong> 方式拦截实例方法，代码如下 ：</p><ul><li>第 79 至 86 行 ：调用 <code>InstanceMethodsAroundInterceptor#beforeMethod(...)</code> 方法，执行在实例方法之前的逻辑。<ul><li><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/MethodInterceptResult.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.MethodInterceptResult</code></a> ，方法拦截器执行结果。当调用 <a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/MethodInterceptResult.java#L51" rel="external nofollow noopener noreferrer" target="_blank"><code>MethodInterceptResult#defineReturnValue(Object)</code></a> 方法，设置执行结果，并标记不再继续执行。</li></ul></li><li>第 90 至 92 行 ：当 MethodInterceptResult 已经有执行结果，<strong>不再执行原有方法，直接返回结果</strong>。</li><li>第 94 至 96 行 ：调用 <code>Callable#call()</code> 方法，执行原有实例方法。</li><li>第 97 至 105 行 ：调用 <code>InstanceMethodsAroundInterceptor#handleMethodException(...)</code> 方法，处理异常。</li><li>第 107 至 113 行 ：调用 <code>InstanceMethodsAroundInterceptor#afterMethod(...)</code> 方法，执行后置逻辑。</li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/InstMethodsInterWithOverrideArgs.java#L37" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.InstMethodsInterWithOverrideArgs</code></a> ，<strong>覆写参数</strong>的实例方法 Inter 。</p><p>不太理解<strong>覆写参数</strong>？有这样一个场景，<code>InstanceMethodsAroundInterceptor#beforeMethod(...)</code> 方法里，我们修改了方法参数，并且希望原有实例方法执行时，<strong>使用的是修改了的方法参数</strong>，此时，就需要使用 InstMethodsInterWithOverrideArgs 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/InstMethodsInterWithOverrideArgs.java#L73" rel="external nofollow noopener noreferrer" target="_blank"><code>InstMethodsInterWithOverrideArgs#intercept(...)</code></a> 方法，总体逻辑和 InstMethodsInter 是一致的，下面我们来看看差异点 ：</p><ul><li>第 76 行 ：方法参数类型是 <a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/OverrideCallable.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.OverrideCallable</code></a>，并且带有 <a href="https://github.com/raphw/byte-buddy/blob/188366ace6e16ec167a00b144c9048d78495165f/byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Morph.java" rel="external nofollow noopener noreferrer" target="_blank"><code>net.bytebuddy.implementation.bind.annotation.@Morph</code></a> 注解。</li><li>第 96 行 ：调用 <a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/OverrideCallable.java#L37" rel="external nofollow noopener noreferrer" target="_blank"><code>OverrideCallable#call(args)</code></a> 方法，使用被前置方法修改过的参数，执行原有实例方法。</li></ul><p>先来瞅瞅 <code>@Morph</code> 注解的定义 ：</p><blockquote><p>This annotation instructs Byte Buddy to inject a proxy class that calls a method’s super method with explicit arguments.  </p><p>For this, the {@link Morph.Binder} needs to be installed for an interface type that takes an argument of the array type {@link java.lang.Object} and returns a non-array type of {@link java.lang.Object}. </p><p>This is an alternative to using the {@link net.bytebuddy.implementation.bind.annotation.SuperCall} or {@link net.bytebuddy.implementation.bind.annotation.DefaultCall} annotations which call a super method using the same arguments as the intercepted method was invoked with.</p></blockquote><p>简单的来说 ：</p><ul><li><code>@Morph</code> 注解，注入一个代理对象，该对象会使用传入的参数，调用被代理的方法。例如在 InstMethodsInterWithOverrideArgs 里，调用 <code>OverrideCallable#call(args)</code> 方法，会调用原有实例方法。</li><li><p>需要使用 <code>Morph.Binder</code> 设置一个接口，并且该接口的方法定义为 <code>Object methodName(Object[])</code> 。在 InstMethodsInterWithOverrideArgs 使用的是  <a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/OverrideCallable.java#L29" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.OverrideCallable</code></a> 接口。另外，调用 <code>Morph.Binder#install(Class&lt;?&gt;)</code> 方法的代码如下 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ClassEnhancePluginDefine.java </span></div><div class="line"><span class="comment">// `#enhanceInstance(...)` 方法</span></div><div class="line">newClassBuilder =</div><div class="line">    newClassBuilder.method(not(isStatic()).and(instanceMethodsInterceptPoint.getMethodsMatcher())) <span class="comment">// 匹配</span></div><div class="line">        .intercept( <span class="comment">// 拦截</span></div><div class="line">            MethodDelegation.withDefaultConfiguration()</div><div class="line">                .withBinders(</div><div class="line">                    Morph.Binder.install(OverrideCallable.class) <span class="comment">// 覆写参数</span></div><div class="line">                )</div><div class="line">                .to(<span class="keyword">new</span> InstMethodsInterWithOverrideArgs(interceptor, classLoader))</div><div class="line">        );</div></pre></td></tr></table></figure></li></ul><h3 id="4-4-3-静态方法-Inter"><a href="#4-4-3-静态方法-Inter" class="headerlink" title="4.4.3 静态方法 Inter"></a>4.4.3 静态方法 Inter</h3><p><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/StaticMethodsInter.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.StaticMethodsInter</code></a> 和 <a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/StaticMethodsInterWithOverrideArgs.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.StaticMethodsInterWithOverrideArgs</code></a> 和<strong>实例方法 Inter</strong>基本一致，胖友可以自己捋一捋，笔者就不瞎比比了。</p><h2 id="4-5-小结"><a href="#4-5-小结" class="headerlink" title="4.5 小结"></a>4.5 小结</h2><p>总的来说，涉及到的组件，如下图 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/11.png" alt=""></p><p>胖友再梳理梳理。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>写完，蛮嗨皮😜。</p><p>近期最认真的一篇文章，没有之一，满足。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/12.png" alt=""></p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/agent-plugin-system/&quot;&gt;http://www.iocoder.cn/SkyWalking/agent-plugin-system/&lt;/a&gt; 「芋道源码」
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Agent 初始化</title>
    <link href="http://www.iocoder.cn/SkyWalking/agent-init/"/>
    <id>http://www.iocoder.cn/SkyWalking/agent-init/</id>
    <published>2020-07-04T16:00:00.000Z</published>
    <updated>2017-12-13T18:28:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/agent-init/">http://www.iocoder.cn/SkyWalking/agent-init/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-init/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-init/">2. SkyWalkingAgent</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-init/">3. SnifferConfigInitializer</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-init/">3.1 Config</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-init/">3.2 RemoteDownstreamConfig</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-init/">4. Plugin</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-init/">4.1 PluginBootstrap</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-init/">4.2 PluginFinder</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-init/">5. ServiceManager</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-init/">5.1 BootService</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-init/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>SkyWalking Agent 启动初始化的过程</strong>。</p><p>SkyWalking Agent 基于 <strong>JavaAgent</strong> 机制，实现应用<strong>透明</strong>接入 SkyWalking 。关于 JavaAgent 机制，笔者推荐如下两篇文章 ：</p><ul><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html" rel="external nofollow noopener noreferrer" target="_blank">《Instrumentation 新功能》</a></li><li><a href="http://www.infoq.com/cn/articles/javaagent-illustrated" rel="external nofollow noopener noreferrer" target="_blank">《JVM源码分析之javaagent原理完全解读》</a></li></ul><blockquote><p>友情提示 ：建议自己手撸一个简单的 JavaAgent ，更容易理解 SkyWalking Agent 。 </p><p>笔者练手的 JavaAgent 项目地址 ：<a href="https://github.com/YunaiV/learning/tree/master/javaagent01" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/YunaiV/learning/tree/master/javaagent01</a></p></blockquote><h1 id="2-SkyWalkingAgent"><a href="#2-SkyWalkingAgent" class="headerlink" title="2. SkyWalkingAgent"></a>2. SkyWalkingAgent</h1><p><code>org.skywalking.apm.agent.SkyWalkingAgent</code> ，在 <code>apm-sniffer/apm-agent</code> Maven 模块项目里，SkyWalking Agent <strong>启动入口</strong>。为什么说它是启动入口呢？在 <code>apm-sniffer/apm-agent</code> 的 <a href="https://github.com/OpenSkywalking/skywalking/blob/23133f7d97d17b471f69e7214a01885ebcd2e882/apm-sniffer/apm-agent/pom.xml#L53" rel="external nofollow noopener noreferrer" target="_blank"><code>pom.xml</code></a> 文件的【第 73 行】，我们可以看到 SkyWalkingAgent 被配置成 JavaAgent 的 <strong>PremainClass</strong> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/c51dbc997348111674dbeedb71d22b0414936cdb/apm-sniffer/apm-agent/src/main/java/org/skywalking/apm/agent/SkyWalkingAgent.java#L54" rel="external nofollow noopener noreferrer" target="_blank"><code>#premain(...)</code></a> 方法，代码如下 ：</p><ul><li>第 58 行 ：调用 <code>SnifferConfigInitializer#initialize()</code> 方法，初始化 Agent 配置。</li><li>第 61 行 ：调用 <code>PluginBootstrap#loadPlugins()</code> 方法，加载 Agent 插件们。而后，创建 PluginFinder 。 </li><li>第 64 行 ：调用 <code>ServiceManager#boot()</code> 方法，初始化 Agent 服务管理。在这过程中，Agent 服务们会被初始化。</li><li>第 79 至 133 行 ：基于 <a href="https://github.com/raphw/byte-buddy" rel="external nofollow noopener noreferrer" target="_blank">byte-buddy</a> ，初始化 Instrumentation 的 <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/instrument/ClassFileTransformer.html" rel="external nofollow noopener noreferrer" target="_blank"><code>java.lang.instrument.ClassFileTransformer</code></a> 。</li></ul><h1 id="3-SnifferConfigInitializer"><a href="#3-SnifferConfigInitializer" class="headerlink" title="3. SnifferConfigInitializer"></a>3. SnifferConfigInitializer</h1><p><code>org.skywalking.apm.agent.core.conf.SnifferConfigInitializer</code> ，Agent 配置初始化器。</p><p>在看具体代码实现之前，我们先看下 <code>org.skywalking.apm.agent.core.conf</code> 包的大体结构 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_05/02.png" alt=""></p><p>配置类有 Config 和 RemoteDownstreamConfig 两种。从命名上可以看出 ：</p><ul><li>Config 为 Agent <strong>本地</strong>配置类，使用 SnifferConfigInitializer 进行初始化。</li><li>RemoteDownstreamConfig 为 Agent <strong>远程</strong>配置类，从 <a href="https://github.com/OpenSkywalking/skywalking/wiki/3.2.3-%E9%83%A8%E7%BD%B2Collector" rel="external nofollow noopener noreferrer" target="_blank">Collector Server</a> 读取。 </li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/cea46a7e93437bbb16db2bfe0fae5c6fcf733fc2/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/conf/SnifferConfigInitializer.java#L56" rel="external nofollow noopener noreferrer" target="_blank"><code>#initialize()</code></a> 方法，初始化 Agent 本地配置，代码如下 ：</p><ul><li>第 59 至 67 行 ：从配置文件( <code>agent.config</code> ) 加载配置。配置文件所在<strong>固定</strong>路径为 <code>${AGENT_PACKAGE_PATH}/config/agent.config</code> ，其中 <code>${AGENT_PACKAGE_PATH}</code> 通过 <a href="https://github.com/YunaiV/skywalking/blob/c51dbc997348111674dbeedb71d22b0414936cdb/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/boot/AgentPackagePath.java#L31" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.boot.AgentPackagePath</code></a> 初始化。Agent 整理目录如下图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_05/01.png" alt=""></li><li>第 70 至 74 行 ：从环境变量<strong>覆盖</strong>配置。环境变量 <strong>Key</strong> 需以 <code>&quot;skywalking.&quot;</code> 开头。例如，<code>Config.Agent.APPLICATION_CODE</code> 在 <code>agent.config</code> 为 <code>agent.application_code</code> ，环境变量为 <code>skywalking.agent.application_code</code> 。另外，环境变量包括 JVM 进程的和系统的。</li><li>第 77 至 82 行 ：校验配置是否正确加载。</li></ul><h2 id="3-1-Config"><a href="#3-1-Config" class="headerlink" title="3.1 Config"></a>3.1 Config</h2><p><code>org.skywalking.apm.agent.core.conf.Config</code> ，Agent 本地配置类。</p><p>打开 <a href="https://github.com/YunaiV/skywalking/blob/cea46a7e93437bbb16db2bfe0fae5c6fcf733fc2/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/conf/Config.java#L32" rel="external nofollow noopener noreferrer" target="_blank">Config</a> ，我们会看到拆分了 Agent / Collector / Jvm / Buffer / Dictionary / Logging / Plugin 七个小类。如下图 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_05/03.png" alt=""></p><p>本文暂不对配置项详细解析，胖友可以看下每个属性的英文注释。</p><h2 id="3-2-RemoteDownstreamConfig"><a href="#3-2-RemoteDownstreamConfig" class="headerlink" title="3.2 RemoteDownstreamConfig"></a>3.2 RemoteDownstreamConfig</h2><p><code>org.skywalking.apm.agent.core.conf.RemoteDownstreamConfig</code> ，Agent 远程配置类。</p><p>打开 <a href="https://github.com/YunaiV/skywalking/blob/cea46a7e93437bbb16db2bfe0fae5c6fcf733fc2/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/conf/RemoteDownstreamConfig.java" rel="external nofollow noopener noreferrer" target="_blank">RemoteDownstreamConfig</a> ，我们会看到拆分了 Agent / Collector 两小类。如下图 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_05/04.png" alt=""></p><p>本文暂不对配置项详细解析，胖友可以看下每个属性的英文注释。</p><h1 id="4-Plugin"><a href="#4-Plugin" class="headerlink" title="4. Plugin"></a>4. Plugin</h1><p>SkyWalking Agent 提供了多种插件，实现不同框架的<strong>透明</strong>接入 SkyWalking 。在 <a href="https://github.com/OpenSkywalking/skywalking/wiki/3.2.3-supported-list" rel="external nofollow noopener noreferrer" target="_blank">《官方文档 —— supported list》</a> 里，有目前的插件列表。</p><p>另外，在 <code>apm-sniffer/apm-sdk-plugin</code> 目录下，有插件的实现代码 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_05/05.png" alt=""></p><p>本小节会分享的较为简单，在 <a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/?self">《SkyWalking 源码分析 —— Agent 插件体系》</a> 详细解析。</p><h2 id="4-1-PluginBootstrap"><a href="#4-1-PluginBootstrap" class="headerlink" title="4.1 PluginBootstrap"></a>4.1 PluginBootstrap</h2><p><code>org.skywalking.apm.agent.core.plugin.PluginBootstrap</code> ，插件引导程序类，创建需要加载的插件对象数组。</p><p><a href="https://github.com/YunaiV/skywalking/blob/130f0a5a3438663b393e53ba2cca02a8d13c258a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginBootstrap.java#L45" rel="external nofollow noopener noreferrer" target="_blank"><code>#loadPlugins()</code></a> 方法，代码如下 ：</p><ul><li>第 47 行 ：初始化 AgentClassLoader 。</li><li>第 50 至 56 行 ：获得插件<strong>定义路径</strong>数组。</li><li>第 59 至 66 行 ：获得插件<strong>定义</strong>( <a href="https://github.com/OpenSkywalking/skywalking/blob/b16d23c1484bec941367d6b36fa932b8ace40971/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginDefine.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.PluginDefine</code></a> )数组。</li><li>第 69 至 82 行 ：创建<strong>类增强插件定义</strong>( <a href="https://github.com/OpenSkywalking/skywalking/blob/b16d23c1484bec941367d6b36fa932b8ace40971/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/AbstractClassEnhancePluginDefine.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.AbstractClassEnhancePluginDefine</code></a> )对象数组。不同插件通过实现 AbstractClassEnhancePluginDefine <strong>抽象类</strong>，定义不同框架的<strong>切面</strong>，<strong>记录调用链路</strong>。以 Spring 插件为例子，如下是相关类图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_05/06.png" alt=""></li></ul><h2 id="4-2-PluginFinder"><a href="#4-2-PluginFinder" class="headerlink" title="4.2 PluginFinder"></a>4.2 PluginFinder</h2><p><code>org.skywalking.apm.agent.core.plugin.PluginFinder</code> ，插件发现者。其提供 <a href="https://github.com/YunaiV/skywalking/blob/09c654af33081e56547cb8b3b9e0c8525ddce32f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginFinder.java#L80" rel="external nofollow noopener noreferrer" target="_blank"><code>#find(...)</code></a> 方法，获得<strong>类增强插件定义</strong>( <a href="https://github.com/OpenSkywalking/skywalking/blob/b16d23c1484bec941367d6b36fa932b8ace40971/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/AbstractClassEnhancePluginDefine.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.AbstractClassEnhancePluginDefine</code></a> )对象。</p><p>PluginFinder <strong><a href="https://github.com/YunaiV/skywalking/blob/09c654af33081e56547cb8b3b9e0c8525ddce32f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginFinder.java#L56" rel="external nofollow noopener noreferrer" target="_blank">构造方法</a></strong>，代码如下 ：</p><ul><li>第 57 至 77 行 ：循环 AbstractClassEnhancePluginDefine 对象数组，添加到 <code>nameMatchDefine</code> / <code>signatureMatchDefine</code> 属性，方便 <code>#find(...)</code> 方法查找 AbstractClassEnhancePluginDefine 对象。<ul><li>第 65 至 72 行 ：处理 NameMatch 为匹配的 AbstractClassEnhancePluginDefine 对象，添加到 <code>nameMatchDefine</code>  属性。</li><li>第 74 至 76 行 ：处理<strong>非</strong> NameMatch 为匹配的 AbstractClassEnhancePluginDefine 对象，添加到 <code>signatureMatchDefine</code> 属性。</li></ul></li></ul><h1 id="5-ServiceManager"><a href="#5-ServiceManager" class="headerlink" title="5. ServiceManager"></a>5. ServiceManager</h1><p><code>org.skywalking.apm.agent.core.boot.ServiceManager</code> ，<a href="https://github.com/YunaiV/skywalking/blob/09c654af33081e56547cb8b3b9e0c8525ddce32f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/boot/BootService.java" rel="external nofollow noopener noreferrer" target="_blank">BootService</a> 管理器。负责管理、初始化 BootService 实例们。</p><p><a href="https://github.com/YunaiV/skywalking/blob/3de8a6c15d07aa3b2c3b4e732e6654fc87c4e70e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/boot/ServiceManager.java#L45" rel="external nofollow noopener noreferrer" target="_blank"><code>#boot()</code></a> 方法，代码如下 ：</p><ul><li><p>第 47 行 ：调用 <a href="https://github.com/YunaiV/skywalking/blob/3de8a6c15d07aa3b2c3b4e732e6654fc87c4e70e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/boot/ServiceManager.java#L72" rel="external nofollow noopener noreferrer" target="_blank"><code>#loadAllServices()</code></a> 方法，加载所有 BootService 实现类的实例数组。ServiceManager 基于 SPI (Service Provider Interface) 机制，在 <a href="https://github.com/OpenSkywalking/skywalking/blob/b16d23c1484bec941367d6b36fa932b8ace40971/apm-sniffer/apm-agent-core/src/main/resources/META-INF/services/org.skywalking.apm.agent.core.boot.BootService" rel="external nofollow noopener noreferrer" target="_blank">/resources/META-INF.services/org.skywalking.apm.agent.core.boot.BootService</a> 文件里，定义了所有 BootService 的实现类。如果胖友对 SPI 机制不熟悉，可以看下如下文章 ：</p><ul><li><a href="http://www.jianshu.com/p/32d3e108f30a" rel="external nofollow noopener noreferrer" target="_blank">《SPI 和 ServiceLoader》</a> </li><li><a href="http://www.jianshu.com/p/46aa69643c97" rel="external nofollow noopener noreferrer" target="_blank">《跟我学Dubbo系列之Java SPI机制简介》</a> </li></ul></li><li><p>第 50 行 ：调用 <a href="https://github.com/YunaiV/skywalking/blob/3de8a6c15d07aa3b2c3b4e732e6654fc87c4e70e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/boot/ServiceManager.java#L82" rel="external nofollow noopener noreferrer" target="_blank"><code>#beforeBoot()</code></a> 方法，调用每个 <code>BootService#beforeBoot()</code> 方法。</p></li><li>第 52 行 ：调用 <a href="https://github.com/YunaiV/skywalking/blob/3de8a6c15d07aa3b2c3b4e732e6654fc87c4e70e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/boot/ServiceManager.java#L92" rel="external nofollow noopener noreferrer" target="_blank"><code>#startup()</code></a> 方法，调用每个 <code>BootService#boot()</code> 方法。</li><li>第 54 行 ：调用 <a href="https://github.com/YunaiV/skywalking/blob/3de8a6c15d07aa3b2c3b4e732e6654fc87c4e70e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/boot/ServiceManager.java#L102" rel="external nofollow noopener noreferrer" target="_blank"><code>#afterBoot()</code></a> 方法，调用每个 <code>BootService#afterBoot()</code> 方法。</li></ul><h2 id="5-1-BootService"><a href="#5-1-BootService" class="headerlink" title="5.1 BootService"></a>5.1 BootService</h2><p><code>org.skywalking.apm.agent.core.boot.BootService</code> ，Agent 启动服务<strong>接口</strong>，定义了 <code>#beforeBoot()</code> / <code>#boot()</code> / <code>#afterBoot()</code> / <code>#shutdown()</code> 接口方法。</p><p>BootService 目前有<strong>七个</strong>实现类，在后续的文章，我们会解析相关实现。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_05/07.png" alt=""></p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>每次写初始化相关的文章，写少了，怕太水；写多了，又怕太复杂。</p><p>嗯，送一发妹子。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_05/08.png" alt=""></p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/agent-init/&quot;&gt;http://www.iocoder.cn/SkyWalking/agent-init/&lt;/a&gt; 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;

      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— 调试环境搭建</title>
    <link href="http://www.iocoder.cn/SkyWalking/build-debugging-environment/"/>
    <id>http://www.iocoder.cn/SkyWalking/build-debugging-environment/</id>
    <published>2020-06-30T16:00:00.000Z</published>
    <updated>2017-12-10T02:02:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/build-debugging-environment/">http://www.iocoder.cn/SkyWalking/build-debugging-environment/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/build-debugging-environment/">1. 依赖工具</a></li><li><a href="http://www.iocoder.cn/SkyWalking/build-debugging-environment/">2. 源码拉取</a></li><li><a href="http://www.iocoder.cn/SkyWalking/build-debugging-environment/">3. 启动 SkyWalking Collector</a></li><li><a href="http://www.iocoder.cn/SkyWalking/build-debugging-environment/">4. 启动 SkyWalking Agent</a></li><li><a href="http://www.iocoder.cn/SkyWalking/build-debugging-environment/">5. 启动 SkyWalking Web UI</a></li><li><a href="http://www.iocoder.cn/SkyWalking/build-debugging-environment/">6. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-依赖工具"><a href="#1-依赖工具" class="headerlink" title="1. 依赖工具"></a>1. 依赖工具</h1><ul><li>Maven</li><li>Git</li><li>JDK</li><li>IntelliJ IDEA</li></ul><h1 id="2-源码拉取"><a href="#2-源码拉取" class="headerlink" title="2. 源码拉取"></a>2. 源码拉取</h1><p>从官方仓库 <a href="https://github.com/OpenSkywalking/skywalking" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/OpenSkywalking/skywalking</a> <code>Fork</code> 出属于自己的仓库。为什么要 <code>Fork</code> ？既然开始阅读、调试源码，我们可能会写一些注释，有了自己的仓库，可以进行自由的提交。😈</p><p>使用 <code>IntelliJ IDEA</code> 从 <code>Fork</code> 出来的仓库拉取代码。拉取完成后，<code>Maven</code> 会下载依赖包，可能会花费一些时间，耐心等待下。</p><p>本文基于 <code>master</code> 分支。</p><h1 id="3-启动-SkyWalking-Collector"><a href="#3-启动-SkyWalking-Collector" class="headerlink" title="3. 启动 SkyWalking Collector"></a>3. 启动 SkyWalking Collector</h1><p>参考 <a href="https://github.com/OpenSkywalking/skywalking/wiki/How-to-build" rel="external nofollow noopener noreferrer" target="_blank">《官方文档 —— How to build》</a></p><ol><li>在 IntelliJ IDEA Terminal 中，执行 <code>mvn compile -Dmaven.test.skip=true</code> 进行编译。</li><li><p>设置 gRPC 的<strong>自动生成</strong>的代码目录，为<strong>源码</strong>目录 ：</p><ul><li>/apm-network/target/generated-sources/protobuf/ 下的 <code>grpc-java</code> 和 <code>java</code> 目录</li><li>/apm-collector-remote/collector-remote-grpc-provider/target/generated-sources/protobuf/ 下的 <code>grpc-java</code> 和 <code>java</code> 目录</li><li><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_01/01.png" alt=""></p><blockquote><p>从 3.2 开始，网络通讯协议引入 GRPC ，所以增加上述的步骤</p></blockquote></li></ul></li><li><p>运行 <code>org.skywalking.apm.collector.bootCollectorBootStartUp</code> 的 <code>#main(args)</code> 方法，启动 Collector 。</p></li><li>访问 <code>http://127.0.0.1:10800/agent/jetty</code> 地址，返回 <code>[&quot;localhost:12800/&quot;]</code> ，说明启动<strong>成功</strong>。</li></ol><h1 id="4-启动-SkyWalking-Agent"><a href="#4-启动-SkyWalking-Agent" class="headerlink" title="4. 启动 SkyWalking Agent"></a>4. 启动 SkyWalking Agent</h1><p>感谢 <a href="https://github.com/wu-sheng" rel="external nofollow noopener noreferrer" target="_blank">吴晟</a> 指导如何搭建 Agent 调试环境。</p><ol><li>在 IntelliJ IDEA Terminal 中，执行 <code>mvn compile -Dmaven.test.skip=true</code> 进行编译。在 /packages/skywalking-agent 目录下，我们可以看到编译出来的 Agent ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_01/02.png" alt=""></li><li><p>使用 Spring Boot 创建一个简单的 Web 项目。类似如下 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_01/03.png" alt=""></p><blockquote><p>友情提示 ：<strong>这里一定要注意下</strong>。创建的 Web 项目，使用  IntelliJ IDEA 的<strong>菜单</strong> File / New / Module 或 File / New / Module from Existing Sources ，<strong>保证 Web 项目和 skywalking 项目平级</strong>。这样，才可以使用 IntelliJ IDEA 调试  Agent 。</p></blockquote><ul><li><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_01/04.png" alt=""></li><li><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_01/05.png" alt=""></li></ul></li><li><p>在 <code>org.skywalking.apm.agent.SkyWalkingAgent</code> 的 <code>#premain(...)</code> 方法，打上调试断点。</p></li><li>运行 Web 项目的 Application 的 <code>#main(args)</code> 方法，并增加 JVM 启动参数，<code>-javaagent:/path/to/skywalking-agent/skywalking-agent.jar</code>。<code>/path/to</code> <strong>参数值</strong>为上面我们编译出来的 /packages/skywalking-agent 目录的绝对路径。如下图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_01/06.png" alt=""></li><li>如果在【<strong>第三步</strong>】的调试断点停住，说明 Agent 启动<strong>成功</strong>。</li></ol><hr><p>考虑到可能我们会在 Agent 上增加代码注释，这样每次不得不重新编译 Agent 。可以配置如下图，自动编译 Agent ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_01/07.png" alt=""></p><ul><li><code>-T 1C clean  package -Dmaven.test.skip=true -Dmaven.compile.fork=true</code> 。</li></ul><hr><p>另外，使用 IntelliJ IDEA Remote 远程调试，也是可以的。如下图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_01/10.png" alt=""></p><h1 id="5-启动-SkyWalking-Web-UI"><a href="#5-启动-SkyWalking-Web-UI" class="headerlink" title="5. 启动 SkyWalking Web UI"></a>5. 启动 SkyWalking Web UI</h1><p>考虑到调试过程中，我们要看下是否收集到追踪日志，可以安装 SkyWalking Web UI 进行查看。</p><p>参考 <a href="https://github.com/OpenSkywalking/skywalking-ui#quickstart-zh" rel="external nofollow noopener noreferrer" target="_blank">《官方文档 —— Sky Walking Web UI》</a> 安装。</p><h1 id="6-彩蛋"><a href="#6-彩蛋" class="headerlink" title="6. 彩蛋"></a>6. 彩蛋</h1><p>SkyWalking 环境搭建完成，胖友们可以起飞，源码读起来。</p><p>这会是个系列文章，笔者会慢慢更新。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_01/08.png" alt=""></p><p>如下是笔者对代码量和用途的简单整理，完善度比较低，可能有一丢丢的帮助 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_01/09.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/build-debugging-environment/&quot;&gt;http://www.iocoder.cn/SkyWalking/build-debugging-environ
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
</feed>
