<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>芋道源码 —— 纯源码解析BLOG</title>
  
  <subtitle>愿半生编码，如一生老友！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.iocoder.cn/"/>
  <updated>2017-12-15T11:36:23.000Z</updated>
  <id>http://www.iocoder.cn/</id>
  
  <author>
    <name>芋道源码</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector Naming Server 命名服务</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-naming-server/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-naming-server/</id>
    <published>2020-08-09T16:00:00.000Z</published>
    <updated>2017-12-15T11:36:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/">http://www.iocoder.cn/SkyWalking/collector-naming-server/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/">2. Collector Naming Server</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/">2.1 NamingModule</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/">2.2 NamingModuleJettyProvider</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/">2.3 NamingHandlerRegisterService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/">2.4 配置文件</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/">3. CollectorDiscoveryService</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/">3.1 CollectorDiscoveryService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/">3.2 配置文件</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Collector Naming Server 命名服务</strong>。主要包含如下部分：</p><ul><li>Collector Naming Server 提供 Http 两个接口，提供 Agent <strong>分别</strong>查询 Collector Agent Jetty Server 、Collector Agent gRPC Server 集群。</li><li>Collector Agent Jetty Server 、Collector Agent gRPC Server 集群内部的注册与发现。</li></ul><blockquote><p>友情提示，建议胖友已经读过 <a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module//?self">《SkyWalking 源码分析 —— Collector Server Component 服务器组件》</a> 、<a href="http://www.iocoder.cn/SkyWalking/collector-server-component/?self">《SkyWalking 源码分析 —— Collector Server Component 服务器组件》</a></p></blockquote><p>Collector Agent Server ( 包括 Jetty 和 gRPC )，提供上传调用链路，JVM Metric 等等 API 给 Agent 调用。<br>Agent 通过 Collector Naming Server 调用 Collector Agent Server 的 API ，查询 Collector Agent Server <strong>最新</strong>的集群地址。</p><p>Naming Server 在 SkyWalking 架构图处于如下位置( <strong>红框</strong> ) ：</p><blockquote><p>FROM <a href="https://github.com/apache/incubating-skywalking" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubating-skywalking</a><br><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_10/01.jpeg" alt=""></p></blockquote><p>下面我们来看看整体的项目结构，如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_10/02.png" alt=""></p><h1 id="2-Collector-Naming-Server"><a href="#2-Collector-Naming-Server" class="headerlink" title="2. Collector Naming Server"></a>2. Collector Naming Server</h1><p>Collector Naming Server 通过 <code>apm-collector-naming</code> 项目实现，其中：</p><ul><li><code>collector-naming-define</code> 项目：定义了 Naming Server 的接口。</li><li><code>collector-naming-jetty-provider</code> 项目：基于 Jetty Server 的 Naming Server 实现。</li></ul><h2 id="2-1-NamingModule"><a href="#2-1-NamingModule" class="headerlink" title="2.1 NamingModule"></a>2.1 NamingModule</h2><p><code>org.skywalking.apm.collector.cluster.ClusterModule</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java" rel="external nofollow noopener noreferrer" target="_blank">Module</a> 抽象类，集群管理 Module 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-naming/collector-naming-define/src/main/java/org/skywalking/apm/collector/naming/NamingModule.java#L34" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回模块名为 <code>&quot;naming&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-naming/collector-naming-define/src/main/java/org/skywalking/apm/collector/naming/NamingModule.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>#services()</code></a> <strong>实现</strong>方法，返回 Service 类名：NamingHandlerRegisterService 。</p><h2 id="2-2-NamingModuleJettyProvider"><a href="#2-2-NamingModuleJettyProvider" class="headerlink" title="2.2 NamingModuleJettyProvider"></a>2.2 NamingModuleJettyProvider</h2><p><code>org.skywalking.apm.collector.naming.jetty.NamingModuleJettyProvider</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java" rel="external nofollow noopener noreferrer" target="_blank">ModuleProvider</a> <strong>抽象类</strong>，基于 Jetty 的命名组件服务提供者实现类。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-naming/collector-naming-jetty-provider/src/main/java/org/skywalking/apm/collector/naming/jetty/NamingModuleJettyProvider.java#L44" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回组件服务提供者名为 <code>&quot;jetty&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-naming/collector-naming-jetty-provider/src/main/java/org/skywalking/apm/collector/naming/jetty/NamingModuleJettyProvider.java#L48" rel="external nofollow noopener noreferrer" target="_blank"><code>module()</code></a> <strong>实现</strong>方法，返回组件类为 NamingModule 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterModuleZookeeperProvider.java#L94" rel="external nofollow noopener noreferrer" target="_blank"><code>#requiredModules()</code></a> <strong>实现</strong>方法，返回依赖组件为 ClusterModule 、JettyManagerModule。</p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterModuleZookeeperProvider.java#L52" rel="external nofollow noopener noreferrer" target="_blank"><code>#prepare(Properties)</code></a> <strong>实现</strong>方法，执行准备阶段逻辑。</p><ul><li>第 55 行 ：创建 ZookeeperModuleListenerService / NamingJettyHandlerRegisterService 对象，并调用 <code>#registerServiceImplementation()</code> <strong>父类</strong>方法，注册到 <code>services</code> 。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-naming/collector-naming-jetty-provider/src/main/java/org/skywalking/apm/collector/naming/jetty/NamingModuleJettyProvider.java#L58" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> <strong>实现</strong>方法，执行启动阶段逻辑。</p><ul><li>第 65 行 ：调用 <code>JettyManagerService#createIfAbsent(host, port, contextPath)</code> 方法，创建 Jetty Server ，<strong>此时不会启动 Jetty Server</strong>。在 <code>JettyManagerProvider#notifyAfterCompleted()</code> 方法，统一启动所有 Jetty Server，在 <a href="http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/?self">《SkyWalking 源码分析 —— Collector Jetty Server Manager》「3. JettyManagerProvider」</a> 有详细解析。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-naming/collector-naming-jetty-provider/src/main/java/org/skywalking/apm/collector/naming/jetty/NamingModuleJettyProvider.java#L68" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyAfterCompleted()</code></a> <strong>实现</strong>方法，执行启动完成逻辑。目前是个空方法。</p><h2 id="2-3-NamingHandlerRegisterService"><a href="#2-3-NamingHandlerRegisterService" class="headerlink" title="2.3 NamingHandlerRegisterService"></a>2.3 NamingHandlerRegisterService</h2><p><code>org.skywalking.apm.collector.naming.service.NamingHandlerRegisterService</code> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> 接口，命名处理器注册服务<strong>接口</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-naming/collector-naming-define/src/main/java/org/skywalking/apm/collector/naming/service/NamingHandlerRegisterService.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><code>#register(ServerHandler)</code></a> <strong>接口</strong>方法，注册 Server 请求处理器。Collector Agent Server 会调用该方法，将其实现的 用于 Naming 的 ServerHandler 进行注册。如下图所示：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_10/03.png" alt=""></p><h3 id="2-3-1-NamingJettyHandlerRegisterService"><a href="#2-3-1-NamingJettyHandlerRegisterService" class="headerlink" title="2.3.1 NamingJettyHandlerRegisterService"></a>2.3.1 NamingJettyHandlerRegisterService</h3><p><code>org.skywalking.apm.collector.naming.jetty.service.service.NamingJettyHandlerRegisterService</code> ，基于 Jetty 的命名处理器注册服务<strong>实现类</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-naming/collector-naming-jetty-provider/src/main/java/org/skywalking/apm/collector/naming/jetty/service/NamingJettyHandlerRegisterService.java#L48" rel="external nofollow noopener noreferrer" target="_blank"><code>#register(moduleName, providerName, registration)</code></a> <strong>实现</strong>方法，调用 <code>JettyManagerService#addHandler(path, registration)</code> 方法，注册 Jetty Server 请求处理器。</p><h3 id="2-3-2-AgentJettyNamingHandler"><a href="#2-3-2-AgentJettyNamingHandler" class="headerlink" title="2.3.2 AgentJettyNamingHandler"></a>2.3.2 AgentJettyNamingHandler</h3><p><code>org.skywalking.apm.collector.agent.jetty.handler.naming.AgentJettyNamingHandler</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyHandler.java" rel="external nofollow noopener noreferrer" target="_blank">JettyHandler</a> <strong>抽象类</strong>，Collector Agent Jetty Server 实现的命名处理器。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-agent-jetty/collector-agent-jetty-provider/src/main/java/org/skywalking/apm/collector/agent/jetty/handler/naming/AgentJettyNamingHandler.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>#pathSpec()</code></a> <strong>实现</strong>方法，获得请求路径为 <code>&quot;/agent/jetty&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-agent-jetty/collector-agent-jetty-provider/src/main/java/org/skywalking/apm/collector/agent/jetty/handler/naming/AgentJettyNamingHandler.java#L43" rel="external nofollow noopener noreferrer" target="_blank"><code>#doGet()</code></a> <strong>实现</strong>方法，调用 <code>AgentJettyNamingListener#getAddresses()</code> 方法，获得 Collector Agent Jetty Server 集群地址。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-agent-jetty/collector-agent-jetty-provider/src/main/java/org/skywalking/apm/collector/agent/jetty/handler/naming/AgentJettyNamingListener.java#L28" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.jetty.handler.naming.AgentJettyNamingListener</code></a> 基于 Collector Cluster 组件，<strong>实现了集群地址变化的发现</strong>，在 <a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/?self">《SkyWalking 源码分析 —— Collector Cluster 集群管理》</a> 有详细解析。</li></ul><h3 id="2-3-3-AgentGRPCNamingHandler"><a href="#2-3-3-AgentGRPCNamingHandler" class="headerlink" title="2.3.3 AgentGRPCNamingHandler"></a>2.3.3 AgentGRPCNamingHandler</h3><p><code>org.skywalking.apm.collector.agent.grpc.handler.naming.AgentGRPCNamingHandler</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyHandler.java" rel="external nofollow noopener noreferrer" target="_blank">JettyHandler</a> <strong>抽象类</strong>，Collector Agent gRPC Server 实现的命名处理器。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ac6c98c1732d6aa62b9d244369478654411ac203/apm-collector/apm-collector-agent-grpc/collector-agent-grpc-provider/src/main/java/org/skywalking/apm/collector/agent/grpc/handler/naming/AgentGRPCNamingHandler.java#L42" rel="external nofollow noopener noreferrer" target="_blank"><code>#pathSpec()</code></a> <strong>实现</strong>方法，获得请求路径为 <code>&quot;/agent/gRPC&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ac6c98c1732d6aa62b9d244369478654411ac203/apm-collector/apm-collector-agent-grpc/collector-agent-grpc-provider/src/main/java/org/skywalking/apm/collector/agent/grpc/handler/naming/AgentGRPCNamingHandler.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#doGet()</code></a> <strong>实现</strong>方法，调用 <code>AgentGRPCNamingListener#getAddresses()</code> 方法，获得 Collector Agent gRPC Server 集群地址。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/ac6c98c1732d6aa62b9d244369478654411ac203/apm-collector/apm-collector-agent-grpc/collector-agent-grpc-provider/src/main/java/org/skywalking/apm/collector/agent/grpc/handler/naming/AgentGRPCNamingListener.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.grpc.handler.naming.AgentGRPCNamingListener</code></a> 基于 Collector Cluster 组件，<strong>实现了集群地址变化的发现</strong>，在 <a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/?self">《SkyWalking 源码分析 —— Collector Cluster 集群管理》</a> 有详细解析。</li></ul><h2 id="2-4-配置文件"><a href="#2-4-配置文件" class="headerlink" title="2.4 配置文件"></a>2.4 配置文件</h2><p>配置文件如下 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_10/02.png" alt=""></p><ul><li>配置 Naming Server 启动在 10800 端口。</li><li>Naming Server <strong>内嵌</strong>在 Collector Server 。通过启动多个 Collector Server 节点，形成 Naming Server 集群。Agent 配置多个 Naming Server 地址。</li></ul><h1 id="3-CollectorDiscoveryService"><a href="#3-CollectorDiscoveryService" class="headerlink" title="3. CollectorDiscoveryService"></a>3. CollectorDiscoveryService</h1><p><code>org.skywalking.apm.agent.core.remote.CollectorDiscoveryService</code> ， 实现 Agent 的 <a href="https://github.com/YunaiV/skywalking/blob/ac6c98c1732d6aa62b9d244369478654411ac203/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/boot/BootService.java" rel="external nofollow noopener noreferrer" target="_blank">BootService</a> <strong>接口</strong>，Collector Agent Server 地址<strong>发现</strong>服务。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ac6c98c1732d6aa62b9d244369478654411ac203/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/CollectorDiscoveryService.java#L45" rel="external nofollow noopener noreferrer" target="_blank"><code>#boot()</code></a> <strong>实现</strong>方法，调用 <code>ScheduledExecutorService#scheduleAtFixedRate(...)</code> 方法，创建定时任务。该定时任务<strong>无初始化延迟</strong>，每 <code>Config.Collector.DISCOVERY_CHECK_INTERVAL</code> ( 默认：60 s ) 执行一次。</p><ul><li>DiscoveryRestServiceClient 实现 <code>java.lang.Runnable</code> <strong>接口</strong>，即创建的任务。</li></ul><h2 id="3-1-CollectorDiscoveryService"><a href="#3-1-CollectorDiscoveryService" class="headerlink" title="3.1 CollectorDiscoveryService"></a>3.1 CollectorDiscoveryService</h2><p><code>org.skywalking.apm.agent.core.remote.CollectorDiscoveryService</code> ，实现 <code>java.lang.Runnable</code> <strong>接口</strong>，Collector 服务发现客户端，基于 <strong>Rest</strong> 方式通信。</p><p><a href="https://github.com/YunaiV/skywalking/blob/e30787c3a7ce91ae6314003cd488e71c1a534d7c/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/DiscoveryRestServiceClient.java#L61" rel="external nofollow noopener noreferrer" target="_blank"><strong>构造方法</strong></a> ，首先随机选择一个 Collector Naming Server ，用于下面 <code>#findServerList()</code> 方法，首次获取 Collector Agent Server 集群地址。</p><p><a href="https://github.com/YunaiV/skywalking/blob/e30787c3a7ce91ae6314003cd488e71c1a534d7c/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/DiscoveryRestServiceClient.java#L76" rel="external nofollow noopener noreferrer" target="_blank"><code>#run()</code></a> <strong>实现</strong>方法，调用 <code>#findServerList()</code> 方法，获取 Collector Agent Server 集群地址。</p><p><a href="https://github.com/YunaiV/skywalking/blob/e30787c3a7ce91ae6314003cd488e71c1a534d7c/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/DiscoveryRestServiceClient.java#L84" rel="external nofollow noopener noreferrer" target="_blank"><code>#findServerList()</code></a> 方法，获取 Collector Agent Server 集群地址。</p><ul><li>第 85 行 ：创建 <code>org.apache.http.impl.client.CloseableHttpClient</code> 对象。目前使用 HttpClient <code>4.5.3</code> 版本。</li><li>第 87 行 ：调用 <a href="https://github.com/YunaiV/skywalking/blob/e30787c3a7ce91ae6314003cd488e71c1a534d7c/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/DiscoveryRestServiceClient.java#L142" rel="external nofollow noopener noreferrer" target="_blank"><code>#buildGet()</code></a> 方法，创建 <code>org.apache.http.client.methods.HttpGet</code> 对象。目前 Agent 查询的是 Collector Agent gRPC Server 集群地址，因为 gRPC 的性能相比 HTTP 更优秀。</li><li>第 89 行 ：向 Collector Naming Server 发起请求。</li><li>第 90 至 93 行 ：当响应状态码非 <code>200</code> 时，调用 <code>#findBackupServer()</code> 方法，<strong>顺序</strong>选择 Collector Naming Server 列表的下一个。<strong>注意</strong>，此时不会再发起请求，需要等下一次执行。</li><li>第 95 至 111 行 ：处理响应结果，若 Collector Agent gRPC Server 集群地址发生变化，进行更新到 <code>RemoteDownstreamConfig.Collector.GRPC_SERVERS</code> 。</li><li>第 114 至 117 行 ：请求发生异常，调用 <code>#findBackupServer()</code> 方法，<strong>顺序</strong>选择 Collector Naming Server 列表的下一个。</li><li>第 119 行 ：调用 <code>CloseableHttpClient#close()</code> 方法，进行关闭。</li></ul><h2 id="3-2-配置文件"><a href="#3-2-配置文件" class="headerlink" title="3.2 配置文件"></a>3.2 配置文件</h2><p>配置文件如下 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_10/05.png" alt=""></p><ul><li>生产环境使用时，<strong>推荐</strong> Agent 配置多个 Naming Server 地址。</li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>2017.12.15 归途 从北京回上海。</p><p>突然有种感觉，获得像包方便面，快捷而不营养。</p><p>有点”丧”。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_10/06.png" alt=""></p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-naming-server/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-naming-server/&lt;/a
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector gRPC Server Manager</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-grpc-server-module/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-grpc-server-module/</id>
    <published>2020-08-04T16:00:00.000Z</published>
    <updated>2017-12-14T16:41:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-grpc-server-module/">http://www.iocoder.cn/SkyWalking/collector-grpc-server-module/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-grpc-server-module/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-grpc-server-module/">2. GRPCManagerModule</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-grpc-server-module/">3. GRPCManagerProvider</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-grpc-server-module/">4. GRPCManagerService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-grpc-server-module/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Collector gRPC Server Manager</strong>。Collector 通过该管理器，管理启动的多个 gRPC Server，例如 Agent gRPC Server、Remote gRPC Server 。<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_05/02.png" alt=""></p><blockquote><p>友情提示：建议胖友已经读过 <a href="http://www.iocoder.cn/SkyWalking/collector-server-component/?self">《SkyWalking 源码分析 —— Collector Server Component 服务器组件》</a></p><p>另外，本文和 <a href="http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/?self">《SkyWalking 源码分析 —— Collector Jetty Server Manager》</a> 相似度 99%</p></blockquote><p>gRPC Server Manager 在 SkyWalking 架构图处于如下位置( <strong>红框</strong> ) ：</p><blockquote><p>FROM <a href="https://github.com/apache/incubating-skywalking" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubating-skywalking</a><br><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_05/01.jpeg" alt=""></p></blockquote><p>下面我们来看看整体的项目结构，如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_05/03.png" alt=""></p><p>😈 代码量非常少，考虑到这是个单独的项目，所以单独成文。</p><h1 id="2-GRPCManagerModule"><a href="#2-GRPCManagerModule" class="headerlink" title="2. GRPCManagerModule"></a>2. GRPCManagerModule</h1><p><code>org.skywalking.apm.collector.grpc.manager.GRPCManagerModule</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java" rel="external nofollow noopener noreferrer" target="_blank">Module</a> 抽象类，gRPC Server 管理器 Module 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/621598af465bfcefee3432c2ef80aff25a33f1bf/apm-collector/apm-collector-grpc-manager/collector-grpc-manager-define/src/main/java/org/skywalking/apm/collector/grpc/manager/GRPCManagerModule.java#L33" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回模块名为 <code>&quot;gRPC_manager&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/621598af465bfcefee3432c2ef80aff25a33f1bf/apm-collector/apm-collector-grpc-manager/collector-grpc-manager-define/src/main/java/org/skywalking/apm/collector/grpc/manager/GRPCManagerModule.java#L37" rel="external nofollow noopener noreferrer" target="_blank"><code>#services()</code></a> <strong>实现</strong>方法，返回 Service 类名：GRPCManagerService 。</p><h1 id="3-GRPCManagerProvider"><a href="#3-GRPCManagerProvider" class="headerlink" title="3. GRPCManagerProvider"></a>3. GRPCManagerProvider</h1><p><code>org.skywalking.apm.collector.grpc.manager.GRPCManagerProvider</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java" rel="external nofollow noopener noreferrer" target="_blank">ModuleProvider</a> <strong>抽象类</strong>，gRPC Server 管理器组件服务提供者。</p><p><a href="https://github.com/YunaiV/skywalking/blob/f9de7bf75f62c16fd05cc0d1beb8f5b756108ec3/apm-collector/apm-collector-grpc-manager/collector-grpc-manager-provider/src/main/java/org/skywalking/apm/collector/grpc/manager/GRPCManagerProvider.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回组件服务提供者名为 <code>&quot;gRPC&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/f9de7bf75f62c16fd05cc0d1beb8f5b756108ec3/apm-collector/apm-collector-grpc-manager/collector-grpc-manager-provider/src/main/java/org/skywalking/apm/collector/grpc/manager/GRPCManagerProvider.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>module()</code></a> <strong>实现</strong>方法，返回组件类为 GRPCManagerModule 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/f9de7bf75f62c16fd05cc0d1beb8f5b756108ec3/apm-collector/apm-collector-grpc-manager/collector-grpc-manager-provider/src/main/java/org/skywalking/apm/collector/grpc/manager/GRPCManagerProvider.java#L72" rel="external nofollow noopener noreferrer" target="_blank"><code>#requiredModules()</code></a> <strong>实现</strong>方法，返回依赖组件为空。</p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/f9de7bf75f62c16fd05cc0d1beb8f5b756108ec3/apm-collector/apm-collector-grpc-manager/collector-grpc-manager-provider/src/main/java/org/skywalking/apm/collector/grpc/manager/GRPCManagerProvider.java#L54" rel="external nofollow noopener noreferrer" target="_blank"><code>#prepare(Properties)</code></a> <strong>实现</strong>方法，执行准备阶段逻辑。</p><ul><li>第 55 行 ：创建 GRPCManagerServiceImpl 对象，并调用 <code>#registerServiceImplementation(...)</code> <strong>父类</strong>方法，注册到 <code>services</code> 。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/f9de7bf75f62c16fd05cc0d1beb8f5b756108ec3/apm-collector/apm-collector-grpc-manager/collector-grpc-manager-provider/src/main/java/org/skywalking/apm/collector/grpc/manager/GRPCManagerProvider.java#L58" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> <strong>实现</strong>方法，执行启动阶段逻辑。目前是个<strong>空方法</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/f9de7bf75f62c16fd05cc0d1beb8f5b756108ec3/apm-collector/apm-collector-grpc-manager/collector-grpc-manager-provider/src/main/java/org/skywalking/apm/collector/grpc/manager/GRPCManagerProvider.java#L62" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyAfterCompleted()</code></a> <strong>实现</strong>方法，执行启动完成逻辑。</p><ul><li>第 63 至 69 行 ：遍历注册的服务器列表，逐个调用 <code>GRPCServer#start()</code> 方法，进行启动。</li></ul><h1 id="4-GRPCManagerService"><a href="#4-GRPCManagerService" class="headerlink" title="4. GRPCManagerService"></a>4. GRPCManagerService</h1><p><code>org.skywalking.apm.collector.grpc.manager.service.GRPCManagerService</code> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> <strong>接口</strong>，gRPC Server 管理器服务<strong>接口</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/48f76a555c043fee2932230077a8112d4888d10f/apm-collector/apm-collector-grpc-manager/collector-grpc-manager-define/src/main/java/org/skywalking/apm/collector/grpc/manager/service/GRPCManagerService.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>#createIfAbsent(host, port)</code></a> <strong>接口</strong>方法，创建 gRPC Server ，若不存在。</p><p><strong>怎么没有类似 JettyManagerService 的 <code>#addHandler(...)</code> 方法</strong>？目前是调用方直接调用 <code>#createIfAbsent(host, port)</code> 方法，获得 gRPC Server 后，后调用 <code>Server#addHandler(ServerHandler)</code> 方法。例如：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/9c586ca730cc89d4d5ad6b4294f2779a23925a8c/apm-collector/apm-collector-agent-grpc/collector-agent-grpc-provider/src/main/java/org/skywalking/apm/collector/agent/grpc/AgentModuleGRPCProvider.java#L72" rel="external nofollow noopener noreferrer" target="_blank"><code>AgentModuleGRPCProvider#start(Properties)</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/9c586ca730cc89d4d5ad6b4294f2779a23925a8c/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/RemoteModuleGRPCProvider.java#L61" rel="external nofollow noopener noreferrer" target="_blank"><code>RemoteModuleGRPCProvider#start(Properties)</code></a></li></ul><h2 id="4-1-GRPCManagerServiceImpl"><a href="#4-1-GRPCManagerServiceImpl" class="headerlink" title="4.1 GRPCManagerServiceImpl"></a>4.1 GRPCManagerServiceImpl</h2><p><code>org.skywalking.apm.collector.grpc.manager.service.GRPCManagerServiceImpl</code> ，gRPC Server 管理器服务<strong>实现类</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/9c586ca730cc89d4d5ad6b4294f2779a23925a8c/apm-collector/apm-collector-grpc-manager/collector-grpc-manager-provider/src/main/java/org/skywalking/apm/collector/grpc/manager/service/GRPCManagerServiceImpl.java#L44" rel="external nofollow noopener noreferrer" target="_blank"><strong>构造方法</strong></a> ，使用来自 GRPCManagerProvider 的 <code>servers</code> 服务器数组。<strong>这是为什么 GRPCManagerProvider 没有对 <code>servers</code> 做新增操作，结果里面有数据的原因</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/9c586ca730cc89d4d5ad6b4294f2779a23925a8c/apm-collector/apm-collector-grpc-manager/collector-grpc-manager-provider/src/main/java/org/skywalking/apm/collector/grpc/manager/service/GRPCManagerServiceImpl.java#L48" rel="external nofollow noopener noreferrer" target="_blank"><code>#createIfAbsent(host, port)</code></a> <strong>实现</strong>方法，创建 gRPC Server ，若不存在。判断方式为 <code>host + port</code> 为唯一。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>呵呵哒的一篇，嘿嘿。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_05/04.png" alt=""></p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-grpc-server-module/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-grpc-server-
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector Jetty Server Manager</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/</id>
    <published>2020-07-31T16:00:00.000Z</published>
    <updated>2017-12-14T16:30:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/">http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/">2. JettyManagerModule</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/">3. JettyManagerProvider</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/">4. JettyManagerService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Collector Jetty Server Manager</strong>。Collector 通过该管理器，管理启动的多个 Jetty Server，例如 Agent Jetty Server、Naming Jetty Server、UI Jetty Server。<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_01/02.png" alt=""></p><blockquote><p>友情提示：建议胖友已经读过 <a href="http://www.iocoder.cn/SkyWalking/collector-server-component/?self">《SkyWalking 源码分析 —— Collector Server Component 服务器组件》</a></p></blockquote><p>Jetty Server Manager 在 SkyWalking 架构图处于如下位置( <strong>红框</strong> ) ：</p><blockquote><p>FROM <a href="https://github.com/apache/incubating-skywalking" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubating-skywalking</a><br><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_01/01.jpeg" alt=""></p></blockquote><p>下面我们来看看整体的项目结构，如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_01/03.png" alt=""></p><p>😈 代码量非常少，考虑到这是个单独的项目，所以单独成文。</p><h1 id="2-JettyManagerModule"><a href="#2-JettyManagerModule" class="headerlink" title="2. JettyManagerModule"></a>2. JettyManagerModule</h1><p><code>org.skywalking.apm.collector.jetty.manager.JettyManagerModule</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java" rel="external nofollow noopener noreferrer" target="_blank">Module</a> 抽象类，Jetty 管理器 Module 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/39ee2260b8463316550c52276109a5af917e34e8/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-define/src/main/java/org/skywalking/apm/collector/jetty/manager/JettyManagerModule.java#L33" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回模块名为 <code>&quot;jetty_manager&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/39ee2260b8463316550c52276109a5af917e34e8/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-define/src/main/java/org/skywalking/apm/collector/jetty/manager/JettyManagerModule.java#L37" rel="external nofollow noopener noreferrer" target="_blank"><code>#services()</code></a> <strong>实现</strong>方法，返回 Service 类名：JettyManagerService 。</p><h1 id="3-JettyManagerProvider"><a href="#3-JettyManagerProvider" class="headerlink" title="3. JettyManagerProvider"></a>3. JettyManagerProvider</h1><p><code>org.skywalking.apm.collector.jetty.manager.JettyManagerProvider</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java" rel="external nofollow noopener noreferrer" target="_blank">ModuleProvider</a> <strong>抽象类</strong>，Jetty 管理器组件服务提供者。</p><p><a href="https://github.com/YunaiV/skywalking/blob/39ee2260b8463316550c52276109a5af917e34e8/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-provider/src/main/java/org/skywalking/apm/collector/jetty/manager/JettyManagerProvider.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回组件服务提供者名为 <code>&quot;jetty&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/39ee2260b8463316550c52276109a5af917e34e8/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-provider/src/main/java/org/skywalking/apm/collector/jetty/manager/JettyManagerProvider.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>module()</code></a> <strong>实现</strong>方法，返回组件类为 JettyManagerModule 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/39ee2260b8463316550c52276109a5af917e34e8/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-provider/src/main/java/org/skywalking/apm/collector/jetty/manager/JettyManagerProvider.java#L72" rel="external nofollow noopener noreferrer" target="_blank"><code>#requiredModules()</code></a> <strong>实现</strong>方法，返回依赖组件为空。</p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/39ee2260b8463316550c52276109a5af917e34e8/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-provider/src/main/java/org/skywalking/apm/collector/jetty/manager/JettyManagerProvider.java#L54" rel="external nofollow noopener noreferrer" target="_blank"><code>#prepare(Properties)</code></a> <strong>实现</strong>方法，执行准备阶段逻辑。</p><ul><li>第 55 行 ：创建 JettyManagerServiceImpl 对象，并调用 <code>#registerServiceImplementation(...)</code> <strong>父类</strong>方法，注册到 <code>services</code> 。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/39ee2260b8463316550c52276109a5af917e34e8/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-provider/src/main/java/org/skywalking/apm/collector/jetty/manager/JettyManagerProvider.java#L58" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> <strong>实现</strong>方法，执行启动阶段逻辑。目前是个<strong>空方法</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/39ee2260b8463316550c52276109a5af917e34e8/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-provider/src/main/java/org/skywalking/apm/collector/jetty/manager/JettyManagerProvider.java#L61" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyAfterCompleted()</code></a> <strong>实现</strong>方法，执行启动完成逻辑。</p><ul><li>第 63 至 69 行 ：遍历注册的服务器列表，逐个调用 <code>JettyServer#start()</code> 方法，进行启动。</li></ul><h1 id="4-JettyManagerService"><a href="#4-JettyManagerService" class="headerlink" title="4. JettyManagerService"></a>4. JettyManagerService</h1><p><code>org.skywalking.apm.collector.jetty.manager.service.JettyManagerService</code> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> <strong>接口</strong>，Jetty 管理器服务<strong>接口</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/71993b1790b29df66644334dcfe1796e889ddc9b/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-define/src/main/java/org/skywalking/apm/collector/jetty/manager/service/JettyManagerService.java#L40" rel="external nofollow noopener noreferrer" target="_blank"><code>#createIfAbsent(host, port, contextPath)</code></a> <strong>接口</strong>方法，创建 Jetty Server ，若不存在。</p><p><a href="https://github.com/YunaiV/skywalking/blob/71993b1790b29df66644334dcfe1796e889ddc9b/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-define/src/main/java/org/skywalking/apm/collector/jetty/manager/service/JettyManagerService.java#L49" rel="external nofollow noopener noreferrer" target="_blank"><code>#addHandler(host, port, serverHandler)</code></a> <strong>接口</strong>方法，添加 Jetty Server 请求处理器。</p><h2 id="4-1-JettyManagerServiceImpl"><a href="#4-1-JettyManagerServiceImpl" class="headerlink" title="4.1 JettyManagerServiceImpl"></a>4.1 JettyManagerServiceImpl</h2><p><code>org.skywalking.apm.collector.jetty.manager.service.JettyManagerServiceImpl</code> ，Jetty 管理器服务<strong>实现类</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/21a84f89165f74c7fe702650ff4d12db5a9613e4/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-provider/src/main/java/org/skywalking/apm/collector/jetty/manager/service/JettyManagerServiceImpl.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><strong>构造方法</strong></a> ，使用来自 JettyManagerProvider 的 <code>servers</code> 服务器数组。<strong>这是为什么 JettyManagerProvider 没有对 <code>servers</code> 做新增操作，结果里面有数据的原因</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/21a84f89165f74c7fe702650ff4d12db5a9613e4/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-provider/src/main/java/org/skywalking/apm/collector/jetty/manager/service/JettyManagerServiceImpl.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>#createIfAbsent(host, port, contextPath)</code></a> <strong>实现</strong>方法，创建 Jetty Server ，若不存在。判断方式为 <code>host + port</code> 为唯一。</p><p><a href="https://github.com/YunaiV/skywalking/blob/21a84f89165f74c7fe702650ff4d12db5a9613e4/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-provider/src/main/java/org/skywalking/apm/collector/jetty/manager/service/JettyManagerServiceImpl.java#L66" rel="external nofollow noopener noreferrer" target="_blank"><code>#addHandler(host, port, serverHandler)</code></a> <strong>实现</strong>方法，添加 Jetty Server 请求处理器。判断方式为 <code>host + port</code> 为唯一。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>呵呵哒的一篇，嘿嘿。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_01/04.png" alt=""></p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-jetty-serve
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector Server Component 服务器组件</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-server-component/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-server-component/</id>
    <published>2020-07-27T16:00:00.000Z</published>
    <updated>2017-12-14T14:44:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">http://www.iocoder.cn/SkyWalking/collector-server-component/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">2. 接口</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">2.1 Server</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">2.2 ServerHandler</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">3. gRPC 实现</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">3.1 GRPCServer</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">3.2 GRPCHandler</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">4. Jetty 实现</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">3.1 JettyServer</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">3.2 JettyHandler</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>SkyWalking Collector Server Component 服务器组件</strong>。Collector 通过服务器，提供 API 接口给调用方，例如 Agent 、WebUI 。</p><p>Server Component 在 SkyWalking 架构图处于如下位置( <strong>红框</strong> ) ：</p><blockquote><p>FROM <a href="https://github.com/apache/incubating-skywalking" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubating-skywalking</a><br><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_25/01.jpeg" alt=""></p></blockquote><p>下面我们来看看整体的项目结构，如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_28/02.png" alt=""></p><p>OK，我们从<strong>接口到实现</strong>的顺序进行分享。</p><h1 id="2-接口"><a href="#2-接口" class="headerlink" title="2. 接口"></a>2. 接口</h1><h2 id="2-1-Server"><a href="#2-1-Server" class="headerlink" title="2.1 Server"></a>2.1 Server</h2><p><code>org.skywalking.apm.collector.server.Server</code> ，服务器<strong>接口</strong>。其实现子类，如下类图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_28/03.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/Server.java#L31" rel="external nofollow noopener noreferrer" target="_blank"><code>#hostPort()</code></a> <strong>接口</strong>方法，获得服务器地址。<br><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/Server.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><code>#serverClassify()</code></a> <strong>接口</strong>方法，获得服务器分类。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/Server.java#L43" rel="external nofollow noopener noreferrer" target="_blank"><code>#initialize()</code></a> <strong>接口</strong>方法，初始化服务器。<br><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/Server.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> <strong>接口</strong>方法，启动服务器。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/Server.java#L57" rel="external nofollow noopener noreferrer" target="_blank"><code>#addHandler()</code></a> <strong>接口</strong>方法，添加请求处理器( ServerHandler )</p><h2 id="2-2-ServerHandler"><a href="#2-2-ServerHandler" class="headerlink" title="2.2 ServerHandler"></a>2.2 ServerHandler</h2><p><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/ServerHandler.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.server.ServerHandler</code></a> ，服务器处理器<strong>接口</strong>。其实现子类，如下类图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_28/04.png" alt=""></p><p>ServerHandler 无任何接口方法。</p><p>一个 ServerHandler 对应一个请求的处理。</p><h1 id="3-gRPC-实现"><a href="#3-gRPC-实现" class="headerlink" title="3. gRPC 实现"></a>3. gRPC 实现</h1><h2 id="3-1-GRPCServer"><a href="#3-1-GRPCServer" class="headerlink" title="3.1 GRPCServer"></a>3.1 GRPCServer</h2><p><code>org.skywalking.apm.collector.server.grpc.GRPCServer</code> ，基于 gRPC 的服务器实现。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/grpc/GRPCServer.java#L47" rel="external nofollow noopener noreferrer" target="_blank"><code>#hostPort()</code></a> <strong>实现</strong>方法，获得服务器地址。<br><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/grpc/GRPCServer.java#L51" rel="external nofollow noopener noreferrer" target="_blank"><code>#serverClassify()</code></a> <strong>实现</strong>方法，获得服务器分类为 <code>&quot;Google-RPC&quot;</code>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/grpc/GRPCServer.java#L55" rel="external nofollow noopener noreferrer" target="_blank"><code>#initialize()</code></a> <strong>实现</strong>方法，调用 <code>io.grpc.netty.NettyServerBuilder#forAddress(address)</code> 方法，NettyServerBuilder 。此处，服务器并未创建与启动。<br><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/grpc/GRPCServer.java#L61" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> <strong>实现</strong>方法，创建 <code>io.grpc.Server</code> 对象，并启动服务器。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/grpc/GRPCServer.java#L70" rel="external nofollow noopener noreferrer" target="_blank"><code>#addHandler(handler)</code></a> <strong>实现</strong>方法，调用 <code>NettyServerBuilder#addService(...)</code> 方法，添加 gRPC 请求处理器( GRPCHandler )。</p><p>目前，GRPCServer 使用在 <a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-agent-grpc/collector-agent-grpc-provider/" rel="external nofollow noopener noreferrer" target="_blank"><code>collector-agent-grpc-provider</code></a> / <a href="https://github.com/YunaiV/skywalking/tree/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-remote/collector-remote-grpc-provider" rel="external nofollow noopener noreferrer" target="_blank"><code>collector-remote-grpc-provider</code></a> 项目。</p><h2 id="3-2-GRPCHandler"><a href="#3-2-GRPCHandler" class="headerlink" title="3.2 GRPCHandler"></a>3.2 GRPCHandler</h2><p><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/ServerHandler.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.server.grpc.GRPCHandler</code></a> ，gRPC 请求处理器<strong>接口</strong>。其实现子类，如下类图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_28/05.png" alt=""></p><p>GRPCHandler 无任何接口方法。</p><h1 id="4-Jetty-实现"><a href="#4-Jetty-实现" class="headerlink" title="4. Jetty 实现"></a>4. Jetty 实现</h1><h2 id="3-1-JettyServer"><a href="#3-1-JettyServer" class="headerlink" title="3.1 JettyServer"></a>3.1 JettyServer</h2><p><code>org.skywalking.apm.collector.server.jetty.JettyServer</code> ，基于 Jetty 的服务器实现。</p><p><a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyServer.java#L52" rel="external nofollow noopener noreferrer" target="_blank"><code>#hostPort()</code></a> <strong>实现</strong>方法，获得服务器地址。<br><a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyServer.java#L56" rel="external nofollow noopener noreferrer" target="_blank"><code>#serverClassify()</code></a> <strong>实现</strong>方法，获得服务器分类为 <code>&quot;Jetty&quot;</code>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyServer.java#L60" rel="external nofollow noopener noreferrer" target="_blank"><code>#initialize()</code></a> <strong>实现</strong>方法，创建 <code>org.eclipse.jetty.server.Server</code> 和 <code>org.eclipse.jetty.servle.ServletContextHandler</code> 对象。此处，服务器并未启动。<br><a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyServer.java#L80" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> <strong>实现</strong>方法，启动服务器。</p><p><a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyServer.java#L72" rel="external nofollow noopener noreferrer" target="_blank"><code>#addHandler(handler)</code></a> <strong>实现</strong>方法，使用 ServerHandler 创建 <code>org.eclipse.jetty.servlet.ServletHolder</code> 对象，并调用 <code>ServletContextHandler#addServlet(servlet, pathSpec)</code> 方法进行添加。</p><p>目前，JettyServer 使用在 <a href="https://github.com/YunaiV/skywalking/tree/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-agent-jetty/collector-agent-jetty-provider" rel="external nofollow noopener noreferrer" target="_blank"><code>collector-agent-jetty-provider</code></a> / <a href="https://github.com/YunaiV/skywalking/tree/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-ui/collector-ui-jetty-provider" rel="external nofollow noopener noreferrer" target="_blank"><code>collector-ui-jetty-provider</code></a> 项目。</p><h2 id="3-2-JettyHandler"><a href="#3-2-JettyHandler" class="headerlink" title="3.2 JettyHandler"></a>3.2 JettyHandler</h2><p><code>org.skywalking.apm.collector.server.jetty.JettyHandler</code> ，继承 <code>javax.servlet.http.HttpServlet</code> <strong>抽象类</strong>，Jetty 请求处理。</p><p><a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyHandler.java#L43" rel="external nofollow noopener noreferrer" target="_blank"><code>#pathSpec()</code></a> <strong>抽象</strong>方法，请求路径定义。</p><p><a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyHandler.java#L61" rel="external nofollow noopener noreferrer" target="_blank"><code>#doGet(HttpServletRequest)</code></a> <strong>抽象</strong>方法，处理 Get 请求，并返回 <code>com.google.gson.JsonElement</code> 对象。</p><ul><li>该抽象方法会被 <a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyHandler.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#doGet(HttpServletRequest, HttpServletResponse)</code></a> 方法调用。<ul><li>成功时，调用 <a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyHandler.java#L174" rel="external nofollow noopener noreferrer" target="_blank"><code>#reply(HttpServletResponse, JsonElement)</code></a> 方法，返回 JSON 。</li><li>错误时，调用 <a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyHandler.java#L195" rel="external nofollow noopener noreferrer" target="_blank"><code>#replyError(HttpServletResponse, errorMessage, status)</code></a> 方法，返回 JSON 。</li></ul></li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyHandler.java#L79" rel="external nofollow noopener noreferrer" target="_blank"><code>#doPost(HttpServletRequest)</code></a> <strong>抽象</strong>方法，处理 Post 请求，并返回 <code>com.google.gson.JsonElement</code> 对象。</p><ul><li>该抽象方法会被 <a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyHandler.java#L64" rel="external nofollow noopener noreferrer" target="_blank"><code>#doPost(HttpServletRequest, HttpServletResponse)</code></a> 方法调用。</li></ul><p><strong>HttpServlet 所有方法被重写，并标记 <code>final</code> 修饰符，不允许子类重写</strong>。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>又双叒叕成功更新了一篇水文。😜</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_28/06.png" alt=""></p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-server-component/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-server-compone
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector Client Component 客户端组件</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-client-component/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-client-component/</id>
    <published>2020-07-24T16:00:00.000Z</published>
    <updated>2017-12-14T14:44:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-client-component/">http://www.iocoder.cn/SkyWalking/collector-client-component/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-client-component/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-client-component/">2. Client</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-client-component/">3. ElasticSearchClient</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-client-component/">4. GRPCClient</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-client-component/">5. H2Client</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-client-component/">6. RedisClient</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-client-component/">7. ZookeeperClient</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-client-component/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>SkyWalking Collector Client Component 客户端组件</strong>。Collector 通过客户端，和其他服务进行通信，例如 Elastic Search 、Zookeeper 、H2 等等。</p><p>Client Component 在 SkyWalking 架构图处于如下位置( <strong>红框</strong> ) ：</p><blockquote><p>FROM <a href="https://github.com/apache/incubating-skywalking" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubating-skywalking</a><br><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_25/01.jpeg" alt=""></p></blockquote><p>下面我们来看看整体的项目结构，如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_25/02.png" alt=""></p><p>OK，我们从<strong>接口到实现</strong>的顺序进行分享。</p><h1 id="2-Client"><a href="#2-Client" class="headerlink" title="2. Client"></a>2. Client</h1><p><a href="https://github.com/YunaiV/skywalking/blob/c546a9a4d4588d99bf532da519ae721ef60b918e/apm-collector/apm-collector-component/client-component/src/main/java/org/skywalking/apm/collector/client/Client.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.client.Client</code></a> ，客户端<strong>接口</strong>。其定义接口方法如下：</p><ul><li><code>#initialize()</code> 方法，初始化客户端。</li><li><code>#shutdown()</code> 方法，关闭客户端。</li></ul><p>Client 的实现类，如下类图：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_25/03.png" alt=""></p><h1 id="3-ElasticSearchClient"><a href="#3-ElasticSearchClient" class="headerlink" title="3. ElasticSearchClient"></a>3. ElasticSearchClient</h1><p><a href="https://github.com/YunaiV/skywalking/blob/001f700612ad52bc1eb1a278bc0e2ff9e5330df8/apm-collector/apm-collector-component/client-component/src/main/java/org/skywalking/apm/collector/client/elasticsearch/ElasticSearchClient.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.client.elasticsearch.ElasticSearchClient</code></a> ，Elastic Search 客户端。 </p><p>基于 <code>org.elasticsearch.client.transport</code> 的 <code>5.5.0</code> 版本，封装 SkyWalking 需要的 Elastic Search 操作。目前用于 <a href="https://github.com/YunaiV/skywalking/blob/001f700612ad52bc1eb1a278bc0e2ff9e5330df8/apm-collector/apm-collector-storage/collector-storage-es-provider" rel="external nofollow noopener noreferrer" target="_blank"><code>collector-storage-es-provider</code></a> 模块。</p><h1 id="4-GRPCClient"><a href="#4-GRPCClient" class="headerlink" title="4. GRPCClient"></a>4. GRPCClient</h1><p><a href="https://github.com/YunaiV/skywalking/blob/001f700612ad52bc1eb1a278bc0e2ff9e5330df8/apm-collector/apm-collector-component/client-component/src/main/java/org/skywalking/apm/collector/client/grpc/GRPCClient.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.client.grpc.GRPCClient</code></a> ，gRPC 客户端。</p><p>基于 <code>io.grpc.grpc-core</code> 的 <code>1.8.0</code> 版本，封装 SkyWalking 需要的 gRPC 操作。目前用于 <a href="https://github.com/YunaiV/skywalking/tree/001f700612ad52bc1eb1a278bc0e2ff9e5330df8/apm-collector/apm-collector-remote/collector-remote-grpc-provider" rel="external nofollow noopener noreferrer" target="_blank"><code>collector-remote-grpc-provider</code></a> 模块。 </p><h1 id="5-H2Client"><a href="#5-H2Client" class="headerlink" title="5. H2Client"></a>5. H2Client</h1><p><a href="https://github.com/YunaiV/skywalking/blob/001f700612ad52bc1eb1a278bc0e2ff9e5330df8/apm-collector/apm-collector-component/client-component/src/main/java/org/skywalking/apm/collector/client/h2/H2Client.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.client.h2.H2Client</code></a> ，H2 数据库客户端。</p><p>基于 <code>com.h2database.h2</code> 的 <code>1.4.196</code> 版本，封装 SkyWalking 需要的 H2 数据库操作。目前用于 <a href="https://github.com/YunaiV/skywalking/tree/001f700612ad52bc1eb1a278bc0e2ff9e5330df8/apm-collector/apm-collector-storage/collector-storage-h2-provider" rel="external nofollow noopener noreferrer" target="_blank"><code>collector-storage-h2-provider</code></a> / <a href="https://github.com/YunaiV/skywalking/tree/001f700612ad52bc1eb1a278bc0e2ff9e5330df8/apm-collector/apm-collector-cluster/collector-cluster-standalone-provider" rel="external nofollow noopener noreferrer" target="_blank"><code>collector-cluster-standalone-provider</code></a> 模块。</p><h1 id="6-RedisClient"><a href="#6-RedisClient" class="headerlink" title="6. RedisClient"></a>6. RedisClient</h1><p><a href="https://github.com/YunaiV/skywalking/blob/001f700612ad52bc1eb1a278bc0e2ff9e5330df8/apm-collector/apm-collector-component/client-component/src/main/java/org/skywalking/apm/collector/client/redis/RedisClient.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.client.redis.RedisClient</code></a> ，Redis 客户端。</p><p>基于 <code>redis.clients.jedis</code> 的 <code>2.9.0</code> 版本，封装 SkyWalking 需要的 Reids 操作。预计未来用于 <a href="https://github.com/YunaiV/skywalking/tree/001f700612ad52bc1eb1a278bc0e2ff9e5330df8/apm-collector/apm-collector-cluster/collector-cluster-redis-provider" rel="external nofollow noopener noreferrer" target="_blank"><code>collector-cluster-redis-provider</code></a> 模块。</p><h1 id="7-ZookeeperClient"><a href="#7-ZookeeperClient" class="headerlink" title="7. ZookeeperClient"></a>7. ZookeeperClient</h1><p><a href="https://github.com/YunaiV/skywalking/blob/001f700612ad52bc1eb1a278bc0e2ff9e5330df8/apm-collector/apm-collector-component/client-component/src/main/java/org/skywalking/apm/collector/client/zookeeper/ZookeeperClient.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.client.zookeeper.ZookeeperClient</code></a> ，Zookeeper 客户端。</p><p>基于 <code>org.apache.zookeeper.zookeeper</code> 的 <code>3.4.10</code> 版本，封装 SkyWalking 需要的 Zookeeper 操作。预计未来用于 <a href="https://github.com/YunaiV/skywalking/tree/001f700612ad52bc1eb1a278bc0e2ff9e5330df8/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider" rel="external nofollow noopener noreferrer" target="_blank"><code>collector-cluster-zookeeper-provider</code></a> 模块。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>哈哈哈，是不是看的很有成就感( 笔者又在水更了 )。</p><p>不要方，下面还有一篇水更。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_25/04.png" alt=""></p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-client-component/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-client-compone
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector Cluster 集群管理</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-cluster-module/</id>
    <published>2020-07-19T16:00:00.000Z</published>
    <updated>2017-12-15T08:29:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">http://www.iocoder.cn/SkyWalking/collector-cluster-module/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">2. collector-cluster-define</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">2.1 ClusterModule</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">2.2 ModuleRegisterService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">2.3 ModuleListenerService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">2.4 DataMonitor</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">3. collector-cluster-zookeeper-provider</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">3.1 ClusterModuleZookeeperProvider</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">3.2 ZookeeperModuleRegisterService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">3.3 ZookeeperModuleListenerService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">3.4 ClusterZKDataMonitor</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">3.5 ZookeeperClient</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">4. collector-cluster-standalone-provider</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">5. collector-cluster-redis-provider</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>SkyWalking Collector Cluster Module</strong>，负责集群的管理，即 Collector 节点的注册于发现。</p><blockquote><p>友情提示：建议先阅读 <a href="http://www.iocoder.cn/SkyWalking/collector-init/?self">《SkyWalking 源码分析 —— Collector 初始化》</a> ，以了解 Collector 组件体系。</p></blockquote><p>Cluster Module 在 SkyWalking 架构图处于如下位置( <strong>红框</strong> ) ：</p><blockquote><p>FROM <a href="https://github.com/apache/incubating-skywalking" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubating-skywalking</a><br><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_20/01.jpeg" alt=""></p></blockquote><p>下面我们来看看整体的项目结构，如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_20/02.png" alt=""></p><ul><li><code>collector-cluster-define</code> ：定义集群管理接口。</li><li><code>collector-cluster-standalone-provider</code> ：基于 H2 的 集群管理实现。<strong>该实现是单机版，建议仅用于 SkyWalking 快速上手，生产环境不建议使用</strong>。</li><li><code>collector-cluster-redis-provider</code> ：基于 Redis 的集群管理实现。<em>目前暂未完成</em>。</li><li><code>collector-cluster-zookeeper-provider</code> ：基于 Zookeeper 的集群管理实现。<strong>生产环境推荐使用</strong></li></ul><p>下面，我们从<strong>接口到实现</strong>的顺序进行分享。</p><h1 id="2-collector-cluster-define"><a href="#2-collector-cluster-define" class="headerlink" title="2. collector-cluster-define"></a>2. collector-cluster-define</h1><p><code>collector-cluster-define</code> ：定义集群管理接口。项目结构如下 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_20/03.png" alt=""></p><ul><li><p>交互如下图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_20/04.png" alt=""></p></li><li><p>ModuleListenerService 暴露给其他 Module 注册监听器 ( ClusterModuleListener ) 到 DataMonitor 。</p></li><li>ModuleRegisterService 暴露给其他 Module 注册组件登记( ModuleRegistration ) 到 DataMonitor 。</li><li>通过实现 DataMonitor 接口，基于不同的存储器实现注册发现。</li></ul><h2 id="2-1-ClusterModule"><a href="#2-1-ClusterModule" class="headerlink" title="2.1 ClusterModule"></a>2.1 ClusterModule</h2><p><code>org.skywalking.apm.collector.cluster.ClusterModule</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java" rel="external nofollow noopener noreferrer" target="_blank">Module</a> 抽象类，集群管理 Module 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/ClusterModule.java#L33" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回模块名为 <code>&quot;cluster&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/ClusterModule.java#L37" rel="external nofollow noopener noreferrer" target="_blank"><code>#services()</code></a> <strong>实现</strong>方法，返回 Service 类名：ModuleListenerService / ModuleRegisterService 。</p><h2 id="2-2-ModuleRegisterService"><a href="#2-2-ModuleRegisterService" class="headerlink" title="2.2 ModuleRegisterService"></a>2.2 ModuleRegisterService</h2><p><code>org.skywalking.apm.collector.cluster.service.ModuleRegisterService</code> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> 接口，模块注册服务<strong>接口</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/service/ModuleRegisterService.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>#register(moduleName, providerName, registration)</code></a> <strong>接口</strong>方法，注册模块注册信息。一般情况下，实现该接口方法，调用 <code>DataMonitor#register(path, registration)</code> 方法。</p><h3 id="2-2-1-ModuleRegistration"><a href="#2-2-1-ModuleRegistration" class="headerlink" title="2.2.1 ModuleRegistration"></a>2.2.1 ModuleRegistration</h3><p><code>org.skywalking.apm.collector.cluster.ModuleRegistration</code> ，模块注册信息<strong>抽象类</strong>。不同 Module 通过实现 ModuleRegistration ，将它们注册到 ModuleRegisterService。目前子类如下 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_20/05.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/ModuleRegistration.java" rel="external nofollow noopener noreferrer" target="_blank"><code>#buildValue()</code></a> <strong>抽象</strong>方法，获得模块注册信息( <a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/ModuleRegistration.java#L30" rel="external nofollow noopener noreferrer" target="_blank">Value</a> )。</p><h2 id="2-3-ModuleListenerService"><a href="#2-3-ModuleListenerService" class="headerlink" title="2.3 ModuleListenerService"></a>2.3 ModuleListenerService</h2><p><code>org.skywalking.apm.collector.cluster.service.ModuleListenerService</code> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> 接口，注册监听器服务<strong>接口</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/service/ModuleListenerService.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><code>#addListener(listener)</code></a> <strong>接口</strong>方法，添加监听器。一般情况下，实现该接口方法，调用 <code>DataMonitor#addListener(listener)</code> 方法。</p><h3 id="2-3-1-ClusterModuleListener"><a href="#2-3-1-ClusterModuleListener" class="headerlink" title="2.3.1 ClusterModuleListener"></a>2.3.1 ClusterModuleListener</h3><p><code>org.skywalking.apm.collector.cluster.ClusterModuleListener</code> ，集群组件监听器<strong>抽象类</strong>。目前子类如下 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_20/11.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/ClusterModuleListener.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><strong>构造方法</strong></a>，创建地址数组( <code>addresses</code> )。该数组的读写方法如下：</p><ul><li><code>#addAddress(address)</code></li><li><code>#removeAddress(address)</code></li><li><code>#getAddresses()</code></li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/ClusterModuleListener.java#L43" rel="external nofollow noopener noreferrer" target="_blank"><code>#path()</code></a> <strong>抽象</strong>方法，返回路径。该路径即为 ClusterModuleListener 监听的<strong>“事件”</strong>。多个 Collector 节点的相同 Module ，<strong>通过路径分组形成集群</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/ClusterModuleListener.java#L62" rel="external nofollow noopener noreferrer" target="_blank"><code>#serverJoinNotify(serverAddress)</code></a> / <a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/ClusterModuleListener.java#L69" rel="external nofollow noopener noreferrer" target="_blank"><code>#serverQuitNotify(serverAddress)</code></a> <strong>抽象</strong>方法，通知服务的加入 / 下线。目前只有 GRPCRemoteSenderService <strong>真正</strong>( 其它都是空方法 )实现该方法，在 <a href="">TODO 【4002】Remote</a> 详细解析。</p><h2 id="2-4-DataMonitor"><a href="#2-4-DataMonitor" class="headerlink" title="2.4 DataMonitor"></a>2.4 DataMonitor</h2><p><code>org.skywalking.apm.collector.cluster.DataMonitor</code> ，数据监<strong>视</strong>器<strong>接口</strong>。通过实现 DataMonitor 接口，基于不同的存储器实现注册发现。目前子类如下 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_20/06.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/DataMonitor.java#L40" rel="external nofollow noopener noreferrer" target="_blank"><code>#register(path, registration)</code></a> <strong>接口</strong>方法，注册模块注册信息。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/DataMonitor.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>#addListener(ClusterModuleListener)</code></a> <strong>接口</strong>方法，添加监听器。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/DataMonitor.java#L42" rel="external nofollow noopener noreferrer" target="_blank"><code>#getListener(path)</code></a> <strong>接口</strong>方法，获得监听<strong>指定路径</strong>的监听器。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/DataMonitor.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><code>#setClient(Client)</code></a> <strong>接口</strong>方法，设置 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-component/client-component/src/main/java/org/skywalking/apm/collector/client/Client.java" rel="external nofollow noopener noreferrer" target="_blank">Client</a> 。在 <a href="https://github.com/YunaiV/skywalking/tree/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-component/client-component/src/main/java/org/skywalking/apm/collector/client" rel="external nofollow noopener noreferrer" target="_blank"><code>client-component</code></a> 有 ZookeeperClient / H2Client / ElasticSearchClient 等多种实现。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/DataMonitor.java#L34" rel="external nofollow noopener noreferrer" target="_blank"><code>BASE_CATALOG</code></a> 属性，基础目录为 <code>&quot;/skywalking&quot;</code> 。例如说，在 Zookeeper 为根节点的路径。</li><li><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/DataMonitor.java#L44" rel="external nofollow noopener noreferrer" target="_blank"><code>#createPath(path)</code></a> <strong>接口</strong>方法，使用 Client 创建路径。</li><li><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/DataMonitor.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#setData(path)</code></a> <strong>接口</strong>方法，使用 Client 设置路径的值。</li></ul><h1 id="3-collector-cluster-zookeeper-provider"><a href="#3-collector-cluster-zookeeper-provider" class="headerlink" title="3. collector-cluster-zookeeper-provider"></a>3. collector-cluster-zookeeper-provider</h1><p><code>collector-cluster-zookeeper-provider</code> ，基于 Zookeeper 的集群管理实现。项目结构如下 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_20/07.png" alt=""></p><p>实际使用时，通过 <code>application.yml</code> 配置如下：</p><figure class="highlight"><table><tr><td class="code"><pre><div class="line">cluster:</div><div class="line">  zookeeper:</div><div class="line">    hostPort: localhost:2181</div><div class="line">    sessionTimeout: 100000</div></pre></td></tr></table></figure><ul><li>生产环境下，推荐 Zookeeper 配置成集群。</li></ul><h2 id="3-1-ClusterModuleZookeeperProvider"><a href="#3-1-ClusterModuleZookeeperProvider" class="headerlink" title="3.1 ClusterModuleZookeeperProvider"></a>3.1 ClusterModuleZookeeperProvider</h2><p><code>org.skywalking.apm.collector.cluster.zookeeper.ClusterModuleZookeeperProvider</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java" rel="external nofollow noopener noreferrer" target="_blank">ModuleProvider</a> <strong>抽象类</strong>，基于 Zookeeper 的集群管理服务提供者。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterModuleZookeeperProvider.java#L53" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回组件服务提供者名为 <code>&quot;zookeeper&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterModuleZookeeperProvider.java#L57" rel="external nofollow noopener noreferrer" target="_blank"><code>module()</code></a> <strong>实现</strong>方法，返回组件类为 ClusterModule 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterModuleZookeeperProvider.java#L94" rel="external nofollow noopener noreferrer" target="_blank"><code>#requiredModules()</code></a> <strong>实现</strong>方法，返回依赖组件为空。</p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterModuleZookeeperProvider.java#L61" rel="external nofollow noopener noreferrer" target="_blank"><code>#prepare(Properties)</code></a> <strong>实现</strong>方法，执行准备阶段逻辑。</p><ul><li>第 63 行 ：创建 ClusterZKDataMonitor 对象。</li><li>第 69 行 ：创建 ZookeeperClient 对象。<strong>注意，此时并未连接 Zookeeper</strong> 。</li><li>第 71 至 73 行 ：创建 ZookeeperModuleListenerService / ZookeeperModuleRegisterService 对象，并调用 <code>#registerServiceImplementation()</code> <strong>父类</strong>方法，注册到 <code>services</code> 。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterModuleZookeeperProvider.java#L76" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> <strong>实现</strong>方法，执行启动阶段逻辑。</p><ul><li>第 79 行 ：调用 <code>ZookeeperClient#initialize()</code> 方法，初始化 ZookeeperClient ，<strong>此时会连接 Zookeeper</strong>。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterModuleZookeeperProvider.java#L85" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyAfterCompleted()</code></a> <strong>实现</strong>方法，执行启动完成逻辑。</p><ul><li>第 88 行 ：调用 <code>ClusterZKDataMonitor#start()</code> 方法，启动 ClusterZKDataMonitor 。在本文 <a href="#">「3.4 ClusterZKDataMonitor」</a> 详细解析。</li></ul><h2 id="3-2-ZookeeperModuleRegisterService"><a href="#3-2-ZookeeperModuleRegisterService" class="headerlink" title="3.2 ZookeeperModuleRegisterService"></a>3.2 ZookeeperModuleRegisterService</h2><p><code>org.skywalking.apm.collector.cluster.zookeeper.service.ZookeeperModuleRegisterService</code> ，基于 Zookeeper 的模块注册服务<strong>实现类</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/service/ZookeeperModuleRegisterService.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>#register(moduleName, providerName, registration)</code></a> <strong>实现</strong>方法，调用 <code>ClusterZKDataMonitor#register(path, registration)</code> 方法，注册模块注册信息。</p><h2 id="3-3-ZookeeperModuleListenerService"><a href="#3-3-ZookeeperModuleListenerService" class="headerlink" title="3.3 ZookeeperModuleListenerService"></a>3.3 ZookeeperModuleListenerService</h2><p><code>org.skywalking.apm.collector.cluster.zookeeper.service.ZookeeperModuleListenerService</code> ，基于 Zookeeper 的注册监听器服务<strong>实现类</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/service/ZookeeperModuleListenerService.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>#addListener(ClusterModuleListener)</code></a> <strong>实现</strong>方法，调用 <code>ClusterZKDataMonitor#addListener(ClusterModuleListener)</code> 方法，注册模块注册信息。</p><h2 id="3-4-ClusterZKDataMonitor"><a href="#3-4-ClusterZKDataMonitor" class="headerlink" title="3.4 ClusterZKDataMonitor"></a>3.4 ClusterZKDataMonitor</h2><p><code>org.skywalking.apm.collector.cluster.zookeeper.ClusterZKDataMonitor</code> ，基于 Zookeeper 的数据监视器<strong>实现类</strong>。</p><p>在看具体代码实现之前，我们先来看看 Zookeeper 是如何存储数据的，如下图所示 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_20/08.png" alt=""></p><ul><li>紫色部分，通过调用 <a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterZKDataMonitor.java#L172" rel="external nofollow noopener noreferrer" target="_blank"><code>#createPath(path)</code></a> 方法，顺着路径，逐层创建<strong>持久</strong>节点。</li><li>黄色部分，通过调用 <a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterZKDataMonitor.java#L184" rel="external nofollow noopener noreferrer" target="_blank"><code>#setData(path)</code></a> 方法，创建<strong>临时</strong>节点，设置 Collector 模块地址。若 Collector 集群有 N 个节点，则此处会有 N 个<strong>临时</strong>节点。</li><li><p>打开 <code>zkClient.sh</code> ，我们来看一个例子 ：</p>  <figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 1] ls /skywalking</div><div class="line">[remote, ui, agent_jetty, agent_gRPC]</div><div class="line"></div><div class="line">[zk: localhost:2181(CONNECTED) 2] ls /skywalking/ui</div><div class="line">[jetty]</div><div class="line"></div><div class="line">[zk: localhost:2181(CONNECTED) 3] ls /skywalking/ui/jetty</div><div class="line">[localhost:12800]</div><div class="line"></div><div class="line">[zk: localhost:2181(CONNECTED) 4] get /skywalking/ui/jetty/localhost:12800</div><div class="line">/</div><div class="line">cZxid = 0x24</div><div class="line">ctime = Thu Dec 14 16:05:25 CST 2017</div><div class="line">mZxid = 0x24</div><div class="line">mtime = Thu Dec 14 16:05:25 CST 2017</div><div class="line">pZxid = 0x24</div><div class="line">cversion = 0</div><div class="line">dataVersion = 0</div><div class="line">aclVersion = 0</div><div class="line">ephemeralOwner = 0x16052d8b9f40006</div><div class="line">dataLength = 1</div><div class="line">numChildren = 0</div></pre></td></tr></table></figure></li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterZKDataMonitor.java#L163" rel="external nofollow noopener noreferrer" target="_blank"><code>#register(path, registration)</code></a> <strong>实现</strong>方法，添加到组件注册信息集合( <code>registrations</code> )。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterZKDataMonitor.java#L123" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> 方法，启动 ClusterZKDataMonitor ，将组件注册信息( <code>registrations</code> ) 写到 Zookeeper 中。</p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterZKDataMonitor.java#L157" rel="external nofollow noopener noreferrer" target="_blank"><code>#addListener(listener)</code></a> <strong>实现</strong>方法，添加到监听器集合( <code>listeners</code> )。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterZKDataMonitor.java#L123" rel="external nofollow noopener noreferrer" target="_blank"><code>#process(WatchedEvent)</code></a> <strong>实现</strong>方法，处理有 Collector 节点的组件加入或下线。总体逻辑是，从 Zookeeper 获取变更的路径下的地址数组，和本地的地址( <code>ClusterModuleListener.addresses</code> )比较，处理加入或移除逻辑的地址。</p><ul><li>ClusterZKDataMonitor 实现 <code>org.apache.zookeeper.Watcher</code> <strong>接口</strong>，所以实现该方法。</li><li>该方法是 <code>synchronized</code> 方法，以保证不会出现并发问题。</li></ul><h2 id="3-5-ZookeeperClient"><a href="#3-5-ZookeeperClient" class="headerlink" title="3.5 ZookeeperClient"></a>3.5 ZookeeperClient</h2><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-component/client-component/src/main/java/org/skywalking/apm/collector/client/zookeeper/ZookeeperClient.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.client.zookeeper.ZookeeperClient</code></a> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-component/client-component/src/main/java/org/skywalking/apm/collector/client/Client.java" rel="external nofollow noopener noreferrer" target="_blank">Client</a> <strong>接口</strong>，Zookeeper 客户端。</p><p>代码比较简单，胖友自己阅读理解。</p><h1 id="4-collector-cluster-standalone-provider"><a href="#4-collector-cluster-standalone-provider" class="headerlink" title="4. collector-cluster-standalone-provider"></a>4. collector-cluster-standalone-provider</h1><p><code>collector-cluster-standalone-provider.ClusterStandaloneDataMonitor</code> ，基于 H2 的 集群管理实现。<strong>该实现是单机版，建议仅用于 SkyWalking 快速上手，生产环境不建议使用</strong>。项目结构如下 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_20/09.png" alt=""></p><p>大体实现和 <code>collector-cluster-zookeeper-provider</code> 差不多，差异在对 DataMonitor 的实现类 ClusterStandaloneDataMonitor 上。</p><p>在 ClusterStandaloneDataMonitor 里，实际并未使用 H2Client ，而是基于内存，胖友可以自己查看下。</p><h1 id="5-collector-cluster-redis-provider"><a href="#5-collector-cluster-redis-provider" class="headerlink" title="5. collector-cluster-redis-provider"></a>5. collector-cluster-redis-provider</h1><p><code>collector-cluster-redis-provider</code> ：基于 Redis 的集群管理实现。<em>目前暂未完成</em>。</p><p>【TODO 4003】等实现后来写写，基于 Redis Pub Sub 保证实时性</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>有一种硬生生把很简单的东西，写的很复杂的感觉。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_20/10.png" alt=""></p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-cluster-module/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-cluster-module/&lt;
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector 初始化</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-init/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-init/</id>
    <published>2020-07-14T16:00:00.000Z</published>
    <updated>2017-12-14T16:44:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-init/">http://www.iocoder.cn/SkyWalking/collector-init/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-init/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-init/">2. CollectorBootStartUp</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-init/">2. ApplicationConfigLoader</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-init/">3. ModuleManager</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-init/">3.1 Module</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-init/">3.2 ModuleProvider</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-init/">3.3 Service</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-init/">3.4 BootstrapFlow</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-init/">4. Module 实现类简介</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>SkyWalking Collector 启动初始化的过程</strong>。在分享的过程中，我们会<strong>简单</strong>介绍 Collector 每个模块及其用途。</p><p>ps ：Collector 是 SkyWalking 的 Server 端。整体如下图 ：</p><blockquote><p>FROM <a href="https://github.com/apache/incubating-skywalking" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubating-skywalking</a><br><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/01.png" alt=""></p></blockquote><h1 id="2-CollectorBootStartUp"><a href="#2-CollectorBootStartUp" class="headerlink" title="2. CollectorBootStartUp"></a>2. CollectorBootStartUp</h1><p><code>org.skywalking.apm.collector.boot.CollectorBootStartUp</code> ，在 <code>apm-sniffer/apm-agent</code> Maven 模块项目里，SkyWalking Collector <strong>启动入口</strong>。 </p><p><a href="https://github.com/YunaiV/skywalking/blob/c633c1f0e143d1df2457926ab239350a642f7be2/apm-collector/apm-collector-boot/src/main/java/org/skywalking/apm/collector/boot/CollectorBootStartUp.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>#main(args)</code></a> 方法，启动 Collector ，代码如下 ：</p><ul><li>第 45 行 ：调用 <code>ApplicationConfiguration#load()</code> 方法，加载 Collector <strong>配置</strong>。</li><li>第 47 行 ：调用 <code>ModuleManager#init(...)</code> 方法，初始化 Collector <strong>组件</strong>们。</li><li>第 60 行 ：调用 <code>Thread#sleep(60000)</code> 方法，等待 Collector 内嵌的 Jetty Server 启动完成。</li></ul><h1 id="2-ApplicationConfigLoader"><a href="#2-ApplicationConfigLoader" class="headerlink" title="2. ApplicationConfigLoader"></a>2. ApplicationConfigLoader</h1><p><code>org.skywalking.apm.collector.boot.config.ApplicationConfigLoader</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/c633c1f0e143d1df2457926ab239350a642f7be2/apm-collector/apm-collector-boot/src/main/java/org/skywalking/apm/collector/boot/config/ConfigLoader.java#L24" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.boot.config.ConfigLoader</code></a> 接口，Collector 配置( <a href="https://github.com/YunaiV/skywalking/blob/c633c1f0e143d1df2457926ab239350a642f7be2/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ApplicationConfiguration.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.core.module.ApplicationConfiguration</code></a> )加载器。</p><p>在看具体代码实现之前，我们先了解下 ApplicationConfiguration 整体类结构。如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/02.png" alt=""></p><ul><li>Collector 使用组件管理器( ModuleManager )，管理<strong>多个</strong>组件( <a href="https://github.com/YunaiV/skywalking/blob/c633c1f0e143d1df2457926ab239350a642f7be2/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java" rel="external nofollow noopener noreferrer" target="_blank">Module</a> )。<ul><li>一个组件有多种组件服务提供者( <a href="https://github.com/YunaiV/skywalking/blob/c633c1f0e143d1df2457926ab239350a642f7be2/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java" rel="external nofollow noopener noreferrer" target="_blank">ModuleProvider</a> )，<strong>同时</strong>一个组件只允许使用<strong>一个</strong>组件服务提供者。这块下面会有代码解析说明。</li></ul></li><li>Collector 使用一个应用配置类( <a href="https://github.com/YunaiV/skywalking/blob/c633c1f0e143d1df2457926ab239350a642f7be2/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ApplicationConfiguration.java" rel="external nofollow noopener noreferrer" target="_blank">ApplicationConfiguration</a> )。<ul><li>一个应用配置类包含多个组件配置类( <a href="https://github.com/YunaiV/skywalking/blob/c633c1f0e143d1df2457926ab239350a642f7be2/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ApplicationConfiguration.java#L62" rel="external nofollow noopener noreferrer" target="_blank">ModuleConfiguration</a> )。每个组件对应一个组件配置类。</li><li>一个组件配置类包含多个组件服务提供者配置( <a href="https://github.com/YunaiV/skywalking/blob/c633c1f0e143d1df2457926ab239350a642f7be2/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ApplicationConfiguration.java#L93" rel="external nofollow noopener noreferrer" target="_blank">ProviderConfiguration</a> )。每个组件服务提供者对应一个组件配置类。<strong>注意</strong>：因为一个组件只允许<strong>同时</strong>使用<strong>一个</strong>组件服务提供者，所以一个组件配置类<strong>只设置</strong>一个组件服务提供者配置。</li></ul></li><li>整个配置文件，对应应用配置类。<strong>绿框</strong>部分，对应一个组件配置类。<strong>红框</strong>部分，对应一个组件服务提供者配置类。</li></ul><p>下面，我们来看看 <a href="https://github.com/YunaiV/skywalking/blob/c633c1f0e143d1df2457926ab239350a642f7be2/apm-collector/apm-collector-boot/src/main/java/org/skywalking/apm/collector/boot/config/ApplicationConfigLoader.java#L43" rel="external nofollow noopener noreferrer" target="_blank"><code>ApplicationConfigLoader#load()</code></a> 方法，代码如下 ：</p><ul><li>第 47 行 ：调用 <code>#loadConfig()</code> 方法，从 <code>apm-collector-core</code> 的 <a href="https://github.com/YunaiV/skywalking/blob/c633c1f0e143d1df2457926ab239350a642f7be2/apm-collector/apm-collector-core/src/main/resources/application-default.yml" rel="external nofollow noopener noreferrer" target="_blank"><code>application.yml</code></a> 加载自定义配置。</li><li>第 49 行 ：调用 <code>#loadDefaultConfig()</code> 方法，从 <code>apm-collector-core</code> 的 <a href="https://github.com/YunaiV/skywalking/blob/c633c1f0e143d1df2457926ab239350a642f7be2/apm-collector/apm-collector-core/src/main/resources/application-default.yml" rel="external nofollow noopener noreferrer" target="_blank"><code>application-default.yml</code></a> 加载默认配置。</li><li>两个方法逻辑基本一致，已经添加代码注释，胖友自己阅读理解。</li></ul><h1 id="3-ModuleManager"><a href="#3-ModuleManager" class="headerlink" title="3. ModuleManager"></a>3. ModuleManager</h1><p><code>org.skywalking.apm.collector.core.module.ModuleManager</code> ，组件管理器，负责组件的管理与初始化。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ff055ee52da855ef6cc8bfdfae7c2758ae3c61cd/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleManager.java#L49" rel="external nofollow noopener noreferrer" target="_blank"><code>#init()</code></a> 方法，初始化组件们，代码如下 ：</p><ul><li><p>第 51 至 53 行 ：调用 <code>java.util.ServiceLoader#load(Module.class)</code> 方法，加载所有 Module 实现类的实例数组。ServiceManager 基于 SPI (Service Provider Interface) 机制，在每个 <code>apm-collector-xxx-define</code> 项目的 <code>/resources/META-INF.services/org.skywalking.apm.collector.core.module.Module</code> 文件里，定义了该项目 Module 的实现类。如果胖友对 SPI 机制不熟悉，可以看下如下文章 ：</p><ul><li><a href="http://www.jianshu.com/p/32d3e108f30a" rel="external nofollow noopener noreferrer" target="_blank">《SPI 和 ServiceLoader》</a> </li><li><a href="http://www.jianshu.com/p/46aa69643c97" rel="external nofollow noopener noreferrer" target="_blank">《跟我学Dubbo系列之Java SPI机制简介》</a> </li></ul></li><li><p>第 55 至 75 行 ：遍历所有 Module 实现类的实例数组，创建<strong>在配置中</strong>的 Module 实现类的实例，并执行 Module 准备阶段的逻辑，后添加到加载的组件实例的映射( <code>loadedModules</code> )。</p><ul><li>第 59 至 67 行 ：创建 Module 对象。</li><li>第 69 行 ：调用 <code>Module#prepare(...)</code> 方法，执行 Module 准备阶段的逻辑。在改方法内部，会创建 Module 对应的 ModuleProvider 。在 <a href="#">「3.1 Module」</a> 详细解析。</li><li>第 71 行 ：添加到 <code>loadedModules</code> 。</li></ul></li><li>第 77 至 80 行 ：校验<strong>在配置中</strong>的 Module 实现类的实例都创建了，否则抛出异常。</li><li>第 84 行 ：调用 <code>BootstrapFlow#start(...)</code> 方法，执行 Module 启动逻辑。<a href="#">「3.4 BootstrapFlow」</a> 详细解析。</li><li>第 86 行 ：调用 <code>BootstrapFlow#notifyAfterCompleted()</code> 方法，执行 Module 启动完成，通知 ModuleProvider 。<a href="#">「3.4 BootstrapFlow」</a> 详细解析。</li><li>总的来说，Module 初始化的过程，可以理解成三个阶段，如下图所示 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/03.png" alt=""></li></ul><h2 id="3-1-Module"><a href="#3-1-Module" class="headerlink" title="3.1 Module"></a>3.1 Module</h2><p><code>org.skywalking.apm.collector.core.module.Module</code> ，组件<strong>抽象类</strong>。通过实现 Module 抽象类，实现不同功能的组件。目前 Collector 的 Module 实现类如下图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/04.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/204a9e658dd95cc8ee5d4e65d7ca1ed58f3a71da/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>抽象</strong>方法，获得组件名。目前组件名有 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/05.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/204a9e658dd95cc8ee5d4e65d7ca1ed58f3a71da/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java#L110" rel="external nofollow noopener noreferrer" target="_blank"><code>#providers()</code></a> 方法，获得 ModuleProvider 数组。实际上，一个 Module <strong>同时</strong>只能有一个 ModuleProvider ，参见 <a href="https://github.com/YunaiV/skywalking/blob/204a9e658dd95cc8ee5d4e65d7ca1ed58f3a71da/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java#L114" rel="external nofollow noopener noreferrer" target="_blank"><code>#provider()</code></a> 方法。</p><p><a href="https://github.com/YunaiV/skywalking/blob/204a9e658dd95cc8ee5d4e65d7ca1ed58f3a71da/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java#L55" rel="external nofollow noopener noreferrer" target="_blank"><code>#services()</code></a> <strong>抽象</strong>方法，获得 Service <strong>类</strong>数组。具体 Service <strong>对象</strong>，在 ModuleProvider 对象里获取，参见 <a href="https://github.com/YunaiV/skywalking/blob/204a9e658dd95cc8ee5d4e65d7ca1ed58f3a71da/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java#L122" rel="external nofollow noopener noreferrer" target="_blank"><code>#getService(serviceType)</code></a> 方法。</p><p><a href="https://github.com/YunaiV/skywalking/blob/204a9e658dd95cc8ee5d4e65d7ca1ed58f3a71da/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java#L66" rel="external nofollow noopener noreferrer" target="_blank"><code>#prepare(...)</code></a> 方法，执行 Module <strong>准备阶段</strong>的逻辑，代码如下 ：</p><ul><li>第 69 行 ：调用 <code>java.util.ServiceLoader#load(ModuleProvider.class)</code> 方法，加载所有 ModuleProvider 实现类的实例数组。ServiceManager 基于 SPI (Service Provider Interface) 机制，在每个 <code>apm-collector-xxx-yyy-provider</code> 项目的 <code>/resources/META-INF.services/org.skywalking.apm.collector.core.module.ModuleProvider</code> 文件里，定义了该项目 ModuleProvider 的实现类。</li><li>第 72 至 93 行 ：遍历所有 ModuleProvider 实现类的实例数组，创建<strong>在配置中</strong>的 ModuleProvider 实现类的实例，后添加到加载的组件服务提供者实例的映射( <code>loadedProviders</code> )。</li><li>第 95 至 98 行 ：校验有 ModuleProvider 初始化，否则抛出异常。</li><li>第 100 至 104 行 ：调用 <code>ModuleProvider#prepare(...)</code>  方法，执行 ModuleProvider 准备阶段的逻辑。在改方法内部，会创建 ModuleProvider 对应的 Service 。在 <a href="#">「3.2 ModuleProvider」</a> 详细解析。</li></ul><h2 id="3-2-ModuleProvider"><a href="#3-2-ModuleProvider" class="headerlink" title="3.2 ModuleProvider"></a>3.2 ModuleProvider</h2><p><code>org.skywalking.apm.collector.core.module.ModuleProvider</code> ，组件服务提供者<strong>抽象类</strong>。通过实现 ModuleProvider 抽象类，实现不同功能的组件服务提供者。目前 Collector 的 ModuleProvider 实现类如下图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/06.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java#L64" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>抽象</strong>方法，获得组件服务提供者名。目前组件服务提供者名有 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/07.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java#L69" rel="external nofollow noopener noreferrer" target="_blank"><code>#module()</code></a> <strong>抽象</strong>方法，获得 ModuleProvider 对应的 Module <strong>类</strong>。注意，ModuleProvider 的名字可以重复，例如上图的 <code>jetty</code> ，通过对应的 Module <strong>类</strong>来区分。</p><p><a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java#L95" rel="external nofollow noopener noreferrer" target="_blank"><code>#requiredModules()</code></a> <strong>抽象</strong>方法，获得 ModuleProvider 依赖的 Module <strong>名字</strong>数组。</p><p>———- Service 相关方法 Begin ———-</p><p><a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java#L103" rel="external nofollow noopener noreferrer" target="_blank"><code>#registerServiceImplementation(Class&lt;? extends Service&gt;, Service)</code></a> 方法，注册 Service 对象。一个 ModuleProvider 可以有 0 到 N 个 Service 对象。</p><p><a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java#L133" rel="external nofollow noopener noreferrer" target="_blank"><code>#getService(Class&lt;T&gt;)</code></a> 方法，获得 Service 对象。</p><p><a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java#L118" rel="external nofollow noopener noreferrer" target="_blank"><code>#requiredCheck(...)</code></a> 方法，<strong>校验</strong> ModuleProvider 包含的 Service 们都创建成功。</p><ul><li><strong>方法参数</strong>，从 <code>Module#services()</code> 方法获得。</li><li>该方法会被 <code>BootstrapFlow#start()</code> 方法调用，在 <a href="#">「3.4 BootstrapFlow」</a> 详细解析。</li></ul><p>———- Service 相关方法 End ———-</p><p><a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java#L76" rel="external nofollow noopener noreferrer" target="_blank"><code>#prepare(Properties)</code></a> <strong>抽象</strong>方法，执行 ModuleProvider 准备阶段的逻辑：Service 的创建，私有变量的创建等等。例如，<a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-storage/collector-storage-h2-provider/src/main/java/org/skywalking/apm/collector/storage/h2/StorageModuleH2Provider.java#L123" rel="external nofollow noopener noreferrer" target="_blank"><code>StorageModuleH2Provider#prepare(Properties)</code></a> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java#L83" rel="external nofollow noopener noreferrer" target="_blank"><code>#start(Properties)</code></a> <strong>抽象</strong>方法，执行 ModuleProvider 启动阶段的逻辑：私有变量的初始化等等。例如，<a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-storage/collector-storage-h2-provider/src/main/java/org/skywalking/apm/collector/storage/h2/StorageModuleH2Provider.java#L136" rel="external nofollow noopener noreferrer" target="_blank"><code>StorageModuleH2Provider#start(Properties)</code></a> 。</p><ul><li>该方法会被 <code>BootstrapFlow#start()</code> 方法调用，在 <a href="#">「3.4 BootstrapFlow」</a> 详细解析。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java#L90" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyAfterCompleted()</code></a> <strong>抽象</strong>方法，执行 ModuleProvider 启动完成阶段的逻辑：私有变量的初始化等等。例如，<a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/StorageModuleEsProvider.java#L170" rel="external nofollow noopener noreferrer" target="_blank"><code>StorageModuleEsProvider#notifyAfterCompleted(Properties)</code></a> 。</p><ul><li>该方法会被 <code>BootstrapFlow#notifyAfterCompleted()</code> 方法调用，在 <a href="#">「3.4 BootstrapFlow」</a> 详细解析。</li></ul><h2 id="3-3-Service"><a href="#3-3-Service" class="headerlink" title="3.3 Service"></a>3.3 Service</h2><p><code>org.skywalking.apm.collector.core.module.Service</code> ，服务<strong>接口</strong>。通过实现 Service 接口，实现不同功能的服务。目前 Collector 的 Service 实现类如下图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/08.png" alt=""></p><p>这里有一点要注意下，实际上 Module 是与 Service <strong>“直接”</strong> 一对多的关系。中间 有一层 ModuleProvider 存在的原因是，相同 Module 可以有多种 ModuleProvider 实现，而 ModuleProvider 提供提供相同功能的 Service ，但是实现不同。</p><p>以 <code>apm-collector-storage</code> 举例子，如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/09.png" alt=""></p><ul><li>StorageModuleEsProvider / StorageModuleH2Provider 分别基于 ES / H2 实现，其提供存储相同数据的不同实现。例如 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/10.png" alt=""></li></ul><p>一般 <code>collector-xxx-define</code> 的 <code>service</code> 包下，会定义当前模块提供的 Service 接口，如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/12.png" alt=""></p><p>这也是为什么有 <code>Module#services()</code> 和 <code>#requiredCheck(Class&lt;? extends Service&gt;[])</code> 这样的方法涉及的原因。</p><p>另外，如下是 Service 接口的解释：</p><blockquote><p>The <code>Service</code> implementation is a service provided by its own modules.  </p><p>And every {@link ModuleProvider} must provide all the given services of the {@link Module}.</p></blockquote><h2 id="3-4-BootstrapFlow"><a href="#3-4-BootstrapFlow" class="headerlink" title="3.4 BootstrapFlow"></a>3.4 BootstrapFlow</h2><p><a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/BootstrapFlow.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.core.module.BootstrapFlow</code></a>，组件启动流程。</p><p>BootstrapFlow <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/BootstrapFlow.java#L42" rel="external nofollow noopener noreferrer" target="_blank"><strong>构造方法</strong></a>，调用 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/BootstrapFlow.java#L86" rel="external nofollow noopener noreferrer" target="_blank"><code>#makeSequence()</code></a> 方法，获得 ModuleProvider 启动顺序，这个是该类的<strong>重点</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/BootstrapFlow.java#L51" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> 方法，执行 Module 启动逻辑。</p><ul><li>第 54 至 63 行 ：校验<strong>依赖</strong> Module 已经都存在。</li><li>第 67 行 ：校验 ModuleProvider 包含的 Service 们都<strong>创建成功</strong>。</li><li>第 70 行 ：调用 <code>ModuleProvider#start(...)</code> 方法，执行 ModuleProvider 启动阶段逻辑。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/BootstrapFlow.java#L74" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyAfterCompleted()</code></a> 方法，调用 <code>ModuleProvider#notifyAfterCompleted()</code> 方法，执行 ModuleProvider 启动完成阶段的逻辑。</p><h1 id="4-Module-实现类简介"><a href="#4-Module-实现类简介" class="headerlink" title="4. Module 实现类简介"></a>4. Module 实现类简介</h1><p><img src="https://camo.githubusercontent.com/2a00cb347f6a7d7afb8faef8d8b0f2a0d3215d9d/68747470733a2f2f736b7977616c6b696e67746573742e6769746875622e696f2f706167652d7265736f75726365732f332e322e352532625f6172636869746563747572652e6a7067" alt=""></p><ul><li><code>Naming Module</code> ：TODO</li><li><code>UI Module</code> ：</li><li><code>Queue Module</code> ：TODO</li><li><code>Cache Module</code> ：TODO</li><li>Cluster Module ：<a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/?self">《SkyWalking 源码分析 —— Collector Cluster 集群管理》</a></li><li>Component Libraries ：<a href="http://www.iocoder.cn/SkyWalking/collector-client-component/?self">《SkyWalking 源码分析 —— Collector Client Component 客户端组件》</a> 、<a href="http://www.iocoder.cn/SkyWalking/collector-server-component/?self">《SkyWalking 源码分析 —— Collector Server Component 服务器组件》</a></li><li>Core ：TODO</li><li>Storage Module ：TODO</li><li>Agent Module ：TODO</li><li>Jetty Manager Module ：<a href="http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/?self">《SkyWalking 源码分析 —— Collector Jetty Server Manager》</a></li><li>gRPC Manager Module ：<a href="http://www.iocoder.cn/SkyWalking/collector-grpc-server-module/?self">《SkyWalking 源码分析 —— Collector gRPC Server Manager》</a></li><li>Agent Streaming Computing ：TODO</li><li>Baseline Module ：todo</li><li>Alerting Module ：todo</li></ul><p>TODO 【4001】Module 实现文章链接 </p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>可能要进入特别忙碌的一段时间，不确定 SkyWalking 文章后续的更新频率。</p><p>继续加油。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/11.png" alt=""></p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-init/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-init/&lt;/a&gt; 「芋道源码」欢迎转载，保留摘要，
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Agent 插件体系</title>
    <link href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/"/>
    <id>http://www.iocoder.cn/SkyWalking/agent-plugin-system/</id>
    <published>2020-07-09T16:00:00.000Z</published>
    <updated>2017-12-12T09:06:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">http://www.iocoder.cn/SkyWalking/agent-plugin-system/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">2. 插件的加载</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">2.1 AgentClassLoader</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">2.2 PluginResourcesResolver</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">2.3 PluginCfg</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">2.4 AbstractClassEnhancePluginDefine</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">2.5 小结</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">3. 插件的匹配</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">3.1 InstrumentDebuggingClass</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">3.2 ClassMatch</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">3.3 PluginFinder</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">4. 插件的拦截</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">4.1 ClassEnhancePluginDefine</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">4.2 InterceptPoint</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">4.3 Interceptor</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">4.4 Inter</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">4.5 小结</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>SkyWalking Agent 插件体系</strong>。主要涉及三个流程 ：</p><ul><li>插件的加载</li><li>插件的匹配</li><li>插件的拦截</li></ul><p>可能看起来有点抽象，不太容易理解。淡定，我们每个小章节进行解析。</p><p>本文涉及到的类主要在 <a href="https://github.com/YunaiV/skywalking/tree/3de8a6c15d07aa3b2c3b4e732e6654fc87c4e70e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin</code></a> 包里，如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/01.png" alt=""></p><p>每个流程会涉及到较多的类，我们会贯穿着解析代码实现。</p><h1 id="2-插件的加载"><a href="#2-插件的加载" class="headerlink" title="2. 插件的加载"></a>2. 插件的加载</h1><p>在 <a href="http://www.iocoder.cn/SkyWalking/agent-init/?self">《SkyWalking 源码分析 —— Agent 初始化》</a> 一文中，Agent 初始化时，调用 <code>PluginBootstrap#loadPlugins()</code> 方法，加载所有的插件。整体流程如下图 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/03.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/130f0a5a3438663b393e53ba2cca02a8d13c258a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginBootstrap.java#L45" rel="external nofollow noopener noreferrer" target="_blank"><code>PluginBootstrap#loadPlugins()</code></a> 方法，代码如下 ：</p><ul><li>第 47 行 ：调用 <code>AgentClassLoader#initDefaultLoader()</code> 方法，初始化 AgentClassLoader 。在本文 <a href="#">「2.1 AgentClassLoader」</a> 详细解析。</li><li>第 50 至 56 行 ：获得插件<strong>定义路径</strong>数组。在本文 <a href="#">「2.2 PluginResourcesResolver」</a> 详细解析。</li><li>第 59 至 66 行 ：获得插件<strong>定义</strong>( <a href="https://github.com/OpenSkywalking/skywalking/blob/b16d23c1484bec941367d6b36fa932b8ace40971/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginDefine.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.PluginDefine</code></a> )数组。在本文 <a href="#">「2.3 PluginCfg」</a> 详细解析。</li><li>第 69 至 82 行 ：创建<strong>类增强插件定义</strong>( <a href="https://github.com/OpenSkywalking/skywalking/blob/b16d23c1484bec941367d6b36fa932b8ace40971/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/AbstractClassEnhancePluginDefine.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.AbstractClassEnhancePluginDefine</code></a> )对象数组。不同插件通过实现 AbstractClassEnhancePluginDefine <strong>抽象类</strong>，定义不同框架的<strong>切面</strong>，<strong>记录调用链路</strong>。在本文 <a href="#">「2.4 AbstractClassEnhancePluginDefine」</a> 简单解析。</li></ul><h2 id="2-1-AgentClassLoader"><a href="#2-1-AgentClassLoader" class="headerlink" title="2.1 AgentClassLoader"></a>2.1 AgentClassLoader</h2><p><code>org.skywalking.apm.agent.core.plugin.loader.AgentClassLoader</code> ，继承 <code>java.lang.ClassLoader</code> ，Agent 类加载器。</p><p><strong>为什么实现自定义的 ClassLoader</strong> ？应用<strong>透明</strong>接入 SkyWalking ，不会<strong>显示</strong>导入 SkyWalking 的插件依赖。通过实现自定义的 ClassLoader ，从插件 Jar 中查找相关类。例如说，从 <code>apm-dubbo-plugin-3.2.6-2017.jar</code> 查找 <code>org.skywalking.apm.plugin.dubbo.DubboInstrumentation</code> 。</p><hr><p>AgentClassLoader <strong>构造方法</strong>，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AgentClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * The default class loader for the agent.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AgentClassLoader DEFAULT_LOADER;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * classpath</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> List&lt;File&gt; classpath;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Jar 数组</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> List&lt;Jar&gt; allJars;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Jar 读取时的锁</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> ReentrantLock jarScanLock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AgentClassLoader</span><span class="params">(ClassLoader parent)</span> <span class="keyword">throws</span> AgentPackageNotFoundException </span>&#123;</div><div class="line">        <span class="keyword">super</span>(parent);</div><div class="line">        File agentDictionary = AgentPackagePath.getPath();</div><div class="line">        classpath = <span class="keyword">new</span> LinkedList&lt;File&gt;();</div><div class="line">        classpath.add(<span class="keyword">new</span> File(agentDictionary, <span class="string">"plugins"</span>));</div><div class="line">        classpath.add(<span class="keyword">new</span> File(agentDictionary, <span class="string">"activations"</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>DEFAULT_LOADER</code> <strong>静态</strong>属性，默认单例。通过 <a href="https://github.com/YunaiV/skywalking/blob/3de8a6c15d07aa3b2c3b4e732e6654fc87c4e70e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/loader/AgentClassLoader.java#L56" rel="external nofollow noopener noreferrer" target="_blank"><code>#getDefault()</code></a> 方法，可以获取到它。</li><li><code>classpath</code> 属性，Java 类所在的目录。在构造方法中，我们可以看到 <code>${AGENT_PACKAGE_PATH}/plugins</code> / <code>${AGENT_PACKAGE_PATH}/activations</code> 添加到 <code>classpath</code> 。在 <a href="https://github.com/YunaiV/skywalking/blob/3de8a6c15d07aa3b2c3b4e732e6654fc87c4e70e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/loader/AgentClassLoader.java#L163" rel="external nofollow noopener noreferrer" target="_blank"><code>#getAllJars()</code></a>  方法中，加载该目录下的 Jar 中的 Class 文件。</li><li><code>allJars</code> 属性，Jar 数组。</li><li><code>jarScanLock</code> 属性，Jar 读取时的<strong>锁</strong>。</li></ul><hr><p><code>#initDefaultLoader()</code> <strong>静态</strong>方法，初始化<strong>默认</strong>的 AgentClassLoader ，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AgentClassLoader <span class="title">initDefaultLoader</span><span class="params">()</span> <span class="keyword">throws</span> AgentPackageNotFoundException </span>&#123;</div><div class="line">    DEFAULT_LOADER = <span class="keyword">new</span> AgentClassLoader(PluginBootstrap.class.getClassLoader());</div><div class="line">    <span class="keyword">return</span> getDefault();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>使用 <code>org.skywalking.apm.agent.core.plugin.PluginBootstrap</code> 的类加载器作为 AgentClassLoader 的<strong>父类加载器</strong>。</li></ul><hr><p>如下方法已经添加相关中文注释，胖友请自行阅读理解 ：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/778093d38a0a820b90092c2ed77a08e3393169eb/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/loader/AgentClassLoader.java#L132" rel="external nofollow noopener noreferrer" target="_blank"><code>#findResource(name)</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/778093d38a0a820b90092c2ed77a08e3393169eb/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/loader/AgentClassLoader.java#L150" rel="external nofollow noopener noreferrer" target="_blank"><code>#findResources(String name)</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/778093d38a0a820b90092c2ed77a08e3393169eb/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/loader/AgentClassLoader.java#L182" rel="external nofollow noopener noreferrer" target="_blank"><code>#getAllJars()</code></a></li></ul><p>在 ClassLoader 加载资源( 例如，类 )，会调用 <code>#findResource(name)</code> / <code>#findResources(name)</code> 方法。</p><h2 id="2-2-PluginResourcesResolver"><a href="#2-2-PluginResourcesResolver" class="headerlink" title="2.2 PluginResourcesResolver"></a>2.2 PluginResourcesResolver</h2><p><code>org.skywalking.apm.agent.core.plugin.PluginResourcesResolver</code> ，插件资源解析器，读取所有插件的定义文件。插件定义文件必须以 <code>skywalking-plugin.def</code> <strong>命名</strong>，例如 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/02.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/d4a6ba291419ab90379a3d1c423b747f682f857f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginResourcesResolver.java#L45" rel="external nofollow noopener noreferrer" target="_blank"><code>#getResources()</code></a> 方法，获得插件定义路径数组，代码如下 ：</p><ul><li>第 50 行 ：使用 AgentClassLoader 获得所有 <code>skywalking-plugin.def</code> 的路径。</li></ul><h2 id="2-3-PluginCfg"><a href="#2-3-PluginCfg" class="headerlink" title="2.3 PluginCfg"></a>2.3 PluginCfg</h2><p><code>org.skywalking.apm.agent.core.plugin.PluginCfg</code> ，插件定义配置，读取 <code>skywalking-plugin.def</code> 文件，生成插件定义( <a href="https://github.com/YunaiV/skywalking/blob/43241fff19e17f19b918c96ffd588787f8f05519/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginDefine.java#L27" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.PluginDefinie</code></a> )数组。</p><p><a href="https://github.com/YunaiV/skywalking/blob/43241fff19e17f19b918c96ffd588787f8f05519/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginCfg.java#L55" rel="external nofollow noopener noreferrer" target="_blank"><code>#load(InputStream)</code></a> 方法，读取 <code>skywalking-plugin.def</code> 文件，添加到 <code>pluginClassList</code> 。如下是 <code>apm-springmvc-annotation-4.x-plugin-3.2.6-2017.jar</code> 插件的定义文件 ：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">spring-mvc-annotation-4.x=org.skywalking.apm.plugin.spring.mvc.v4.define.ControllerInstrumentation</div><div class="line">spring-mvc-annotation-4.x=org.skywalking.apm.plugin.spring.mvc.v4.define.RestControllerInstrumentation</div><div class="line">spring-mvc-annotation-4.x=org.skywalking.apm.plugin.spring.mvc.v4.define.HandlerMethodInstrumentation</div><div class="line">spring-mvc-annotation-4.x=org.skywalking.apm.plugin.spring.mvc.v4.define.InvocableHandlerInstrumentation</div></pre></td></tr></table></figure><h2 id="2-4-AbstractClassEnhancePluginDefine"><a href="#2-4-AbstractClassEnhancePluginDefine" class="headerlink" title="2.4 AbstractClassEnhancePluginDefine"></a>2.4 AbstractClassEnhancePluginDefine</h2><p><code>org.skywalking.apm.agent.core.plugin.AbstractClassEnhancePluginDefine</code> ，类增强插件定义<strong>抽象基类</strong>。不同插件通过实现 AbstractClassEnhancePluginDefine <strong>抽象类</strong>，定义不同框架的<strong>切面</strong>，<strong>记录调用链路</strong>。以 Spring 插件为例子，如下是相关类图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_05/06.png" alt=""></p><p>PluginDefine 对象的 <code>defineClass</code> 属性，即对应不同插件对AbstractClassEnhancePluginDefine 的<strong>实现类</strong>。所以在 <a href="https://github.com/YunaiV/skywalking/blob/130f0a5a3438663b393e53ba2cca02a8d13c258a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginBootstrap.java#L45" rel="external nofollow noopener noreferrer" target="_blank"><code>PluginBootstrap#loadPlugins()</code></a> 方法的【<strong>第 74 行</strong>】，我们看到通过该属性，创建创建<strong>类增强插件定义</strong>对象。</p><h2 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h2><p>胖友，回过头，在看一下流程图，理解理解。</p><h1 id="3-插件的匹配"><a href="#3-插件的匹配" class="headerlink" title="3. 插件的匹配"></a>3. 插件的匹配</h1><p>在 <a href="http://www.iocoder.cn/SkyWalking/agent-init/?self">《SkyWalking 源码分析 —— Agent 初始化》</a> 一文，我们提到，SkyWalking Agent 基于 <strong>JavaAgent</strong> 机制，实现应用<strong>透明</strong>接入 SkyWalking 。下面笔者默认胖友已经对 JavaAgent 机制已经有一定的了解。如果胖友暂时不了解，建议先阅读如下文章 ：</p><ul><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html" rel="external nofollow noopener noreferrer" target="_blank">《Instrumentation 新功能》</a></li><li><a href="http://www.infoq.com/cn/articles/javaagent-illustrated" rel="external nofollow noopener noreferrer" target="_blank">《JVM源码分析之javaagent原理完全解读》</a></li></ul><blockquote><p>友情提示 ：建议自己手撸一个简单的 JavaAgent ，更容易理解 SkyWalking Agent 。 </p><p>笔者练手的 JavaAgent 项目地址 ：<a href="https://github.com/YunaiV/learning/tree/master/javaagent01" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/YunaiV/learning/tree/master/javaagent01</a></p></blockquote><p>通过 JavaAgent 机制，我们可以在 <code>#premain(String, Instrumentation)</code> 方法里，调用 <code>Instrumentation#addTransformer(ClassFileTransformer)</code> 方法，向 Instrumentation 注册 <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/instrument/ClassFileTransformer.html" rel="external nofollow noopener noreferrer" target="_blank"><code>java.lang.instrument.ClassFileTransformer</code></a> 对象，可以修改 Java 类的二进制，从而<strong>动态</strong>修改 Java 类的代码实现。</p><p>如果胖友使用过 AOP 实现切面记录日志，那么就很容易理解，SkyWalking 通过这样的方式，使用不同框架定义<strong>方法切面</strong>，从而在在切面<strong>记录调用链路</strong>。</p><hr><p>直接修改 Java 类的二进制，是非常繁杂的。因此，SkyWalking 引入了 <a href="https://github.com/raphw/byte-buddy" rel="external nofollow noopener noreferrer" target="_blank"><code>byte-buddy</code></a> 。</p><blockquote><p><code>byte-buddy</code> 是一个代码生成和操作库，用于在 Java 应用程序<br>运行时创建和修改 Java 类，而徐无需编译器的帮助。</p><p>除了参与 Java 类库一起提供代码生成工具外，<code>byte-buddy</code> 允许创建任意类，并不限于实现用于创建运行时代理的接口。  </p><p>此外，<code>byte-buddy</code> 提供了一个方便的 API ，用于 Java Agent 或在构建过程中更改类。</p></blockquote><p>下面笔者默认胖友已经对 <code>byte-buddy</code> 有一定的了解。如果胖友暂不了解，建议先阅读如下文章 ：</p><ul><li><a href="http://www.jianshu.com/p/fe1448bf7d31" rel="external nofollow noopener noreferrer" target="_blank">《Java字节码3-使用ByteBuddy实现一个Java-Agent》</a></li><li><a href="https://notes.diguage.com/byte-buddy-tutorial/" rel="external nofollow noopener noreferrer" target="_blank">《Byte Buddy 教程》</a></li><li><a href="https://www.infoq.com/articles/Easily-Create-Java-Agents-with-ByteBuddy" rel="external nofollow noopener noreferrer" target="_blank">《Easily Create Java Agents with Byte Buddy》</a></li><li><a href="http://www.kailing.pub/article/index/arcid/178.html" rel="external nofollow noopener noreferrer" target="_blank">《skywalking源码分析之javaAgent工具ByteBuddy的应用》</a> 搜索 “BYTE BUDDY应用” 部分</li></ul><blockquote><p>友情提示 ：建议自己简单使用下 <code>byte-buddy</code> ，更容易理解 SkyWalking Agent 。 </p><p>笔者练手的 <code>byte-buddy</code> 项目地址 ：<a href="https://github.com/YunaiV/learning/tree/master/bytebuddy" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/YunaiV/learning/tree/master/bytebuddy</a></p></blockquote><hr><p>下面，让我们打开 <a href="https://github.com/YunaiV/skywalking/blob/b68162306b4db7adfd4a2c2891a205b7085f38f0/apm-sniffer/apm-agent/src/main/java/org/skywalking/apm/agent/SkyWalkingAgent.java#L79" rel="external nofollow noopener noreferrer" target="_blank"><code>SkyWalkingAgent#premain(String, Instrumentation)</code></a> 方法，从【第 79 行】代码开始看 ：</p><ul><li>第 79 至 104 行 ：创建 <a href="https://github.com/raphw/byte-buddy/blob/188366ace6e16ec167a00b144c9048d78495165f/byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java" rel="external nofollow noopener noreferrer" target="_blank"><code>net.bytebuddy.agent.builder.AgentBuilder</code></a> 对象，并设置相关属性。<ul><li>AgentBuilder ，提供便利的 API ，创建 Java Agent 。</li><li>第 79 行 ：调用 <code>AgentBuilder#type(ElementMatcher)</code> 方法，实现 <a href="https://github.com/raphw/byte-buddy/blob/188366ace6e16ec167a00b144c9048d78495165f/byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ElementMatcher.java#L13" rel="external nofollow noopener noreferrer" target="_blank"><code>net.bytebuddy.matcher.ElementMatcher</code></a> 接口，设置需要拦截的类。<code>PluginFinder#buildMatch()</code> 方法，在本文 <a href="#">「3.3 PluginFinder」</a> 详细解析。</li><li>第 79 至 104 行 ：调用 <code>AgentBuilder#transform(Transformer)</code> 方法，设置 Java 类的修改逻辑。<ul><li>第 84 行 ：调用 <code>PluginFinder#find(TypeDescription, ClassLoader)</code> 方法，获得<strong>匹配</strong>的 AbstractClassEnhancePluginDefine 数组。因为在【<strong>第 79 行</strong>】的代码，设置了<strong>所有</strong>插件需要拦截的类，所以此处需要匹配<strong>该类对应</strong>的 AbstractClassEnhancePluginDefine 数组。<code>PluginFinder#find(TypeDescription, ClassLoader)</code> 方法，在本文 <a href="#">「3.3 PluginFinder」</a> 详细解析。</li><li>第 85 行 ：判断匹配的 AbstractClassEnhancePluginDefine 数组大于零。从目前的代码看下来，此处属于<strong>防御性编程</strong>，在【<strong>第 79 行</strong>】的代码保证一定能匹配到 AbstractClassEnhancePluginDefine 。</li><li>第 86 至 100 行 ：循环匹配到 AbstractClassEnhancePluginDefine 数组，调用 <code>AbstractClassEnhancePluginDefine#define(...)</code> 方法，设置 <a href="https://github.com/raphw/byte-buddy/blob/188366ace6e16ec167a00b144c9048d78495165f/byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java" rel="external nofollow noopener noreferrer" target="_blank"><code>net.bytebuddy.dynamic.DynamicType.Builder</code></a> 对象。通过该对象，定义<strong>如何拦截</strong>需要修改的 Java 类。在 <code>AbstractClassEnhancePluginDefine#define(...)</code> 方法的内部，会调用 <a href="https://github.com/raphw/byte-buddy/blob/188366ace6e16ec167a00b144c9048d78495165f/byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java#L1512" rel="external nofollow noopener noreferrer" target="_blank"><code>net.bytebuddy.dynamic.DynamicType.ImplementationDefinition#intercept(Implementation)</code></a> 方法，本文 <a href="#">「4. 插件的拦截」</a> 也会详细解析。</li><li>第 91 行 ：为什么会出现返回为<strong>空</strong>的情况呢？同一个框架在不同的<strong>大</strong>版本，使用的方式相同，但是实现的代码却不尽相同。举个例子，SpringMVC 3 和 SpringMVC 4 ，<strong>都</strong>有 <code>@RequestMapping</code> 注解定义 URL ，所以【<strong>第 84 行</strong>】会匹配到 <code>AbstractSpring3Instrumentation</code> / <code>AbstractSpring4Instrumentation</code> <strong>两个</strong>。当应用使用的是 Spring MVC 4 时，调用 <code>AbstractSpring3Instrumentation#define(...)</code> 方法会返回空，而调用 <code>AbstractSpring4Instrumentation#define(...)</code> 方法会有返回值。这是如何实现的呢？本文 <a href="#">「4. 插件的拦截」</a> 也会详细解析。</li></ul></li></ul></li><li>第 105 至 134 行 ：调用 <a href="https://github.com/raphw/byte-buddy/blob/188366ace6e16ec167a00b144c9048d78495165f/byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java#L114" rel="external nofollow noopener noreferrer" target="_blank"><code>AgentBuilder#with(Listener)</code></a> 方法，添加监听器。<ul><li><code>#onTransformation(...)</code> 方法，当 Java 类的修改<strong>成功</strong>，进行调用。</li><li><code>#onError(...)</code> 方法，当 Java 类的修改<strong>失败</strong>，进行调用。InstrumentDebuggingClass 在本文 <a href="#">「3.1 InstrumentDebuggingClass」</a> 详细解析。</li></ul></li><li>第 135 行 ：调用 <a href="https://github.com/raphw/byte-buddy/blob/master/byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java#L620" rel="external nofollow noopener noreferrer" target="_blank"><code>AgentBuilder#installOn(Instrumentation)</code></a> 方法，根据<strong>上面</strong> AgentBuilder 设置的属性，创建 <a href="https://github.com/raphw/byte-buddy/blob/188366ace6e16ec167a00b144c9048d78495165f/byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/ResettableClassFileTransformer.java" rel="external nofollow noopener noreferrer" target="_blank"><code>net.bytebuddy.agent.builder.ResettableClassFileTransformer</code></a> 对象，配置到 Instrumentation 对象上。在 <code>AgentBuilder#installOn(Instrumentation)</code> 方法的内部，会调用 <code>Instrumentation#addTransformer(ClassFileTransformer)</code> 方法。</li></ul><hr><p>😈 这个方法信息量比较大，笔者对 <code>byte-buddy</code> 不是很熟悉，花费了较多时间梳理与理解。建议，如果胖友此处不是理解的很清晰，可以阅读完全文，在回过头再捋一捋这块的代码实现。</p><h2 id="3-1-InstrumentDebuggingClass"><a href="#3-1-InstrumentDebuggingClass" class="headerlink" title="3.1 InstrumentDebuggingClass"></a>3.1 InstrumentDebuggingClass</h2><p><code>org.skywalking.apm.agent.InstrumentDebuggingClass</code> ，Instrument 调试类，用于将被 JavaAgent 修改的<strong>所有</strong>类存储到 <code>${JAVA_AGENT_PACKAGE}/debugger</code> 目录下。需要配置 <code>agent.is_open_debugging_class = true</code> ，效果如下图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/04.png" alt=""></p><p>代码比较简单，胖友点击 <a href="https://github.com/YunaiV/skywalking/blob/b68162306b4db7adfd4a2c2891a205b7085f38f0/apm-sniffer/apm-agent/src/main/java/org/skywalking/apm/agent/InstrumentDebuggingClass.java" rel="external nofollow noopener noreferrer" target="_blank">InstrumentDebuggingClass</a> 理解。</p><h2 id="3-2-ClassMatch"><a href="#3-2-ClassMatch" class="headerlink" title="3.2 ClassMatch"></a>3.2 ClassMatch</h2><p>在分享本节相关内容之前，我们先来看下 <code>bytebuddy</code> 的 <a href="https://github.com/raphw/byte-buddy/tree/188366ace6e16ec167a00b144c9048d78495165f/byte-buddy-dep/src/main/java/net/bytebuddy/matcher" rel="external nofollow noopener noreferrer" target="_blank"><code>net.bytebuddy.matcher</code></a> 模块。该模块提供了各种灵活的匹配方法。那么 SkyWalking 为什么实现自己的 <a href="https://github.com/YunaiV/skywalking/tree/43241fff19e17f19b918c96ffd588787f8f05519/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/match" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.match</code></a> 模块？笔者认为，仅定位于<strong>类级别的匹配</strong>，更常用而又精简的 API 。</p><hr><p><code>org.skywalking.apm.agent.core.plugin.match.ClassMatch</code> ，类匹配<strong>接口</strong>。目前子类如下 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/05.png" alt=""></p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/b68162306b4db7adfd4a2c2891a205b7085f38f0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/match/NameMatch.java#L28" rel="external nofollow noopener noreferrer" target="_blank">NameMatch</a> ：基于<strong>完整的类名</strong>进行匹配，例如：<code>&quot;com.alibaba.dubbo.monitor.support.MonitorFilter&quot;</code> 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/b68162306b4db7adfd4a2c2891a205b7085f38f0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/match/IndirectMatch.java" rel="external nofollow noopener noreferrer" target="_blank">IndirectMatch</a> ：<strong>间接</strong>匹配<strong>接口</strong>。相比 NameMatch 来说，确实比较 “委婉” 🙂 。<ul><li><a href="https://github.com/YunaiV/skywalking/blob/b68162306b4db7adfd4a2c2891a205b7085f38f0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/match/ClassAnnotationMatch.java" rel="external nofollow noopener noreferrer" target="_blank">ClassAnnotationMatch</a> ：基于<strong>类注解</strong>进行匹配，可设置<strong>同时</strong>匹配多个。例如：<code>&quot;@RequestMapping&quot;</code>。</li><li><a href="https://github.com/YunaiV/skywalking/blob/b68162306b4db7adfd4a2c2891a205b7085f38f0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/match/HierarchyMatch.java" rel="external nofollow noopener noreferrer" target="_blank">HierarchyMatch</a> ：基于<strong>父类 / 接口</strong>进行匹配，可设置<strong>同时</strong>匹配多个。</li><li><a href="https://github.com/YunaiV/skywalking/blob/b68162306b4db7adfd4a2c2891a205b7085f38f0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/match/MethodAnnotationMatch.java" rel="external nofollow noopener noreferrer" target="_blank">MethodAnnotationMatch</a> ：基于<strong>方法注解</strong>进行匹配，可设置<strong>同时</strong>匹配多个。目前项目里主要用于匹配方法上的  <a href="https://github.com/OpenSkywalking/skywalking/blob/8d9820322bdfc956d9d4f0d04f55ce985926cfae/apm-application-toolkit/apm-toolkit-trace/src/main/java/org/apache/skywalking/apm/toolkit/trace/Trace.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.toolkit.trace.@Trace</code></a> 注解。</li></ul></li></ul><p>每个类已经添加详细的代码注释，胖友喜欢哪个点哪个哟。</p><h2 id="3-3-PluginFinder"><a href="#3-3-PluginFinder" class="headerlink" title="3.3 PluginFinder"></a>3.3 PluginFinder</h2><p><code>org.skywalking.apm.agent.core.plugin.PluginFinder</code> ，插件发现者。其提供 <a href="https://github.com/YunaiV/skywalking/blob/09c654af33081e56547cb8b3b9e0c8525ddce32f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginFinder.java#L80" rel="external nofollow noopener noreferrer" target="_blank"><code>#find(...)</code></a> 方法，获得<strong>类增强插件定义</strong>( <a href="https://github.com/OpenSkywalking/skywalking/blob/b16d23c1484bec941367d6b36fa932b8ace40971/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/AbstractClassEnhancePluginDefine.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.AbstractClassEnhancePluginDefine</code></a> )对象。</p><p>PluginFinder <strong><a href="https://github.com/YunaiV/skywalking/blob/09c654af33081e56547cb8b3b9e0c8525ddce32f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginFinder.java#L56" rel="external nofollow noopener noreferrer" target="_blank">构造方法</a></strong>，代码如下 ：</p><ul><li>第 57 至 77 行 ：循环 AbstractClassEnhancePluginDefine 对象数组，添加到 <code>nameMatchDefine</code> / <code>signatureMatchDefine</code> 属性，方便 <code>#find(...)</code> 方法查找 AbstractClassEnhancePluginDefine 对象。<ul><li>第 65 至 72 行 ：处理 NameMatch 为匹配的 AbstractClassEnhancePluginDefine 对象，添加到 <code>nameMatchDefine</code>  属性。</li><li>第 74 至 76 行 ：处理<strong>非</strong> NameMatch 为匹配的 AbstractClassEnhancePluginDefine 对象，添加到 <code>signatureMatchDefine</code> 属性。</li></ul></li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/b68162306b4db7adfd4a2c2891a205b7085f38f0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginFinder.java#L89" rel="external nofollow noopener noreferrer" target="_blank"><code>#find(...)</code></a> 方法，获得<strong>类增强插件定义</strong>( <a href="https://github.com/OpenSkywalking/skywalking/blob/b16d23c1484bec941367d6b36fa932b8ace40971/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/AbstractClassEnhancePluginDefine.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.AbstractClassEnhancePluginDefine</code></a> )对象，代码如下 ：</p><ul><li>第 92 至 96 行 ：以 <code>nameMatchDefine</code> 属性来匹配 AbstractClassEnhancePluginDefine 对象。</li><li>第 98 至 104 行 ：以 <code>signatureMatchDefine</code> 属性来匹配 AbstractClassEnhancePluginDefine 对象。在这个过程中，会调用 <code>IndirectMatch#isMatch(TypeDescription)</code> 方法，进行匹配。</li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/b68162306b4db7adfd4a2c2891a205b7085f38f0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginFinder.java#L116" rel="external nofollow noopener noreferrer" target="_blank"><code>#buildMatch()</code></a> 方法，获得全部插件的类匹配，多个插件的类匹配条件以 <code>or</code> 分隔，代码如下 ：</p><ul><li>第 117 至 123 行 ：以 <code>nameMatchDefine</code> 属性来匹配。</li><li>第 124 至 132 行 ：以 <code>signatureMatchDefine</code> 属性来匹配。</li><li><strong>实际上，该方法和 <code>#find(...)</code> 方法逻辑是一致的</strong>。</li></ul><h1 id="4-插件的拦截"><a href="#4-插件的拦截" class="headerlink" title="4. 插件的拦截"></a>4. 插件的拦截</h1><p>在上文中，我们已经提到，SkyWalking 通过 JavaAgent 机制，对需要拦截的类的方法，使用 <code>byte-buddy</code> <strong>动态</strong>修改 Java 类的二进制，从而进行方法切面拦截，记录调用链路。</p><p>看具体的代码实现之前，想一下<strong>拦截</strong>会涉及到哪些元素 ：</p><ul><li>拦截切面 InterceptPoint</li><li>拦截器 Interceptor</li><li>拦截类的定义 Define ：一个类有哪些拦截切面及对应的拦截器</li></ul><p>下面，我们来看看本小节会涉及到的类。如图所示：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/06.png" alt=""></p><p>看起来类比想象的多？梳理之，结果如图 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/07.png" alt=""></p><ul><li>根据方法类型的不同，使用不同 ClassEnhancePluginDefine 的实现类。其中，构造方法和静态方法使用相同的实现类。</li><li><p>相比上面提到<strong>拦截</strong>会涉及到的元素，多了一个 <strong>Inter</strong> ？如下是官方的说明 ：</p><blockquote><p>In this class, it provide a bridge between <code>byte-buddy</code> and <code>sky-walking</code> plugin.</p></blockquote></li></ul><h2 id="4-1-ClassEnhancePluginDefine"><a href="#4-1-ClassEnhancePluginDefine" class="headerlink" title="4.1 ClassEnhancePluginDefine"></a>4.1 ClassEnhancePluginDefine</h2><p>整体类图如下：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/08.png" alt=""></p><ul><li>AbstractClassEnhancePluginDefine ：SkyWalking 类增强插件定义<strong>抽象基类</strong>。</li><li>ClassEnhancePluginDefine ：SkyWalking 类增强插件定义<strong>抽象类</strong>。</li><li>从 UML 图中的方法，我们可以看出，AbstractClassEnhancePluginDefine 注重在<strong>定义</strong>( Define )，ClassEnhancePluginDefine 注重在<strong>增强</strong>( Enhance )。</li></ul><p>整体流程如下 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/09.png" alt=""></p><p>OK ，下面我们开始看看代码是如何实现的。</p><h3 id="4-1-1-AbstractClassEnhancePluginDefine"><a href="#4-1-1-AbstractClassEnhancePluginDefine" class="headerlink" title="4.1.1 AbstractClassEnhancePluginDefine"></a>4.1.1 AbstractClassEnhancePluginDefine</h3><p><code>org.skywalking.apm.agent.core.plugin.AbstractClassEnhancePluginDefine</code> ，SkyWalking 类增强插件定义<strong>抽象基类</strong>。它注重在<strong>定义</strong>( Define )的抽象与实现。</p><p><a href="https://github.com/YunaiV/skywalking/blob/30683167c79c71ad088666c587a05c6d9f0daf3f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/AbstractClassEnhancePluginDefine.java#L93" rel="external nofollow noopener noreferrer" target="_blank"><code>#enhanceClass()</code></a> <strong>抽象</strong>方法，定义了类匹配( ClassMatch ) 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/30683167c79c71ad088666c587a05c6d9f0daf3f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/AbstractClassEnhancePluginDefine.java#L105" rel="external nofollow noopener noreferrer" target="_blank"><code>#witnessClasses()</code></a> 方法，见证类列表。当且仅当应用存在见证类列表，插件才生效。<strong>什么意思</strong>？让我们看看这种情况：一个<strong>类库</strong>存在两个发布的版本( 如 <code>1.0</code> 和 <code>2.0</code> )，其中包括<strong>相同</strong>的目标类，但不同的方法或不同的方法参数列表。所以我们需要根据库的不同版本使用插件的不同版本。然而版本显然不是一个选项，这时需要使用见证类列表，判断出当前引用类库的发布版本。</p><ul><li>举个实际的例子，SpringMVC 3 和 SpringMVC 4 ，<strong>都</strong>有 <code>@RequestMapping</code> 注解定义 URL 。<ul><li>通过判断存在 <code>org.springframework.web.servlet.view.xslt.AbstractXsltView</code> 类，应用使用 SpringMVC 3 ，使用 <code>apm-springmvc-annotation-3.x-plugin.jar</code> 。</li><li>通过判断存在 <code>org.springframework.web.servlet.tags.ArgumentTag</code> 类，应用使用 SpringMVC 4 ，使用 <code>apm-springmvc-annotation-4.x-plugin.jar</code> 。</li></ul></li><li><strong>另外</strong>，该方法返回<strong>空数组</strong>。即默认情况，插件生效，无需见证类列表。</li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/30683167c79c71ad088666c587a05c6d9f0daf3f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/AbstractClassEnhancePluginDefine.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#define(...)</code></a> 方法，设置 <a href="https://github.com/raphw/byte-buddy/blob/188366ace6e16ec167a00b144c9048d78495165f/byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java" rel="external nofollow noopener noreferrer" target="_blank"><code>net.bytebuddy.dynamic.DynamicType.Builder</code></a> 对象。通过该对象，定义<strong>如何拦截</strong>需要修改的目标 Java 类(方法的 <code>transformClassName</code> 参数)。代码如下 ：</p><ul><li>第 57 至 70 行 ：判断见证类列表是否都存在。若不存在，则插件不生效。<ul><li><a href="https://github.com/YunaiV/skywalking/blob/30683167c79c71ad088666c587a05c6d9f0daf3f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/WitnessClassFinder.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.WitnessClassFinder</code></a> ，已经添加完整注释，胖友点击查看。</li></ul></li><li>第 72 至 76 行 ：调用 <code>#enhance(...)</code> <strong>抽象</strong>方法，使用拦截器增强目标类。</li></ul><h3 id="4-1-2-ClassEnhancePluginDefine"><a href="#4-1-2-ClassEnhancePluginDefine" class="headerlink" title="4.1.2 ClassEnhancePluginDefine"></a>4.1.2 ClassEnhancePluginDefine</h3><p><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.ClassEnhancePluginDefine</code> ，SkyWalking 类增强插件定义<strong>抽象类</strong>。它注重在<strong>增强</strong>( Enhance )的抽象与实现。包括如下 ：</p><ul><li>静态方法、构造方法、实例方法的<strong>增强</strong></li><li>静态方法、构造方法、实例方法的<strong>拦截切面</strong></li></ul><hr><p>拦截切面，在 <a href="#">「4.2 InterceptPoint」</a> 有相关解析。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/ClassEnhancePluginDefine.java#L248" rel="external nofollow noopener noreferrer" target="_blank"><code>#getStaticMethodsInterceptPoints()</code></a> <strong>抽象</strong>方法，获得 StaticMethodsInterceptPoint <strong>数组</strong>。<br><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/ClassEnhancePluginDefine.java#L185" rel="external nofollow noopener noreferrer" target="_blank"><code>#getConstructorsInterceptPoints()</code></a> <strong>抽象</strong>方法，获得 ConstructorInterceptPoint <strong>数组</strong>。<br><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/ClassEnhancePluginDefine.java#L192" rel="external nofollow noopener noreferrer" target="_blank"><code>#getInstanceMethodsInterceptPoints()</code></a> <strong>抽象</strong>方法，获得 InstanceMethodsInterceptPoint <strong>数组</strong>。</p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/ClassEnhancePluginDefine.java#L67" rel="external nofollow noopener noreferrer" target="_blank"><code>#enhance(...)</code></a> 方法，增强静态方法、构造方法、实例方法。</p><h4 id="4-1-2-1-增强静态方法"><a href="#4-1-2-1-增强静态方法" class="headerlink" title="4.1.2.1 增强静态方法"></a>4.1.2.1 增强静态方法</h4><p>调用 <a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/ClassEnhancePluginDefine.java#L203" rel="external nofollow noopener noreferrer" target="_blank"><code>#enhanceClass(...)</code></a> 方法，增强静态方法，代码如下 ：</p><ul><li>第 206 至 210 行 ：调用 <code>#getStaticMethodsInterceptPoints()</code> 方法，获得 StaticMethodsInterceptPoint 数组。若为<strong>空</strong>，不进行增强。</li><li>第 212 至 238 行 ：<strong>遍历</strong> StaticMethodsInterceptPoint 数组，逐个增强StaticMethodsInterceptPoint 对应的静态方法。<ul><li>第 214 至 218 行 ：获得拦截器的<strong>类名</strong>。拦截器的实例，在 <strong>Inter 类</strong>里获取。</li><li>第 221 至 229 行 ：当 <code>StaticMethodsInterceptPoint#isOverrideArgs()</code> 方法返回 <code>true</code> 时，使用 StaticMethodsInterWithOverrideArgs 处理拦截逻辑。在 <a href="#">「4.4.3 静态方法 Inter」</a> 详细解析。</li><li>第 230 至 236 行 ：当 <code>StaticMethodsInterceptPoint#isOverrideArgs()</code> 方法返回 <code>false</code> 时，使用 StaticMethodsInter 处理拦截逻辑，在 <a href="#">「4.4.3 静态方法 Inter」</a> 详细解析。</li></ul></li></ul><h4 id="4-1-2-2-增强构造方法和实例方法"><a href="#4-1-2-2-增强构造方法和实例方法" class="headerlink" title="4.1.2.2 增强构造方法和实例方法"></a>4.1.2.2 增强构造方法和实例方法</h4><p>调用 <a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/ClassEnhancePluginDefine.java#L89" rel="external nofollow noopener noreferrer" target="_blank"><code>#enhanceInstance()</code></a> 方法，增强构造方法和实例方法，代码如下 ：</p><ul><li>第 92 至 110 行 ：调用 <code>#getConstructorsInterceptPoints()</code> / <code>#getInstanceMethodsInterceptPoints()</code>  方法，获得 ConstructorInterceptPoint / InstanceMethodsInterceptPoint 数组。若<strong>都</strong>为<strong>空</strong>，不进行增强。</li><li>第 112 至 128 行 ：使用 <code>byte-buddy</code> ，为目标 Java 类<strong>“自动”</strong>实现 <a href="https://github.com/OpenSkywalking/skywalking/blob/15328202b8b7df89a609885d9110361ff29ce668/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/plugin/interceptor/enhance/EnhancedInstance.java#L25" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.EnhancedInstance</code></a> 接口。这样，目标 Java 类就有一个私有变量，拦截器在执行过程中，可以存储状态到该私有变量。这里如果暂时不理解<strong>没关系</strong>，后面分享每个插件的实现时，会有实际的例子，更易懂。</li><li>———- 构造方法 ———-</li><li>第 130 至 143 行 ：<strong>遍历</strong> ConstructorInterceptPoint 数组，逐个增强 ConstructorInterceptPoint 对应的构造方法。使用 ConstructorInter 处理拦截逻辑，在 <a href="#">「4.4.1 构造方法 Inter」</a> 详细解析。</li><li>———- 实例方法 ———-</li><li>第 145 至 175 行 ：<strong>遍历</strong> InstanceMethodsInterceptPoint 数组，逐个增强 InstanceMethodsInterceptPoint 对应的静态方法。<ul><li>第 151 至 154 行 ：获得拦截器的<strong>类名</strong>。拦截器的实例，在 <strong>Inter 类</strong>里获取。</li><li>第 156 至 165 行 ：当 <code>InstanceMethodsInterceptPoint#isOverrideArgs()</code> 方法返回 <code>true</code> 时，使用 InstMethodsInterWithOverrideArgs 处理拦截逻辑。在 <a href="#">「4.4.2 实例方法 Inter」</a> 详细解析。</li><li>第 166 至 173 行 ：当 <code>InstanceMethodsInterceptPoint#isOverrideArgs()</code> 方法返回 <code>false</code> 时，使用 InstMethodsInter 处理拦截逻辑，在 <a href="#">「4.4.2 实例方法 Inter」</a> 详细解析。</li></ul></li></ul><h3 id="4-1-3-ClassStaticMethodsEnhancePluginDefine"><a href="#4-1-3-ClassStaticMethodsEnhancePluginDefine" class="headerlink" title="4.1.3 ClassStaticMethodsEnhancePluginDefine"></a>4.1.3 ClassStaticMethodsEnhancePluginDefine</h3><p><a href="https://github.com/YunaiV/skywalking/blob/c7c800bba485dcb9d532d6cb5686df273ae53d6d/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/ClassStaticMethodsEnhancePluginDefine.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.ClassStaticMethodsEnhancePluginDefine</code></a> ，类<strong>增强静态方法</strong>的插件定义<strong>抽象类</strong>，和本文 <a href="#">「4.1.2.1 增强静态方法」</a> 对应。</p><p>实现 <code>#getConstructorsInterceptPoints()</code> / <code>#getInstanceMethodsInterceptPoints()</code> <strong>抽象</strong>方法，返回空，表示不增强构造方法和实例方法。<strong>即只增强静态方法</strong>。</p><h3 id="4-1-4-ClassInstanceMethodsEnhancePluginDefine"><a href="#4-1-4-ClassInstanceMethodsEnhancePluginDefine" class="headerlink" title="4.1.4 ClassInstanceMethodsEnhancePluginDefine"></a>4.1.4 ClassInstanceMethodsEnhancePluginDefine</h3><p><a href="https://github.com/YunaiV/skywalking/blob/c7c800bba485dcb9d532d6cb5686df273ae53d6d/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/ClassInstanceMethodsEnhancePluginDefine.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.ClassInstanceMethodsEnhancePluginDefine</code></a> ，类<strong>增强构造方法和实例方法</strong>的插件定义<strong>抽象类</strong>，和本文 <a href="#">「4.1.2.2 增强构造方法和实例方法」</a> 对应。</p><p>实现 <code>#getStaticMethodsInterceptPoints()</code> <strong>抽象</strong>方法，返回空，表示不增强静态方法。<strong>即只增强构造方法和实例方法</strong>。</p><h2 id="4-2-InterceptPoint"><a href="#4-2-InterceptPoint" class="headerlink" title="4.2 InterceptPoint"></a>4.2 InterceptPoint</h2><table><thead><tr><th>InterceptPoint</th><th>方法类型</th><th>方法匹配</th><th>拦截器</th><th><code>#isOverrideArgs()</code></th></tr></thead><tbody><tr><td>StaticMethodsInterceptPoint</td><td>静态方法</td><td><code>#getMethodsMatcher()</code></td><td><code>#getMethodsInterceptor()</code></td><td>有</td></tr><tr><td>ConstructorInterceptPoint</td><td>构造方法</td><td><code>#getConstructorMatcher()</code></td><td><code>#getConstructorInterceptor()</code></td><td>无</td></tr><tr><td>InstanceMethodsInterceptPoint</td><td>实例方法</td><td><code>#getMethodsMatcher()</code></td><td><code>#getMethodsInterceptor()</code></td><td>有</td></tr></tbody></table><p>XXXInterceptPoint <strong>接口</strong>，对应一个 <code>net.bytebuddy.matcher.ElementMatcher</code>  和一个拦截器。</p><p>代码比较简单，胖友自己查看。</p><h2 id="4-3-Interceptor"><a href="#4-3-Interceptor" class="headerlink" title="4.3 Interceptor"></a>4.3 Interceptor</h2><p>在开始分享 <strong>Inter</strong> 之前，我们先来看看 Interceptor 相关接口。如下图所见：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/10.png" alt=""></p><ul><li>InstanceConstructorInterceptor ，构造方法拦截器<strong>接口</strong>。</li><li><em>AroundInterceptor</em><ul><li>StaticMethodsAroundInterceptor ，静态方法拦截器<strong>接口</strong>。</li><li>InstanceMethodsAroundInterceptor ，实例方法拦截器<strong>接口</strong>。</li><li>接口方法基本一致，下面 Inter 逻辑也基本一致。</li></ul></li></ul><p>在 <a href="#">「4. 2 InterceptPoint」</a> 里，我们看到 <code>#getXXXInterceptor()</code> 方法返回的拦截器类名，需要通过 <a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/loader/InterceptorInstanceLoader.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.loader.InterceptorInstanceLoader</code></a> 加载与创建拦截器实例。</p><h2 id="4-4-Inter"><a href="#4-4-Inter" class="headerlink" title="4.4 Inter"></a>4.4 Inter</h2><p>我们先来看 Inter 的定义 ：</p><blockquote><p>In this class, it provide a bridge between byte-buddy and sky-walking plugin.</p></blockquote><p>根据方法类型，将 Inter 整理如下 ：</p><table><thead><tr><th>方法类型</th><th></th><th></th></tr></thead><tbody><tr><td>构造方法</td><td>ConstructorInter</td><td></td></tr><tr><td>实例方法</td><td>InstMethodsInter</td><td>InstMethodsInterWithOverrideArgs</td></tr><tr><td>静态方法</td><td>StaticMethodsInter</td><td>StaticMethodsInterWithOverrideArgs</td></tr></tbody></table><h3 id="4-4-1-构造方法-Inter"><a href="#4-4-1-构造方法-Inter" class="headerlink" title="4.4.1 构造方法 Inter"></a>4.4.1 构造方法 Inter</h3><p><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/ConstructorInter.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.ConstructorInter</code></a> ，构造方法 Inter 。</p><p>ConstructorInter <a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/ConstructorInter.java#L52" rel="external nofollow noopener noreferrer" target="_blank"><strong>构造方法</strong></a>，调用 <code>InterceptorInstanceLoader#load(String, classLoader)</code> 方法，加载构造方法拦截器。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/ConstructorInter.java#L68" rel="external nofollow noopener noreferrer" target="_blank"><code>#intercept(Object)</code></a> 方法，<strong>在构造方法执行完成后进行拦截</strong>，调用 <code>InstanceConstructorInterceptor#onConstruct(...)</code> 方法。</p><p><strong>为什么没有 ConstructorInterWithOverrideArgs</strong>？<code>InstanceConstructorInterceptor#onConstruct(...)</code> 方法，是<strong>在构造方法执行完成后进行调用拦截</strong>，OverrideArgs 用于在调用方法之前，<strong>改变传入方法的参数</strong>。所以，在此处暂时没这块需要，因而没有 ConstructorInterWithOverrideArgs 。</p><h3 id="4-4-2-实例方法-Inter"><a href="#4-4-2-实例方法-Inter" class="headerlink" title="4.4.2 实例方法 Inter"></a>4.4.2 实例方法 Inter</h3><p><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/InstMethodsInter.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.InstMethodsInter</code></a> ，实例方法 Inter 。</p><p>ConstructorInter <a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/InstMethodsInter.java#L51" rel="external nofollow noopener noreferrer" target="_blank"><strong>构造方法</strong></a>，调用 <code>InterceptorInstanceLoader#load(String, classLoader)</code> 方法，加载实例方法拦截器。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/InstMethodsInter.java#L72" rel="external nofollow noopener noreferrer" target="_blank"><code>#intercept(...)</code></a> 方法，<strong>Before-After</strong> 方式拦截实例方法，代码如下 ：</p><ul><li>第 79 至 86 行 ：调用 <code>InstanceMethodsAroundInterceptor#beforeMethod(...)</code> 方法，执行在实例方法之前的逻辑。<ul><li><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/MethodInterceptResult.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.MethodInterceptResult</code></a> ，方法拦截器执行结果。当调用 <a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/MethodInterceptResult.java#L51" rel="external nofollow noopener noreferrer" target="_blank"><code>MethodInterceptResult#defineReturnValue(Object)</code></a> 方法，设置执行结果，并标记不再继续执行。</li></ul></li><li>第 90 至 92 行 ：当 MethodInterceptResult 已经有执行结果，<strong>不再执行原有方法，直接返回结果</strong>。</li><li>第 94 至 96 行 ：调用 <code>Callable#call()</code> 方法，执行原有实例方法。</li><li>第 97 至 105 行 ：调用 <code>InstanceMethodsAroundInterceptor#handleMethodException(...)</code> 方法，处理异常。</li><li>第 107 至 113 行 ：调用 <code>InstanceMethodsAroundInterceptor#afterMethod(...)</code> 方法，执行后置逻辑。</li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/InstMethodsInterWithOverrideArgs.java#L37" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.InstMethodsInterWithOverrideArgs</code></a> ，<strong>覆写参数</strong>的实例方法 Inter 。</p><p>不太理解<strong>覆写参数</strong>？有这样一个场景，<code>InstanceMethodsAroundInterceptor#beforeMethod(...)</code> 方法里，我们修改了方法参数，并且希望原有实例方法执行时，<strong>使用的是修改了的方法参数</strong>，此时，就需要使用 InstMethodsInterWithOverrideArgs 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/InstMethodsInterWithOverrideArgs.java#L73" rel="external nofollow noopener noreferrer" target="_blank"><code>InstMethodsInterWithOverrideArgs#intercept(...)</code></a> 方法，总体逻辑和 InstMethodsInter 是一致的，下面我们来看看差异点 ：</p><ul><li>第 76 行 ：方法参数类型是 <a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/OverrideCallable.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.OverrideCallable</code></a>，并且带有 <a href="https://github.com/raphw/byte-buddy/blob/188366ace6e16ec167a00b144c9048d78495165f/byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Morph.java" rel="external nofollow noopener noreferrer" target="_blank"><code>net.bytebuddy.implementation.bind.annotation.@Morph</code></a> 注解。</li><li>第 96 行 ：调用 <a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/OverrideCallable.java#L37" rel="external nofollow noopener noreferrer" target="_blank"><code>OverrideCallable#call(args)</code></a> 方法，使用被前置方法修改过的参数，执行原有实例方法。</li></ul><p>先来瞅瞅 <code>@Morph</code> 注解的定义 ：</p><blockquote><p>This annotation instructs Byte Buddy to inject a proxy class that calls a method’s super method with explicit arguments.  </p><p>For this, the {@link Morph.Binder} needs to be installed for an interface type that takes an argument of the array type {@link java.lang.Object} and returns a non-array type of {@link java.lang.Object}. </p><p>This is an alternative to using the {@link net.bytebuddy.implementation.bind.annotation.SuperCall} or {@link net.bytebuddy.implementation.bind.annotation.DefaultCall} annotations which call a super method using the same arguments as the intercepted method was invoked with.</p></blockquote><p>简单的来说 ：</p><ul><li><code>@Morph</code> 注解，注入一个代理对象，该对象会使用传入的参数，调用被代理的方法。例如在 InstMethodsInterWithOverrideArgs 里，调用 <code>OverrideCallable#call(args)</code> 方法，会调用原有实例方法。</li><li><p>需要使用 <code>Morph.Binder</code> 设置一个接口，并且该接口的方法定义为 <code>Object methodName(Object[])</code> 。在 InstMethodsInterWithOverrideArgs 使用的是  <a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/OverrideCallable.java#L29" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.OverrideCallable</code></a> 接口。另外，调用 <code>Morph.Binder#install(Class&lt;?&gt;)</code> 方法的代码如下 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ClassEnhancePluginDefine.java </span></div><div class="line"><span class="comment">// `#enhanceInstance(...)` 方法</span></div><div class="line">newClassBuilder =</div><div class="line">    newClassBuilder.method(not(isStatic()).and(instanceMethodsInterceptPoint.getMethodsMatcher())) <span class="comment">// 匹配</span></div><div class="line">        .intercept( <span class="comment">// 拦截</span></div><div class="line">            MethodDelegation.withDefaultConfiguration()</div><div class="line">                .withBinders(</div><div class="line">                    Morph.Binder.install(OverrideCallable.class) <span class="comment">// 覆写参数</span></div><div class="line">                )</div><div class="line">                .to(<span class="keyword">new</span> InstMethodsInterWithOverrideArgs(interceptor, classLoader))</div><div class="line">        );</div></pre></td></tr></table></figure></li></ul><h3 id="4-4-3-静态方法-Inter"><a href="#4-4-3-静态方法-Inter" class="headerlink" title="4.4.3 静态方法 Inter"></a>4.4.3 静态方法 Inter</h3><p><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/StaticMethodsInter.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.StaticMethodsInter</code></a> 和 <a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/StaticMethodsInterWithOverrideArgs.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.StaticMethodsInterWithOverrideArgs</code></a> 和<strong>实例方法 Inter</strong>基本一致，胖友可以自己捋一捋，笔者就不瞎比比了。</p><h2 id="4-5-小结"><a href="#4-5-小结" class="headerlink" title="4.5 小结"></a>4.5 小结</h2><p>总的来说，涉及到的组件，如下图 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/11.png" alt=""></p><p>胖友再梳理梳理。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>写完，蛮嗨皮😜。</p><p>近期最认真的一篇文章，没有之一，满足。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/12.png" alt=""></p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/agent-plugin-system/&quot;&gt;http://www.iocoder.cn/SkyWalking/agent-plugin-system/&lt;/a&gt; 「芋道源码」
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Agent 初始化</title>
    <link href="http://www.iocoder.cn/SkyWalking/agent-init/"/>
    <id>http://www.iocoder.cn/SkyWalking/agent-init/</id>
    <published>2020-07-04T16:00:00.000Z</published>
    <updated>2017-12-13T18:28:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/agent-init/">http://www.iocoder.cn/SkyWalking/agent-init/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-init/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-init/">2. SkyWalkingAgent</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-init/">3. SnifferConfigInitializer</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-init/">3.1 Config</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-init/">3.2 RemoteDownstreamConfig</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-init/">4. Plugin</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-init/">4.1 PluginBootstrap</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-init/">4.2 PluginFinder</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-init/">5. ServiceManager</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-init/">5.1 BootService</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-init/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>SkyWalking Agent 启动初始化的过程</strong>。</p><p>SkyWalking Agent 基于 <strong>JavaAgent</strong> 机制，实现应用<strong>透明</strong>接入 SkyWalking 。关于 JavaAgent 机制，笔者推荐如下两篇文章 ：</p><ul><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html" rel="external nofollow noopener noreferrer" target="_blank">《Instrumentation 新功能》</a></li><li><a href="http://www.infoq.com/cn/articles/javaagent-illustrated" rel="external nofollow noopener noreferrer" target="_blank">《JVM源码分析之javaagent原理完全解读》</a></li></ul><blockquote><p>友情提示 ：建议自己手撸一个简单的 JavaAgent ，更容易理解 SkyWalking Agent 。 </p><p>笔者练手的 JavaAgent 项目地址 ：<a href="https://github.com/YunaiV/learning/tree/master/javaagent01" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/YunaiV/learning/tree/master/javaagent01</a></p></blockquote><h1 id="2-SkyWalkingAgent"><a href="#2-SkyWalkingAgent" class="headerlink" title="2. SkyWalkingAgent"></a>2. SkyWalkingAgent</h1><p><code>org.skywalking.apm.agent.SkyWalkingAgent</code> ，在 <code>apm-sniffer/apm-agent</code> Maven 模块项目里，SkyWalking Agent <strong>启动入口</strong>。为什么说它是启动入口呢？在 <code>apm-sniffer/apm-agent</code> 的 <a href="https://github.com/OpenSkywalking/skywalking/blob/23133f7d97d17b471f69e7214a01885ebcd2e882/apm-sniffer/apm-agent/pom.xml#L53" rel="external nofollow noopener noreferrer" target="_blank"><code>pom.xml</code></a> 文件的【第 73 行】，我们可以看到 SkyWalkingAgent 被配置成 JavaAgent 的 <strong>PremainClass</strong> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/c51dbc997348111674dbeedb71d22b0414936cdb/apm-sniffer/apm-agent/src/main/java/org/skywalking/apm/agent/SkyWalkingAgent.java#L54" rel="external nofollow noopener noreferrer" target="_blank"><code>#premain(...)</code></a> 方法，代码如下 ：</p><ul><li>第 58 行 ：调用 <code>SnifferConfigInitializer#initialize()</code> 方法，初始化 Agent 配置。</li><li>第 61 行 ：调用 <code>PluginBootstrap#loadPlugins()</code> 方法，加载 Agent 插件们。而后，创建 PluginFinder 。 </li><li>第 64 行 ：调用 <code>ServiceManager#boot()</code> 方法，初始化 Agent 服务管理。在这过程中，Agent 服务们会被初始化。</li><li>第 79 至 133 行 ：基于 <a href="https://github.com/raphw/byte-buddy" rel="external nofollow noopener noreferrer" target="_blank">byte-buddy</a> ，初始化 Instrumentation 的 <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/instrument/ClassFileTransformer.html" rel="external nofollow noopener noreferrer" target="_blank"><code>java.lang.instrument.ClassFileTransformer</code></a> 。</li></ul><h1 id="3-SnifferConfigInitializer"><a href="#3-SnifferConfigInitializer" class="headerlink" title="3. SnifferConfigInitializer"></a>3. SnifferConfigInitializer</h1><p><code>org.skywalking.apm.agent.core.conf.SnifferConfigInitializer</code> ，Agent 配置初始化器。</p><p>在看具体代码实现之前，我们先看下 <code>org.skywalking.apm.agent.core.conf</code> 包的大体结构 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_05/02.png" alt=""></p><p>配置类有 Config 和 RemoteDownstreamConfig 两种。从命名上可以看出 ：</p><ul><li>Config 为 Agent <strong>本地</strong>配置类，使用 SnifferConfigInitializer 进行初始化。</li><li>RemoteDownstreamConfig 为 Agent <strong>远程</strong>配置类，从 <a href="https://github.com/OpenSkywalking/skywalking/wiki/3.2.3-%E9%83%A8%E7%BD%B2Collector" rel="external nofollow noopener noreferrer" target="_blank">Collector Server</a> 读取。 </li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/cea46a7e93437bbb16db2bfe0fae5c6fcf733fc2/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/conf/SnifferConfigInitializer.java#L56" rel="external nofollow noopener noreferrer" target="_blank"><code>#initialize()</code></a> 方法，初始化 Agent 本地配置，代码如下 ：</p><ul><li>第 59 至 67 行 ：从配置文件( <code>agent.config</code> ) 加载配置。配置文件所在<strong>固定</strong>路径为 <code>${AGENT_PACKAGE_PATH}/config/agent.config</code> ，其中 <code>${AGENT_PACKAGE_PATH}</code> 通过 <a href="https://github.com/YunaiV/skywalking/blob/c51dbc997348111674dbeedb71d22b0414936cdb/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/boot/AgentPackagePath.java#L31" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.boot.AgentPackagePath</code></a> 初始化。Agent 整理目录如下图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_05/01.png" alt=""></li><li>第 70 至 74 行 ：从环境变量<strong>覆盖</strong>配置。环境变量 <strong>Key</strong> 需以 <code>&quot;skywalking.&quot;</code> 开头。例如，<code>Config.Agent.APPLICATION_CODE</code> 在 <code>agent.config</code> 为 <code>agent.application_code</code> ，环境变量为 <code>skywalking.agent.application_code</code> 。另外，环境变量包括 JVM 进程的和系统的。</li><li>第 77 至 82 行 ：校验配置是否正确加载。</li></ul><h2 id="3-1-Config"><a href="#3-1-Config" class="headerlink" title="3.1 Config"></a>3.1 Config</h2><p><code>org.skywalking.apm.agent.core.conf.Config</code> ，Agent 本地配置类。</p><p>打开 <a href="https://github.com/YunaiV/skywalking/blob/cea46a7e93437bbb16db2bfe0fae5c6fcf733fc2/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/conf/Config.java#L32" rel="external nofollow noopener noreferrer" target="_blank">Config</a> ，我们会看到拆分了 Agent / Collector / Jvm / Buffer / Dictionary / Logging / Plugin 七个小类。如下图 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_05/03.png" alt=""></p><p>本文暂不对配置项详细解析，胖友可以看下每个属性的英文注释。</p><h2 id="3-2-RemoteDownstreamConfig"><a href="#3-2-RemoteDownstreamConfig" class="headerlink" title="3.2 RemoteDownstreamConfig"></a>3.2 RemoteDownstreamConfig</h2><p><code>org.skywalking.apm.agent.core.conf.RemoteDownstreamConfig</code> ，Agent 远程配置类。</p><p>打开 <a href="https://github.com/YunaiV/skywalking/blob/cea46a7e93437bbb16db2bfe0fae5c6fcf733fc2/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/conf/RemoteDownstreamConfig.java" rel="external nofollow noopener noreferrer" target="_blank">RemoteDownstreamConfig</a> ，我们会看到拆分了 Agent / Collector 两小类。如下图 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_05/04.png" alt=""></p><p>本文暂不对配置项详细解析，胖友可以看下每个属性的英文注释。</p><h1 id="4-Plugin"><a href="#4-Plugin" class="headerlink" title="4. Plugin"></a>4. Plugin</h1><p>SkyWalking Agent 提供了多种插件，实现不同框架的<strong>透明</strong>接入 SkyWalking 。在 <a href="https://github.com/OpenSkywalking/skywalking/wiki/3.2.3-supported-list" rel="external nofollow noopener noreferrer" target="_blank">《官方文档 —— supported list》</a> 里，有目前的插件列表。</p><p>另外，在 <code>apm-sniffer/apm-sdk-plugin</code> 目录下，有插件的实现代码 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_05/05.png" alt=""></p><p>本小节会分享的较为简单，在 <a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/?self">《SkyWalking 源码分析 —— Agent 插件体系》</a> 详细解析。</p><h2 id="4-1-PluginBootstrap"><a href="#4-1-PluginBootstrap" class="headerlink" title="4.1 PluginBootstrap"></a>4.1 PluginBootstrap</h2><p><code>org.skywalking.apm.agent.core.plugin.PluginBootstrap</code> ，插件引导程序类，创建需要加载的插件对象数组。</p><p><a href="https://github.com/YunaiV/skywalking/blob/130f0a5a3438663b393e53ba2cca02a8d13c258a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginBootstrap.java#L45" rel="external nofollow noopener noreferrer" target="_blank"><code>#loadPlugins()</code></a> 方法，代码如下 ：</p><ul><li>第 47 行 ：初始化 AgentClassLoader 。</li><li>第 50 至 56 行 ：获得插件<strong>定义路径</strong>数组。</li><li>第 59 至 66 行 ：获得插件<strong>定义</strong>( <a href="https://github.com/OpenSkywalking/skywalking/blob/b16d23c1484bec941367d6b36fa932b8ace40971/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginDefine.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.PluginDefine</code></a> )数组。</li><li>第 69 至 82 行 ：创建<strong>类增强插件定义</strong>( <a href="https://github.com/OpenSkywalking/skywalking/blob/b16d23c1484bec941367d6b36fa932b8ace40971/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/AbstractClassEnhancePluginDefine.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.AbstractClassEnhancePluginDefine</code></a> )对象数组。不同插件通过实现 AbstractClassEnhancePluginDefine <strong>抽象类</strong>，定义不同框架的<strong>切面</strong>，<strong>记录调用链路</strong>。以 Spring 插件为例子，如下是相关类图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_05/06.png" alt=""></li></ul><h2 id="4-2-PluginFinder"><a href="#4-2-PluginFinder" class="headerlink" title="4.2 PluginFinder"></a>4.2 PluginFinder</h2><p><code>org.skywalking.apm.agent.core.plugin.PluginFinder</code> ，插件发现者。其提供 <a href="https://github.com/YunaiV/skywalking/blob/09c654af33081e56547cb8b3b9e0c8525ddce32f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginFinder.java#L80" rel="external nofollow noopener noreferrer" target="_blank"><code>#find(...)</code></a> 方法，获得<strong>类增强插件定义</strong>( <a href="https://github.com/OpenSkywalking/skywalking/blob/b16d23c1484bec941367d6b36fa932b8ace40971/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/AbstractClassEnhancePluginDefine.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.AbstractClassEnhancePluginDefine</code></a> )对象。</p><p>PluginFinder <strong><a href="https://github.com/YunaiV/skywalking/blob/09c654af33081e56547cb8b3b9e0c8525ddce32f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginFinder.java#L56" rel="external nofollow noopener noreferrer" target="_blank">构造方法</a></strong>，代码如下 ：</p><ul><li>第 57 至 77 行 ：循环 AbstractClassEnhancePluginDefine 对象数组，添加到 <code>nameMatchDefine</code> / <code>signatureMatchDefine</code> 属性，方便 <code>#find(...)</code> 方法查找 AbstractClassEnhancePluginDefine 对象。<ul><li>第 65 至 72 行 ：处理 NameMatch 为匹配的 AbstractClassEnhancePluginDefine 对象，添加到 <code>nameMatchDefine</code>  属性。</li><li>第 74 至 76 行 ：处理<strong>非</strong> NameMatch 为匹配的 AbstractClassEnhancePluginDefine 对象，添加到 <code>signatureMatchDefine</code> 属性。</li></ul></li></ul><h1 id="5-ServiceManager"><a href="#5-ServiceManager" class="headerlink" title="5. ServiceManager"></a>5. ServiceManager</h1><p><code>org.skywalking.apm.agent.core.boot.ServiceManager</code> ，<a href="https://github.com/YunaiV/skywalking/blob/09c654af33081e56547cb8b3b9e0c8525ddce32f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/boot/BootService.java" rel="external nofollow noopener noreferrer" target="_blank">BootService</a> 管理器。负责管理、初始化 BootService 实例们。</p><p><a href="https://github.com/YunaiV/skywalking/blob/3de8a6c15d07aa3b2c3b4e732e6654fc87c4e70e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/boot/ServiceManager.java#L45" rel="external nofollow noopener noreferrer" target="_blank"><code>#boot()</code></a> 方法，代码如下 ：</p><ul><li><p>第 47 行 ：调用 <a href="https://github.com/YunaiV/skywalking/blob/3de8a6c15d07aa3b2c3b4e732e6654fc87c4e70e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/boot/ServiceManager.java#L72" rel="external nofollow noopener noreferrer" target="_blank"><code>#loadAllServices()</code></a> 方法，加载所有 BootService 实现类的实例数组。ServiceManager 基于 SPI (Service Provider Interface) 机制，在 <a href="https://github.com/OpenSkywalking/skywalking/blob/b16d23c1484bec941367d6b36fa932b8ace40971/apm-sniffer/apm-agent-core/src/main/resources/META-INF/services/org.skywalking.apm.agent.core.boot.BootService" rel="external nofollow noopener noreferrer" target="_blank">/resources/META-INF.services/org.skywalking.apm.agent.core.boot.BootService</a> 文件里，定义了所有 BootService 的实现类。如果胖友对 SPI 机制不熟悉，可以看下如下文章 ：</p><ul><li><a href="http://www.jianshu.com/p/32d3e108f30a" rel="external nofollow noopener noreferrer" target="_blank">《SPI 和 ServiceLoader》</a> </li><li><a href="http://www.jianshu.com/p/46aa69643c97" rel="external nofollow noopener noreferrer" target="_blank">《跟我学Dubbo系列之Java SPI机制简介》</a> </li></ul></li><li><p>第 50 行 ：调用 <a href="https://github.com/YunaiV/skywalking/blob/3de8a6c15d07aa3b2c3b4e732e6654fc87c4e70e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/boot/ServiceManager.java#L82" rel="external nofollow noopener noreferrer" target="_blank"><code>#beforeBoot()</code></a> 方法，调用每个 <code>BootService#beforeBoot()</code> 方法。</p></li><li>第 52 行 ：调用 <a href="https://github.com/YunaiV/skywalking/blob/3de8a6c15d07aa3b2c3b4e732e6654fc87c4e70e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/boot/ServiceManager.java#L92" rel="external nofollow noopener noreferrer" target="_blank"><code>#startup()</code></a> 方法，调用每个 <code>BootService#boot()</code> 方法。</li><li>第 54 行 ：调用 <a href="https://github.com/YunaiV/skywalking/blob/3de8a6c15d07aa3b2c3b4e732e6654fc87c4e70e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/boot/ServiceManager.java#L102" rel="external nofollow noopener noreferrer" target="_blank"><code>#afterBoot()</code></a> 方法，调用每个 <code>BootService#afterBoot()</code> 方法。</li></ul><h2 id="5-1-BootService"><a href="#5-1-BootService" class="headerlink" title="5.1 BootService"></a>5.1 BootService</h2><p><code>org.skywalking.apm.agent.core.boot.BootService</code> ，Agent 启动服务<strong>接口</strong>，定义了 <code>#beforeBoot()</code> / <code>#boot()</code> / <code>#afterBoot()</code> / <code>#shutdown()</code> 接口方法。</p><p>BootService 目前有<strong>七个</strong>实现类，在后续的文章，我们会解析相关实现。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_05/07.png" alt=""></p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>每次写初始化相关的文章，写少了，怕太水；写多了，又怕太复杂。</p><p>嗯，送一发妹子。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_05/08.png" alt=""></p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/agent-init/&quot;&gt;http://www.iocoder.cn/SkyWalking/agent-init/&lt;/a&gt; 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;

      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— 调试环境搭建</title>
    <link href="http://www.iocoder.cn/SkyWalking/build-debugging-environment/"/>
    <id>http://www.iocoder.cn/SkyWalking/build-debugging-environment/</id>
    <published>2020-06-30T16:00:00.000Z</published>
    <updated>2017-12-10T02:02:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/build-debugging-environment/">http://www.iocoder.cn/SkyWalking/build-debugging-environment/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/build-debugging-environment/">1. 依赖工具</a></li><li><a href="http://www.iocoder.cn/SkyWalking/build-debugging-environment/">2. 源码拉取</a></li><li><a href="http://www.iocoder.cn/SkyWalking/build-debugging-environment/">3. 启动 SkyWalking Collector</a></li><li><a href="http://www.iocoder.cn/SkyWalking/build-debugging-environment/">4. 启动 SkyWalking Agent</a></li><li><a href="http://www.iocoder.cn/SkyWalking/build-debugging-environment/">5. 启动 SkyWalking Web UI</a></li><li><a href="http://www.iocoder.cn/SkyWalking/build-debugging-environment/">6. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-依赖工具"><a href="#1-依赖工具" class="headerlink" title="1. 依赖工具"></a>1. 依赖工具</h1><ul><li>Maven</li><li>Git</li><li>JDK</li><li>IntelliJ IDEA</li></ul><h1 id="2-源码拉取"><a href="#2-源码拉取" class="headerlink" title="2. 源码拉取"></a>2. 源码拉取</h1><p>从官方仓库 <a href="https://github.com/OpenSkywalking/skywalking" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/OpenSkywalking/skywalking</a> <code>Fork</code> 出属于自己的仓库。为什么要 <code>Fork</code> ？既然开始阅读、调试源码，我们可能会写一些注释，有了自己的仓库，可以进行自由的提交。😈</p><p>使用 <code>IntelliJ IDEA</code> 从 <code>Fork</code> 出来的仓库拉取代码。拉取完成后，<code>Maven</code> 会下载依赖包，可能会花费一些时间，耐心等待下。</p><p>本文基于 <code>master</code> 分支。</p><h1 id="3-启动-SkyWalking-Collector"><a href="#3-启动-SkyWalking-Collector" class="headerlink" title="3. 启动 SkyWalking Collector"></a>3. 启动 SkyWalking Collector</h1><p>参考 <a href="https://github.com/OpenSkywalking/skywalking/wiki/How-to-build" rel="external nofollow noopener noreferrer" target="_blank">《官方文档 —— How to build》</a></p><ol><li>在 IntelliJ IDEA Terminal 中，执行 <code>mvn compile -Dmaven.test.skip=true</code> 进行编译。</li><li><p>设置 gRPC 的<strong>自动生成</strong>的代码目录，为<strong>源码</strong>目录 ：</p><ul><li>/apm-network/target/generated-sources/protobuf/ 下的 <code>grpc-java</code> 和 <code>java</code> 目录</li><li>/apm-collector-remote/collector-remote-grpc-provider/target/generated-sources/protobuf/ 下的 <code>grpc-java</code> 和 <code>java</code> 目录</li><li><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_01/01.png" alt=""></p><blockquote><p>从 3.2 开始，网络通讯协议引入 GRPC ，所以增加上述的步骤</p></blockquote></li></ul></li><li><p>运行 <code>org.skywalking.apm.collector.bootCollectorBootStartUp</code> 的 <code>#main(args)</code> 方法，启动 Collector 。</p></li><li>访问 <code>http://127.0.0.1:10800/agent/jetty</code> 地址，返回 <code>[&quot;localhost:12800/&quot;]</code> ，说明启动<strong>成功</strong>。</li></ol><h1 id="4-启动-SkyWalking-Agent"><a href="#4-启动-SkyWalking-Agent" class="headerlink" title="4. 启动 SkyWalking Agent"></a>4. 启动 SkyWalking Agent</h1><p>感谢 <a href="https://github.com/wu-sheng" rel="external nofollow noopener noreferrer" target="_blank">吴晟</a> 指导如何搭建 Agent 调试环境。</p><ol><li>在 IntelliJ IDEA Terminal 中，执行 <code>mvn compile -Dmaven.test.skip=true</code> 进行编译。在 /packages/skywalking-agent 目录下，我们可以看到编译出来的 Agent ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_01/02.png" alt=""></li><li><p>使用 Spring Boot 创建一个简单的 Web 项目。类似如下 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_01/03.png" alt=""></p><blockquote><p>友情提示 ：<strong>这里一定要注意下</strong>。创建的 Web 项目，使用  IntelliJ IDEA 的<strong>菜单</strong> File / New / Module 或 File / New / Module from Existing Sources ，<strong>保证 Web 项目和 skywalking 项目平级</strong>。这样，才可以使用 IntelliJ IDEA 调试  Agent 。</p></blockquote><ul><li><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_01/04.png" alt=""></li><li><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_01/05.png" alt=""></li></ul></li><li><p>在 <code>org.skywalking.apm.agent.SkyWalkingAgent</code> 的 <code>#premain(...)</code> 方法，打上调试断点。</p></li><li>运行 Web 项目的 Application 的 <code>#main(args)</code> 方法，并增加 JVM 启动参数，<code>-javaagent:/path/to/skywalking-agent/skywalking-agent.jar</code>。<code>/path/to</code> <strong>参数值</strong>为上面我们编译出来的 /packages/skywalking-agent 目录的绝对路径。如下图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_01/06.png" alt=""></li><li>如果在【<strong>第三步</strong>】的调试断点停住，说明 Agent 启动<strong>成功</strong>。</li></ol><hr><p>考虑到可能我们会在 Agent 上增加代码注释，这样每次不得不重新编译 Agent 。可以配置如下图，自动编译 Agent ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_01/07.png" alt=""></p><ul><li><code>-T 1C clean  package -Dmaven.test.skip=true -Dmaven.compile.fork=true</code> 。</li></ul><hr><p>另外，使用 IntelliJ IDEA Remote 远程调试，也是可以的。如下图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_01/10.png" alt=""></p><h1 id="5-启动-SkyWalking-Web-UI"><a href="#5-启动-SkyWalking-Web-UI" class="headerlink" title="5. 启动 SkyWalking Web UI"></a>5. 启动 SkyWalking Web UI</h1><p>考虑到调试过程中，我们要看下是否收集到追踪日志，可以安装 SkyWalking Web UI 进行查看。</p><p>参考 <a href="https://github.com/OpenSkywalking/skywalking-ui#quickstart-zh" rel="external nofollow noopener noreferrer" target="_blank">《官方文档 —— Sky Walking Web UI》</a> 安装。</p><h1 id="6-彩蛋"><a href="#6-彩蛋" class="headerlink" title="6. 彩蛋"></a>6. 彩蛋</h1><p>SkyWalking 环境搭建完成，胖友们可以起飞，源码读起来。</p><p>这会是个系列文章，笔者会慢慢更新。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_01/08.png" alt=""></p><p>如下是笔者对代码量和用途的简单整理，完善度比较低，可能有一丢丢的帮助 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_01/09.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/build-debugging-environment/&quot;&gt;http://www.iocoder.cn/SkyWalking/build-debugging-environ
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring-Cloud-Gateway 源码解析 —— 网关管理 HTTP API</title>
    <link href="http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-api/"/>
    <id>http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-api/</id>
    <published>2020-04-14T16:00:00.000Z</published>
    <updated>2017-12-01T16:48:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-api/">http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-api/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Spring-Cloud-Gateway 2.0.X M4</strong>  </p><ul><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-api/">1. 概述</a><ul><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-api/">2. 过滤器 HTTP API</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-api/">2.1 全局过滤器列表</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-api/">2.2 路由过滤器工厂列表</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-api/">3. 路由 HTTP API</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-api/">2.1 路由列表</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-api/">2.2 单个路由信息</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-api/">2.3 单个路由的过滤器</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-api/">2.4 添加/修改单个路由</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-api/">2.5 删除单个路由</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-api/">2.6 刷新路由缓存</a></li></ul></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-api/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享<strong>网关管理 HTTP API</strong>。</p><p><code>org.springframework.cloud.gateway.actuate.GatewayWebfluxEndpoint</code> ，提供<strong>管理</strong>网关的 HTTP API 。<strong>构造方法</strong>，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"$&#123;management.context-path:/application&#125;/gateway"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GatewayWebfluxEndpoint</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(GatewayWebfluxEndpoint.class);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 路由定义定位器</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="keyword">private</span> RouteDefinitionLocator routeDefinitionLocator;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 全局过滤器</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="keyword">private</span> List&lt;GlobalFilter&gt; globalFilters;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 网关过滤器工厂</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="keyword">private</span> List&lt;GatewayFilterFactory&gt; gatewayFilters;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 存储器 RouteDefinitionLocator 对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="keyword">private</span> RouteDefinitionWriter routeDefinitionWriter;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 路由定位器</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="keyword">private</span> RouteLocator routeLocator;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用事件发布器</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="keyword">private</span> ApplicationEventPublisher publisher;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">GatewayWebfluxEndpoint</span><span class="params">(RouteDefinitionLocator routeDefinitionLocator, List&lt;GlobalFilter&gt; globalFilters,</span></span></div><div class="line"><span class="function"><span class="params">  List&lt;GatewayFilterFactory&gt; GatewayFilters, RouteDefinitionWriter routeDefinitionWriter,</span></span></div><div class="line"><span class="function"><span class="params">  RouteLocator routeLocator)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.routeDefinitionLocator = routeDefinitionLocator;</div><div class="line"><span class="keyword">this</span>.globalFilters = globalFilters;</div><div class="line"><span class="keyword">this</span>.gatewayFilters = GatewayFilters;</div><div class="line"><span class="keyword">this</span>.routeDefinitionWriter = routeDefinitionWriter;</div><div class="line"><span class="keyword">this</span>.routeLocator = routeLocator;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>@RequestMapping</code> 注解，HTTP  API 以 <code>&quot;${management.context-path:/application}/gateway&quot;</code> 。</li><li><code>routeDefinitionLocator</code> 属性，路由定义定位器。在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/route-locator-route-definition/?self">《Spring-Cloud-Gateway 源码解析 —— 路由（2.2）之 RouteDefinitionRouteLocator 路由配置》</a> 有详细解析。</li><li><code>globalFilters</code> 属性，全局过滤器。在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-intro/?self">《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.1) 之 GatewayFilter 一览》</a> 有详细解析。</li><li><code>gatewayFilters</code> 属性，网关过滤器工厂。在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-factory/?self">《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.2) 之 GatewayFilterFactory 过滤器工厂》</a></li><li><code>routeLocator</code> 属性，路由定位器。在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/route-locator-intro/?self">《Spring-Cloud-Gateway 源码解析 —— 路由（2.1）之 RouteLocator 一览》</a> 有详细解析。</li><li><code>publisher</code> 属性，应用事件发布器。在 <a href="https://muyinchen.github.io/2017/09/27/Spring5%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/" rel="external nofollow noopener noreferrer" target="_blank">《Spring5源码解析-Spring框架中的事件和监听器》</a> 有相关解析。</li></ul><hr><p>GatewayWebfluxEndpoint 提供两类 HTTP API ：</p><ul><li>过滤器 HTTP API</li><li>路由 HTTP API</li></ul><hr><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h2 id="2-过滤器-HTTP-API"><a href="#2-过滤器-HTTP-API" class="headerlink" title="2. 过滤器 HTTP API"></a>2. 过滤器 HTTP API</h2><h2 id="2-1-全局过滤器列表"><a href="#2-1-全局过滤器列表" class="headerlink" title="2.1 全局过滤器列表"></a>2.1 全局过滤器列表</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"/globalfilters"</span>)</div><div class="line"><span class="keyword">public</span> Mono&lt;HashMap&lt;String, Object&gt;&gt; globalfilters() &#123;</div><div class="line"><span class="keyword">return</span> getNamesToOrders(<span class="keyword">this</span>.globalFilters);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> &lt;T&gt; Mono&lt;HashMap&lt;String, Object&gt;&gt; getNamesToOrders(List&lt;T&gt; list) &#123;</div><div class="line"><span class="keyword">return</span> Flux.fromIterable(list).reduce(<span class="keyword">new</span> HashMap&lt;&gt;(), <span class="keyword">this</span>::putItem);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> HashMap&lt;String, Object&gt; <span class="title">putItem</span><span class="params">(HashMap&lt;String, Object&gt; map, Object o)</span> </span>&#123;</div><div class="line">Integer order = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> Ordered) &#123;</div><div class="line">order = ((Ordered)o).getOrder();</div><div class="line">&#125;</div><div class="line"><span class="comment">//filters.put(o.getClass().getName(), order);</span></div><div class="line">map.put(o.toString(), order);</div><div class="line"><span class="keyword">return</span> map;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="2-2-路由过滤器工厂列表"><a href="#2-2-路由过滤器工厂列表" class="headerlink" title="2.2 路由过滤器工厂列表"></a>2.2 路由过滤器工厂列表</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"/routefilters"</span>)</div><div class="line"><span class="keyword">public</span> Mono&lt;HashMap&lt;String, Object&gt;&gt; routefilers() &#123;</div><div class="line"><span class="keyword">return</span> getNamesToOrders(<span class="keyword">this</span>.gatewayFilters);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3-路由-HTTP-API"><a href="#3-路由-HTTP-API" class="headerlink" title="3. 路由 HTTP API"></a>3. 路由 HTTP API</h2><h2 id="2-1-路由列表"><a href="#2-1-路由列表" class="headerlink" title="2.1 路由列表"></a>2.1 路由列表</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"/routes"</span>)</div><div class="line"><span class="keyword">public</span> Mono&lt;Map&lt;String, List&gt;&gt; routes() &#123;</div><div class="line">Mono&lt;List&lt;RouteDefinition&gt;&gt; routeDefs = <span class="keyword">this</span>.routeDefinitionLocator.getRouteDefinitions().collectList();</div><div class="line">Mono&lt;List&lt;Route&gt;&gt; routes = <span class="keyword">this</span>.routeLocator.getRoutes().collectList();</div><div class="line"><span class="keyword">return</span> Mono.zip(routeDefs, routes).map(tuple -&gt; &#123;</div><div class="line">Map&lt;String, List&gt; allRoutes = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">allRoutes.put(<span class="string">"routeDefinitions"</span>, tuple.getT1());</div><div class="line">allRoutes.put(<span class="string">"routes"</span>, tuple.getT2());</div><div class="line"><span class="keyword">return</span> allRoutes;</div><div class="line">&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="2-2-单个路由信息"><a href="#2-2-单个路由信息" class="headerlink" title="2.2 单个路由信息"></a>2.2 单个路由信息</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"/routes/&#123;id&#125;"</span>)</div><div class="line"><span class="keyword">public</span> Mono&lt;ResponseEntity&lt;RouteDefinition&gt;&gt; route(<span class="meta">@PathVariable</span> String id) &#123;</div><div class="line"><span class="comment">//<span class="doctag">TODO:</span> missing RouteLocator</span></div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.routeDefinitionLocator.getRouteDefinitions()</div><div class="line">.filter(route -&gt; route.getId().equals(id))</div><div class="line">.singleOrEmpty()</div><div class="line">.map(route -&gt; ResponseEntity.ok(route))</div><div class="line">.switchIfEmpty(Mono.just(ResponseEntity.notFound().build()));</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>从 <code>TODO: missing RouteLocator</code> ，我们可以看到，目前不支持从 RouteLocator 获取 Route ，只返回 RouteDefinition 。等待未来的版本支持。</li></ul><h2 id="2-3-单个路由的过滤器"><a href="#2-3-单个路由的过滤器" class="headerlink" title="2.3 单个路由的过滤器"></a>2.3 单个路由的过滤器</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"/routes/&#123;id&#125;/combinedfilters"</span>)</div><div class="line"><span class="keyword">public</span> Mono&lt;HashMap&lt;String, Object&gt;&gt; combinedfilters(<span class="meta">@PathVariable</span> String id) &#123;</div><div class="line"><span class="comment">//<span class="doctag">TODO:</span> missing global filters</span></div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.routeLocator.getRoutes()</div><div class="line">.filter(route -&gt; route.getId().equals(id))</div><div class="line">.reduce(<span class="keyword">new</span> HashMap&lt;&gt;(), <span class="keyword">this</span>::putItem);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>从 <code>TODO: missing global filters</code> ，我们可以看到，目前返回的过滤器不包括 GlobalFilter ，可以调用 <code>/globalfilters</code> 查看。等待未来的版本支持。</li></ul><h2 id="2-4-添加-修改单个路由"><a href="#2-4-添加-修改单个路由" class="headerlink" title="2.4 添加/修改单个路由"></a>2.4 添加/修改单个路由</h2><p>在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/route-definition-locator-repository/?self">《Spring-Cloud-Gateway 源码解析 —— 路由（1.3）之 RouteDefinitionRepository 存储器》「5. GatewayWebfluxEndpoint」</a> 有详细解析。</p><h2 id="2-5-删除单个路由"><a href="#2-5-删除单个路由" class="headerlink" title="2.5 删除单个路由"></a>2.5 删除单个路由</h2><p>在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/route-definition-locator-repository/?self">《Spring-Cloud-Gateway 源码解析 —— 路由（1.3）之 RouteDefinitionRepository 存储器》「5. GatewayWebfluxEndpoint」</a> 有详细解析。</p><h2 id="2-6-刷新路由缓存"><a href="#2-6-刷新路由缓存" class="headerlink" title="2.6 刷新路由缓存"></a>2.6 刷新路由缓存</h2><p>在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/route-locator-intro/?self">《Spring-Cloud-Gateway 源码解析 —— 路由（2.1）之 RouteLocator 一览》「5. CachingRouteLocator」</a> 有详细解析。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>水更一篇，哈哈哈。</p><p><img src="http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_04_15/01.png" alt=""></p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-api/&quot;&gt;http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-a
      
    
    </summary>
    
      <category term="Spring-Cloud-Gateway" scheme="http://www.iocoder.cn/categories/Spring-Cloud-Gateway/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.10) 之 RequestRateLimiterGatewayFilterFactory 请求限流</title>
    <link href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-request-rate-limiter/"/>
    <id>http://www.iocoder.cn/Spring-Cloud-Gateway/filter-request-rate-limiter/</id>
    <published>2020-04-09T16:00:00.000Z</published>
    <updated>2017-12-01T16:41:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-request-rate-limiter/">http://www.iocoder.cn/Spring-Cloud-Gateway/filter-request-rate-limiter/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Spring-Cloud-Gateway 2.0.X M4</strong>  </p><ul><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/">2. 环境搭建</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/">3. RequestRateLimiterGatewayFilterFactory</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/">4. KeyResolver</a><ul><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/">4.1 PrincipalNameKeyResolver</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/">4.2 自定义 KeyResolver</a></li></ul></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/">5. RateLimiter</a><ul><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/">5.1 GatewayRedisAutoConfiguration</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/">5.2 RedisRateLimiter</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/">5.3 Redis Lua 脚本</a></li></ul></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>RequestRateLimiterGatewayFilterFactory 的代码实现</strong>。</p><p>在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-factory/?self">《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.2) 之 GatewayFilterFactory 过滤器工厂》</a> 一文中，我们看到 Spring Cloud Gateway 提供了多种 GatewayFilterFactory 的实现，而 RequestRateLimiterGatewayFilterFactory 也是其中的一种。</p><p>通过 RequestRateLimiterGatewayFilterFactory ，可以创建 RequestRateLimiterGatewayFilter ( 实际是内部匿名类，为了表述方便，下面继续这么称呼 ) 。</p><p>RequestRateLimiterGatewayFilter 使用 <strong>Redis + Lua</strong> 实现分布式限流。而限流的粒度，例如 URL / 用户 / IP 等，通过 <code>org.springframework.cloud.gateway.filter.ratelimit.KeyResolver</code> <strong>实现类</strong>决定，在 <a href="#">「4. KeyResolver」</a> 详细解析。</p><p>这里，笔者一本正经的推荐下自己分享的 <a href="http://www.iocoder.cn/Eureka/rate-limiter/?self">《Eureka 源码解析 —— 基于令牌桶算法的 RateLimiter》</a> ，简直业界良心。</p><hr><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2. 环境搭建"></a>2. 环境搭建</h1><p>第一步，以 <code>spring-cloud-gateway-sample</code> 项目为基础，在 <code>pom.xml</code> 文件添加依赖库。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis-reactive&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure><p>第二步，在 <code>application.yml</code> 配置<strong>一个</strong> RouteDefinition 。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  cloud:</span></div><div class="line"><span class="attr">    gateway:</span></div><div class="line"><span class="attr">      routes:</span></div><div class="line">      <span class="comment"># =====================================</span></div><div class="line"><span class="attr">      - id:</span> <span class="string">default_path_to_httpbin</span></div><div class="line"><span class="attr">        uri:</span> <span class="attr">http://127.0.0.1:8081</span></div><div class="line"><span class="attr">        order:</span> <span class="number">10000</span></div><div class="line"><span class="attr">        predicates:</span></div><div class="line"><span class="bullet">        -</span> <span class="string">Path=/**</span></div><div class="line"><span class="attr">        filters:</span></div><div class="line"><span class="bullet">        -</span> <span class="string">RequestRateLimiter=10,</span> <span class="number">20</span><span class="string">,</span> <span class="comment">#&#123;@principalNameKeyResolver&#125;</span></div></pre></td></tr></table></figure><ul><li><code>- RequestRateLimiter=10, 20, #{@principalNameKeyResolver}</code> ，配置 RequestRateLimiterGatewayFilterFactory 。 <ul><li>默认情况下，基于<strong>令牌桶算法</strong>实现限流。 </li><li>第一个参数，<code>burstCapacity</code> ，令牌桶上限 。</li><li>第二个参数，<code>replenishRate</code> ，令牌桶填充平均速率，单位：秒。</li><li>第三个参数，<code>keyResolver</code> ，限流<strong>键</strong>解析器 Bean 对象名字，根据 <code>#{@beanName}</code> ，使用 SpEL 表达式，从 Spring 容器中获取 Bean 对象，详细参见 <a href="https://github.com/spring-cloud/spring-cloud-gateway/blob/83496b78944269050373bb92bb2181e1b7c070e8/spring-cloud-gateway-core/src/main/java/org/springframework/cloud/gateway/route/RouteDefinitionRouteLocator.java#L182" rel="external nofollow noopener noreferrer" target="_blank"><code>RouteDefinitionRouteLocator#getTuple(ArgumentHints, Map&lt;String, String&gt;, SpelExpressionParser, BeanFactory)</code></a> 处的代码。另外，这里有一个 BUG ：在 YAML 里，<code>#</code> 代表注释，所以第三个参数无法正确被读取，需要等待官方修复。如果比较着急使用，可以考虑将此处的 <code>#</code> 修改成 <code>\#</code> ，并修改部分相关代码以解决该 BUG 。</li></ul></li></ul><p>第三步，配置完成，启动 <code>spring-cloud-gateway-sample</code> 项目。</p><blockquote><p><strong>友情提示</strong>，RequestRateLimiterGatewayFilter 使用了 RedisTemplate ，生产环境请配置。</p></blockquote><h1 id="3-RequestRateLimiterGatewayFilterFactory"><a href="#3-RequestRateLimiterGatewayFilterFactory" class="headerlink" title="3. RequestRateLimiterGatewayFilterFactory"></a>3. RequestRateLimiterGatewayFilterFactory</h1><p><code>org.springframework.cloud.gateway.filter.factory.RequestRateLimiterGatewayFilterFactory</code> ，请求限流网关过滤器<strong>工厂</strong>类。代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestRateLimiterGatewayFilterFactory</span> <span class="keyword">implements</span> <span class="title">GatewayFilterFactory</span> </span>&#123;</div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>: <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_RESOLVER_KEY = <span class="string">"keyResolver"</span>;</div><div class="line"> <span class="number">4</span>: </div><div class="line"> <span class="number">5</span>: <span class="keyword">private</span> <span class="keyword">final</span> RateLimiter rateLimiter;</div><div class="line"> <span class="number">6</span>: <span class="keyword">private</span> <span class="keyword">final</span> KeyResolver defaultKeyResolver;</div><div class="line"> <span class="number">7</span>: </div><div class="line"> <span class="number">8</span>: <span class="function"><span class="keyword">public</span> <span class="title">RequestRateLimiterGatewayFilterFactory</span><span class="params">(RateLimiter rateLimiter,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">9</span>: KeyResolver defaultKeyResolver)</span> </span>&#123;</div><div class="line"><span class="number">10</span>: <span class="keyword">this</span>.rateLimiter = rateLimiter;</div><div class="line"><span class="number">11</span>: <span class="keyword">this</span>.defaultKeyResolver = defaultKeyResolver;</div><div class="line"><span class="number">12</span>: &#125;</div><div class="line"><span class="number">13</span>: </div><div class="line"><span class="number">14</span>: <span class="meta">@Override</span></div><div class="line"><span class="number">15</span>: <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">argNames</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">16</span>:         <span class="keyword">return</span> Arrays.asList(</div><div class="line"><span class="number">17</span>:                 RedisRateLimiter.REPLENISH_RATE_KEY,</div><div class="line"><span class="number">18</span>:                 RedisRateLimiter.BURST_CAPACITY_KEY,</div><div class="line"><span class="number">19</span>:                 KEY_RESOLVER_KEY</div><div class="line"><span class="number">20</span>:         );</div><div class="line"><span class="number">21</span>: &#125;</div><div class="line"><span class="number">22</span>: </div><div class="line"><span class="number">23</span>: <span class="meta">@Override</span></div><div class="line"><span class="number">24</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateArgs</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">25</span>:  <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"><span class="number">26</span>: &#125;</div><div class="line"><span class="number">27</span>: </div><div class="line"><span class="number">28</span>: <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="number">29</span>: <span class="meta">@Override</span></div><div class="line"><span class="number">30</span>: <span class="function"><span class="keyword">public</span> GatewayFilter <span class="title">apply</span><span class="params">(Tuple args)</span> </span>&#123;</div><div class="line"><span class="number">31</span>:         validateMin(<span class="number">2</span>, args);</div><div class="line"><span class="number">32</span>: </div><div class="line"><span class="number">33</span>:         <span class="comment">// 获得 KeyResolver</span></div><div class="line"><span class="number">34</span>: KeyResolver keyResolver;</div><div class="line"><span class="number">35</span>: <span class="keyword">if</span> (args.hasFieldName(KEY_RESOLVER_KEY)) &#123;</div><div class="line"><span class="number">36</span>: keyResolver = args.getValue(KEY_RESOLVER_KEY, KeyResolver.class);</div><div class="line"><span class="number">37</span>: &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">38</span>: keyResolver = defaultKeyResolver;</div><div class="line"><span class="number">39</span>: &#125;</div><div class="line"><span class="number">40</span>: </div><div class="line"><span class="number">41</span>: <span class="keyword">return</span> (exchange, chain) -&gt; keyResolver.resolve(exchange).flatMap(key -&gt;</div><div class="line"><span class="number">42</span>:             <span class="comment">// <span class="doctag">TODO:</span> if key is empty?</span></div><div class="line"><span class="number">43</span>:             rateLimiter.isAllowed(key, args).flatMap(response -&gt; &#123;</div><div class="line"><span class="number">44</span>:                 <span class="comment">// <span class="doctag">TODO:</span> set some headers for rate, tokens left</span></div><div class="line"><span class="number">45</span>: </div><div class="line"><span class="number">46</span>:                 <span class="comment">// 允许访问</span></div><div class="line"><span class="number">47</span>:                 <span class="keyword">if</span> (response.isAllowed()) &#123;</div><div class="line"><span class="number">48</span>:                     <span class="keyword">return</span> chain.filter(exchange);</div><div class="line"><span class="number">49</span>:                 &#125;</div><div class="line"><span class="number">50</span>: </div><div class="line"><span class="number">51</span>:                 <span class="comment">// 被限流，不允许访问</span></div><div class="line"><span class="number">52</span>:                 exchange.getResponse().setStatusCode(HttpStatus.TOO_MANY_REQUESTS);</div><div class="line"><span class="number">53</span>:                 <span class="keyword">return</span> exchange.getResponse().setComplete();</div><div class="line"><span class="number">54</span>:             &#125;));</div><div class="line"><span class="number">55</span>: &#125;</div><div class="line"><span class="number">56</span>: </div><div class="line"><span class="number">57</span>: &#125;</div></pre></td></tr></table></figure><ul><li><code>rateLimiter</code> 属性，限流器。默认情况下，使用 RedisRateLimiter 。</li><li><code>defaultKeyResolver</code> 属性，默认限流<strong>键</strong>解析器。默认情况下，使用 PrincipalNameKeyResolver 。</li><li><code>#argNames()</code> 方法，定义了 Tuple 参数的 Key 为 <code>replenishRate</code> / <code>burstCapacity</code> / <code>keyResolver</code> 。</li><li><code>#validateArgs()</code> 方法，定义在 <a href="https://github.com/spring-cloud/spring-cloud-gateway/blob/83496b78944269050373bb92bb2181e1b7c070e8/spring-cloud-gateway-core/src/main/java/org/springframework/cloud/gateway/route/RouteDefinitionRouteLocator.java#L182" rel="external nofollow noopener noreferrer" target="_blank"><code>RouteDefinitionRouteLocator#getTuple(ArgumentHints, Map&lt;String, String&gt;, SpelExpressionParser, BeanFactory)</code></a> 无需校验 Tuple 结果。因为 <code>keyResolver</code> 非必填项，在 <code>#apply()</code> 方法，创建 RequestRateLimiterGatewayFilter 时<strong>校验</strong>。</li><li><code>#apply()</code> 方法，创建 RequestRateLimiterGatewayFilter 对象。</li><li>第 31 行 ：校验 Tuple 参数至少有两个元素，即 <code>replenishRate</code> 和 <code>burstCapacity</code> 。而 <code>keyResolver</code> 是<strong>选填</strong>，为空时，使用默认值 <code>defaultKeyResolver</code> 。</li><li>第 34 至 39 行 ：获得 <code>keyResolver</code> 。通过它，获得请求的限流<strong>键</strong>，例如URL / 用户 / IP 等。</li><li>——— 第 41 至 54 行 ：<strong>创建 RequestRateLimiterGatewayFilter 对象并返回</strong>。</li><li>第 41 行 ：调用 <code>KeyResolver#resolve(ServerWebExchange)</code> 方法，获得请求的限流<strong>键</strong>。<ul><li><strong>注意下</strong>，这里未处理限流<strong>键</strong>为空的情况( <code>TODO: if key is empty?</code> )。所以，当限流<strong>键</strong>为空时，过滤器链不会继续向下执行，也就是说，不会请求后端 Http / Websocket 服务，并且最终返回客户端 <strong>200</strong> 状态码，内容为<strong>空</strong>。</li></ul></li><li>第 43 至 54 行 ：调用 <code>RateLimiter#isAllowed(ServerWebExchange, Tuple)</code> 方法，判断是否被限流。<ul><li>第 47 至 49 行 ：<strong>未</strong>被限流，允许访问，提交过滤器链继续过滤。</li><li>第 52 至 53 行 ：被限流， <strong>不</strong>允许访问，设置响应 429 状态码，并回写客户端<strong>响应</strong>( <code>exchange.getResponse().setComplete()</code> ) 。</li></ul></li></ul><h1 id="4-KeyResolver"><a href="#4-KeyResolver" class="headerlink" title="4. KeyResolver"></a>4. KeyResolver</h1><p><code>org.springframework.cloud.gateway.filter.ratelimit.KeyResolver</code> ，请求<strong>键</strong>解析器<strong>接口</strong>。代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">KeyResolver</span> </span>&#123;</div><div class="line"><span class="function">Mono&lt;String&gt; <span class="title">resolve</span><span class="params">(ServerWebExchange exchange)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>KeyResolver#resolve(ServerWebExchange)</code> 方法，获得请求的限流<strong>键</strong>。</li></ul><p>通过实现 KeyResolver 接口，实现获得不同的请求的限流<strong>键</strong>，例如URL / 用户 / IP 等。</p><p>目前版本，Spring Cloud Gateway 提供的 KeyResolver 实现类只有 PrincipalNameKeyResolver 。据官方说法，在未来的里程碑版本中，将会有一些 KeyResolver 具体实现类。</p><h2 id="4-1-PrincipalNameKeyResolver"><a href="#4-1-PrincipalNameKeyResolver" class="headerlink" title="4.1 PrincipalNameKeyResolver"></a>4.1 PrincipalNameKeyResolver</h2><p><code>org.springframework.cloud.gateway.filter.ratelimit.PrincipalNameKeyResolver</code> ，使用请求认证的 <code>java.security.Principal</code> 作为限流<strong>键</strong>。代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrincipalNameKeyResolver</span> <span class="keyword">implements</span> <span class="title">KeyResolver</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEAN_NAME = <span class="string">"principalNameKeyResolver"</span>;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Mono&lt;String&gt; <span class="title">resolve</span><span class="params">(ServerWebExchange exchange)</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> exchange.getPrincipal().map(Principal::getName).switchIfEmpty(Mono.empty());</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="4-2-自定义-KeyResolver"><a href="#4-2-自定义-KeyResolver" class="headerlink" title="4.2 自定义 KeyResolver"></a>4.2 自定义 KeyResolver</h2><p>通过实现 KeyResolver 接口，实现自定义 KeyResolver 。下面我们实现一个使用请求 IP 作为限流<strong>键</strong>的 KeyResolver 。</p><p>第一步，创建 RemoteAddrKeyResolver 类，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteAddrKeyResolver</span> <span class="keyword">implements</span> <span class="title">KeyResolver</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEAN_NAME = <span class="string">"remoteAddrKeyResolver"</span>;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Mono&lt;String&gt; <span class="title">resolve</span><span class="params">(ServerWebExchange exchange)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Mono.just(exchange.getRequest().getRemoteAddress().getAddress().getHostAddress());</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>第二步，配置 RemoteAddrKeyResolver Bean 对象，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Bean</span>(name = RemoteAddrKeyResolver.BEAN_NAME)</div><div class="line"><span class="meta">@ConditionalOnBean</span>(RateLimiter.class)</div><div class="line"><span class="function"><span class="keyword">public</span> RemoteAddrKeyResolver <span class="title">remoteAddrKeyResolver</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RemoteAddrKeyResolver();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>第三步，配置 RouteDefinition 路由配置，配置如下 ：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  cloud:</span></div><div class="line"><span class="attr">    gateway:</span></div><div class="line"><span class="attr">      routes:</span></div><div class="line">      <span class="comment"># =====================================</span></div><div class="line"><span class="attr">      - id:</span> <span class="string">default_path_to_httpbin</span></div><div class="line"><span class="attr">        uri:</span> <span class="attr">http://127.0.0.1:8081</span></div><div class="line"><span class="attr">        order:</span> <span class="number">10000</span></div><div class="line"><span class="attr">        predicates:</span></div><div class="line"><span class="bullet">        -</span> <span class="string">Path=/**</span></div><div class="line"><span class="attr">        filters:</span></div><div class="line"><span class="bullet">        -</span> <span class="string">RequestRateLimiter=10,</span> <span class="number">20</span><span class="string">,</span> <span class="comment">#&#123;@remoteAddrKeyResolver&#125;</span></div></pre></td></tr></table></figure><p>第四步，<strong>大功告成</strong>，启动 Spring Cloud Gateway 即可。</p><p>另外，推荐 <a href="https://mp.weixin.qq.com/s?__biz=MzI4ODQ3NjE2OA==&amp;mid=2247483811&amp;idx=1&amp;sn=16fe7e25a90635e93c60048ebe8b40a2&amp;chksm=ec3c9cc4db4b15d2937fb8b2ef571c941b2bb9fefcf5ed8232e3699b4868392022a62b963699&amp;mpshare=1&amp;scene=1&amp;srcid=1201O46Ma9D5ln5TuxHUgziY#rd" rel="external nofollow noopener noreferrer" target="_blank">《周立 —— Spring Cloud限流详解（附源码）》</a>，里面有一些限流维度的分析。</p><h1 id="5-RateLimiter"><a href="#5-RateLimiter" class="headerlink" title="5. RateLimiter"></a>5. RateLimiter</h1><p><code>org.springframework.cloud.gateway.filter.ratelimit.RateLimiter</code> ，限流器<strong>接口</strong>。代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RateLimiter</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function">Mono&lt;Response&gt; <span class="title">isAllowed</span><span class="params">(String id, Tuple args)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>#isAllowed(String id, Tuple args)</code> 方法，判断是否被限流。</li><li><p>Response 类，代码如下 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Response</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 是否允许访问( 未被限流 )</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> allowed;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 令牌桶剩余数量</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> tokensRemaining;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Response</span><span class="params">(<span class="keyword">boolean</span> allowed, <span class="keyword">long</span> tokensRemaining)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.allowed = allowed;</div><div class="line"><span class="keyword">this</span>.tokensRemaining = tokensRemaining;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h2 id="5-1-GatewayRedisAutoConfiguration"><a href="#5-1-GatewayRedisAutoConfiguration" class="headerlink" title="5.1 GatewayRedisAutoConfiguration"></a>5.1 GatewayRedisAutoConfiguration</h2><p><code>org.springframework.cloud.gateway.config.GatewayRedisAutoConfiguration</code> ，Redis 相关配置类，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Configuration</span></div><div class="line"> <span class="number">2</span>: <span class="meta">@AutoConfigureAfter</span>(RedisReactiveAutoConfiguration.class)</div><div class="line"> <span class="number">3</span>: <span class="meta">@AutoConfigureBefore</span>(GatewayAutoConfiguration.class)</div><div class="line"> <span class="number">4</span>: <span class="meta">@ConditionalOnBean</span>(ReactiveRedisTemplate.class)</div><div class="line"> <span class="number">5</span>: <span class="meta">@ConditionalOnClass</span>(&#123;RedisTemplate.class, DispatcherHandler.class&#125;)</div><div class="line"> <span class="number">6</span>: <span class="class"><span class="keyword">class</span> <span class="title">GatewayRedisAutoConfiguration</span> </span>&#123;</div><div class="line"> <span class="number">7</span>: </div><div class="line"> <span class="number">8</span>: <span class="meta">@Bean</span></div><div class="line"> <span class="number">9</span>: <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="number">10</span>: <span class="function"><span class="keyword">public</span> RedisScript <span class="title">redisRequestRateLimiterScript</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">11</span>: DefaultRedisScript redisScript = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;();</div><div class="line"><span class="number">12</span>: redisScript.setScriptSource(<span class="keyword">new</span> ResourceScriptSource(<span class="keyword">new</span> ClassPathResource(<span class="string">"META-INF/scripts/request_rate_limiter.lua"</span>)));</div><div class="line"><span class="number">13</span>: redisScript.setResultType(List.class);</div><div class="line"><span class="number">14</span>: <span class="keyword">return</span> redisScript;</div><div class="line"><span class="number">15</span>: &#125;</div><div class="line"><span class="number">16</span>: </div><div class="line"><span class="number">17</span>: <span class="meta">@Bean</span></div><div class="line"><span class="number">18</span>: <span class="comment">//<span class="doctag">TODO:</span> replace with ReactiveStringRedisTemplate in future</span></div><div class="line"><span class="number">19</span>: <span class="function"><span class="keyword">public</span> ReactiveRedisTemplate&lt;String, String&gt; <span class="title">stringReactiveRedisTemplate</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params"><span class="number">20</span>: ReactiveRedisConnectionFactory reactiveRedisConnectionFactory,</span></span></div><div class="line"><span class="function"><span class="params"><span class="number">21</span>: ResourceLoader resourceLoader)</span> </span>&#123;</div><div class="line"><span class="number">22</span>: RedisSerializer&lt;String&gt; serializer = <span class="keyword">new</span> StringRedisSerializer();</div><div class="line"><span class="number">23</span>: RedisSerializationContext&lt;String , String&gt; serializationContext = RedisSerializationContext</div><div class="line"><span class="number">24</span>: .&lt;String, String&gt;newSerializationContext()</div><div class="line"><span class="number">25</span>: .key(serializer)</div><div class="line"><span class="number">26</span>: .value(serializer)</div><div class="line"><span class="number">27</span>: .hashKey(serializer)</div><div class="line"><span class="number">28</span>: .hashValue(serializer)</div><div class="line"><span class="number">29</span>: .build();</div><div class="line"><span class="number">30</span>: <span class="keyword">return</span> <span class="keyword">new</span> ReactiveRedisTemplate&lt;&gt;(reactiveRedisConnectionFactory,</div><div class="line"><span class="number">31</span>: serializationContext);</div><div class="line"><span class="number">32</span>: &#125;</div><div class="line"><span class="number">33</span>: </div><div class="line"><span class="number">34</span>: <span class="meta">@Bean</span></div><div class="line"><span class="number">35</span>: <span class="function"><span class="keyword">public</span> RedisRateLimiter <span class="title">redisRateLimiter</span><span class="params">(ReactiveRedisTemplate&lt;String, String&gt; redisTemplate,</span></span></div><div class="line"><span class="function"><span class="params"><span class="number">36</span>:  @Qualifier(<span class="string">"redisRequestRateLimiterScript"</span>)</span> RedisScript&lt;List&lt;Long&gt;&gt; redisScript) </span>&#123;</div><div class="line"><span class="number">37</span>: <span class="keyword">return</span> <span class="keyword">new</span> RedisRateLimiter(redisTemplate, redisScript);</div><div class="line"><span class="number">38</span>: &#125;</div><div class="line"><span class="number">39</span>: </div><div class="line"><span class="number">40</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 8 至 15 行 ：创建 <code>org.springframework.data.redis.core.script.RedisScript</code> Bean 对象，加载 <code>META-INF/scripts/request_rate_limiter.lua</code> 路径下的 Redis Lua 脚本。该脚本使用 Redis 基于<strong>令牌桶算法</strong>实现限流。在本文 <a href="#">「Redis Lua 脚本」</a> 详细解析。 </li><li>第 17 至 32 行 ：创建 <code>org.springframework.data.redis.core.ReactiveRedisTemplate</code> Bean 对象。</li><li>第 34 至 38 行 ：使用 RedisScript 和 ReactiveRedisTemplate Bean 对象，创建 RedisRateLimiter Bean 对象。</li></ul><h2 id="5-2-RedisRateLimiter"><a href="#5-2-RedisRateLimiter" class="headerlink" title="5.2 RedisRateLimiter"></a>5.2 RedisRateLimiter</h2><p><code>org.springframework.cloud.gateway.filter.ratelimit.RedisRateLimiter</code> ，基于 Redis 的分布式限流器<strong>实现类</strong>。</p><p><strong>构造方法</strong>，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisRateLimiter</span> <span class="keyword">implements</span> <span class="title">RateLimiter</span> </span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REPLENISH_RATE_KEY = <span class="string">"replenishRate"</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BURST_CAPACITY_KEY = <span class="string">"burstCapacity"</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReactiveRedisTemplate&lt;String, String&gt; redisTemplate;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> RedisScript&lt;List&lt;Long&gt;&gt; script;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">RedisRateLimiter</span><span class="params">(ReactiveRedisTemplate&lt;String, String&gt; redisTemplate,</span></span></div><div class="line"><span class="function"><span class="params">RedisScript&lt;List&lt;Long&gt;&gt; script)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.redisTemplate = redisTemplate;</div><div class="line"><span class="keyword">this</span>.script = script;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>redisTemplate</code> 属性，RedisTemplate 。</li><li><code>script</code> 属性，Lua 脚本。</li></ul><hr><p><code>#isAllowed(id, Tuple)</code> ，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> Mono&lt;Response&gt; <span class="title">isAllowed</span><span class="params">(String id, Tuple args)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>: <span class="comment">// How many requests per second do you want a user to be allowed to do?</span></div><div class="line"> <span class="number">3</span>: <span class="keyword">int</span> replenishRate = args.getInt(REPLENISH_RATE_KEY);</div><div class="line"> <span class="number">4</span>: </div><div class="line"> <span class="number">5</span>: <span class="comment">// How much bursting do you want to allow?</span></div><div class="line"> <span class="number">6</span>: <span class="keyword">int</span> burstCapacity;</div><div class="line"> <span class="number">7</span>: <span class="keyword">if</span> (args.hasFieldName(BURST_CAPACITY_KEY)) &#123;</div><div class="line"> <span class="number">8</span>: burstCapacity = args.getInt(BURST_CAPACITY_KEY);</div><div class="line"> <span class="number">9</span>: &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">10</span>: burstCapacity = <span class="number">0</span>;</div><div class="line"><span class="number">11</span>: &#125;</div><div class="line"><span class="number">12</span>: </div><div class="line"><span class="number">13</span>: <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">14</span>: <span class="comment">// Make a unique key per user.</span></div><div class="line"><span class="number">15</span>: String prefix = <span class="string">"request_rate_limiter."</span> + id;</div><div class="line"><span class="number">16</span>: </div><div class="line"><span class="number">17</span>: <span class="comment">// You need two Redis keys for Token Bucket.</span></div><div class="line"><span class="number">18</span>: List&lt;String&gt; keys = Arrays.asList(prefix + <span class="string">".tokens"</span>, prefix + <span class="string">".timestamp"</span>);</div><div class="line"><span class="number">19</span>: </div><div class="line"><span class="number">20</span>: <span class="comment">// The arguments to the LUA script. time() returns unixtime in seconds.</span></div><div class="line"><span class="number">21</span>: List&lt;String&gt; scriptArgs = Arrays.asList(replenishRate + <span class="string">""</span>, burstCapacity + <span class="string">""</span>,</div><div class="line"><span class="number">22</span>:  Instant.now().getEpochSecond() + <span class="string">""</span>, <span class="string">"1"</span>);</div><div class="line"><span class="number">23</span>: <span class="comment">// allowed, tokens_left = redis.eval(SCRIPT, keys, args)</span></div><div class="line"><span class="number">24</span>: Flux&lt;List&lt;Long&gt;&gt; flux = <span class="keyword">this</span>.redisTemplate.execute(<span class="keyword">this</span>.script, keys, scriptArgs);</div><div class="line"><span class="number">25</span>: <span class="comment">// .log("redisratelimiter", Level.FINER);</span></div><div class="line"><span class="number">26</span>: <span class="keyword">return</span> flux</div><div class="line"><span class="number">27</span>: <span class="comment">// Throwable =&gt; Flux.just(Arrays.asList(1L, -1L)) 。</span></div><div class="line"><span class="number">28</span>: .onErrorResume(throwable -&gt; Flux.just(Arrays.asList(<span class="number">1L</span>, -<span class="number">1L</span>)))</div><div class="line"><span class="number">29</span>: <span class="comment">// Flux&lt;List&lt;Long&gt;&gt; =&gt; Mono&lt;List&lt;Long&gt;&gt;</span></div><div class="line"><span class="number">30</span>: .reduce(<span class="keyword">new</span> ArrayList&lt;Long&gt;(), (longs, l) -&gt; &#123;</div><div class="line"><span class="number">31</span>: longs.addAll(l);</div><div class="line"><span class="number">32</span>: <span class="keyword">return</span> longs;</div><div class="line"><span class="number">33</span>: &#125;)</div><div class="line"><span class="number">34</span>: <span class="comment">// Mono&lt;List&lt;Long&gt;&gt; =&gt; Mono&lt;Response&gt;</span></div><div class="line"><span class="number">35</span>: .map(results -&gt; &#123;</div><div class="line"><span class="number">36</span>: <span class="keyword">boolean</span> allowed = results.get(<span class="number">0</span>) == <span class="number">1L</span>;</div><div class="line"><span class="number">37</span>: Long tokensLeft = results.get(<span class="number">1</span>);</div><div class="line"><span class="number">38</span>: </div><div class="line"><span class="number">39</span>: Response response = <span class="keyword">new</span> Response(allowed, tokensLeft);</div><div class="line"><span class="number">40</span>: </div><div class="line"><span class="number">41</span>: <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</div><div class="line"><span class="number">42</span>: log.debug(<span class="string">"response: "</span> + response);</div><div class="line"><span class="number">43</span>: &#125;</div><div class="line"><span class="number">44</span>: <span class="keyword">return</span> response;</div><div class="line"><span class="number">45</span>: &#125;);</div><div class="line"><span class="number">46</span>: &#125;</div><div class="line"><span class="number">47</span>: <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"><span class="number">48</span>: <span class="comment">/*</span></div><div class="line"><span class="comment">49:  * We don't want a hard dependency on Redis to allow traffic. Make sure to set</span></div><div class="line"><span class="comment">50:  * an alert so you know if this is happening too much. Stripe's observed</span></div><div class="line"><span class="comment">51:  * failure rate is 0.01%.</span></div><div class="line"><span class="comment">52:  */</span></div><div class="line"><span class="number">53</span>: log.error(<span class="string">"Error determining if user allowed from redis"</span>, e);</div><div class="line"><span class="number">54</span>: &#125;</div><div class="line"><span class="number">55</span>: <span class="keyword">return</span> Mono.just(<span class="keyword">new</span> Response(<span class="keyword">true</span>, -<span class="number">1</span>));</div><div class="line"><span class="number">56</span>: &#125;</div></pre></td></tr></table></figure><ul><li><code>id</code> 方法参数，令牌桶编号。一个令牌桶编号对应令牌桶。<ul><li>在本文场景中为请求限流<strong>键</strong>。</li></ul></li><li>第 3 行 ：获得 <code>burstCapacity</code> 令牌桶上限。</li><li>第 5 至 11 行 ：获得 <code>replenishRate</code> ，令牌桶填充平均速率，单位：秒。</li><li>第 15 行 ：获得令牌桶前缀，<code>request_rate_limiter.${id}</code> 。</li><li>第 18 行 ：获得令牌桶键数组 ：<ul><li><code>request_rate_limiter.${id}.tokens</code> ：令牌桶<strong>剩余</strong>令牌数。</li><li><code>request_rate_limiter.${id}.timestamp</code> ：令牌桶<strong>最后</strong>填充令牌时间，单位：秒。</li></ul></li><li><p>第 21 至 22 行 ：获得 Lua 脚本参数 ：</p><ul><li>第一个参数 ：<code>replenishRate</code> 。</li><li>第二个参数 ：<code>burstCapacity</code> 。</li><li><p>第三个参数 ：得到从 <code>1970-01-01 00:00:00</code> 开始的秒数。<strong>为什么在 Java 代码里获取，而不使用 Lua 在 Reids 里获取</strong>？</p><blockquote><p>FROM <a href="https://union-click.jd.com/jdc?d=pT3LH8" rel="external nofollow noopener noreferrer" target="_blank">《亿级流量网站架构核心技术》</a><br>因为 Redis 的限制（ Lua中有写操作不能使用带随机性质的读操作，如TIME ）不能在 Redis Lua中 使用 TIME 获取时间戳，因此只好从应用获取然后传入，在某些极端情况下（机器时钟不准的情况下），限流会存在一些小问题。</p><ul><li>涛哥这本书非常不错，推荐购买。</li></ul></blockquote></li><li><p>第四个参数 ：消耗令牌数量，默认 1 。</p></li></ul></li><li><p>第 24 行 ：调用 <code>ReactiveRedisTemplate#execute(RedisScript&lt;T&gt;, List&lt;K&gt;, List&lt;?&gt;)</code> 方法，执行 Redis Lua 脚本，获取令牌。返回结果为 <code>[是否获取令牌成功, 剩余令牌数]</code> ，其中，<code>1</code> 代表获取令牌<strong>成功</strong>，<code>0</code> 代表令牌获取<strong>失败</strong>。</p></li><li><p>第 25 行 ：当 Redis Lua 脚本过程中发生<strong>异常</strong>，忽略异常，返回 <code>Flux.just(Arrays.asList(1L, -1L))</code> ，即认为<strong>获取令牌成功</strong>。为什么？在 Redis 发生故障时，我们不希望限流器对 Reids 是<strong>强依赖</strong>，并且 Redis 发生故障的概率本身就很低。</p><blockquote><p>We don’t want a hard dependency on Redis to allow traffic.<br>Make sure to set an alert so you know if this is happening too much. Stripe’s observed failure rate is 0.01%.</p></blockquote></li><li><p>第 30 至 33 行 ：调用 <code>Flux#reduce(A, BiFunction&lt;A, ? super T, A&gt;)</code> 方法，将 <code>Flux&lt;List&lt;Long&gt;&gt;</code> 转换成 <code>Mono&lt;List&lt;Long&gt;&gt;</code> 。因为 <code>ReactiveRedisTemplate#execute(RedisScript&lt;T&gt;, List&lt;K&gt;, List&lt;?&gt;)</code> 方法的执行结果为 Flux ( 多次 )，实际在当前场景里，自行 Redis Lua 脚本只会返回<strong>一次</strong>数组，所以转换成 Mono (一次)。</p></li><li>第 35 至 45 行 ：调用 <code>Mono#map(Function&lt;? super T, ? extends R&gt;)</code> 方法，将 <code>Mono&lt;List&lt;Long&gt;&gt;</code> =&gt; <code>Mono&lt;Response&gt;</code> 。</li><li>第 47 至 55 行 ：当【第 15 至 24 行】代码部分执行发生异常时，例如 Redis 挂了，返回 <code>Flux.just(Arrays.asList(1L, -1L))</code> ，即认为<strong>获取令牌成功</strong>。</li></ul><h2 id="5-3-Redis-Lua-脚本"><a href="#5-3-Redis-Lua-脚本" class="headerlink" title="5.3 Redis Lua 脚本"></a>5.3 Redis Lua 脚本</h2><p><code>META-INF/scripts/request_rate_limiter.lua</code> ，Redis Lua 脚本，实现基于<strong>令牌桶算法</strong>实现限流。代码如下 ：</p><figure class="highlight lua"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">local</span> tokens_key = KEYS[<span class="number">1</span>]</div><div class="line"> <span class="number">2</span>: <span class="keyword">local</span> timestamp_key = KEYS[<span class="number">2</span>]</div><div class="line"> <span class="number">3</span>: </div><div class="line"> <span class="number">4</span>: <span class="keyword">local</span> rate = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</div><div class="line"> <span class="number">5</span>: <span class="keyword">local</span> capacity = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])</div><div class="line"> <span class="number">6</span>: <span class="keyword">local</span> now = <span class="built_in">tonumber</span>(ARGV[<span class="number">3</span>])</div><div class="line"> <span class="number">7</span>: <span class="keyword">local</span> requested = <span class="built_in">tonumber</span>(ARGV[<span class="number">4</span>])</div><div class="line"> <span class="number">8</span>: </div><div class="line"> <span class="number">9</span>: <span class="keyword">local</span> fill_time = capacity/rate</div><div class="line"><span class="number">10</span>: <span class="keyword">local</span> ttl = <span class="built_in">math</span>.<span class="built_in">floor</span>(fill_time*<span class="number">2</span>)</div><div class="line"><span class="number">11</span>: </div><div class="line"><span class="number">12</span>: <span class="keyword">local</span> last_tokens = <span class="built_in">tonumber</span>(redis.call(<span class="string">"get"</span>, tokens_key))</div><div class="line"><span class="number">13</span>: <span class="keyword">if</span> last_tokens == <span class="literal">nil</span> <span class="keyword">then</span></div><div class="line"><span class="number">14</span>:   last_tokens = capacity</div><div class="line"><span class="number">15</span>: <span class="keyword">end</span></div><div class="line"><span class="number">16</span>: </div><div class="line"><span class="number">17</span>: <span class="keyword">local</span> last_refreshed = <span class="built_in">tonumber</span>(redis.call(<span class="string">"get"</span>, timestamp_key))</div><div class="line"><span class="number">18</span>: <span class="keyword">if</span> last_refreshed == <span class="literal">nil</span> <span class="keyword">then</span></div><div class="line"><span class="number">19</span>:   last_refreshed = <span class="number">0</span></div><div class="line"><span class="number">20</span>: <span class="keyword">end</span></div><div class="line"><span class="number">21</span>: </div><div class="line"><span class="number">22</span>: <span class="keyword">local</span> delta = <span class="built_in">math</span>.<span class="built_in">max</span>(<span class="number">0</span>, now-last_refreshed)</div><div class="line"><span class="number">23</span>: <span class="keyword">local</span> filled_tokens = <span class="built_in">math</span>.<span class="built_in">min</span>(capacity, last_tokens+(delta*rate))</div><div class="line"><span class="number">24</span>: <span class="keyword">local</span> allowed = filled_tokens &gt;= requested</div><div class="line"><span class="number">25</span>: <span class="keyword">local</span> new_tokens = filled_tokens</div><div class="line"><span class="number">26</span>: <span class="keyword">local</span> allowed_num = <span class="number">0</span></div><div class="line"><span class="number">27</span>: <span class="keyword">if</span> allowed <span class="keyword">then</span></div><div class="line"><span class="number">28</span>:   new_tokens = filled_tokens - requested</div><div class="line"><span class="number">29</span>:   allowed_num = <span class="number">1</span></div><div class="line"><span class="number">30</span>: <span class="keyword">end</span></div><div class="line"><span class="number">31</span>: </div><div class="line"><span class="number">32</span>: redis.call(<span class="string">"setex"</span>, tokens_key, ttl, new_tokens)</div><div class="line"><span class="number">33</span>: redis.call(<span class="string">"setex"</span>, timestamp_key, ttl, now)</div><div class="line"><span class="number">34</span>: </div><div class="line"><span class="number">35</span>: <span class="keyword">return</span> &#123; allowed_num, new_tokens &#125;</div></pre></td></tr></table></figure><ul><li>第 1 至 2 行 ：KEYS 方法参数 ：<ul><li>第一个参数 ：<code>request_rate_limiter.${id}.tokens</code> ，令牌桶<strong>剩余</strong>令牌数。</li><li>第二个参数 ：<code>request_rate_limiter.${id}.timestamp</code> ，令牌桶<strong>最后</strong>填充令牌时间，单位：秒。</li></ul></li><li><p>第 4 至 7 行 ：ARGV 方法参数 ：</p><ul><li>第一个参数 ：<code>replenishRate</code> 。</li><li>第二个参数 ：<code>burstCapacity</code> 。</li><li>第三个参数 ：得到从 <code>1970-01-01 00:00:00</code> 开始的秒数。</li><li>第四个参数 ：消耗令牌数量，默认 1 。</li></ul></li><li><p>第 9 行 ：计算令牌桶填充<strong>满</strong>令牌需要多久时间，单位：秒。</p></li><li>第 10 行 ：计算 <code>request_rate_limiter.${id}.tokens</code> / <code>request_rate_limiter.${id}.timestamp</code> 的 <strong>ttl</strong> 。<code>* 2</code> 保证时间充足。</li><li>第 12 至 20 行 ：调用 <code>get</code> 命令，获得令牌桶<strong>剩余</strong>令牌数( <code>last_tokens</code> ) ，令牌桶<strong>最后</strong>填充令牌时间(<code>last_refreshed</code>) 。</li><li>第 22 至 23 行 ：填充令牌，计算<strong>新</strong>的令牌桶<strong>剩余</strong>令牌数( <code>filled_tokens</code> )。填充不超过令牌桶令牌<strong>上限</strong>。</li><li><p>第 24 至 30 行 ：获取令牌是否成功。</p><ul><li>若<strong>成功</strong>，令牌桶<strong>剩余</strong>令牌数(<code>new_tokens</code>) <strong>减</strong>消耗令牌数( <code>requested</code> )，并设置获取成功( <code>allowed_num = 1</code> ) 。</li><li>若<strong>失败</strong>，设置获取失败( <code>allowed_num = 0</code> ) 。</li></ul></li><li><p>第 32 至 33 行 ：设置令牌桶<strong>剩余</strong>令牌数( <code>new_tokens</code> ) ，令牌桶<strong>最后</strong>填充令牌时间(<code>now</code>) 。</p></li><li>第 35 行 ：返回数组结果，<code>[是否获取令牌成功, 剩余令牌数]</code> 。</li></ul><p><strong>Redis Lua 脚本不会有并发问题么</strong>？</p><blockquote><p>FROM <a href="https://union-click.jd.com/jdc?d=pT3LH8" rel="external nofollow noopener noreferrer" target="_blank">《亿级流量网站架构核心技术》</a><br>因 Redis 是单线程模型，因此是线程安全的。</p></blockquote><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>哇哈哈，过滤器全部完成。恩，当然后面需要在考虑一下，例如认证过滤器等等。</p><p><img src="http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_04_10/01.png" alt=""></p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Spring-Cloud-Gateway/filter-request-rate-limiter/&quot;&gt;http://www.iocoder.cn/Spring-Cloud-Gateway/fil
      
    
    </summary>
    
      <category term="Spring-Cloud-Gateway" scheme="http://www.iocoder.cn/categories/Spring-Cloud-Gateway/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.9) 之 HystrixGatewayFilterFactory 熔断</title>
    <link href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/"/>
    <id>http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/</id>
    <published>2020-04-04T16:00:00.000Z</published>
    <updated>2017-12-01T16:41:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/">http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Spring-Cloud-Gateway 2.0.X M4</strong>  </p><ul><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/">2. 环境搭建</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/">3. HystrixGatewayFilterFactory</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/">4. 注意事项</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>HystrixGatewayFilterFactory 的代码实现</strong>。</p><p>在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-factory/?self">《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.2) 之 GatewayFilterFactory 过滤器工厂》</a> 一文中，我们看到 Spring Cloud Gateway 提供了多种 GatewayFilterFactory 的实现，而 HystrixGatewayFilterFactory 也是其中的一种。</p><p>通过 HystrixGatewayFilterFactory ，可以创建 HystrixGatewayFilter ( 实际是内部匿名类，为了表述方便，下面继续这么称呼 ) 。</p><p>HystrixGatewayFilter 使用 <a href="https://github.com/Netflix/Hystrix" rel="external nofollow noopener noreferrer" target="_blank">Hystrix</a> ，实现基于 <strong>Route</strong> 级别的熔断功能。</p><p>这里，笔者一本正经的推荐下自己分享的 <a href="http://www.iocoder.cn/categories/Hystrix/?self">《Hystrix 源码解析系列》</a> ，简直业界良心。</p><hr><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2. 环境搭建"></a>2. 环境搭建</h1><p>第一步，以 <code>spring-cloud-gateway-sample</code> 项目为基础，在 <code>pom.xml</code> 文件添加依赖库。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure><p>第二步，在 <code>application.yml</code> 配置<strong>一个</strong> RouteDefinition 。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  cloud:</span></div><div class="line"><span class="attr">    gateway:</span></div><div class="line"><span class="attr">      routes:</span></div><div class="line">      <span class="comment"># =====================================</span></div><div class="line"><span class="attr">      - id:</span> <span class="string">default_path_to_httpbin</span></div><div class="line"><span class="attr">        uri:</span> <span class="attr">http://127.0.0.1:8081</span></div><div class="line"><span class="attr">        order:</span> <span class="number">10000</span></div><div class="line"><span class="attr">        predicates:</span></div><div class="line"><span class="bullet">        -</span> <span class="string">Path=/**</span></div><div class="line"><span class="attr">        filters:</span></div><div class="line"><span class="bullet">        -</span> <span class="string">Hystrix=myCommandName</span></div></pre></td></tr></table></figure><ul><li><code>- Hystrix=myCommandName</code> ，配置 HystrixGatewayFilterFactory ，并以 <code>myCommandName</code> 为 <strong>Hystrix Command 名字</strong>。</li></ul><p>第三步，配置完成，启动 <code>spring-cloud-gateway-sample</code> 项目。</p><h1 id="3-HystrixGatewayFilterFactory"><a href="#3-HystrixGatewayFilterFactory" class="headerlink" title="3. HystrixGatewayFilterFactory"></a>3. HystrixGatewayFilterFactory</h1><p><code>org.springframework.cloud.gateway.filter.factory.HystrixGatewayFilterFactory</code> ，熔断网关过滤器<strong>工厂</strong>。代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixGatewayFilterFactory</span> <span class="keyword">implements</span> <span class="title">GatewayFilterFactory</span> </span>&#123;</div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">4</span>: <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">argNames</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">5</span>: <span class="keyword">return</span> Arrays.asList(NAME_KEY);</div><div class="line"> <span class="number">6</span>: &#125;</div><div class="line"> <span class="number">7</span>: </div><div class="line"> <span class="number">8</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">9</span>: <span class="function"><span class="keyword">public</span> GatewayFilter <span class="title">apply</span><span class="params">(Tuple args)</span> </span>&#123;</div><div class="line"><span class="number">10</span>: <span class="comment">//<span class="doctag">TODO:</span> if no name is supplied, generate one from command id (useful for default filter)</span></div><div class="line"><span class="number">11</span>: <span class="keyword">final</span> String commandName = args.getString(NAME_KEY);</div><div class="line"><span class="number">12</span>: <span class="keyword">final</span> HystrixCommandGroupKey groupKey = HystrixCommandGroupKey.Factory.asKey(getClass().getSimpleName());</div><div class="line"><span class="number">13</span>: <span class="keyword">final</span> HystrixCommandKey commandKey = HystrixCommandKey.Factory.asKey(commandName);</div><div class="line"><span class="number">14</span>: </div><div class="line"><span class="number">15</span>: <span class="keyword">final</span> HystrixObservableCommand.Setter setter = HystrixObservableCommand.Setter</div><div class="line"><span class="number">16</span>: .withGroupKey(groupKey)</div><div class="line"><span class="number">17</span>: .andCommandKey(commandKey);</div><div class="line"><span class="number">18</span>: </div><div class="line"><span class="number">19</span>: <span class="keyword">return</span> (exchange, chain) -&gt; &#123;</div><div class="line"><span class="number">20</span>: RouteHystrixCommand command = <span class="keyword">new</span> RouteHystrixCommand(setter, exchange, chain);</div><div class="line"><span class="number">21</span>: </div><div class="line"><span class="number">22</span>: <span class="keyword">return</span> Mono.create(s -&gt; &#123;</div><div class="line"><span class="number">23</span>:     <span class="comment">// 使用 Hystrix Command Observable 订阅</span></div><div class="line"><span class="number">24</span>: Subscription sub = command.toObservable().subscribe(s::success, s::error, s::success);</div><div class="line"><span class="number">25</span>: <span class="comment">// Mono 取消时，取消 Hystrix Command Observable 的订阅，结束 Hystrix Command 的执行</span></div><div class="line"><span class="number">26</span>: s.onCancel(sub::unsubscribe);</div><div class="line"><span class="number">27</span>: &#125;).onErrorResume((Function&lt;Throwable, Mono&lt;Void&gt;&gt;) throwable -&gt; &#123;</div><div class="line"><span class="number">28</span>: <span class="keyword">if</span> (throwable <span class="keyword">instanceof</span> HystrixRuntimeException) &#123;</div><div class="line"><span class="number">29</span>: HystrixRuntimeException e = (HystrixRuntimeException) throwable;</div><div class="line"><span class="number">30</span>: <span class="keyword">if</span> (e.getFailureType() == TIMEOUT) &#123; <span class="comment">//<span class="doctag">TODO:</span> optionally set status</span></div><div class="line"><span class="number">31</span>: setResponseStatus(exchange, HttpStatus.GATEWAY_TIMEOUT);</div><div class="line"><span class="number">32</span>: <span class="keyword">return</span> exchange.getResponse().setComplete();</div><div class="line"><span class="number">33</span>: &#125;</div><div class="line"><span class="number">34</span>: &#125;</div><div class="line"><span class="number">35</span>: <span class="keyword">return</span> Mono.empty();</div><div class="line"><span class="number">36</span>: &#125;).then();</div><div class="line"><span class="number">37</span>: &#125;;</div><div class="line"><span class="number">38</span>: &#125;</div><div class="line"><span class="number">39</span>: &#125;</div></pre></td></tr></table></figure><ul><li><code>#argNames()</code> 方法，定义了 Tuple 参数的 Key 为 <code>name</code> 。</li><li><code>#apply()</code> 方法，创建 HystrixGatewayFilter 对象。</li><li>第 11 行 ：从 Tuple 参数获得 Hystrix Command 名字，例如上面举例的 RouteDefinition 时，<code>commandName = myCommandName</code> 。</li><li>第 12 行 ：创建 Hystrix Command 分组 Key 为 <code>HystrixGatewayFilterFactory</code> 。</li><li>第 13 行 ：创建 Hystrix Command Key 为 <code>commandName</code> 。</li><li>第 15 至 17 行 ：创建 HystrixObservableCommand.Setter 对象。</li><li>——— 第 19 至 37 行 ：<strong>创建 HystrixGatewayFilter 对象并返回</strong>。</li><li><p>第 20 行 ：创建 RouteHystrixCommand 对象。代码如下 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">RouteHystrixCommand</span> <span class="keyword">extends</span> <span class="title">HystrixObservableCommand</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ServerWebExchange exchange;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> GatewayFilterChain chain;</div><div class="line"></div><div class="line">RouteHystrixCommand(Setter setter, ServerWebExchange exchange, GatewayFilterChain chain) &#123;</div><div class="line"><span class="keyword">super</span>(setter);</div><div class="line"><span class="keyword">this</span>.exchange = exchange;</div><div class="line"><span class="keyword">this</span>.chain = chain;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> Observable&lt;Void&gt; <span class="title">construct</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> RxReactiveStreams.toObservable(<span class="keyword">this</span>.chain.filter(<span class="keyword">this</span>.exchange));</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>第 22 至 26 行 ：调用 <code>Mono#create(Consumer&lt;MonoSink&lt;T&gt;&gt;)</code> 方法，创建 Mono 对象。点击 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#create-java.util.function.Consumer-" rel="external nofollow noopener noreferrer" target="_blank">传送门</a> 查看该方法详细说明。因为 Hystrix 基于 RxJava ，而 GatewayFilter 基于 Reactor ( Mono 是其内部的一个类 )，通过这个方法，实现订阅的适配。<strong>未来，会实现 <a href="https://github.com/Netflix/Hystrix/issues/1089#issuecomment-180512000" rel="external nofollow noopener noreferrer" target="_blank">HystrixMonoCommand</a> 替换 HystrixObservableCommand ，从而统一订阅，去除适配代码</strong>。</p><ul><li>第 24 行 ：1）调用 <code>RouteHystrixCommand#toObservable()</code> 方法，内部会调用 <code>RouteHystrixCommand#construct()</code> 方法，获得执行 <code>this.chain.filter(this.exchange)</code> 的 Observable 。2）订阅 Observable ：成功或完成时，调用 <code>Mono#success(Object)</code> 方法，目前创建的 Mono 上没有相关的订阅；<strong>异常时</strong>，调用 <code>Mono#error(Object)</code> 方法，目前创建的 Mono 上调用 <code>Mongo#onErrorResume(Function&lt;Throwable, Mono&lt;Void&gt;&gt;))</code> 方法，进行订阅。</li><li>第 26 行 ：Mono 取消时，取消 Hystrix Command Observable 的订阅，结束 Hystrix Command 的执行。</li></ul></li><li>第 27 至 34 行 ：当 Hystrix Command <strong>执行超时</strong>时，设置响应 504 状态码，并回写客户端<strong>响应</strong>( <code>exchange.getResponse().setComplete()</code> ) 。</li><li>第 35 行 ：<strong>当 Hystrix Command 发生其他异常时，例如断路器打开，返回 <code>Mono.empty()</code> ，最终返回客户端 200 状态码，内容为空</strong>。</li><li>第 36 行 ：调用 <code>Mono#then()</code> 方法，<strong>参数为空</strong>，返回空 Mono ，不再向后发射数据。</li></ul><h1 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h1><ol><li>目前 Hystrix Command 执行超时时，返回客户端 504 状态码，如果使用 JSON 格式作为数据返回，则需要修改下该 HystrixGatewayFilter 的代码实现。</li><li><p>Hystrix 配置参数，目前只能<strong>全局</strong>配置，例如说 Hystrix 执行超时时间，配置如下 ：</p> <figure class="highlight yaml"><table><tr><td class="code"><pre><div class="line"><span class="attr">hystrix:</span></div><div class="line"><span class="attr">  command:</span></div><div class="line"><span class="attr">    default:</span></div><div class="line"><span class="attr">      execution:</span></div><div class="line"><span class="attr">        isolation:</span></div><div class="line"><span class="attr">          thread:</span></div><div class="line"><span class="attr">            timeoutInMilliseconds:</span> <span class="number">10000</span></div></pre></td></tr></table></figure><ul><li>如果想实现 Route / URL 级别的 Hystrix 配置参数，则需要修改下该 HystrixGatewayFilter 的代码实现。</li><li><a href="https://github.com/Netflix/Hystrix/wiki/Configuration#contents" rel="external nofollow noopener noreferrer" target="_blank">《Hystrix —— Configuration》</a> ，Hystrix 配置项，需要自取。</li></ul></li><li><p>当 Hystrix 熔断时，最终返回客户端 200 状态码，内容为空，此处建议该 HystrixGatewayFilter 的代码实现。</p></li></ol><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>嘿嘿嘿，写完熔断，准备限流过滤器走起。鸡冻！</p><p><img src="http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_04_05/01.png" alt=""></p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/&quot;&gt;http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/&lt;
      
    
    </summary>
    
      <category term="Spring-Cloud-Gateway" scheme="http://www.iocoder.cn/categories/Spring-Cloud-Gateway/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.8) 之 WebClientHttpRoutingFilter</title>
    <link href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-web-client-http-routing/"/>
    <id>http://www.iocoder.cn/Spring-Cloud-Gateway/filter-web-client-http-routing/</id>
    <published>2020-03-31T16:00:00.000Z</published>
    <updated>2017-12-01T16:41:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-web-client-http-routing/">http://www.iocoder.cn/Spring-Cloud-Gateway/filter-web-client-http-routing/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Spring-Cloud-Gateway 2.0.X M4</strong>  </p><ul><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-web-client-http-routing/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-web-client-http-routing/">2. 环境配置</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-web-client-http-routing/">3. WebClientHttpRoutingFilter</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-web-client-http-routing/">4. WebClientWriteResponseFilter</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-web-client-http-routing/">5. 和 NettyRoutingFilter 对比</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-web-client-http-routing/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>WebClientHttpRoutingFilter 的代码实现</strong>。</p><p>WebClientHttpRoutingFilter ，Http <strong>路由</strong>网关过滤器。其根据 <code>http://</code> 或 <code>https://</code> 前缀( Scheme )过滤处理，使用基于 <code>org.springframework.cloud.gateway.filter.WebClient</code> 实现的 HttpClient 请求后端 Http 服务。</p><p>WebClientWriteResponseFilter ，与 WebClientHttpRoutingFilter <strong>成对使用</strong>的网关过滤器。其将 WebClientWriteResponseFilter 请求后端 Http 服务的<strong>响应</strong>写回客户端。</p><p>大体流程如下 ：</p><p><img src="http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_04_01/01.png" alt=""></p><h1 id="2-环境配置"><a href="#2-环境配置" class="headerlink" title="2. 环境配置"></a>2. 环境配置</h1><p>目前 WebClientHttpRoutingFilter / WebClientWriteResponseFilter 处于<strong>实验</strong>阶段，建议等正式发布在使用。</p><p>OK，下面我们来看看怎么配置环境。</p><p>第一步，在 NettyConfiguration 注释掉 <code>#routingFilter(...)</code> 和 <code>#nettyWriteResponseFilter()</code> 两个 Bean 方法。</p><p>第二步，在 GatewayAutoConfiguration 打开 <code>#webClientHttpRoutingFilter()</code> 和 <code>#webClientWriteResponseFilter()</code> 两个 Bean 方法。</p><p>第三步，配置完成，启动 Spring Cloud Gateway 。</p><h1 id="3-WebClientHttpRoutingFilter"><a href="#3-WebClientHttpRoutingFilter" class="headerlink" title="3. WebClientHttpRoutingFilter"></a>3. WebClientHttpRoutingFilter</h1><p><code>org.springframework.cloud.gateway.filter.WebClientHttpRoutingFilter</code> ，Http <strong>路由</strong>网关过滤器。</p><p><strong>构造方法</strong>，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebClientHttpRoutingFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> WebClient webClient;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">WebClientHttpRoutingFilter</span><span class="params">(WebClient webClient)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.webClient = webClient;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>webClient</code> 属性，默认情况下，使用 <code>org.springframework.web.reactive.function.client.DefaultWebClient</code> 实现类。通过该属性，<strong>请求后端的 Http 服务</strong>。</li></ul><hr><p><code>#getOrder()</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Ordered.LOWEST_PRECEDENCE;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>返回顺序为 <code>Integer.MAX_VALUE</code> 。在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-intro/?self">《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.1) 之 GatewayFilter 一览》「3. GlobalFilter」</a> ，我们列举了所有 GlobalFilter 的顺序。</li></ul><hr><p><code>#filter(ServerWebExchange, GatewayFilterChain)</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>: <span class="comment">// 获得 requestUrl</span></div><div class="line"> <span class="number">4</span>: URI requestUrl = exchange.getRequiredAttribute(GATEWAY_REQUEST_URL_ATTR);</div><div class="line"> <span class="number">5</span>: </div><div class="line"> <span class="number">6</span>: <span class="comment">// 判断是否能够处理</span></div><div class="line"> <span class="number">7</span>: String scheme = requestUrl.getScheme();</div><div class="line"> <span class="number">8</span>: <span class="keyword">if</span> (isAlreadyRouted(exchange) || (!scheme.equals(<span class="string">"http"</span>) &amp;&amp; !scheme.equals(<span class="string">"https"</span>))) &#123;</div><div class="line"> <span class="number">9</span>: <span class="keyword">return</span> chain.filter(exchange);</div><div class="line"><span class="number">10</span>: &#125;</div><div class="line"><span class="number">11</span>: </div><div class="line"><span class="number">12</span>: <span class="comment">// 设置已经路由</span></div><div class="line"><span class="number">13</span>: setAlreadyRouted(exchange);</div><div class="line"><span class="number">14</span>: </div><div class="line"><span class="number">15</span>: ServerHttpRequest request = exchange.getRequest();</div><div class="line"><span class="number">16</span>: </div><div class="line"><span class="number">17</span>: <span class="comment">//<span class="doctag">TODO:</span> support forms</span></div><div class="line"><span class="number">18</span>: <span class="comment">// Request Method</span></div><div class="line"><span class="number">19</span>: HttpMethod method = request.getMethod();</div><div class="line"><span class="number">20</span>: </div><div class="line"><span class="number">21</span>: <span class="comment">// Request</span></div><div class="line"><span class="number">22</span>: RequestBodySpec bodySpec = <span class="keyword">this</span>.webClient.method(method)</div><div class="line"><span class="number">23</span>: .uri(requestUrl)</div><div class="line"><span class="number">24</span>: .headers(httpHeaders -&gt; &#123;</div><div class="line"><span class="number">25</span>: httpHeaders.addAll(request.getHeaders());</div><div class="line"><span class="number">26</span>: httpHeaders.remove(HttpHeaders.HOST);</div><div class="line"><span class="number">27</span>: &#125;);</div><div class="line"><span class="number">28</span>: </div><div class="line"><span class="number">29</span>: <span class="comment">// Request Body</span></div><div class="line"><span class="number">30</span>: RequestHeadersSpec&lt;?&gt; headersSpec;</div><div class="line"><span class="number">31</span>: <span class="keyword">if</span> (requiresBody(method)) &#123;</div><div class="line"><span class="number">32</span>: headersSpec = bodySpec.body(BodyInserters.fromDataBuffers(request.getBody()));</div><div class="line"><span class="number">33</span>: &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">34</span>: headersSpec = bodySpec;</div><div class="line"><span class="number">35</span>: &#125;</div><div class="line"><span class="number">36</span>: </div><div class="line"><span class="number">37</span>: <span class="keyword">return</span> headersSpec.exchange()</div><div class="line"><span class="number">38</span>: <span class="comment">// .log("webClient route")</span></div><div class="line"><span class="number">39</span>: .flatMap(res -&gt; &#123;</div><div class="line"><span class="number">40</span>: ServerHttpResponse response = exchange.getResponse();</div><div class="line"><span class="number">41</span>: </div><div class="line"><span class="number">42</span>: <span class="comment">// Response Header</span></div><div class="line"><span class="number">43</span>: response.getHeaders().putAll(res.headers().asHttpHeaders());</div><div class="line"><span class="number">44</span>: </div><div class="line"><span class="number">45</span>: <span class="comment">// Response Status</span></div><div class="line"><span class="number">46</span>: response.setStatusCode(res.statusCode());</div><div class="line"><span class="number">47</span>: </div><div class="line"><span class="number">48</span>: <span class="comment">// 设置 Response 到 CLIENT_RESPONSE_ATTR</span></div><div class="line"><span class="number">49</span>: <span class="comment">// Defer committing the response until all route filters have run</span></div><div class="line"><span class="number">50</span>: <span class="comment">// Put client response as ServerWebExchange attribute and write response later NettyWriteResponseFilter</span></div><div class="line"><span class="number">51</span>: exchange.getAttributes().put(CLIENT_RESPONSE_ATTR, res);</div><div class="line"><span class="number">52</span>: <span class="keyword">return</span> chain.filter(exchange);</div><div class="line"><span class="number">53</span>: &#125;);</div><div class="line"><span class="number">54</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 4 行 ：获得 <code>requestUrl</code> 。</li><li><p>第 7 至 10 行 ：判断 ForwardRoutingFilter 是否能够处理该请求，需要满足两个条件 ：</p><ul><li><code>http://</code> 或者 <code>https://</code> 前缀( Scheme ) 。</li><li><p>调用 <code>ServerWebExchangeUtils#isAlreadyRouted(ServerWebExchange)</code> 方法，判断该请求暂未被其他 Routing 网关处理。代码如下 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAlreadyRouted</span><span class="params">(ServerWebExchange exchange)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> exchange.getAttributeOrDefault(GATEWAY_ALREADY_ROUTED_ATTR, <span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul></li></ul></li><li><p>第 13 行 ：设置该请求已经被处理。代码如下 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setAlreadyRouted</span><span class="params">(ServerWebExchange exchange)</span> </span>&#123;</div><div class="line">    exchange.getAttributes().put(GATEWAY_ALREADY_ROUTED_ATTR, <span class="keyword">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>第 17 行 ：TODO 【3025】 目前暂不支持 forms 参数</p></li><li>第 22 至 35 行 ：<strong>创建</strong>向后端服务的请求。<ul><li>第 22 行 ：设置 Method 属性。</li><li>第 24 至 27 行 ：设置 Header 属性。</li><li>第 30 至 35 行 ：设置 Body 属性。</li></ul></li><li>第 37 行 ：<strong>发起</strong>向后端服务的请求。</li><li>第 40 至 53 行 ：<strong>处理</strong>返回自后端服务的相应。<ul><li>第 43 行 ：设置 <code>response</code> 的 Header 属性。</li><li>第 46 行 ：设置 <code>response</code> 的 Status 属性。</li><li>第 51 行 ：设置 <code>res</code> 到 <code>CLIENT_RESPONSE_ATTR</code> 。后续 WebClientWriteResponseFilter 将响应<strong>写回</strong>给客户端。</li><li>第 52 行 ：提交过滤器链继续过滤。</li></ul></li></ul><h1 id="4-WebClientWriteResponseFilter"><a href="#4-WebClientWriteResponseFilter" class="headerlink" title="4. WebClientWriteResponseFilter"></a>4. WebClientWriteResponseFilter</h1><p><code>org.springframework.cloud.gateway.filter.WebClientWriteResponseFilter</code> ，Http 回写<strong>响应</strong>网关过滤器。</p><p><code>#getOrder()</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITE_RESPONSE_FILTER_ORDER = -<span class="number">1</span>;</div><div class="line">    </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> WRITE_RESPONSE_FILTER_ORDER;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>返回顺序为 <code>-1</code> 。在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-intro/?self">《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.1) 之 GatewayFilter 一览》「3. GlobalFilter」</a> ，我们列举了所有 GlobalFilter 的顺序。</li></ul><hr><p><code>#filter(ServerWebExchange, GatewayFilterChain)</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>: <span class="comment">// NOTICE: nothing in "pre" filter stage as CLIENT_RESPONSE_ATTR is not added</span></div><div class="line"> <span class="number">4</span>: <span class="comment">// until the WebHandler is run</span></div><div class="line"> <span class="number">5</span>: <span class="keyword">return</span> chain.filter(exchange).then(Mono.defer(() -&gt; &#123;</div><div class="line"> <span class="number">6</span>:     <span class="comment">// 获得 Response</span></div><div class="line"> <span class="number">7</span>: ClientResponse clientResponse = exchange.getAttribute(CLIENT_RESPONSE_ATTR);</div><div class="line"> <span class="number">8</span>: <span class="keyword">if</span> (clientResponse == <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">9</span>: <span class="keyword">return</span> Mono.empty();</div><div class="line"><span class="number">10</span>: &#125;</div><div class="line"><span class="number">11</span>: log.trace(<span class="string">"WebClientWriteResponseFilter start"</span>);</div><div class="line"><span class="number">12</span>: ServerHttpResponse response = exchange.getResponse();</div><div class="line"><span class="number">13</span>: </div><div class="line"><span class="number">14</span>: <span class="keyword">return</span> response.writeWith(clientResponse.body(BodyExtractors.toDataBuffers())).log(<span class="string">"webClient response"</span>);</div><div class="line"><span class="number">15</span>: &#125;));</div><div class="line"><span class="number">16</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 5 行 ：调用 <code>#then(Mono)</code> 方法，实现 <strong>After Filter</strong> 逻辑。</li><li>第 7 至 11 行 ：从 <code>CLIENT_RESPONSE_ATTR</code> 中，获得 ClientResponse 。</li><li>第 14 行 ：将 ClientResponse 写回给客户端。</li></ul><h1 id="5-和-NettyRoutingFilter-对比"><a href="#5-和-NettyRoutingFilter-对比" class="headerlink" title="5. 和 NettyRoutingFilter 对比"></a>5. 和 NettyRoutingFilter 对比</h1><p>在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-netty-routing/?self">《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.7) 之 NettyRoutingFilter》</a> 中，我们知道 NettyRoutingFilter / NettyWriteResponseFilter 和 WebClientHttpRoutingFilter / WebClientHttpRoutingFilter 实现<strong>一样</strong>的功能。</p><p>那么为什么要再实现一次呢？</p><p>TODO 【3001】</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>呼呼，主要的过滤器已经写完，后面熔断、限流过滤器的实现。</p><p><img src="http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_04_01/02.png" alt=""></p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Spring-Cloud-Gateway/filter-web-client-http-routing/&quot;&gt;http://www.iocoder.cn/Spring-Cloud-Gateway/
      
    
    </summary>
    
      <category term="Spring-Cloud-Gateway" scheme="http://www.iocoder.cn/categories/Spring-Cloud-Gateway/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.7) 之 NettyRoutingFilter</title>
    <link href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-netty-routing/"/>
    <id>http://www.iocoder.cn/Spring-Cloud-Gateway/filter-netty-routing/</id>
    <published>2020-03-27T16:00:00.000Z</published>
    <updated>2017-12-01T16:41:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-netty-routing/">http://www.iocoder.cn/Spring-Cloud-Gateway/filter-netty-routing/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Spring-Cloud-Gateway 2.0.X M4</strong>  </p><ul><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-netty-routing/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-netty-routing/">2. NettyRoutingFilter</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-netty-routing/">3. NettyWriteResponseFilter</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-netty-routing/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>NettyRoutingFilter 的代码实现</strong>。</p><p>NettyRoutingFilter ，Netty <strong>路由</strong>网关过滤器。其根据 <code>http://</code> 或 <code>https://</code> 前缀( Scheme )过滤处理，使用基于 Netty 实现的 HttpClient 请求后端 Http 服务。</p><p>NettyWriteResponseFilter ，与 NettyRoutingFilter <strong>成对使用</strong>的网关过滤器。其将 NettyRoutingFilter 请求后端 Http 服务的<strong>响应</strong>写回客户端。</p><p>大体流程如下 ：</p><p><img src="http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_03_28/01.png" alt=""></p><p>另外，Spring Cloud Gateway 实现了 WebClientHttpRoutingFilter / WebClientWriteResponseFilter ，功能上和 NettyRoutingFilter / NettyWriteResponseFilter <strong>相同</strong>，差别在于基于 <code>org.springframework.cloud.gateway.filter.WebClient</code> 实现的 HttpClient 请求后端 Http 服务。在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-web-client-http-routing?self">《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.8) 之 WebClientHttpRoutingFilter》</a> ，我们会详细解析。</p><hr><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-NettyRoutingFilter"><a href="#2-NettyRoutingFilter" class="headerlink" title="2. NettyRoutingFilter"></a>2. NettyRoutingFilter</h1><p><code>org.springframework.cloud.gateway.filter.NettyRoutingFilter</code> ，Netty <strong>路由</strong>网关过滤器。</p><p><strong>构造方法</strong>，代码如下 ：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class NettyRoutingFilter implements GlobalFilter, Ordered &#123;</div><div class="line"></div><div class="line">private final HttpClient httpClient;</div><div class="line"></div><div class="line">public NettyRoutingFilter(HttpClient httpClient) &#123;</div><div class="line">this.httpClient = httpClient;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>httpClient</code> 属性，基于 <strong>Netty</strong> 实现的 HttpClient 。通过该属性，<strong>请求后端的 Http 服务</strong>。</li></ul><hr><p><code>#getOrder()</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Ordered.LOWEST_PRECEDENCE;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>返回顺序为 <code>Integer.MAX_VALUE</code> 。在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-intro/?self">《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.1) 之 GatewayFilter 一览》「3. GlobalFilter」</a> ，我们列举了所有 GlobalFilter 的顺序。</li></ul><hr><p><code>#filter(ServerWebExchange, GatewayFilterChain)</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>: <span class="comment">// 获得 requestUrl</span></div><div class="line"> <span class="number">4</span>: URI requestUrl = exchange.getRequiredAttribute(GATEWAY_REQUEST_URL_ATTR);</div><div class="line"> <span class="number">5</span>: </div><div class="line"> <span class="number">6</span>: <span class="comment">// 判断是否能够处理</span></div><div class="line"> <span class="number">7</span>: String scheme = requestUrl.getScheme();</div><div class="line"> <span class="number">8</span>: <span class="keyword">if</span> (isAlreadyRouted(exchange) || (!scheme.equals(<span class="string">"http"</span>) &amp;&amp; !scheme.equals(<span class="string">"https"</span>))) &#123;</div><div class="line"> <span class="number">9</span>: <span class="keyword">return</span> chain.filter(exchange);</div><div class="line"><span class="number">10</span>: &#125;</div><div class="line"><span class="number">11</span>: </div><div class="line"><span class="number">12</span>: <span class="comment">// 设置已经路由</span></div><div class="line"><span class="number">13</span>: setAlreadyRouted(exchange);</div><div class="line"><span class="number">14</span>: </div><div class="line"><span class="number">15</span>: ServerHttpRequest request = exchange.getRequest();</div><div class="line"><span class="number">16</span>: </div><div class="line"><span class="number">17</span>: <span class="comment">// Request Method</span></div><div class="line"><span class="number">18</span>: <span class="keyword">final</span> HttpMethod method = HttpMethod.valueOf(request.getMethod().toString());</div><div class="line"><span class="number">19</span>: </div><div class="line"><span class="number">20</span>: <span class="comment">// 获得 url</span></div><div class="line"><span class="number">21</span>: <span class="keyword">final</span> String url = requestUrl.toString();</div><div class="line"><span class="number">22</span>: </div><div class="line"><span class="number">23</span>: <span class="comment">// Request Header</span></div><div class="line"><span class="number">24</span>: <span class="keyword">final</span> DefaultHttpHeaders httpHeaders = <span class="keyword">new</span> DefaultHttpHeaders();</div><div class="line"><span class="number">25</span>: request.getHeaders().forEach(httpHeaders::set);</div><div class="line"><span class="number">26</span>: </div><div class="line"><span class="number">27</span>: <span class="comment">// 请求</span></div><div class="line"><span class="number">28</span>: <span class="keyword">return</span> <span class="keyword">this</span>.httpClient.request(method, url, req -&gt; &#123;</div><div class="line"><span class="number">29</span>: <span class="keyword">final</span> HttpClientRequest proxyRequest = req.options(NettyPipeline.SendOptions::flushOnEach)</div><div class="line"><span class="number">30</span>: .failOnClientError(<span class="keyword">false</span>) <span class="comment">// // 是否请求失败，抛出异常</span></div><div class="line"><span class="number">31</span>: .headers(httpHeaders);</div><div class="line"><span class="number">32</span>: </div><div class="line"><span class="number">33</span>: <span class="comment">// Request Form</span></div><div class="line"><span class="number">34</span>: <span class="keyword">if</span> (MediaType.APPLICATION_FORM_URLENCODED.includes(request.getHeaders().getContentType())) &#123;</div><div class="line"><span class="number">35</span>: <span class="keyword">return</span> exchange.getFormData()</div><div class="line"><span class="number">36</span>: .flatMap(map -&gt; proxyRequest.sendForm(form -&gt; &#123;</div><div class="line"><span class="number">37</span>: <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;String&gt;&gt; entry: map.entrySet()) &#123;</div><div class="line"><span class="number">38</span>: <span class="keyword">for</span> (String value : entry.getValue()) &#123;</div><div class="line"><span class="number">39</span>: form.attr(entry.getKey(), value);</div><div class="line"><span class="number">40</span>: &#125;</div><div class="line"><span class="number">41</span>: &#125;</div><div class="line"><span class="number">42</span>: &#125;).then())</div><div class="line"><span class="number">43</span>: .then(chain.filter(exchange));</div><div class="line"><span class="number">44</span>: &#125;</div><div class="line"><span class="number">45</span>: </div><div class="line"><span class="number">46</span>: <span class="comment">// Request Body</span></div><div class="line"><span class="number">47</span>: <span class="keyword">return</span> proxyRequest.sendHeaders() <span class="comment">//I shouldn't need this</span></div><div class="line"><span class="number">48</span>: .send(request.getBody()</div><div class="line"><span class="number">49</span>: .map(DataBuffer::asByteBuffer) <span class="comment">// Flux&lt;DataBuffer&gt; =&gt; ByteBuffer</span></div><div class="line"><span class="number">50</span>: .map(Unpooled::wrappedBuffer)); <span class="comment">// ByteBuffer =&gt; Flux&lt;DataBuffer&gt;</span></div><div class="line"><span class="number">51</span>: &#125;).doOnNext(res -&gt; &#123;</div><div class="line"><span class="number">52</span>: ServerHttpResponse response = exchange.getResponse();</div><div class="line"><span class="number">53</span>: <span class="comment">// Response Header</span></div><div class="line"><span class="number">54</span>: <span class="comment">// put headers and status so filters can modify the response</span></div><div class="line"><span class="number">55</span>: HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</div><div class="line"><span class="number">56</span>: res.responseHeaders().forEach(entry -&gt; headers.add(entry.getKey(), entry.getValue()));</div><div class="line"><span class="number">57</span>: response.getHeaders().putAll(headers);</div><div class="line"><span class="number">58</span>: </div><div class="line"><span class="number">59</span>: <span class="comment">// Response Status</span></div><div class="line"><span class="number">60</span>: response.setStatusCode(HttpStatus.valueOf(res.status().code()));</div><div class="line"><span class="number">61</span>: </div><div class="line"><span class="number">62</span>: <span class="comment">// 设置 Response 到 CLIENT_RESPONSE_ATTR</span></div><div class="line"><span class="number">63</span>: <span class="comment">// Defer committing the response until all route filters have run</span></div><div class="line"><span class="number">64</span>: <span class="comment">// Put client response as ServerWebExchange attribute and write response later NettyWriteResponseFilter</span></div><div class="line"><span class="number">65</span>: exchange.getAttributes().put(CLIENT_RESPONSE_ATTR, res);</div><div class="line"><span class="number">66</span>: &#125;).then(chain.filter(exchange));</div><div class="line"><span class="number">67</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 4 行 ：获得 <code>requestUrl</code> 。</li><li><p>第 7 至 10 行 ：判断 ForwardRoutingFilter 是否能够处理该请求，需要满足两个条件 ：</p><ul><li><code>http://</code> 或者 <code>https://</code> 前缀( Scheme ) 。</li><li><p>调用 <code>ServerWebExchangeUtils#isAlreadyRouted(ServerWebExchange)</code> 方法，判断该请求暂未被其他 Routing 网关处理。代码如下 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAlreadyRouted</span><span class="params">(ServerWebExchange exchange)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> exchange.getAttributeOrDefault(GATEWAY_ALREADY_ROUTED_ATTR, <span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul></li></ul></li><li><p>第 13 行 ：设置该请求已经被处理。代码如下 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setAlreadyRouted</span><span class="params">(ServerWebExchange exchange)</span> </span>&#123;</div><div class="line">    exchange.getAttributes().put(GATEWAY_ALREADY_ROUTED_ATTR, <span class="keyword">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>第 18 行 ：创建 <strong>Netty Request Method</strong> 对象。<code>request#getMethod()</code> 返回的不是 <code>io.netty.handler.codec.http.HttpMethod</code> ，所以需要进行转换。</p></li><li>第 21 行 ：获得 <code>url</code> 。</li><li>第 24 至 25 行 ：创建  <strong>Netty Request Header</strong> 对象( <code>io.netty.handler.codec.http.DefaultHttpHeaders</code> )，将请求的 Header 设置给它。</li><li>——— 第 28 至 50 行 ：调用 <code>HttpClient#request(HttpMethod, String, Function)</code> 方法，请求后端 Http 服务。</li><li><p>第 29 至 31 行 ：创建 <strong>Netty Request</strong> 对象( <code>reactor.ipc.netty.http.client.HttpClientRequest</code> )。</p><ul><li>第 29 行 ：TODO 【3024】 NettyPipeline.SendOptions::flushOnEach</li><li><p>第 30 行 ：设置请求失败( 后端服务返回响应状体码 <code>&gt;= 400</code> )时，不抛出异常。相关代码如下 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// HttpClientOperations#checkResponseCode(HttpResponse response)</span></div><div class="line"><span class="comment">// ... 省略无关代码</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> (code &gt;= <span class="number">400</span>) &#123;</div><div class="line"><span class="keyword">if</span> (clientError) &#123;</div><div class="line"><span class="keyword">if</span> (log.isDebugEnabled()) &#123;</div><div class="line">log.debug(<span class="string">"&#123;&#125; Received Request Error, stop reading: &#123;&#125;"</span>,</div><div class="line">channel(),</div><div class="line">response.toString());</div><div class="line">&#125;</div><div class="line">Exception ex = <span class="keyword">new</span> HttpClientException(uri(), response);</div><div class="line">parentContext().fireContextError(ex);</div><div class="line">receive().subscribe();</div><div class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>通过设置 <code>clientError = false</code> ，第 51 行可以调用 <code>Mono#doNext(Consumer)</code> 方法，<strong>统一订阅处理</strong>返回的 <code>reactor.ipc.netty.http.client.HttpClientResponse</code> 对象。</li></ul></li><li><p>第 31 行 ：设置 <strong>Netty Request</strong> 对象的 Header 。</p></li></ul></li><li><p>第 34 至 44 行 ：【TODO 3025】目前是一个 BUG ，在 2.0.X 版本修复。见 <a href="FormIntegrationTests">FormIntegrationTests#formUrlencodedWorks()</a> 单元测试的注释说明。</p></li><li><p>第 47 至 50 行 ：请求后端的 Http 服务。</p><ul><li>第 47 行 ：发送请求 Header 。</li><li>第 48 至 50 行 ：发送请求 Body 。其中中间的 <code>#map(...)</code> 的过程为 <code>Flux&lt;DataBuffer&gt; =&gt; ByteBuffer =&gt; Flux&lt;DataBuffer&gt;</code> 。</li></ul></li><li><p>——— 第 51 至 65 行 ：请求后端 Http 服务<strong>完成</strong>，将 <strong>Netty Response</strong> 赋值给响应 <code>response</code> 。</p></li><li>第 53 至 57 行 ：创建 <code>org.springframework.http.HttpHeaders</code> 对象，将 <strong>Netty Response Header</strong> 设置给它，而后设置回给响应 <code>response</code> 。</li><li>第 60 行 ：设置响应 <code>response</code> 的状态码。</li><li>第 65 行 ：设置 <strong>Netty Response</strong> 到 <code>CLIENT_RESPONSE_ATTR</code> 。后续 NettyWriteResponseFilter 将 <strong>Netty Response</strong> 写回给客户端。</li><li>——— 第 66 行 ：提交过滤器链继续过滤。</li></ul><h1 id="3-NettyWriteResponseFilter"><a href="#3-NettyWriteResponseFilter" class="headerlink" title="3. NettyWriteResponseFilter"></a>3. NettyWriteResponseFilter</h1><p><code>org.springframework.cloud.gateway.filter.NettyWriteResponseFilter</code> ，Netty 回写<strong>响应</strong>网关过滤器。</p><p><code>#getOrder()</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITE_RESPONSE_FILTER_ORDER = -<span class="number">1</span>;</div><div class="line">    </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> WRITE_RESPONSE_FILTER_ORDER;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>返回顺序为 <code>-1</code> 。在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-intro/?self">《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.1) 之 GatewayFilter 一览》「3. GlobalFilter」</a> ，我们列举了所有 GlobalFilter 的顺序。</li></ul><hr><p><code>#filter(ServerWebExchange, GatewayFilterChain)</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>: <span class="comment">// NOTICE: nothing in "pre" filter stage as CLIENT_RESPONSE_ATTR is not added</span></div><div class="line"> <span class="number">4</span>: <span class="comment">// until the WebHandler is run</span></div><div class="line"> <span class="number">5</span>: <span class="keyword">return</span> chain.filter(exchange).then(Mono.defer(() -&gt; &#123;</div><div class="line"> <span class="number">6</span>:     <span class="comment">// 获得 Response</span></div><div class="line"> <span class="number">7</span>: HttpClientResponse clientResponse = exchange.getAttribute(CLIENT_RESPONSE_ATTR);</div><div class="line"> <span class="number">8</span>: <span class="comment">// HttpClientResponse clientResponse = getAttribute(exchange, CLIENT_RESPONSE_ATTR, HttpClientResponse.class);</span></div><div class="line"> <span class="number">9</span>: <span class="keyword">if</span> (clientResponse == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">10</span>: <span class="keyword">return</span> Mono.empty();</div><div class="line"><span class="number">11</span>: &#125;</div><div class="line"><span class="number">12</span>: log.trace(<span class="string">"NettyWriteResponseFilter start"</span>);</div><div class="line"><span class="number">13</span>: ServerHttpResponse response = exchange.getResponse();</div><div class="line"><span class="number">14</span>: </div><div class="line"><span class="number">15</span>: <span class="comment">// 将 Netty Response 写回给客户端。</span></div><div class="line"><span class="number">16</span>: NettyDataBufferFactory factory = (NettyDataBufferFactory) response.bufferFactory();</div><div class="line"><span class="number">17</span>: <span class="comment">//<span class="doctag">TODO:</span> what if it's not netty</span></div><div class="line"><span class="number">18</span>: <span class="keyword">final</span> Flux&lt;NettyDataBuffer&gt; body = clientResponse.receive()</div><div class="line"><span class="number">19</span>: .retain() <span class="comment">// ByteBufFlux =&gt; ByteBufFlux</span></div><div class="line"><span class="number">20</span>: .map(factory::wrap); <span class="comment">// ByteBufFlux  =&gt; Flux&lt;NettyDataBuffer&gt;</span></div><div class="line"><span class="number">21</span>: <span class="keyword">return</span> response.writeWith(body);</div><div class="line"><span class="number">22</span>: &#125;));</div><div class="line"><span class="number">23</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 5 行 ：调用 <code>#then(Mono)</code> 方法，实现 <strong>After Filter</strong> 逻辑。</li><li>第 7 至 11 行 ：从 <code>CLIENT_RESPONSE_ATTR</code> 中，获得 <strong>Netty Response</strong> 。</li><li>第 15 至 21 行 ：将 <strong>Netty Response</strong> 写回给客户端。因为 <code>org.springframework.http.server.reactive#writeWith(Publisher&lt;? extends DataBuffer&gt;)</code> 需要的参数类型是 <code>Publisher&lt;? extends DataBuffer&gt;</code> ，所以【第 18 至 20 行】的转换过程是 <code>ByteBufFlux =&gt; Flux&lt;NettyDataBuffer&gt;</code> 。<ul><li>第 19 行 ：TODO 【3024】ByteBufFlux#retain() </li></ul></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>下一篇 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-web-client-http-routing">《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.8) 之 WebClientHttpRoutingFilter》</a> 走起！</p><p><img src="http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_03_28/02.png" alt=""></p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Spring-Cloud-Gateway/filter-netty-routing/&quot;&gt;http://www.iocoder.cn/Spring-Cloud-Gateway/filter-net
      
    
    </summary>
    
      <category term="Spring-Cloud-Gateway" scheme="http://www.iocoder.cn/categories/Spring-Cloud-Gateway/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.6) 之 WebSocketRoutingFilter</title>
    <link href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-websocket-routing/"/>
    <id>http://www.iocoder.cn/Spring-Cloud-Gateway/filter-websocket-routing/</id>
    <published>2020-03-24T16:00:00.000Z</published>
    <updated>2017-12-01T16:41:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-websocket-routing/">http://www.iocoder.cn/Spring-Cloud-Gateway/filter-websocket-routing/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Spring-Cloud-Gateway 2.0.X M4</strong>  </p><ul><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-websocket-routing/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-websocket-routing/">2. 环境搭建</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-websocket-routing/">3. WebsocketRoutingFilter</a><ul><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-websocket-routing/">3.1 ProxyWebSocketHandler</a></li></ul></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-websocket-routing/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>WebsocketRoutingFilter 的代码实现</strong>。</p><p>WebsocketRoutingFilter ，Websocket <strong>路由</strong>网关过滤器。其根据 <code>ws://</code> / <code>wss://</code> 前缀( Scheme )过滤处理，<strong>代理后端 Websocket 服务</strong>，提供给客户端连接。如下图 ：</p><p><img src="http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_03_25/01.png" alt=""></p><ul><li>目前<strong>一个</strong> RouteDefinition 只能指定<strong>一个</strong>后端 WebSocket 服务。官方正在计划在 LoadBalancerClientFilter 上实现 Websocket 的负载均衡功能。也就说，未来<strong>一个</strong> RouteDefinition 能够指定<strong>多个</strong>后端 WebSocket 服务。</li></ul><p>Websocket 的 RouteDefinition 配置如下 ：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><div class="line"><span class="attr">cloud:</span></div><div class="line"><span class="attr">    gateway:</span></div><div class="line"><span class="attr">      routes:</span></div><div class="line"><span class="attr">      - id:</span> <span class="string">websocket_test</span></div><div class="line"><span class="attr">        uri:</span> <span class="attr">ws://localhost:9000</span></div><div class="line"><span class="attr">        order:</span> <span class="number">8000</span></div><div class="line"><span class="attr">        predicates:</span></div><div class="line"><span class="bullet">        -</span> <span class="string">Path=/echo</span></div></pre></td></tr></table></figure><ul><li><code>uri</code> 使用 <code>ws://</code> 或者 <code>wss://</code> 为前缀。</li></ul><hr><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2. 环境搭建"></a>2. 环境搭建</h1><p>在解析源码之前，我们先以 <a href="https://github.com/websockets/wscat" rel="external nofollow noopener noreferrer" target="_blank">wscat</a>  搭建一个 WebSocket 服务。</p><p>第一步，安装 wscat 。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">npm install -g wscat</div></pre></td></tr></table></figure><p>第二步，启动 wscat 。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">wscat --listen 9000</div></pre></td></tr></table></figure><p>第三步，连接 wscat 。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">wscat --listen 9000</div></pre></td></tr></table></figure><p>第四步，配置 RouteDefinition ，并启动 Spring Cloud Gateway 。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">cloud:</div><div class="line">    gateway:</div><div class="line">      routes:</div><div class="line">      - id: websocket_test</div><div class="line">        uri: ws://localhost:9000</div><div class="line">        order: 8000</div><div class="line">        predicates:</div><div class="line">        - Path=/echo</div></pre></td></tr></table></figure><p>第五步，通过 Gateway 连接 wscat 。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">wscat --connect ws://localhost:8080/echo</div></pre></td></tr></table></figure><p>大功告成。</p><p>注意，wscat 同一时间仅允许一个客户端连接。</p><h1 id="3-WebsocketRoutingFilter"><a href="#3-WebsocketRoutingFilter" class="headerlink" title="3. WebsocketRoutingFilter"></a>3. WebsocketRoutingFilter</h1><p><code>org.springframework.cloud.gateway.filter.WebsocketRoutingFilter</code> ，Websocket <strong>路由</strong>网关过滤器。</p><p><strong>构造方法</strong>，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebsocketRoutingFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SEC_WEBSOCKET_PROTOCOL = <span class="string">"Sec-WebSocket-Protocol"</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> WebSocketClient webSocketClient;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> WebSocketService webSocketService;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">WebsocketRoutingFilter</span><span class="params">(WebSocketClient webSocketClient)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>(webSocketClient, <span class="keyword">new</span> HandshakeWebSocketService());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">WebsocketRoutingFilter</span><span class="params">(WebSocketClient webSocketClient,</span></span></div><div class="line"><span class="function"><span class="params">WebSocketService webSocketService)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.webSocketClient = webSocketClient;</div><div class="line"><span class="keyword">this</span>.webSocketService = webSocketService;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>webSocketClient</code> 属性，在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/init/?self">《Spring-Cloud-Gateway 源码解析 —— 网关初始化》「5.2 初始化 NettyConfiguration」</a> 一文中，我们可以看到使用的是 <code>org.springframework.web.reactive.socket.client.ReactorNettyWebSocketClient</code> 实现类。通过该属性，<strong>连接后端【被代理】的 WebSocket 服务</strong>。</li><li><code>webSocketService</code> 属性，在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/init/?self">《Spring-Cloud-Gateway 源码解析 —— 网关初始化》「5.3 初始化 GlobalFilter」</a> 一文中，我们可以看到使用的是 <code>org.springframework.web.reactive.socket.server.support.HandshakeWebSocketService</code> 实现类。通过该属性，处理客户端发起的连接请求( Handshake Request ) 。</li></ul><hr><p><code>#getOrder()</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Ordered.LOWEST_PRECEDENCE;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>返回顺序为 <code>Integer.MAX_VALUE</code> 。在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-intro/?self">《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.1) 之 GatewayFilter 一览》「3. GlobalFilter」</a> ，我们列举了所有 GlobalFilter 的顺序。</li></ul><hr><p><code>#filter(ServerWebExchange, GatewayFilterChain)</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>: <span class="comment">// 获得 requestUrl</span></div><div class="line"> <span class="number">4</span>: URI requestUrl = exchange.getRequiredAttribute(GATEWAY_REQUEST_URL_ATTR);</div><div class="line"> <span class="number">5</span>: </div><div class="line"> <span class="number">6</span>: <span class="comment">// 判断是否能够处理</span></div><div class="line"> <span class="number">7</span>: String scheme = requestUrl.getScheme();</div><div class="line"> <span class="number">8</span>: <span class="keyword">if</span> (isAlreadyRouted(exchange) || (!scheme.equals(<span class="string">"ws"</span>) &amp;&amp; !scheme.equals(<span class="string">"wss"</span>))) &#123;</div><div class="line"> <span class="number">9</span>: <span class="keyword">return</span> chain.filter(exchange);</div><div class="line"><span class="number">10</span>: &#125;</div><div class="line"><span class="number">11</span>: </div><div class="line"><span class="number">12</span>: <span class="comment">// 设置已经路由</span></div><div class="line"><span class="number">13</span>: setAlreadyRouted(exchange);</div><div class="line"><span class="number">14</span>: </div><div class="line"><span class="number">15</span>: <span class="comment">// 处理连接请求</span></div><div class="line"><span class="number">16</span>: <span class="keyword">return</span> <span class="keyword">this</span>.webSocketService.handleRequest(exchange,</div><div class="line"><span class="number">17</span>: <span class="keyword">new</span> ProxyWebSocketHandler(requestUrl, <span class="keyword">this</span>.webSocketClient, exchange.getRequest().getHeaders()));</div><div class="line"><span class="number">18</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 4 行 ：获得 <code>requestUrl</code> 。</li><li><p>第 7 至 10 行 ：判断 ForwardRoutingFilter 是否能够处理该请求，需要满足两个条件 ：</p><ul><li><code>ws://</code> 或者 <code>wss://</code> 前缀( Scheme ) 。</li><li><p>调用 <code>ServerWebExchangeUtils#isAlreadyRouted(ServerWebExchange)</code> 方法，判断该请求暂未被其他 Routing 网关处理。代码如下 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAlreadyRouted</span><span class="params">(ServerWebExchange exchange)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> exchange.getAttributeOrDefault(GATEWAY_ALREADY_ROUTED_ATTR, <span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul></li></ul></li><li><p>第 13 行 ：设置该请求已经被处理。代码如下 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setAlreadyRouted</span><span class="params">(ServerWebExchange exchange)</span> </span>&#123;</div><div class="line">    exchange.getAttributes().put(GATEWAY_ALREADY_ROUTED_ATTR, <span class="keyword">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>第 15 至 16 行 ：调用 <code>WebSocketService#hanldeRequest(ServerWebExchange, WebSocketHandler)</code> 方法，处理客户端发起的连接请求( Handshake Request ) 。这个方法的实现不在本文范围内，但是良心如笔者，大概讲下涉及到的类 ：</p><ul><li>主要逻辑在 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-webflux/src/main/java/org/springframework/web/reactive/socket/server/upgrade/ReactorNettyRequestUpgradeStrategy.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>org.springframework.web.reactive.socket.server.upgrade.ReactorNettyRequestUpgradeStrategy</code></a> 类里。</li><li>【第一步】 ReactorNettyRequestUpgradeStrategy 调用 <a href="https://github.com/reactor/reactor-netty/blob/master/src/main/java/reactor/ipc/netty/http/server/HttpServerWSOperations.java" rel="external nofollow noopener noreferrer" target="_blank"><code>reactor.ipc.netty.http.server.HttpServerWSOperations</code></a> ，处理客户端发起的连接请求。处理成功，告知客户端连接成功。</li><li>【第二步】ReactorNettyRequestUpgradeStrategy 调用 <a href="https://github.com/spring-projects/spring-framework/blob/8f69b5ff23d6835eee89a26c0e1e3e63a64a21a0/spring-webflux/src/main/java/org/springframework/web/reactive/socket/WebSocketHandler.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.springframework.web.reactive.socket.server.upgrade.ReactorNettyRequestUpgradeStrategy</code></a> <strong>接口</strong>的 <code>#handle(WebSocketSession)</code> 方法，处理客户端 WebSocket Session 。ProxyWebSocketHandler 是 WebSocketHandler 的<strong>实现类</strong>，在 <a href="#">「3.1 ProxyWebSocketHandler」</a> 来详细解析 <code>#handle(WebSocketSession)</code> 实现了什么逻辑。</li></ul></li></ul><h2 id="3-1-ProxyWebSocketHandler"><a href="#3-1-ProxyWebSocketHandler" class="headerlink" title="3.1 ProxyWebSocketHandler"></a>3.1 ProxyWebSocketHandler</h2><p><code>org.springframework.cloud.gateway.filter.WebsocketRoutingFilter.ProxyWebSocketHandler</code> ，<strong>代理</strong>后端 WebSocket 服务处理器。</p><p><strong>构造方法</strong>，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyWebSocketHandler</span> <span class="keyword">implements</span> <span class="title">WebSocketHandler</span> </span>&#123;</div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>: <span class="keyword">private</span> <span class="keyword">final</span> WebSocketClient client;</div><div class="line"> <span class="number">4</span>: <span class="keyword">private</span> <span class="keyword">final</span> URI url;</div><div class="line"> <span class="number">5</span>: <span class="keyword">private</span> <span class="keyword">final</span> HttpHeaders headers;</div><div class="line"> <span class="number">6</span>: <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; subProtocols;</div><div class="line"> <span class="number">7</span>: </div><div class="line"> <span class="number">8</span>: <span class="function"><span class="keyword">public</span> <span class="title">ProxyWebSocketHandler</span><span class="params">(URI url, WebSocketClient client, HttpHeaders headers)</span> </span>&#123;</div><div class="line"> <span class="number">9</span>: <span class="keyword">this</span>.client = client;</div><div class="line"><span class="number">10</span>: <span class="keyword">this</span>.url = url;</div><div class="line"><span class="number">11</span>: <span class="keyword">this</span>.headers = <span class="keyword">new</span> HttpHeaders();<span class="comment">//headers;</span></div><div class="line"><span class="number">12</span>: <span class="comment">//<span class="doctag">TODO:</span> better strategy to filter these headers?</span></div><div class="line"><span class="number">13</span>: headers.entrySet().forEach(header -&gt; &#123;</div><div class="line"><span class="number">14</span>: <span class="keyword">if</span> (!header.getKey().toLowerCase().startsWith(<span class="string">"sec-websocket"</span>)</div><div class="line"><span class="number">15</span>: &amp;&amp; !header.getKey().equalsIgnoreCase(<span class="string">"upgrade"</span>)</div><div class="line"><span class="number">16</span>: &amp;&amp; !header.getKey().equalsIgnoreCase(<span class="string">"connection"</span>)) &#123;</div><div class="line"><span class="number">17</span>: <span class="keyword">this</span>.headers.addAll(header.getKey(), header.getValue());</div><div class="line"><span class="number">18</span>: &#125;</div><div class="line"><span class="number">19</span>: &#125;);</div><div class="line"><span class="number">20</span>: List&lt;String&gt; protocols = headers.get(SEC_WEBSOCKET_PROTOCOL);</div><div class="line"><span class="number">21</span>: <span class="keyword">if</span> (protocols != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">22</span>: <span class="keyword">this</span>.subProtocols = protocols;</div><div class="line"><span class="number">23</span>: &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">24</span>: <span class="keyword">this</span>.subProtocols = Collections.emptyList();</div><div class="line"><span class="number">25</span>: &#125;</div><div class="line"><span class="number">26</span>: &#125;</div><div class="line"><span class="number">27</span>: &#125;</div></pre></td></tr></table></figure><ul><li><code>client</code> 属性，在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/init/?self">《Spring-Cloud-Gateway 源码解析 —— 网关初始化》「5.2 初始化 NettyConfiguration」</a> 一文中，我们可以看到使用的是 <code>org.springframework.web.reactive.socket.client.ReactorNettyWebSocketClient</code> 实现类。通过该属性，<strong>连接后端【被代理】的 WebSocket 服务</strong>。</li><li><code>url</code> 属性，后端【被代理】的 WebSocket 服务的地址。</li><li><code>header</code> 属性，请求头，在 <a href="http://blog.csdn.net/baiye_xing/article/details/73938360" rel="external nofollow noopener noreferrer" target="_blank">《 【计网】HTTP与WebSocket的区别》</a> 有详细解析，包括为什么【第 14 至 18 行】的代码这样处理。</li><li><code>subProtocols</code> 属性，最终通信使用的协议。</li></ul><hr><p><code>#handle(WebSocketSession)</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">handle</span><span class="params">(WebSocketSession session)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>: <span class="comment">// pass headers along so custom headers can be sent through</span></div><div class="line"> <span class="number">4</span>: <span class="keyword">return</span> client.execute(url, <span class="keyword">this</span>.headers, <span class="keyword">new</span> WebSocketHandler() &#123;</div><div class="line"> <span class="number">5</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">6</span>: <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">handle</span><span class="params">(WebSocketSession proxySession)</span> </span>&#123;</div><div class="line"> <span class="number">7</span>: <span class="comment">// Use retain() for Reactor Netty</span></div><div class="line"> <span class="number">8</span>: <span class="comment">// 转发消息 客户端 =》后端服务</span></div><div class="line"> <span class="number">9</span>: Mono&lt;Void&gt; proxySessionSend = proxySession</div><div class="line"><span class="number">10</span>: .send(session.receive().doOnNext(WebSocketMessage::retain));</div><div class="line"><span class="number">11</span>: <span class="comment">// 转发消息 后端服务=》客户端</span></div><div class="line"><span class="number">12</span>: <span class="comment">// .log("proxySessionSend", Level.FINE);</span></div><div class="line"><span class="number">13</span>: Mono&lt;Void&gt; serverSessionSend = session</div><div class="line"><span class="number">14</span>: .send(proxySession.receive().doOnNext(WebSocketMessage::retain));</div><div class="line"><span class="number">15</span>: <span class="comment">// .log("sessionSend", Level.FINE);</span></div><div class="line"><span class="number">16</span>: </div><div class="line"><span class="number">17</span>: <span class="comment">// </span></div><div class="line"><span class="number">18</span>: <span class="keyword">return</span> Mono.when(proxySessionSend, serverSessionSend).then();</div><div class="line"><span class="number">19</span>: &#125;</div><div class="line"><span class="number">20</span>: </div><div class="line"><span class="number">21</span>: <span class="comment">/**</span></div><div class="line"><span class="comment">22:  * Copy subProtocols so they are available downstream.</span></div><div class="line"><span class="comment">23:  * <span class="doctag">@return</span></span></div><div class="line"><span class="comment">24:  */</span></div><div class="line"><span class="number">25</span>: <span class="meta">@Override</span></div><div class="line"><span class="number">26</span>: <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getSubProtocols</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">27</span>: <span class="keyword">return</span> ProxyWebSocketHandler.<span class="keyword">this</span>.subProtocols;</div><div class="line"><span class="number">28</span>: &#125;</div><div class="line"><span class="number">29</span>: &#125;);</div><div class="line"><span class="number">30</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 6 行 ：调用 <code>WebSocketClient#execute(URI, HttpHeaders, WebSocketHandler)</code> 方法，<strong>连接后端【被代理】的 WebSocket 服务</strong>。连接成功后，回调 WebSocketHandler 实现的内部类的 <code>#handle(WebSocketSession)</code> 方法。</li><li>WebSocketHandler 实现的内部类 <ul><li>第 9 至 10 行 ：转发消息，客户端 <code>=&gt;</code> 后端服务。</li><li>第 13 至 14 行 ：转发消息，后端服务 <code>=&gt;</code> 客户端。</li><li>第 18 行 ：调用 <code>Mono#when()</code> 方法，合并 <code>proxySessionSend</code> / <code>serverSessionSend</code> 两个 Mono 。调用 <code>Mono#then()</code> 方法，<strong>参数为空</strong>，合并的 Mono 不发射数据出来。RxJava 和 Reactor 类似，可以参考 <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/And.html" rel="external nofollow noopener noreferrer" target="_blank">《ReactiveX文档中文翻译 —— And/Then/When》</a> 学习下 <code>when / and / then</code> 操作符。</li><li>下图可以帮助理解下这个类的用途 ：<img src="http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_03_25/01.png" alt=""></li></ul></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>😈 限于对 Reactor 和 Netty 了解不够深入，写的不够透彻。回头深入理解下它们。</p><p><img src="http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_03_25/03.png" alt=""></p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Spring-Cloud-Gateway/filter-websocket-routing/&quot;&gt;http://www.iocoder.cn/Spring-Cloud-Gateway/filter
      
    
    </summary>
    
      <category term="Spring-Cloud-Gateway" scheme="http://www.iocoder.cn/categories/Spring-Cloud-Gateway/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.5) 之 ForwardRoutingFilter</title>
    <link href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-forward-routing/"/>
    <id>http://www.iocoder.cn/Spring-Cloud-Gateway/filter-forward-routing/</id>
    <published>2020-03-19T16:00:00.000Z</published>
    <updated>2017-12-01T16:41:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-forward-routing/">http://www.iocoder.cn/Spring-Cloud-Gateway/filter-forward-routing/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Spring-Cloud-Gateway 2.0.X M4</strong>  </p><ul><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-forward-routing/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-forward-routing/">2. RouteToRequestUrlFilter</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-forward-routing/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>ForwardRoutingFilter 的代码实现</strong>。</p><p>RouteToRequestUrlFilter ，转发<strong>路由</strong>网关过滤器。其根据 <code>forward://</code> 前缀( Scheme )过滤处理，<strong>将请求转发到当前网关实例本地接口</strong>。</p><p>举个例子，配置 RouteDefinition 路由定义如下 ：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  application:</span></div><div class="line"><span class="attr">      name:</span> <span class="string">juejin-gateway</span></div><div class="line"><span class="attr">  cloud:</span></div><div class="line"><span class="attr">    gateway:</span></div><div class="line"><span class="attr">      routes:</span></div><div class="line">      <span class="comment"># =====================================</span></div><div class="line"><span class="attr">      - id:</span> <span class="string">forward_sample</span></div><div class="line"><span class="attr">        uri:</span> <span class="attr">forward:///globalfilters</span></div><div class="line"><span class="attr">        order:</span> <span class="number">10000</span></div><div class="line"><span class="attr">        predicates:</span></div><div class="line"><span class="bullet">        -</span> <span class="string">Path=/globalfilters</span></div><div class="line"><span class="attr">        filters:</span></div><div class="line"><span class="bullet">        -</span> <span class="string">PrefixPath=/application/gateway</span></div></pre></td></tr></table></figure><ul><li>我们假定网关端口为 <code>8080</code> 。</li><li>当请求 <code>http://127.0.0.1:8080/globalfilters</code> 接口，Spring Cloud Gateway 处理过程如下 ：<ul><li>匹配到路由 Route (<code>id = forward_sample</code>) 。</li><li><strong>配置</strong>的 PrefixPathGatewayFilterFactory 将请求<strong>改写</strong>成 <code>http://127.0.0.1:8080/application/gateway/globalfilters</code> 。</li><li>ForwardRoutingFilter 判断有 <code>forward://</code> 前缀( Scheme )，过滤处理，将请求<strong>转发</strong>给 DispatcherHandler 。</li><li>DispatcherHandler 匹配并转发到<strong>当前网关实例本地接口</strong> <a href="https://github.com/spring-cloud/spring-cloud-gateway/blob/83496b78944269050373bb92bb2181e1b7c070e8/spring-cloud-gateway-core/src/main/java/org/springframework/cloud/gateway/actuate/GatewayWebfluxEndpoint.java#L96" rel="external nofollow noopener noreferrer" target="_blank"><code>application/gateway/globalfilters</code></a> 。</li></ul></li><li>为什么需要配置 PrefixPathGatewayFilterFactory ？需要通过 PrefixPathGatewayFilterFactory 将请求重写路径，以匹配本地 API ，否则 DispatcherHandler 转发会失败。</li></ul><p>另外，RouteToRequestUrlFilter 是 Spring Cloud Gateway 实现的一种<strong>路由</strong>网关过滤器，目前还提供 WebsocketRoutingFilter / NettyRoutingFilter / WebClientHttpRoutingFilter 。</p><hr><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-RouteToRequestUrlFilter"><a href="#2-RouteToRequestUrlFilter" class="headerlink" title="2. RouteToRequestUrlFilter"></a>2. RouteToRequestUrlFilter</h1><p><code>org.springframework.cloud.gateway.filter.ForwardRoutingFilter</code> ，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardRoutingFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>: <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(ForwardRoutingFilter.class);</div><div class="line"> <span class="number">4</span>: </div><div class="line"> <span class="number">5</span>: <span class="keyword">private</span> <span class="keyword">final</span> DispatcherHandler dispatcherHandler;</div><div class="line"> <span class="number">6</span>: </div><div class="line"> <span class="number">7</span>: <span class="function"><span class="keyword">public</span> <span class="title">ForwardRoutingFilter</span><span class="params">(DispatcherHandler dispatcherHandler)</span> </span>&#123;</div><div class="line"> <span class="number">8</span>: <span class="keyword">this</span>.dispatcherHandler = dispatcherHandler;</div><div class="line"> <span class="number">9</span>: &#125;</div><div class="line"><span class="number">10</span>: </div><div class="line"><span class="number">11</span>: <span class="meta">@Override</span></div><div class="line"><span class="number">12</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">13</span>: <span class="keyword">return</span> Ordered.LOWEST_PRECEDENCE;</div><div class="line"><span class="number">14</span>: &#125;</div><div class="line"><span class="number">15</span>: </div><div class="line"><span class="number">16</span>: <span class="meta">@Override</span></div><div class="line"><span class="number">17</span>: <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</div><div class="line"><span class="number">18</span>:     <span class="comment">// 获得 requestUrl</span></div><div class="line"><span class="number">19</span>: URI requestUrl = exchange.getRequiredAttribute(GATEWAY_REQUEST_URL_ATTR);</div><div class="line"><span class="number">20</span>: </div><div class="line"><span class="number">21</span>: <span class="comment">// 判断是否能够处理</span></div><div class="line"><span class="number">22</span>: String scheme = requestUrl.getScheme();</div><div class="line"><span class="number">23</span>: <span class="keyword">if</span> (isAlreadyRouted(exchange) || !scheme.equals(<span class="string">"forward"</span>)) &#123;</div><div class="line"><span class="number">24</span>: <span class="keyword">return</span> chain.filter(exchange);</div><div class="line"><span class="number">25</span>: &#125;</div><div class="line"><span class="number">26</span>: </div><div class="line"><span class="number">27</span>: <span class="comment">// 设置已经路由</span></div><div class="line"><span class="number">28</span>: setAlreadyRouted(exchange);</div><div class="line"><span class="number">29</span>: </div><div class="line"><span class="number">30</span>: <span class="comment">//<span class="doctag">TODO:</span> translate url?</span></div><div class="line"><span class="number">31</span>: </div><div class="line"><span class="number">32</span>: <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</div><div class="line"><span class="number">33</span>: log.trace(<span class="string">"Forwarding to URI: "</span>+requestUrl);</div><div class="line"><span class="number">34</span>: &#125;</div><div class="line"><span class="number">35</span>: </div><div class="line"><span class="number">36</span>: <span class="comment">// DispatcherHandler 匹配并转发到当前网关实例本地接口</span></div><div class="line"><span class="number">37</span>: <span class="keyword">return</span> <span class="keyword">this</span>.dispatcherHandler.handle(exchange);</div><div class="line"><span class="number">38</span>: &#125;</div><div class="line"><span class="number">39</span>: &#125;</div></pre></td></tr></table></figure><ul><li>实现 <strong>GlobalFilter</strong> 接口。</li><li><code>#getOrder()</code> 方法，返回顺序为 <code>Integer.MAX_VALUE</code> 。在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-intro/?self">《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.1) 之 GatewayFilter 一览》「3. GlobalFilter」</a> ，我们列举了所有 GlobalFilter 的顺序。</li><li>第 19 行 ：获得 <code>requestUrl</code> 。</li><li><p>第 22 至 25 行 ：判断 ForwardRoutingFilter 是否能够处理该请求，需要满足两个条件 ：</p><ul><li><code>forward://</code> 前缀( Scheme ) 。</li><li><p>调用 <code>ServerWebExchangeUtils#isAlreadyRouted(ServerWebExchange)</code> 方法，判断该请求暂未被其他 Routing 网关处理。代码如下 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAlreadyRouted</span><span class="params">(ServerWebExchange exchange)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> exchange.getAttributeOrDefault(GATEWAY_ALREADY_ROUTED_ATTR, <span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul></li></ul></li><li><p>第 28 行 ：设置该请求已经被处理。代码如下 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setAlreadyRouted</span><span class="params">(ServerWebExchange exchange)</span> </span>&#123;</div><div class="line">    exchange.getAttributes().put(GATEWAY_ALREADY_ROUTED_ATTR, <span class="keyword">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>第 37 行 ：将请求<strong>转发</strong>给 DispatcherHandler 。DispatcherHandler 匹配并转发到<strong>当前网关实例本地接口</strong>。</p></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>一开始想错了 ForwardRoutingFilter 了的用途，调试许久，后面看了官方提供的示例 <code>org.springframework.cloud.gateway.test.ForwardTests</code> ，豁然开朗。</p><p><img src="http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_03_20/01.png" alt=""></p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Spring-Cloud-Gateway/filter-forward-routing/&quot;&gt;http://www.iocoder.cn/Spring-Cloud-Gateway/filter-f
      
    
    </summary>
    
      <category term="Spring-Cloud-Gateway" scheme="http://www.iocoder.cn/categories/Spring-Cloud-Gateway/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.4) 之 LoadBalancerClientFilter 负载均衡</title>
    <link href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-load-balancer-client/"/>
    <id>http://www.iocoder.cn/Spring-Cloud-Gateway/filter-load-balancer-client/</id>
    <published>2020-03-14T16:00:00.000Z</published>
    <updated>2017-12-01T16:41:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-load-balancer-client/">http://www.iocoder.cn/Spring-Cloud-Gateway/filter-load-balancer-client/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Spring-Cloud-Gateway 2.0.X M4</strong>  </p><ul><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-load-balancer-client/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-load-balancer-client/">2. 环境搭建</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-load-balancer-client/">3. LoadBalancerClientFilter</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-load-balancer-client/">4. 高能</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-load-balancer-client/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>LoadBalancerClientFilter 的代码实现</strong>。</p><p>LoadBalancerClientFilter 根据 <code>lb://</code> 前缀过滤处理，使用 <code>serviceId</code> 选择<strong>一个</strong>服务实例，从而实现<strong>负载均衡</strong>。</p><hr><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2. 环境搭建"></a>2. 环境搭建</h1><p>在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/route-definition-locator-discover-client/?self">《Spring-Cloud-Gateway 源码解析 —— 路由（1.4）之 DiscoveryClientRouteDefinitionLocator 注册中心》「2. 环境搭建」</a> 有详细教程。</p><h1 id="3-LoadBalancerClientFilter"><a href="#3-LoadBalancerClientFilter" class="headerlink" title="3. LoadBalancerClientFilter"></a>3. LoadBalancerClientFilter</h1><p><code>org.springframework.cloud.gateway.filter.LoadBalancerClientFilter</code> ，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerClientFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>: <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(LoadBalancerClientFilter.class);</div><div class="line"> <span class="number">4</span>: <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LOAD_BALANCER_CLIENT_FILTER_ORDER = <span class="number">10100</span>;</div><div class="line"> <span class="number">5</span>: </div><div class="line"> <span class="number">6</span>: <span class="keyword">private</span> <span class="keyword">final</span> LoadBalancerClient loadBalancer;</div><div class="line"> <span class="number">7</span>: </div><div class="line"> <span class="number">8</span>: <span class="function"><span class="keyword">public</span> <span class="title">LoadBalancerClientFilter</span><span class="params">(LoadBalancerClient loadBalancer)</span> </span>&#123;</div><div class="line"> <span class="number">9</span>: <span class="keyword">this</span>.loadBalancer = loadBalancer;</div><div class="line"><span class="number">10</span>: &#125;</div><div class="line"><span class="number">11</span>: </div><div class="line"><span class="number">12</span>: <span class="meta">@Override</span></div><div class="line"><span class="number">13</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">14</span>: <span class="keyword">return</span> LOAD_BALANCER_CLIENT_FILTER_ORDER;</div><div class="line"><span class="number">15</span>: &#125;</div><div class="line"><span class="number">16</span>: </div><div class="line"><span class="number">17</span>: <span class="meta">@Override</span></div><div class="line"><span class="number">18</span>: <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</div><div class="line"><span class="number">19</span>: <span class="comment">// 获得 URL</span></div><div class="line"><span class="number">20</span>: URI url = exchange.getAttribute(GATEWAY_REQUEST_URL_ATTR);</div><div class="line"><span class="number">21</span>: <span class="keyword">if</span> (url == <span class="keyword">null</span> || !url.getScheme().equals(<span class="string">"lb"</span>)) &#123;</div><div class="line"><span class="number">22</span>: <span class="keyword">return</span> chain.filter(exchange);</div><div class="line"><span class="number">23</span>: &#125;</div><div class="line"><span class="number">24</span>: <span class="comment">// 添加 原始请求URI 到 GATEWAY_ORIGINAL_REQUEST_URL_ATTR</span></div><div class="line"><span class="number">25</span>: <span class="comment">//preserve the original url</span></div><div class="line"><span class="number">26</span>: addOriginalRequestUrl(exchange, url);</div><div class="line"><span class="number">27</span>: </div><div class="line"><span class="number">28</span>: log.trace(<span class="string">"LoadBalancerClientFilter url before: "</span> + url);</div><div class="line"><span class="number">29</span>: </div><div class="line"><span class="number">30</span>: <span class="comment">// 获取 服务实例</span></div><div class="line"><span class="number">31</span>: <span class="keyword">final</span> ServiceInstance instance = loadBalancer.choose(url.getHost());</div><div class="line"><span class="number">32</span>: <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">33</span>: <span class="keyword">throw</span> <span class="keyword">new</span> NotFoundException(<span class="string">"Unable to find instance for "</span> + url.getHost());</div><div class="line"><span class="number">34</span>: &#125;</div><div class="line"><span class="number">35</span>: </div><div class="line"><span class="number">36</span>: <span class="comment">/*URI uri = exchange.getRequest().getURI();</span></div><div class="line"><span class="comment">37: URI requestUrl = loadBalancer.reconstructURI(instance, uri);*/</span></div><div class="line"><span class="number">38</span>: <span class="comment">//</span></div><div class="line"><span class="number">39</span>: URI requestUrl = UriComponentsBuilder.fromUri(url)</div><div class="line"><span class="number">40</span>: .scheme(instance.isSecure()? <span class="string">"https"</span> : <span class="string">"http"</span>) <span class="comment">//<span class="doctag">TODO:</span> support websockets</span></div><div class="line"><span class="number">41</span>: .host(instance.getHost())</div><div class="line"><span class="number">42</span>: .port(instance.getPort())</div><div class="line"><span class="number">43</span>: .build(<span class="keyword">true</span>)</div><div class="line"><span class="number">44</span>: .toUri();</div><div class="line"><span class="number">45</span>: log.trace(<span class="string">"LoadBalancerClientFilter url chosen: "</span> + requestUrl);</div><div class="line"><span class="number">46</span>: </div><div class="line"><span class="number">47</span>: <span class="comment">// 添加 请求URI 到 GATEWAY_REQUEST_URL_ATTR</span></div><div class="line"><span class="number">48</span>: exchange.getAttributes().put(GATEWAY_REQUEST_URL_ATTR, requestUrl);</div><div class="line"><span class="number">49</span>: </div><div class="line"><span class="number">50</span>: <span class="comment">// 提交过滤器链继续过滤</span></div><div class="line"><span class="number">51</span>: <span class="keyword">return</span> chain.filter(exchange);</div><div class="line"><span class="number">52</span>: &#125;</div><div class="line"><span class="number">53</span>: </div><div class="line"><span class="number">54</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 19 至 23 行 ：获得 URL 。<strong>只处理 <code>lb://</code> 为前缀( Scheme )的地址</strong>。</li><li><p>第 第 26 行 ：调用 <code>ServerWebExchangeUtils#addOriginalRequestUrl(...)</code> 添加原始请求 URI 到 <code>GATEWAY_ORIGINAL_REQUEST_URL_ATTR</code> 。代码如下 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addOriginalRequestUrl</span><span class="params">(ServerWebExchange exchange, URI url)</span> </span>&#123;</div><div class="line">exchange.getAttributes().computeIfAbsent(GATEWAY_ORIGINAL_REQUEST_URL_ATTR, s -&gt; <span class="keyword">new</span> LinkedHashSet&lt;&gt;()); <span class="comment">// 数组，考虑多次重写</span></div><div class="line">    LinkedHashSet&lt;URI&gt; uris = exchange.getRequiredAttribute(GATEWAY_ORIGINAL_REQUEST_URL_ATTR);</div><div class="line">    uris.add(url);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>为什么使用 LinkedHashSet ？因为可以使用 RewritePathGatewayFilterFactory / PrefixPathGatewayFilterFactory 多次重写。</li></ul></li><li><p>第 30 至 34 行 ：调用 <code>LoadBalancerClient#choose(String)</code> 方法，获得<strong>一个</strong>服务实例( ServiceInstance ) ，从而实现<strong>负载均衡</strong>。</p><ul><li>熟悉 Spring Cloud 的同学都知道，一般情况下 LoadBalancerClient 实现类为 <code>org.springframework.cloud.netflix.ribbon.RibbonLoadBalancerClient</code> 。</li><li>举个 <code>instance</code> 的<strong>值</strong>例子 ：<img src="http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_03_15/01.png" alt=""></li></ul></li><li>第 39 至 45 行 ：创建 <code>requestUrl</code> 。举个例子 ：<img src="http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_03_15/02.png" alt=""></li><li>第 48 行 ：设置 <code>requestUrl</code> 到 <code>GATEWAY_REQUEST_URL_ATTR</code> 。后面 Routing 相关的 GatewayFilter 会通过该属性，发起请求。</li><li>第 51 行 ：提交过滤器链继续过滤。<strong>注意</strong>，这里不需要创建<strong>新</strong>的 ServerWebExchange </li></ul><h1 id="4-高能"><a href="#4-高能" class="headerlink" title="4. 高能"></a>4. 高能</h1><p>我们回过头看 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/route-definition-locator-discover-client/?self">《Spring-Cloud-Gateway 源码解析 —— 路由（1.4）之 DiscoveryClientRouteDefinitionLocator 注册中心》「4. 高能」</a></p><p>相同服务( <code>serviceId</code> 相同) ，服务实例的注册或下线，Ribbon 已经处理，所以不用担心。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>没有彩蛋，继续往下写！当然，《天才麻将少女》的福利还是有的！</p><p><img src="http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_03_15/03.png" alt=""></p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Spring-Cloud-Gateway/filter-load-balancer-client/&quot;&gt;http://www.iocoder.cn/Spring-Cloud-Gateway/fil
      
    
    </summary>
    
      <category term="Spring-Cloud-Gateway" scheme="http://www.iocoder.cn/categories/Spring-Cloud-Gateway/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.3) 之 RouteToRequestUrlFilter</title>
    <link href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-route-to-request/"/>
    <id>http://www.iocoder.cn/Spring-Cloud-Gateway/filter-route-to-request/</id>
    <published>2020-03-09T16:00:00.000Z</published>
    <updated>2017-12-01T16:41:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-route-to-request/">http://www.iocoder.cn/Spring-Cloud-Gateway/filter-route-to-request/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Spring-Cloud-Gateway 2.0.X M4</strong>  </p><ul><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-route-to-request/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-route-to-request/">2. RouteToRequestUrlFilter</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-route-to-request/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>RouteToRequestUrlFilter 的代码实现</strong>。</p><p>RouteToRequestUrlFilter 根据<strong>匹配</strong>的 Route ，计算请求的地址。<strong>注意，这里的地址指的是 URL ，而不是 URI</strong> 。</p><p>😈 RouteToRequestUrlFilter 的代码十分少，所以这会是一篇简单的文章。</p><hr><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-RouteToRequestUrlFilter"><a href="#2-RouteToRequestUrlFilter" class="headerlink" title="2. RouteToRequestUrlFilter"></a>2. RouteToRequestUrlFilter</h1><p><code>org.springframework.cloud.gateway.filter.RouteToRequestUrlFilter</code> ，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RouteToRequestUrlFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>: <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(RouteToRequestUrlFilter.class);</div><div class="line"> <span class="number">4</span>: <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ROUTE_TO_URL_FILTER_ORDER = <span class="number">10000</span>;</div><div class="line"> <span class="number">5</span>: </div><div class="line"> <span class="number">6</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">7</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">8</span>: <span class="keyword">return</span> ROUTE_TO_URL_FILTER_ORDER;</div><div class="line"> <span class="number">9</span>: &#125;</div><div class="line"><span class="number">10</span>: </div><div class="line"><span class="number">11</span>: <span class="meta">@Override</span></div><div class="line"><span class="number">12</span>: <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</div><div class="line"><span class="number">13</span>:     <span class="comment">// 获得 Route</span></div><div class="line"><span class="number">14</span>: Route route = exchange.getAttribute(GATEWAY_ROUTE_ATTR);</div><div class="line"><span class="number">15</span>: <span class="keyword">if</span> (route == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">16</span>: <span class="keyword">return</span> chain.filter(exchange);</div><div class="line"><span class="number">17</span>: &#125;</div><div class="line"><span class="number">18</span>: log.trace(<span class="string">"RouteToRequestUrlFilter start"</span>);</div><div class="line"><span class="number">19</span>: <span class="comment">// 拼接 requestUrl</span></div><div class="line"><span class="number">20</span>: URI requestUrl = UriComponentsBuilder.fromHttpRequest(exchange.getRequest())</div><div class="line"><span class="number">21</span>: .uri(route.getUri())</div><div class="line"><span class="number">22</span>: .build(<span class="keyword">true</span>) <span class="comment">// encoded=true</span></div><div class="line"><span class="number">23</span>: .toUri();</div><div class="line"><span class="number">24</span>: <span class="comment">// 设置 requestUrl 到 GATEWAY_REQUEST_URL_ATTR &#123;@link RewritePathGatewayFilterFactory&#125;</span></div><div class="line"><span class="number">25</span>: exchange.getAttributes().put(GATEWAY_REQUEST_URL_ATTR, requestUrl);</div><div class="line"><span class="number">26</span>: <span class="comment">// 提交过滤器链继续过滤</span></div><div class="line"><span class="number">27</span>: <span class="keyword">return</span> chain.filter(exchange);</div><div class="line"><span class="number">28</span>: &#125;</div><div class="line"><span class="number">29</span>: </div><div class="line"><span class="number">30</span>: &#125;</div></pre></td></tr></table></figure><ul><li>实现 <strong>GlobalFilter</strong> 接口。</li><li><code>#getOrder()</code> 方法，返回顺序为 10000 。在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-intro/?self">《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.1) 之 GatewayFilter 一览》「3. GlobalFilter」</a> ，我们列举了所有 GlobalFilter 的顺序。</li><li>第 13 至 18 行 ：获得请求匹配的 Route ，在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/handler-route-predicate-handler-mapping/?self">《Spring-Cloud-Gateway 源码解析 —— 处理器 (3.2) 之 RoutePredicateHandlerMapping 路由匹配》</a> 有详细解析。</li><li>第 20 至 23 行 ：拼接 <code>requestUrl</code> 。这里有一点要注意下，如果 <code>Route.uri</code> 属性配置带有 Path ，则会覆盖请求的 Path 。我们来举个例子 ：</li></ul><table><thead><tr><th><code>Route.uri</code></th><th><code>Request.uri</code></th><th><code>requestUrl</code></th></tr></thead><tbody><tr><td><a href="http://bin.org:80" rel="external nofollow noopener noreferrer" target="_blank">http://bin.org:80</a></td><td><a href="http://127.0.0.1:8080/test/segment" rel="external nofollow noopener noreferrer" target="_blank">http://127.0.0.1:8080/test/segment</a></td><td><a href="http://httpbin.org:80/123" rel="external nofollow noopener noreferrer" target="_blank">http://httpbin.org:80/123</a></td></tr><tr><td><a href="http://bin.org:80/123" rel="external nofollow noopener noreferrer" target="_blank">http://bin.org:80/123</a></td><td><a href="http://127.0.0.1:8080/test/segment" rel="external nofollow noopener noreferrer" target="_blank">http://127.0.0.1:8080/test/segment</a></td><td><a href="http://httpbin.org:80/test/segment" rel="external nofollow noopener noreferrer" target="_blank">http://httpbin.org:80/test/segment</a></td></tr></tbody></table><ul><li><p>为什么会导致覆盖的情况呢 ？答案在 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/util/UriComponentsBuilder.java#L413" rel="external nofollow noopener noreferrer" target="_blank"><code>UriComponentsBuilder#uri(URI)</code></a> 方法，代码如下 ：</p><pre><code class="Java"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> UriComponentsBuilder <span class="title">uri</span><span class="params">(URI uri)</span> </span>{ <span class="number">2</span>:     Assert.notNull(uri, <span class="string">"URI must not be null"</span>); <span class="number">3</span>:     <span class="keyword">this</span>.scheme = uri.getScheme(); <span class="number">4</span>:     <span class="keyword">if</span> (uri.isOpaque()) { <span class="number">5</span>:         <span class="keyword">this</span>.ssp = uri.getRawSchemeSpecificPart(); <span class="number">6</span>:         resetHierarchicalComponents(); <span class="number">7</span>:     } <span class="number">8</span>:     <span class="keyword">else</span> { <span class="number">9</span>:         <span class="keyword">if</span> (uri.getRawUserInfo() != <span class="keyword">null</span>) {<span class="number">10</span>:             <span class="keyword">this</span>.userInfo = uri.getRawUserInfo();<span class="number">11</span>:         }<span class="number">12</span>:         <span class="keyword">if</span> (uri.getHost() != <span class="keyword">null</span>) {<span class="number">13</span>:             <span class="keyword">this</span>.host = uri.getHost();<span class="number">14</span>:         }<span class="number">15</span>:         <span class="keyword">if</span> (uri.getPort() != -<span class="number">1</span>) {<span class="number">16</span>:             <span class="keyword">this</span>.port = String.valueOf(uri.getPort());<span class="number">17</span>:         }<span class="number">18</span>:         <span class="keyword">if</span> (StringUtils.hasLength(uri.getRawPath())) {<span class="number">19</span>:             <span class="keyword">this</span>.pathBuilder = <span class="keyword">new</span> CompositePathComponentBuilder();<span class="number">20</span>:             <span class="keyword">this</span>.pathBuilder.addPath(uri.getRawPath());<span class="number">21</span>:         }<span class="number">22</span>:         <span class="keyword">if</span> (StringUtils.hasLength(uri.getRawQuery())) {<span class="number">23</span>:             <span class="keyword">this</span>.queryParams.clear();<span class="number">24</span>:             query(uri.getRawQuery());<span class="number">25</span>:         }<span class="number">26</span>:         resetSchemeSpecificPart();<span class="number">27</span>:     }<span class="number">28</span>:     <span class="keyword">if</span> (uri.getRawFragment() != <span class="keyword">null</span>) {<span class="number">29</span>:         <span class="keyword">this</span>.fragment = uri.getRawFragment();<span class="number">30</span>:     }<span class="number">31</span>:     <span class="keyword">return</span> <span class="keyword">this</span>;<span class="number">32</span>: }</code></pre><ul><li>第 18 至 21 行 ：当 <code>uri</code> 参数有 Path 时，<strong>新建</strong>一个 CompositePathComponentBuilder ，因此原有的 <code>this.pathBuilder</code> 被<strong>覆盖</strong>了。</li></ul></li><li><p>第 25 行 ：设置 <code>requestUrl</code> 到 <code>GATEWAY_REQUEST_URL_ATTR</code> 。后面 Routing 相关的 GatewayFilter 会通过该属性，发起请求。</p></li><li>第 27 行 ：提交过滤器链继续过滤。<strong>注意</strong>，这里不需要创建<strong>新</strong>的 ServerWebExchange 。 </li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>😈 硬生生把这个文章丰富了下。人生如戏，全靠套路。</p><p><img src="http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_03_10/01.png" alt=""></p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Spring-Cloud-Gateway/filter-route-to-request/&quot;&gt;http://www.iocoder.cn/Spring-Cloud-Gateway/filter-
      
    
    </summary>
    
      <category term="Spring-Cloud-Gateway" scheme="http://www.iocoder.cn/categories/Spring-Cloud-Gateway/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.2) 之 GatewayFilterFactory 过滤器工厂</title>
    <link href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-factory/"/>
    <id>http://www.iocoder.cn/Spring-Cloud-Gateway/filter-factory/</id>
    <published>2020-03-04T16:00:00.000Z</published>
    <updated>2017-12-01T16:41:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-factory/">http://www.iocoder.cn/Spring-Cloud-Gateway/filter-factory/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Spring-Cloud-Gateway 2.0.X M4</strong>  </p><ul><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-factory/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-factory/">2. Header</a><ul><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-factory/">2.1 AddRequestHeaderGatewayFilterFactory</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-factory/">2.2 RemoveRequestHeaderGatewayFilterFactory</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-factory/">2.3 AddResponseHeaderGatewayFilterFactory</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-factory/">2.4 RemoveResponseHeaderGatewayFilterFactory</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-factory/">2.5 SetResponseHeaderGatewayFilterFactory</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-factory/">2.6 RemoveNonProxyHeadersGatewayFilterFactory</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-factory/">2.7 SecureHeadersGatewayFilterFactory</a></li></ul></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-factory/">3. Parameter</a><ul><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-factory/">3.1 AddRequestParameterGatewayFilterFactory</a></li></ul></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-factory/">4. Path</a><ul><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-factory/">4.1 RewritePathGatewayFilterFactory</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-factory/">4.2 PrefixPathGatewayFilterFactory</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-factory/">4.3 SetPathGatewayFilterFactory</a></li></ul></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-factory/">5. Status</a><ul><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-factory/">5.1 SetStatusGatewayFilterFactory</a></li></ul></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-factory/">6. Redirect</a><ul><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-factory/">6.1 RedirectToGatewayFilterFactory</a></li></ul></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-factory/">7. Hystrix</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-factory/">8. RateLimiter</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-factory/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>GatewayFilterFactory 的实现类</strong>。</p><p>GatewayFilterFactory 实现类较多，根据用途整理如下脑图 ：</p><p><img src="http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_03_05/01.png" alt=""></p><p>下面我们开始逐块解析源码实现。</p><hr><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-Header"><a href="#2-Header" class="headerlink" title="2. Header"></a>2. Header</h1><p>本小节分享 Header 相关的 GatewayFilterFactory 实现类。</p><h2 id="2-1-AddRequestHeaderGatewayFilterFactory"><a href="#2-1-AddRequestHeaderGatewayFilterFactory" class="headerlink" title="2.1 AddRequestHeaderGatewayFilterFactory"></a>2.1 AddRequestHeaderGatewayFilterFactory</h2><ul><li>用途 ：添加指定请求 Header 为指定值。</li><li><p>配置 ：</p>  <figure class="highlight yaml"><table><tr><td class="code"><pre><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  cloud:</span></div><div class="line"><span class="attr">    gateway:</span></div><div class="line"><span class="attr">      routes:</span></div><div class="line">      <span class="comment"># =====================================</span></div><div class="line"><span class="attr">      - id:</span> <span class="string">add_request_header_route</span></div><div class="line"><span class="attr">        uri:</span> <span class="attr">http://example.org</span></div><div class="line"><span class="attr">        filters:</span></div><div class="line"><span class="bullet">        -</span> <span class="string">AddRequestHeader=X-Request-Foo,</span> <span class="string">Bar</span></div></pre></td></tr></table></figure></li><li><p>代码 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddRequestHeaderGatewayFilterFactory</span> <span class="keyword">implements</span> <span class="title">GatewayFilterFactory</span> </span>&#123;</div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">4</span>: <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">argNames</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">5</span>: <span class="keyword">return</span> Arrays.asList(NAME_KEY, VALUE_KEY);</div><div class="line"> <span class="number">6</span>: &#125;</div><div class="line"> <span class="number">7</span>: </div><div class="line"> <span class="number">8</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">9</span>: <span class="function"><span class="keyword">public</span> GatewayFilter <span class="title">apply</span><span class="params">(Tuple args)</span> </span>&#123;</div><div class="line"><span class="number">10</span>: String name = args.getString(NAME_KEY);</div><div class="line"><span class="number">11</span>: String value = args.getString(VALUE_KEY);</div><div class="line"><span class="number">12</span>: </div><div class="line"><span class="number">13</span>: <span class="keyword">return</span> (exchange, chain) -&gt; &#123; <span class="comment">// GatewayFilter</span></div><div class="line"><span class="number">14</span>: <span class="comment">// 创建新的 ServerHttpRequest</span></div><div class="line"><span class="number">15</span>: ServerHttpRequest request = exchange.getRequest().mutate()</div><div class="line"><span class="number">16</span>: .header(name, value)</div><div class="line"><span class="number">17</span>: .build();</div><div class="line"><span class="number">18</span>: </div><div class="line"><span class="number">19</span>: <span class="comment">// 创建新的 ServerWebExchange ，提交过滤器链继续过滤</span></div><div class="line"><span class="number">20</span>: <span class="keyword">return</span> chain.filter(exchange.mutate().request(request).build());</div><div class="line"><span class="number">21</span>: &#125;;</div><div class="line"><span class="number">22</span>: &#125;</div><div class="line"><span class="number">23</span>: &#125;</div></pre></td></tr></table></figure><ul><li>Tuple 参数 ：<code>name</code> / <code>value</code> 。</li><li>第 14 至 17 行 ：创建<strong>新</strong>的 ServerHttpRequest 。</li><li>第 19 至 20 行 ：创建<strong>新</strong>的 ServerWebExchange ，提交<strong>过滤器链</strong>继续过滤。</li></ul></li></ul><h2 id="2-2-RemoveRequestHeaderGatewayFilterFactory"><a href="#2-2-RemoveRequestHeaderGatewayFilterFactory" class="headerlink" title="2.2 RemoveRequestHeaderGatewayFilterFactory"></a>2.2 RemoveRequestHeaderGatewayFilterFactory</h2><p>类似 AddRequestHeaderGatewayFilterFactory ，不重复分享，点击 <a href="https://github.com/spring-cloud/spring-cloud-gateway/blob/9ffb0f18678460fda9b25c572c12f9054a62ca52/docs/src/main/asciidoc/spring-cloud-gateway.adoc#removerequestheader-gatewayfilter-factory" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud Gateway —— RemoveRequestHeader GatewayFilter Factory》</a> 查看官方文档。</p><h2 id="2-3-AddResponseHeaderGatewayFilterFactory"><a href="#2-3-AddResponseHeaderGatewayFilterFactory" class="headerlink" title="2.3 AddResponseHeaderGatewayFilterFactory"></a>2.3 AddResponseHeaderGatewayFilterFactory</h2><p>类似 AddRequestHeaderGatewayFilterFactory ，不重复分享，点击 <a href="https://github.com/spring-cloud/spring-cloud-gateway/blob/9ffb0f18678460fda9b25c572c12f9054a62ca52/docs/src/main/asciidoc/spring-cloud-gateway.adoc#addresponseheader-gatewayfilter-factory" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud Gateway —— AddResponseHeader GatewayFilter Factory》</a> 查看官方文档。</p><h2 id="2-4-RemoveResponseHeaderGatewayFilterFactory"><a href="#2-4-RemoveResponseHeaderGatewayFilterFactory" class="headerlink" title="2.4 RemoveResponseHeaderGatewayFilterFactory"></a>2.4 RemoveResponseHeaderGatewayFilterFactory</h2><p>类似 AddRequestHeaderGatewayFilterFactory ，不重复分享，点击 <a href="https://github.com/spring-cloud/spring-cloud-gateway/blob/9ffb0f18678460fda9b25c572c12f9054a62ca52/docs/src/main/asciidoc/spring-cloud-gateway.adoc#removeresponseheader-gatewayfilter-factory" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud Gateway —— RemoveResponseHeader GatewayFilter Factory》</a> 查看官方文档。</p><h2 id="2-5-SetResponseHeaderGatewayFilterFactory"><a href="#2-5-SetResponseHeaderGatewayFilterFactory" class="headerlink" title="2.5 SetResponseHeaderGatewayFilterFactory"></a>2.5 SetResponseHeaderGatewayFilterFactory</h2><p>类似 AddRequestHeaderGatewayFilterFactory ，不重复分享，点击 <a href="https://github.com/spring-cloud/spring-cloud-gateway/blob/9ffb0f18678460fda9b25c572c12f9054a62ca52/docs/src/main/asciidoc/spring-cloud-gateway.adoc#removeresponseheader-gatewayfilter-factory" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud Gateway —— SetStatus GatewayFilter Factory》</a> 查看官方文档。</p><h2 id="2-6-RemoveNonProxyHeadersGatewayFilterFactory"><a href="#2-6-RemoveNonProxyHeadersGatewayFilterFactory" class="headerlink" title="2.6 RemoveNonProxyHeadersGatewayFilterFactory"></a>2.6 RemoveNonProxyHeadersGatewayFilterFactory</h2><ul><li>用途 ：移除请求 <strong>Proxy</strong> 相关的 Header 。默认值为 <code>[ &quot;Connection&quot;, &quot;Keep-Alive&quot;, &quot;Proxy-Authenticate&quot;, &quot;Proxy-Authorization&quot;, &quot;TE&quot;, &quot;Trailer&quot;, &quot;Transfer-Encoding&quot;, &quot;Upgrade&quot; ]</code> ( 参考自 ：<a href="https://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-14#section-7.1.3" rel="external nofollow noopener noreferrer" target="_blank">https://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-14#section-7.1.3</a> ) ，可以通过 <code>spring.cloud.gateway.filter.remove-non-proxy-headers</code> 配置。</li><li><p>代码 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="number">1</span>: <span class="meta">@ConfigurationProperties</span>(<span class="string">"spring.cloud.gateway.filter.remove-non-proxy-headers"</span>)</div><div class="line"> <span class="number">2</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveNonProxyHeadersGatewayFilterFactory</span> <span class="keyword">implements</span> <span class="title">GatewayFilterFactory</span> </span>&#123;</div><div class="line"> <span class="number">3</span>: </div><div class="line"> <span class="number">4</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment"> 5:      * 默认</span></div><div class="line"><span class="comment"> 6:      */</span></div><div class="line"> <span class="number">7</span>: <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] DEFAULT_HEADERS_TO_REMOVE = <span class="keyword">new</span> String[] &#123;<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>,</div><div class="line"> <span class="number">8</span>: <span class="string">"Proxy-Authenticate"</span>, <span class="string">"Proxy-Authorization"</span>, <span class="string">"TE"</span>, <span class="string">"Trailer"</span>, <span class="string">"Transfer-Encoding"</span>, <span class="string">"Upgrade"</span>&#125;;</div><div class="line"> <span class="number">9</span>: </div><div class="line"><span class="number">10</span>: <span class="keyword">private</span> List&lt;String&gt; headers = Arrays.asList(DEFAULT_HEADERS_TO_REMOVE);</div><div class="line"><span class="number">11</span>: </div><div class="line"><span class="number">12</span>: <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getHeaders</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">13</span>: <span class="keyword">return</span> headers;</div><div class="line"><span class="number">14</span>: &#125;</div><div class="line"><span class="number">15</span>: </div><div class="line"><span class="number">16</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeaders</span><span class="params">(List&lt;String&gt; headers)</span> </span>&#123;</div><div class="line"><span class="number">17</span>: <span class="keyword">this</span>.headers = headers;</div><div class="line"><span class="number">18</span>: &#125;</div><div class="line"><span class="number">19</span>: </div><div class="line"><span class="number">20</span>: <span class="meta">@Override</span></div><div class="line"><span class="number">21</span>: <span class="function"><span class="keyword">public</span> GatewayFilter <span class="title">apply</span><span class="params">(Tuple args)</span> </span>&#123;</div><div class="line"><span class="number">22</span>: <span class="comment">//<span class="doctag">TODO:</span> support filter args</span></div><div class="line"><span class="number">23</span>: </div><div class="line"><span class="number">24</span>: <span class="keyword">return</span> (exchange, chain) -&gt; &#123;</div><div class="line"><span class="number">25</span>: <span class="comment">// 创建新的 ServerHttpRequest</span></div><div class="line"><span class="number">26</span>: ServerHttpRequest request = exchange.getRequest().mutate()</div><div class="line"><span class="number">27</span>: .headers(httpHeaders -&gt; &#123;</div><div class="line"><span class="number">28</span>: <span class="keyword">for</span> (String header : <span class="keyword">this</span>.headers) &#123;</div><div class="line"><span class="number">29</span>: httpHeaders.remove(header); <span class="comment">// 移除</span></div><div class="line"><span class="number">30</span>: &#125;</div><div class="line"><span class="number">31</span>: &#125;)</div><div class="line"><span class="number">32</span>: .build();</div><div class="line"><span class="number">33</span>: </div><div class="line"><span class="number">34</span>: <span class="comment">// 创建新的 ServerWebExchange ，提交过滤器链继续过滤</span></div><div class="line"><span class="number">35</span>: <span class="keyword">return</span> chain.filter(exchange.mutate().request(request).build());</div><div class="line"><span class="number">36</span>: &#125;;</div><div class="line"><span class="number">37</span>: &#125;</div><div class="line"><span class="number">38</span>:</div></pre></td></tr></table></figure></li></ul><h2 id="2-7-SecureHeadersGatewayFilterFactory"><a href="#2-7-SecureHeadersGatewayFilterFactory" class="headerlink" title="2.7 SecureHeadersGatewayFilterFactory"></a>2.7 SecureHeadersGatewayFilterFactory</h2><ul><li>用途 ：添加响应 Secure 相关的 Header 。默认值在 <a href="https://github.com/spring-cloud/spring-cloud-gateway/blob/9ffb0f18678460fda9b25c572c12f9054a62ca52/spring-cloud-gateway-core/src/main/java/org/springframework/cloud/gateway/filter/factory/SecureHeadersProperties.java#L27" rel="external nofollow noopener noreferrer" target="_blank"><code>org.springframework.cloud.gateway.filter.factory.SecureHeadersProperties</code></a> ，可以通过 <code>spring.cloud.gateway.filter.secure-headers</code> 配置。</li><li>推荐文章 ：<ul><li><a href="https://blog.appcanary.com/2017/http-security-headers.html" rel="external nofollow noopener noreferrer" target="_blank">《Everything you need to know about HTTP security headers》</a></li><li><a href="http://blog.jobbole.com/60143/" rel="external nofollow noopener noreferrer" target="_blank">《4个常用的HTTP安全头部》</a> </li></ul></li><li><p>代码 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecureHeadersGatewayFilterFactory</span> <span class="keyword">implements</span> <span class="title">GatewayFilterFactory</span> </span>&#123;</div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>: <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String X_XSS_PROTECTION_HEADER = <span class="string">"X-Xss-Protection"</span>;</div><div class="line"> <span class="number">4</span>: <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String STRICT_TRANSPORT_SECURITY_HEADER = <span class="string">"Strict-Transport-Security"</span>;</div><div class="line"> <span class="number">5</span>: <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String X_FRAME_OPTIONS_HEADER = <span class="string">"X-Frame-Options"</span>;</div><div class="line"> <span class="number">6</span>: <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String X_CONTENT_TYPE_OPTIONS_HEADER = <span class="string">"X-Content-Type-Options"</span>;</div><div class="line"> <span class="number">7</span>: <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REFERRER_POLICY_HEADER = <span class="string">"Referrer-Policy"</span>;</div><div class="line"> <span class="number">8</span>: <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONTENT_SECURITY_POLICY_HEADER = <span class="string">"Content-Security-Policy"</span>;</div><div class="line"> <span class="number">9</span>: <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String X_DOWNLOAD_OPTIONS_HEADER = <span class="string">"X-Download-Options"</span>;</div><div class="line"><span class="number">10</span>: <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String X_PERMITTED_CROSS_DOMAIN_POLICIES_HEADER = <span class="string">"X-Permitted-Cross-Domain-Policies"</span>;</div><div class="line"><span class="number">11</span>: </div><div class="line"><span class="number">12</span>: <span class="keyword">private</span> <span class="keyword">final</span> SecureHeadersProperties properties;</div><div class="line"><span class="number">13</span>: </div><div class="line"><span class="number">14</span>: <span class="function"><span class="keyword">public</span> <span class="title">SecureHeadersGatewayFilterFactory</span><span class="params">(SecureHeadersProperties properties)</span> </span>&#123;</div><div class="line"><span class="number">15</span>: <span class="keyword">this</span>.properties = properties;</div><div class="line"><span class="number">16</span>: &#125;</div><div class="line"><span class="number">17</span>: </div><div class="line"><span class="number">18</span>: <span class="meta">@Override</span></div><div class="line"><span class="number">19</span>: <span class="function"><span class="keyword">public</span> GatewayFilter <span class="title">apply</span><span class="params">(Tuple args)</span> </span>&#123;</div><div class="line"><span class="number">20</span>: <span class="comment">//<span class="doctag">TODO:</span> allow args to override properties</span></div><div class="line"><span class="number">21</span>: </div><div class="line"><span class="number">22</span>: <span class="keyword">return</span> (exchange, chain) -&gt; &#123;</div><div class="line"><span class="number">23</span>: HttpHeaders headers = exchange.getResponse().getHeaders();</div><div class="line"><span class="number">24</span>: </div><div class="line"><span class="number">25</span>: <span class="comment">//<span class="doctag">TODO:</span> allow header to be disabled</span></div><div class="line"><span class="number">26</span>: headers.add(X_XSS_PROTECTION_HEADER, properties.getXssProtectionHeader());</div><div class="line"><span class="number">27</span>: headers.add(STRICT_TRANSPORT_SECURITY_HEADER, properties.getStrictTransportSecurity());</div><div class="line"><span class="number">28</span>: headers.add(X_FRAME_OPTIONS_HEADER, properties.getFrameOptions());</div><div class="line"><span class="number">29</span>: headers.add(X_CONTENT_TYPE_OPTIONS_HEADER, properties.getContentTypeOptions());</div><div class="line"><span class="number">30</span>: headers.add(REFERRER_POLICY_HEADER, properties.getReferrerPolicy());</div><div class="line"><span class="number">31</span>: headers.add(CONTENT_SECURITY_POLICY_HEADER, properties.getContentSecurityPolicy());</div><div class="line"><span class="number">32</span>: headers.add(X_DOWNLOAD_OPTIONS_HEADER, properties.getDownloadOptions());</div><div class="line"><span class="number">33</span>: headers.add(X_PERMITTED_CROSS_DOMAIN_POLICIES_HEADER, properties.getPermittedCrossDomainPolicies());</div><div class="line"><span class="number">34</span>: </div><div class="line"><span class="number">35</span>: <span class="keyword">return</span> chain.filter(exchange);</div><div class="line"><span class="number">36</span>: &#125;;</div><div class="line"><span class="number">37</span>: &#125;</div><div class="line"><span class="number">38</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 26 至 33 行 ：添加响应 Secure 相关的 Header 。 </li></ul></li></ul><h1 id="3-Parameter"><a href="#3-Parameter" class="headerlink" title="3. Parameter"></a>3. Parameter</h1><p>本小节分享 Parameter 相关的 GatewayFilterFactory 实现类。</p><h2 id="3-1-AddRequestParameterGatewayFilterFactory"><a href="#3-1-AddRequestParameterGatewayFilterFactory" class="headerlink" title="3.1 AddRequestParameterGatewayFilterFactory"></a>3.1 AddRequestParameterGatewayFilterFactory</h2><p>类似 AddRequestHeaderGatewayFilterFactory ，不重复分享，点击 <a href="https://github.com/spring-cloud/spring-cloud-gateway/blob/9ffb0f18678460fda9b25c572c12f9054a62ca52/docs/src/main/asciidoc/spring-cloud-gateway.adoc#addrequestheader-gatewayfilter-factory" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud Gateway —— AddRequestParameter GatewayFilter Factory》</a> 查看官方文档。</p><h1 id="4-Path"><a href="#4-Path" class="headerlink" title="4. Path"></a>4. Path</h1><p>本小节分享 Path 相关的 GatewayFilterFactory 实现类。</p><h2 id="4-1-RewritePathGatewayFilterFactory"><a href="#4-1-RewritePathGatewayFilterFactory" class="headerlink" title="4.1 RewritePathGatewayFilterFactory"></a>4.1 RewritePathGatewayFilterFactory</h2><ul><li>用途 ：根据配置的正则表达式 <code>regexp</code> ，使用配置的 <code>replacement</code> 重写请求 Path 。从功能目的上类似 <a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html" rel="external nofollow noopener noreferrer" target="_blank">《Module ngx_http_rewrite_module》</a> 。</li><li><p>配置 ：</p>  <figure class="highlight yaml"><table><tr><td class="code"><pre><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  cloud:</span></div><div class="line"><span class="attr">    gateway:</span></div><div class="line"><span class="attr">      routes:</span></div><div class="line">      <span class="comment"># =====================================</span></div><div class="line"><span class="attr">      - id:</span> <span class="string">rewritepath_route</span></div><div class="line"><span class="attr">        uri:</span> <span class="attr">http://example.org</span></div><div class="line"><span class="attr">        predicates:</span></div><div class="line"><span class="bullet">        -</span> <span class="string">Path=/foo/**</span></div><div class="line"><span class="attr">        filters:</span></div><div class="line"><span class="bullet">        -</span> <span class="string">RewritePath=/foo/(?&lt;segment&gt;.*),</span> <span class="string">/$\&#123;segment&#125;</span></div></pre></td></tr></table></figure><ul><li>注意，<code>$\</code> 用于替代 <code>$</code> ，避免和 YAML 语法冲突。</li></ul></li><li><p>代码 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RewritePathGatewayFilterFactory</span> <span class="keyword">implements</span> <span class="title">GatewayFilterFactory</span> </span>&#123;</div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>: <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REGEXP_KEY = <span class="string">"regexp"</span>;</div><div class="line"> <span class="number">4</span>: <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REPLACEMENT_KEY = <span class="string">"replacement"</span>;</div><div class="line"> <span class="number">5</span>: </div><div class="line"> <span class="number">6</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">7</span>: <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">argNames</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">8</span>: <span class="keyword">return</span> Arrays.asList(REGEXP_KEY, REPLACEMENT_KEY);</div><div class="line"> <span class="number">9</span>: &#125;</div><div class="line"><span class="number">10</span>: </div><div class="line"><span class="number">11</span>: <span class="meta">@Override</span></div><div class="line"><span class="number">12</span>: <span class="function"><span class="keyword">public</span> GatewayFilter <span class="title">apply</span><span class="params">(Tuple args)</span> </span>&#123;</div><div class="line"><span class="number">13</span>: <span class="keyword">final</span> String regex = args.getString(REGEXP_KEY);</div><div class="line"><span class="number">14</span>: <span class="comment">// `$\` 用于替代 `$` ，避免和 YAML 语法冲突。</span></div><div class="line"><span class="number">15</span>: String replacement = args.getString(REPLACEMENT_KEY).replace(<span class="string">"$\\"</span>, <span class="string">"$"</span>);</div><div class="line"><span class="number">16</span>: </div><div class="line"><span class="number">17</span>: <span class="keyword">return</span> (exchange, chain) -&gt; &#123;</div><div class="line"><span class="number">18</span>: ServerHttpRequest req = exchange.getRequest();</div><div class="line"><span class="number">19</span>: <span class="comment">// 添加 原始请求URI 到 GATEWAY_ORIGINAL_REQUEST_URL_ATTR</span></div><div class="line"><span class="number">20</span>: addOriginalRequestUrl(exchange, req.getURI());</div><div class="line"><span class="number">21</span>: <span class="comment">// 重写 Path</span></div><div class="line"><span class="number">22</span>: String path = req.getURI().getPath();</div><div class="line"><span class="number">23</span>: String newPath = path.replaceAll(regex, replacement);</div><div class="line"><span class="number">24</span>: </div><div class="line"><span class="number">25</span>: <span class="comment">// 创建新的 ServerHttpRequest</span></div><div class="line"><span class="number">26</span>: ServerHttpRequest request = req.mutate()</div><div class="line"><span class="number">27</span>: .path(newPath) <span class="comment">// 设置 Path</span></div><div class="line"><span class="number">28</span>: .build();</div><div class="line"><span class="number">29</span>: </div><div class="line"><span class="number">30</span>: <span class="comment">// 添加 请求URI 到 GATEWAY_REQUEST_URL_ATTR</span></div><div class="line"><span class="number">31</span>: exchange.getAttributes().put(GATEWAY_REQUEST_URL_ATTR, request.getURI());</div><div class="line"><span class="number">32</span>: </div><div class="line"><span class="number">33</span>: <span class="comment">// 创建新的 ServerWebExchange ，提交过滤器链继续过滤</span></div><div class="line"><span class="number">34</span>: <span class="keyword">return</span> chain.filter(exchange.mutate().request(request).build());</div><div class="line"><span class="number">35</span>: &#125;;</div><div class="line"><span class="number">36</span>: &#125;</div><div class="line"><span class="number">37</span>: &#125;</div></pre></td></tr></table></figure><ul><li>Tuple 参数 ：<code>regexp</code> / <code>replacement</code> 。</li><li>第 15 行 ：<code>$\</code> 用于替代 <code>$</code> ，避免和 YAML 语法冲突。</li><li><p>第 20 行 ：调用 <code>ServerWebExchangeUtils#addOriginalRequestUrl(...)</code> 添加原始请求 URI 到 <code>GATEWAY_ORIGINAL_REQUEST_URL_ATTR</code> 。代码如下 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addOriginalRequestUrl</span><span class="params">(ServerWebExchange exchange, URI url)</span> </span>&#123;</div><div class="line">exchange.getAttributes().computeIfAbsent(GATEWAY_ORIGINAL_REQUEST_URL_ATTR, s -&gt; <span class="keyword">new</span> LinkedHashSet&lt;&gt;()); <span class="comment">// 数组，考虑多次重写</span></div><div class="line">    LinkedHashSet&lt;URI&gt; uris = exchange.getRequiredAttribute(GATEWAY_ORIGINAL_REQUEST_URL_ATTR);</div><div class="line">    uris.add(url);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>为什么使用 LinkedHashSet ？因为可以使用 RewritePathGatewayFilterFactory / PrefixPathGatewayFilterFactory 多次重写。</li></ul></li><li><p>第 21 至 23 行 ：<strong>重写</strong>请求 Path 。</p></li><li>第 26 至 28 行 ：创建<strong>新</strong>的 ServerHttpRequest 。</li><li>第 31 行 ：添加请求 URI 到 <code>GATEWAY_REQUEST_URL_ATTR</code> 。</li><li>第 34 行 ：创建<strong>新</strong>的 ServerWebExchange ，提交过滤器链继续过滤。</li></ul></li></ul><h2 id="4-2-PrefixPathGatewayFilterFactory"><a href="#4-2-PrefixPathGatewayFilterFactory" class="headerlink" title="4.2 PrefixPathGatewayFilterFactory"></a>4.2 PrefixPathGatewayFilterFactory</h2><p>类似 RewritePathGatewayFilterFactory ，不重复分享，点击 <a href="https://github.com/spring-cloud/spring-cloud-gateway/blob/9ffb0f18678460fda9b25c572c12f9054a62ca52/docs/src/main/asciidoc/spring-cloud-gateway.adoc#setpath-gatewayfilter-factory" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud Gateway —— PrefixPath GatewayFilter Factory》</a> 查看官方文档。</p><h2 id="4-3-SetPathGatewayFilterFactory"><a href="#4-3-SetPathGatewayFilterFactory" class="headerlink" title="4.3 SetPathGatewayFilterFactory"></a>4.3 SetPathGatewayFilterFactory</h2><p>类似 RewritePathGatewayFilterFactory ，不重复分享，点击 <a href="https://github.com/spring-cloud/spring-cloud-gateway/blob/9ffb0f18678460fda9b25c572c12f9054a62ca52/docs/src/main/asciidoc/spring-cloud-gateway.adoc#prefixpath-gatewayfilter-factory" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud Gateway —— SetPath GatewayFilter Factory》</a> 查看官方文档。</p><h1 id="5-Status"><a href="#5-Status" class="headerlink" title="5. Status"></a>5. Status</h1><p>本小节分享 Status 相关的 GatewayFilterFactory 实现类。</p><h2 id="5-1-SetStatusGatewayFilterFactory"><a href="#5-1-SetStatusGatewayFilterFactory" class="headerlink" title="5.1 SetStatusGatewayFilterFactory"></a>5.1 SetStatusGatewayFilterFactory</h2><p>类似 RedirectToGatewayFilterFactory ，不重复分享，点击 <a href="https://github.com/spring-cloud/spring-cloud-gateway/blob/9ffb0f18678460fda9b25c572c12f9054a62ca52/docs/src/main/asciidoc/spring-cloud-gateway.adoc#setstatus-gatewayfilter-factory" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud Gateway —— SetStatus GatewayFilter Factory》</a> 查看官方文档。</p><h1 id="6-Redirect"><a href="#6-Redirect" class="headerlink" title="6. Redirect"></a>6. Redirect</h1><p>本小节分享 Redirect 相关的 GatewayFilterFactory 实现类。</p><h2 id="6-1-RedirectToGatewayFilterFactory"><a href="#6-1-RedirectToGatewayFilterFactory" class="headerlink" title="6.1 RedirectToGatewayFilterFactory"></a>6.1 RedirectToGatewayFilterFactory</h2><ul><li>用途 ：将响应重定向到指定 URL ，并设置响应状态码为指定 Status 。<strong>注意</strong>，Status 必须为 3XX 重定向状态码。</li><li><p>配置 ：</p>  <figure class="highlight yaml"><table><tr><td class="code"><pre><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  cloud:</span></div><div class="line"><span class="attr">    gateway:</span></div><div class="line"><span class="attr">      routes:</span></div><div class="line">      <span class="comment"># =====================================</span></div><div class="line"><span class="attr">      - id:</span> <span class="string">prefixpath_route</span></div><div class="line"><span class="attr">        uri:</span> <span class="attr">http://example.org</span></div><div class="line"><span class="attr">        filters:</span></div><div class="line"><span class="bullet">        -</span> <span class="string">RedirectTo=302,</span> <span class="attr">http://www.iocoder.cn</span></div></pre></td></tr></table></figure></li></ul><ul><li><p>代码 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedirectToGatewayFilterFactory</span> <span class="keyword">implements</span> <span class="title">GatewayFilterFactory</span> </span>&#123;</div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>: <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String STATUS_KEY = <span class="string">"status"</span>;</div><div class="line"> <span class="number">4</span>: <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String URL_KEY = <span class="string">"url"</span>;</div><div class="line"> <span class="number">5</span>: </div><div class="line"> <span class="number">6</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">7</span>: <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">argNames</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">8</span>: <span class="keyword">return</span> Arrays.asList(STATUS_KEY, URL_KEY);</div><div class="line"> <span class="number">9</span>: &#125;</div><div class="line"><span class="number">10</span>: </div><div class="line"><span class="number">11</span>: <span class="meta">@Override</span></div><div class="line"><span class="number">12</span>: <span class="function"><span class="keyword">public</span> GatewayFilter <span class="title">apply</span><span class="params">(Tuple args)</span> </span>&#123;</div><div class="line"><span class="number">13</span>: String statusString = args.getRawString(STATUS_KEY);</div><div class="line"><span class="number">14</span>: String urlString = args.getString(URL_KEY);</div><div class="line"><span class="number">15</span>: </div><div class="line"><span class="number">16</span>: <span class="comment">// 解析 status ，并判断是否是 3XX 重定向状态</span></div><div class="line"><span class="number">17</span>: <span class="keyword">final</span> HttpStatus httpStatus = parse(statusString);</div><div class="line"><span class="number">18</span>: Assert.isTrue(httpStatus.is3xxRedirection(), <span class="string">"status must be a 3xx code, but was "</span> + statusString);</div><div class="line"><span class="number">19</span>: <span class="comment">// 创建 URL</span></div><div class="line"><span class="number">20</span>: <span class="keyword">final</span> URL url;</div><div class="line"><span class="number">21</span>: <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">22</span>: url = URI.create(urlString).toURL();</div><div class="line"><span class="number">23</span>: &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</div><div class="line"><span class="number">24</span>: <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid url "</span> + urlString, e);</div><div class="line"><span class="number">25</span>: &#125;</div><div class="line"><span class="number">26</span>: </div><div class="line"><span class="number">27</span>: <span class="keyword">return</span> (exchange, chain) -&gt;</div><div class="line"><span class="number">28</span>: chain.filter(exchange).then(Mono.defer(() -&gt; &#123; <span class="comment">// After Filter</span></div><div class="line"><span class="number">29</span>: <span class="keyword">if</span> (!exchange.getResponse().isCommitted()) &#123;</div><div class="line"><span class="number">30</span>:     <span class="comment">// 设置响应 Status</span></div><div class="line"><span class="number">31</span>: setResponseStatus(exchange, httpStatus);</div><div class="line"><span class="number">32</span>: </div><div class="line"><span class="number">33</span>: <span class="comment">// 设置响应 Header</span></div><div class="line"><span class="number">34</span>: <span class="keyword">final</span> ServerHttpResponse response = exchange.getResponse();</div><div class="line"><span class="number">35</span>: response.getHeaders().set(HttpHeaders.LOCATION, url.toString());</div><div class="line"><span class="number">36</span>: <span class="keyword">return</span> response.setComplete();</div><div class="line"><span class="number">37</span>: &#125;</div><div class="line"><span class="number">38</span>: <span class="keyword">return</span> Mono.empty();</div><div class="line"><span class="number">39</span>: &#125;));</div><div class="line"><span class="number">40</span>: &#125;</div><div class="line"><span class="number">41</span>: </div><div class="line"><span class="number">42</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 16 至 18 行 ：解析配置的 <code>statusString</code> ，并判断是否是 3XX 重定向状态码。</li><li>第 19 至 25 行 ：解析配置的 <code>urlString</code> ，创建 URL 。</li><li>第 28 行 ：调用 <code>#then(Mono)</code> 方法，实现 <strong>After Filter</strong> 逻辑。这里和 AddRequestHeaderGatewayFilterFactory 实现的 <strong>Before Filter</strong> 【方式】<strong>不同</strong>。</li><li>第 29 至 37 行 ：<strong>若响应未提交</strong>，设置响应的状态码、响应的 Header ( <code>Location</code> ) 。</li><li>第 38 行 ：<strong>设置响应已提交</strong>。</li></ul></li></ul><h1 id="7-Hystrix"><a href="#7-Hystrix" class="headerlink" title="7. Hystrix"></a>7. Hystrix</h1><p>熔断相关 GatewayFilter，我们在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/?self">《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.9) 之 HystrixGatewayFilterFactory 熔断》</a> 详细解析。</p><h1 id="8-RateLimiter"><a href="#8-RateLimiter" class="headerlink" title="8. RateLimiter"></a>8. RateLimiter</h1><p>限流相关 GatewayFilter，我们在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-request-rate-limiter/?self">《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.10) 之 RequestRateLimiterGatewayFilterFactory 请求限流》</a> 详细解析。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>恩，稍显啰嗦的一篇文章，后面会比较精彩，你懂的。</p><p><img src="http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_03_05/02.png" alt=""></p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Spring-Cloud-Gateway/filter-factory/&quot;&gt;http://www.iocoder.cn/Spring-Cloud-Gateway/filter-factory/&lt;
      
    
    </summary>
    
      <category term="Spring-Cloud-Gateway" scheme="http://www.iocoder.cn/categories/Spring-Cloud-Gateway/"/>
    
    
  </entry>
  
</feed>
