<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>芋道源码 —— 纯源码解析博客</title>
  
  <subtitle>愿半生编码，如一生老友！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.iocoder.cn/"/>
  <updated>2018-01-09T09:50:59.000Z</updated>
  <id>http://www.iocoder.cn/</id>
  
  <author>
    <name>芋道源码</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SkyWalking 源码分析 —— Agent 插件（一）之 Tomcat</title>
    <link href="http://www.iocoder.cn/SkyWalking/agent-plugin-tomcat/"/>
    <id>http://www.iocoder.cn/SkyWalking/agent-plugin-tomcat/</id>
    <published>2020-11-19T16:00:00.000Z</published>
    <updated>2018-01-09T09:50:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/agent-plugin-tomcat/">http://www.iocoder.cn/SkyWalking/agent-plugin-tomcat/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-tomcat/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-tomcat/">2. TomcatInstrumentation</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-tomcat/">2.1 TomcatInvokeInterceptor</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-tomcat/">2.2 TomcatExceptionInterceptor</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-tomcat/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>SkyWalking Agent Tomcat 插件</strong>。涉及到的代码不多，如下图：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_11_20/01.png" alt=""></p><h1 id="2-TomcatInstrumentation"><a href="#2-TomcatInstrumentation" class="headerlink" title="2. TomcatInstrumentation"></a>2. TomcatInstrumentation</h1><p>在 <a href="https://github.com/YunaiV/skywalking/blob/0128349b40592b8ae329443c52f43577cc9fa16b/apm-sniffer/apm-sdk-plugin/tomcat-7.x-8.x-plugin/src/main/resources/skywalking-plugin.def" rel="external nofollow noopener noreferrer" target="_blank"><code>skywalking-plugin.def</code></a> 里，定义了插件，如下图：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_11_20/03.png" alt=""></p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/0128349b40592b8ae329443c52f43577cc9fa16b/apm-sniffer/apm-sdk-plugin/tomcat-7.x-8.x-plugin/src/main/java/org/skywalking/apm/plugin/tomcat78x/define/TomcatInstrumentation.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.plugin.tomcat78x.define.TomcatInstrumentation</code></a> ，实现 ClassInstanceMethodsEnhancePluginDefine 抽象类，定义了方法切面，代码如下：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_11_20/02.png" alt=""></p><h2 id="2-1-TomcatInvokeInterceptor"><a href="#2-1-TomcatInvokeInterceptor" class="headerlink" title="2.1 TomcatInvokeInterceptor"></a>2.1 TomcatInvokeInterceptor</h2><p><a href="https://github.com/YunaiV/skywalking/blob/0128349b40592b8ae329443c52f43577cc9fa16b/apm-sniffer/apm-sdk-plugin/tomcat-7.x-8.x-plugin/src/main/java/org/skywalking/apm/plugin/tomcat78x/TomcatInvokeInterceptor.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.plugin.tomcat78x.TomcatInvokeInterceptor</code></a> ，实现 InstanceMethodsAroundInterceptor 接口，TomcatInstrumentation 的拦截器。代码如下：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/0128349b40592b8ae329443c52f43577cc9fa16b/apm-sniffer/apm-sdk-plugin/tomcat-7.x-8.x-plugin/src/main/java/org/skywalking/apm/plugin/tomcat78x/TomcatInvokeInterceptor.java#L5" rel="external nofollow noopener noreferrer" target="_blank"><code>#beforeMethod(...)</code></a> 方法，创建 EntrySpan 对象。代码如下：<ul><li>第 59 至 65 行：解析 ContextCarrier 对象，用于跨进程的链路追踪。在 <a href="http://www.iocoder.cn/SkyWalking/agent-collect-trace/?self">《SkyWalking 源码分析 —— Agent 收集 Trace 数据》「 3.2.3 ContextCarrier 」</a> 有详细解析。</li><li>第 68 行：调用 <code>ContextManager#createLocalSpan(operationName, contextCarrier)</code> 方法，创建 EntrySpan 对象。</li><li>第 71 至 72 行：设置 EntrySpan 对象的 <code>url</code> / <code>http.method</code> 标签键值对。</li><li>第 75 行：设置 EntrySpan 对象的组件类型。</li><li>第 78 行：设置 EntrySpan 对象的分层。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/0128349b40592b8ae329443c52f43577cc9fa16b/apm-sniffer/apm-sdk-plugin/tomcat-7.x-8.x-plugin/src/main/java/org/skywalking/apm/plugin/tomcat78x/TomcatInvokeInterceptor.java#L81" rel="external nofollow noopener noreferrer" target="_blank"><code>#afterMethod(...)</code></a> 方法，完成 EntrySpan 对象。<ul><li>第 89 至 92 行：当返回状态码大于等于 400 时，标记 EntrySpan 发生异常，并设置 <code>status_code</code> 标签键值对。</li><li>调用 <code>ContextManager#stopSpan()</code> 方法，完成 EntrySpan 对象。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/0128349b40592b8ae329443c52f43577cc9fa16b/apm-sniffer/apm-sdk-plugin/tomcat-7.x-8.x-plugin/src/main/java/org/skywalking/apm/plugin/tomcat78x/TomcatInvokeInterceptor.java#L99" rel="external nofollow noopener noreferrer" target="_blank"><code>#handleMethodException(...)</code></a> 方法，处理异常。<strong>注意</strong>，该方法实际并且调用，在 Tomcat 的<a href="https://github.com/Oreste-Luci/apache-tomcat-8.0.26-src/blob/master/java/org/apache/catalina/core/StandardWrapperValve.java#L94" rel="external nofollow noopener noreferrer" target="_blank"><code>StandardWrapperValve#invoke(request, response)</code></a> 方法里，发生异常时，会提交异常给 <a href="https://github.com/Oreste-Luci/apache-tomcat-8.0.26-src/blob/master/java/org/apache/catalina/core/StandardWrapperValve.java#L507" rel="external nofollow noopener noreferrer" target="_blank"><code>StandardWrapperValve#exception(request, response, exception)</code></a> 处理，所以会被 <a href="#">「 2.2 TomcatExceptionInterceptor 」</a> 拦截。</li></ul><h2 id="2-2-TomcatExceptionInterceptor"><a href="#2-2-TomcatExceptionInterceptor" class="headerlink" title="2.2 TomcatExceptionInterceptor"></a>2.2 TomcatExceptionInterceptor</h2><p><a href="https://github.com/YunaiV/skywalking/blob/0128349b40592b8ae329443c52f43577cc9fa16b/apm-sniffer/apm-sdk-plugin/tomcat-7.x-8.x-plugin/src/main/java/org/skywalking/apm/plugin/tomcat78x/TomcatExceptionInterceptor.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.plugin.tomcat78x.TomcatExceptionInterceptor</code></a> ，实现 InstanceMethodsAroundInterceptor 接口，TomcatInstrumentation 的拦截器。代码如下：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/0128349b40592b8ae329443c52f43577cc9fa16b/apm-sniffer/apm-sdk-plugin/tomcat-7.x-8.x-plugin/src/main/java/org/skywalking/apm/plugin/tomcat78x/TomcatExceptionInterceptor.java#L31" rel="external nofollow noopener noreferrer" target="_blank"><code>#beforeMethod(...)</code></a> 方法，处理异常。代码如下：<ul><li>第 35 行：调用 <code>AbstractSpan#errorOccurred()</code> 方法，标记 EntrySpan 对象发生异常。</li><li>第 35 行：调用 <code>AbstractSpan#log(Throwable)</code> 方法，记录异常日志到 EntrySpan 对象。</li></ul></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>一大波插件来袭！</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_11_20/04.png" alt=""></p><p>胖友，分享一波胖友圈括号。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/agent-plugin-tomcat/&quot;&gt;http://www.iocoder.cn/SkyWalking/agent-plugin-tomcat/&lt;/a&gt; 「芋道源码」
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— @Trace 注解想要追踪的任何方法</title>
    <link href="http://www.iocoder.cn/SkyWalking/@trace-for-any-methods/"/>
    <id>http://www.iocoder.cn/SkyWalking/@trace-for-any-methods/</id>
    <published>2020-11-09T16:00:00.000Z</published>
    <updated>2018-01-09T04:50:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/@trace-for-any-methods/">http://www.iocoder.cn/SkyWalking/@trace-for-any-methods/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/@trace-for-any-methods/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/@trace-for-any-methods/">2. 使用例子</a></li><li><a href="http://www.iocoder.cn/SkyWalking/@trace-for-any-methods/">3. 实现代码</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/@trace-for-any-methods/">3.1 TraceAnnotationActivation</a></li><li><a href="http://www.iocoder.cn/SkyWalking/@trace-for-any-methods/">3.2 ActiveSpanTagActivation</a></li><li><a href="http://www.iocoder.cn/SkyWalking/@trace-for-any-methods/">3.3 TraceContextActivation</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/@trace-for-any-methods/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>@Trace 注解想要追踪的任何方法</strong>。</p><p>我们首先看看 <a href="https://github.com/apache/incubator-skywalking/blob/af2c1b979fe025603dc65d7e2a2dbdea8005ede8/apm-application-toolkit/apm-toolkit-trace/src/main/java/org/apache/skywalking/apm/toolkit/trace/Trace.java" rel="external nofollow noopener noreferrer" target="_blank"><code>@Trace</code></a> 的使用例子，再看看 <code>@Trace</code> 的实现代码。涉及代码如下：</p><ul><li><img src="http://www.iocoder.cn/images/SkyWalking/2020_11_10/01.png" alt=""></li><li><img src="http://www.iocoder.cn/images/SkyWalking/2020_11_10/02.png" alt=""></li></ul><h1 id="2-使用例子"><a href="#2-使用例子" class="headerlink" title="2. 使用例子"></a>2. 使用例子</h1><blockquote><p>本节参考官方文档：<a href="https://github.com/apache/incubator-skywalking/blob/master/docs/cn/Application-toolkit-trace-CN.md" rel="external nofollow noopener noreferrer" target="_blank">Application-toolkit-trace-CN.md</a></p></blockquote><p>1、使用 Maven 引入相应的工具包</p><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.skywalking<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>apm-toolkit-trace<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;skywalking.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure><p>2、在<strong>任何想要追踪</strong>的方法上添加 <code>@Trace</code> 注解，以 SpringMVC 为例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Trace</span></div><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"/log"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">log</span><span class="params">()</span> </span>&#123;</div><div class="line">    ActiveSpan.tag(<span class="string">"mp"</span>, <span class="string">"芋道源码"</span>);</div><div class="line">    System.out.println(<span class="string">"traceId："</span> + TraceContext.traceId());</div><div class="line">    <span class="keyword">return</span> <span class="string">"log"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>@Trace</code> 注解的方法，会创建一个 <strong>LocalSpan</strong> 。</li><li><a href="https://github.com/apache/incubator-skywalking/blob/af2c1b979fe025603dc65d7e2a2dbdea8005ede8/apm-application-toolkit/apm-toolkit-trace/src/main/java/org/apache/skywalking/apm/toolkit/trace/ActiveSpan.java#L32" rel="external nofollow noopener noreferrer" target="_blank"><code>ActiveSpan#tag(key, value)</code></a> 方法，在 LocalSpan 上添加标签键值对。</li><li><a href=""><code>TraceContext.traceId#traceId</code></a> 方法，获得全局链路追踪编号。</li></ul><p>3、执行后，我们看来看看 SkyWalking WEBUI 的展示。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_11_10/03.png" alt=""></p><h1 id="3-实现代码"><a href="#3-实现代码" class="headerlink" title="3. 实现代码"></a>3. 实现代码</h1><blockquote><p>友情提示：本小节需要胖友阅读过 <a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/?self">《SkyWalking 源码分析 —— Agent 插件体系》</a>  。</p></blockquote><h2 id="3-1-TraceAnnotationActivation"><a href="#3-1-TraceAnnotationActivation" class="headerlink" title="3.1 TraceAnnotationActivation"></a>3.1 TraceAnnotationActivation</h2><p><a href="https://github.com/YunaiV/skywalking/blob/5106601937af942dabcad917b90d8c92886a2e4d/apm-sniffer/apm-toolkit-activation/apm-toolkit-trace-activation/src/main/java/org/skywalking/apm/toolkit/activation/trace/TraceAnnotationActivation.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.toolkit.activation.trace.TraceAnnotationActivation</code></a> ，实现 ClassInstanceMethodsEnhancePluginDefine 抽象类，定义了方法切面，代码如下：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_11_10/04.png" alt=""></p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/5106601937af942dabcad917b90d8c92886a2e4d/apm-sniffer/apm-toolkit-activation/apm-toolkit-trace-activation/src/main/java/org/skywalking/apm/toolkit/activation/trace/TraceAnnotationMethodInterceptor.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.toolkit.activation.trace.TraceAnnotationMethodInterceptor</code></a> ，实现 InstanceMethodsAroundInterceptor 接口，TraceAnnotationActivation 的拦截器。代码如下：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/5106601937af942dabcad917b90d8c92886a2e4d/apm-sniffer/apm-toolkit-activation/apm-toolkit-trace-activation/src/main/java/org/skywalking/apm/toolkit/activation/trace/TraceAnnotationMethodInterceptor.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>#beforeMethod(...)</code></a> 方法，创建 LocalSpan 对象。代码如下：<ul><li>第 42 至 46 行：获得操作名。若 <a href="https://github.com/apache/incubator-skywalking/blob/af2c1b979fe025603dc65d7e2a2dbdea8005ede8/apm-application-toolkit/apm-toolkit-trace/src/main/java/org/apache/skywalking/apm/toolkit/trace/Trace.java#L40" rel="external nofollow noopener noreferrer" target="_blank"><code>@Trace#operationName()</code></a> 非空，作为操作名。否则，调用 <a href="https://github.com/YunaiV/skywalking/blob/5106601937af942dabcad917b90d8c92886a2e4d/apm-sniffer/apm-toolkit-activation/apm-toolkit-trace-activation/src/main/java/org/skywalking/apm/toolkit/activation/trace/TraceAnnotationMethodInterceptor.java#L58" rel="external nofollow noopener noreferrer" target="_blank"><code>#generateOperationName(Method)</code></a> 方法，使用方法签名。</li><li>第 49 行：调用 <code>ContextManager#createLocalSpan(operationName)</code> 方法，创建 LocalSpan 对象。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/5106601937af942dabcad917b90d8c92886a2e4d/apm-sniffer/apm-toolkit-activation/apm-toolkit-trace-activation/src/main/java/org/skywalking/apm/toolkit/activation/trace/TraceAnnotationMethodInterceptor.java#L72" rel="external nofollow noopener noreferrer" target="_blank"><code>#afterMethod(...)</code></a> 方法，调用 <code>ContextManager#stopSpan()</code> 方法，完成 LocalSpan 对象。</li><li><a href="https://github.com/YunaiV/skywalking/blob/5106601937af942dabcad917b90d8c92886a2e4d/apm-sniffer/apm-toolkit-activation/apm-toolkit-trace-activation/src/main/java/org/skywalking/apm/toolkit/activation/trace/TraceAnnotationMethodInterceptor.java#L79" rel="external nofollow noopener noreferrer" target="_blank"><code>#handleMethodException(...)</code></a> 方法，发生异常时，打印错误日志。</li></ul><h2 id="3-2-ActiveSpanTagActivation"><a href="#3-2-ActiveSpanTagActivation" class="headerlink" title="3.2 ActiveSpanTagActivation"></a>3.2 ActiveSpanTagActivation</h2><p><a href="https://github.com/YunaiV/skywalking/blob/5106601937af942dabcad917b90d8c92886a2e4d/apm-sniffer/apm-toolkit-activation/apm-toolkit-trace-activation/src/main/java/org/skywalking/apm/toolkit/activation/trace/ActiveSpanTagActivation.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.toolkit.activation.trace.ActiveSpanTagActivation</code></a> ，实现 ClassStaticMethodsEnhancePluginDefine 抽象类，定义了方法切面，代码如下：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_11_10/05.png" alt=""></p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/5106601937af942dabcad917b90d8c92886a2e4d/apm-sniffer/apm-toolkit-activation/apm-toolkit-trace-activation/src/main/java/org/skywalking/apm/toolkit/activation/trace/TraceAnnotationMethodInterceptor.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.toolkit.activation.trace.TraceAnnotationMethodInterceptor</code></a> ，实现 StaticMethodsAroundInterceptor 接口，ActiveSpanTag 的拦截器。代码如下：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/5106601937af942dabcad917b90d8c92886a2e4d/apm-sniffer/apm-toolkit-activation/apm-toolkit-trace-activation/src/main/java/org/skywalking/apm/toolkit/activation/trace/ActiveSpanTagInterceptor.java#L30" rel="external nofollow noopener noreferrer" target="_blank"><code>#beforeMethod(...)</code></a> 方法，添加 Span 的<strong>标签键值对</strong>。<strong>注意</strong>，可以不依赖 <code>@Trace</code> 注解。</li></ul><h2 id="3-3-TraceContextActivation"><a href="#3-3-TraceContextActivation" class="headerlink" title="3.3 TraceContextActivation"></a>3.3 TraceContextActivation</h2><p><a href="https://github.com/YunaiV/skywalking/blob/5106601937af942dabcad917b90d8c92886a2e4d/apm-sniffer/apm-toolkit-activation/apm-toolkit-trace-activation/src/main/java/org/skywalking/apm/toolkit/activation/trace/TraceContextActivation.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.toolkit.activation.trace.TraceContextActivation</code></a> ，实现 ClassStaticMethodsEnhancePluginDefine 抽象类，定义了方法切面，代码如下：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_11_10/06.png" alt=""></p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/5106601937af942dabcad917b90d8c92886a2e4d/apm-sniffer/apm-toolkit-activation/apm-toolkit-trace-activation/src/main/java/org/skywalking/apm/toolkit/activation/trace/TraceContextInterceptor.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.toolkit.activation.trace.TraceAnnotationMethodInterceptor</code></a> ，实现 StaticMethodsAroundInterceptor 接口，TraceContextActivation 的拦截器。代码如下：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/5106601937af942dabcad917b90d8c92886a2e4d/apm-sniffer/apm-toolkit-activation/apm-toolkit-trace-activation/src/main/java/org/skywalking/apm/toolkit/activation/trace/TraceContextInterceptor.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>#afterMethod(...)</code></a> 方法，调用 <code>ContextManager#getGlobalTraceId()</code> 方法，使用全局链路追踪编号，而不是原有结果。</li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>简单一文一篇。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_11_10/07.png" alt=""></p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/@trace-for-any-methods/&quot;&gt;http://www.iocoder.cn/SkyWalking/@trace-for-any-methods/&lt;/a&gt; 
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— traceId 集成到日志组件</title>
    <link href="http://www.iocoder.cn/SkyWalking/trace-id-integrate-into-logs/"/>
    <id>http://www.iocoder.cn/SkyWalking/trace-id-integrate-into-logs/</id>
    <published>2020-11-09T16:00:00.000Z</published>
    <updated>2018-01-09T07:45:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/trace-id-integrate-into-logs/">http://www.iocoder.cn/SkyWalking/trace-id-integrate-into-logs/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/trace-id-integrate-into-logs/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/trace-id-integrate-into-logs/">2. 使用例子</a></li><li><a href="http://www.iocoder.cn/SkyWalking/trace-id-integrate-into-logs/">3. 实现代码</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/trace-id-integrate-into-logs/">3.1 TraceIdPatternLogbackLayout</a></li><li><a href="http://www.iocoder.cn/SkyWalking/trace-id-integrate-into-logs/">3.2 LogbackPatternConverterActivation</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/trace-id-integrate-into-logs/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>traceId 集成到日志组件</strong>，例如 log4j 、log4j2 、logback 等等。</p><p>我们首先看看<strong>集成</strong>的使用例子，再看看<strong>集成</strong>的实现代码。涉及代码如下：</p><ul><li><img src="http://www.iocoder.cn/images/SkyWalking/2020_11_15/01.png" alt=""></li><li><img src="http://www.iocoder.cn/images/SkyWalking/2020_11_15/02.png" alt=""></li></ul><p>本文以 <strong>logback 1.x</strong> 为例子。</p><h1 id="2-使用例子"><a href="#2-使用例子" class="headerlink" title="2. 使用例子"></a>2. 使用例子</h1><p>1、<strong>无需</strong>引入相应的工具包，只需启动参数带上 <code>-javaagent:/Users/yunai/Java/skywalking/packages/skywalking-agent/skywalking-agent.jar</code> 。</p><p>2、在 <code>logback.xml</code> 配置 <code>%tid</code> 占位符：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_11_15/03.png" alt=""></p><p>3、使用 <code>logger.info(...)</code> ，会打印日志如下：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_11_15/04.png" alt=""></p><p><strong>注意</strong>，traceId 打印到每条日志里，最终需要经过例如 ELK ，收集到日志中心。</p><h1 id="3-实现代码"><a href="#3-实现代码" class="headerlink" title="3. 实现代码"></a>3. 实现代码</h1><h2 id="3-1-TraceIdPatternLogbackLayout"><a href="#3-1-TraceIdPatternLogbackLayout" class="headerlink" title="3.1 TraceIdPatternLogbackLayout"></a>3.1 TraceIdPatternLogbackLayout</h2><p><a href=""><code>org.skywalking.apm.toolkit.log.logback.v1.x.TraceIdPatternLogbackLayout</code></a> ，实现 <code>ch.qos.logback.classic.PatternLayout</code> 类，实现支持 <code>%tid</code> 的占位符。代码如下：</p><ul><li>第 33 行：添加 <code>tid</code> 的转换器为 <a href="https://github.com/YunaiV/skywalking/blob/5106601937af942dabcad917b90d8c92886a2e4d/apm-application-toolkit/apm-toolkit-logback-1.x/src/main/java/org/skywalking/apm/toolkit/log/logback/v1/x/LogbackPatternConverter.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.toolkit.log.logback.v1.x.LogbackPatternConverter</code></a> 类。</li></ul><h2 id="3-2-LogbackPatternConverterActivation"><a href="#3-2-LogbackPatternConverterActivation" class="headerlink" title="3.2 LogbackPatternConverterActivation"></a>3.2 LogbackPatternConverterActivation</h2><p><a href="https://github.com/YunaiV/skywalking/blob/5106601937af942dabcad917b90d8c92886a2e4d/apm-sniffer/apm-toolkit-activation/apm-toolkit-logback-1.x-activation/src/main/java/org/skywalking/apm/toolkit/activation/log/logback/v1/x/LogbackPatternConverterActivation.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.toolkit.activation.log.logback.v1.x.LogbackPatternConverterActivation</code></a> ，实现 ClassInstanceMethodsEnhancePluginDefine 抽象类，定义了方法切面，代码如下：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_11_15/05.png" alt=""></p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/5106601937af942dabcad917b90d8c92886a2e4d/apm-sniffer/apm-toolkit-activation/apm-toolkit-logback-1.x-activation/src/main/java/org/skywalking/apm/toolkit/activation/log/logback/v1/x/PrintTraceIdInterceptor.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.toolkit.activation.log.logback.v1.x.PrintTraceIdInterceptor</code></a> ，实现 InstanceMethodsAroundInterceptor 接口，LogbackPatternConverterActivation 的拦截器。代码如下：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/5106601937af942dabcad917b90d8c92886a2e4d/apm-sniffer/apm-toolkit-activation/apm-toolkit-logback-1.x-activation/src/main/java/org/skywalking/apm/toolkit/activation/log/logback/v1/x/PrintTraceIdInterceptor.java#L37" rel="external nofollow noopener noreferrer" target="_blank"><code>#afterMethod(...)</code></a> 方法，调用 <code>ContextManager#getGlobalTraceId()</code> 方法，使用全局链路追踪编号，而不是原有结果。</li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>简单一文一篇 Again 。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_11_15/06.png" alt=""></p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/trace-id-integrate-into-logs/&quot;&gt;http://www.iocoder.cn/SkyWalking/trace-id-integrate-int
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— 运维界面（四）之操作视角</title>
    <link href="http://www.iocoder.cn/SkyWalking/ui-4-operation/"/>
    <id>http://www.iocoder.cn/SkyWalking/ui-4-operation/</id>
    <published>2020-11-04T16:00:00.000Z</published>
    <updated>2018-01-08T23:39:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/ui-4-operation/">http://www.iocoder.cn/SkyWalking/ui-4-operation/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/ui-4-operation/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/ui-4-operation/">2. AllInstanceLastTimeGetHandler</a></li><li><a href="http://www.iocoder.cn/SkyWalking/ui-4-operation/">3. ApplicationsGetHandler</a></li><li><a href="http://www.iocoder.cn/SkyWalking/ui-4-operation/">4. EntryServiceGetHandler</a></li><li><a href="http://www.iocoder.cn/SkyWalking/ui-4-operation/">5. ServiceTreeGetByIdHandler</a></li><li><a href="http://www.iocoder.cn/SkyWalking/ui-4-operation/">6. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享<strong>运维界面的第四部分，操作视角</strong>。</p><blockquote><p>SkyWalking WEBUI ：<a href="https://github.com/apache/incubator-skywalking-ui" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubator-skywalking-ui</a></p></blockquote><p>在我们打开 SkyWalking WEBUI 的 <code>Service Tree</code> ( <code>service/serviceTree.html</code> ) 页时，如下图：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_11_05/01.png" alt=""></p><ul><li>以操作为维度进行展示。</li><li>黄色部分，时间进度条，调用 <a href="#">「2. AllInstanceLastTimeGetHandler」</a> 接口，获得应用实例最后心跳时间。大多情况下，我们进入该界面，看的是从最后心跳时间开始的操作情况。</li><li>红色部分，应用筛选器，调用 <a href="#">「3. ApplicationsGetHandler」</a> 接口，获得应用列表。</li><li>紫色部分，入口操作( EntryService )分页列表，调用 <a href="#">「4. EntryServiceGetHandler」</a> 接口，获得数据。</li><li>蓝色部分，【点击单个操作】，获得指定操作的关联操作调用统计<strong>树列表</strong>，调用 <a href="#">「5. ServiceTreeGetByIdHandler」</a> 接口，获得数据。</li></ul><blockquote><p>基情提示：运维界面相关 HTTP 接口，逻辑简单易懂，笔者写的会比较简略一些。 </p></blockquote><h1 id="2-AllInstanceLastTimeGetHandler"><a href="#2-AllInstanceLastTimeGetHandler" class="headerlink" title="2. AllInstanceLastTimeGetHandler"></a>2. AllInstanceLastTimeGetHandler</h1><p>同 <a href="http://www.iocoder.cn/SkyWalking/ui-1-application/?self">《SkyWalking 源码分析 —— 运维界面（一）之应用视角》「2. AllInstanceLastTimeGetHandler」</a> 相同。</p><h1 id="3-ApplicationsGetHandler"><a href="#3-ApplicationsGetHandler" class="headerlink" title="3. ApplicationsGetHandler"></a>3. ApplicationsGetHandler</h1><p>同 <a href="http://www.iocoder.cn/SkyWalking/ui-2-instance/?self">《SkyWalking 源码分析 —— 运维界面（二）之应用实例视角》「3. ApplicationsGetHandler」</a> 相同。</p><h1 id="4-EntryServiceGetHandler"><a href="#4-EntryServiceGetHandler" class="headerlink" title="4. EntryServiceGetHandler"></a>4. EntryServiceGetHandler</h1><p><a href="https://github.com/YunaiV/skywalking/blob/3b31539e2e77baf00fafbc60ac9c30802e6c922a/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/jetty/handler/servicetree/EntryServiceGetHandler.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.ui.jetty.handler.servicetree.EntryServiceGetHandler</code></a> ，实现 JettyHandler 接口，获得入口操作( EntryService )分页列表的逻辑处理器。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/3b31539e2e77baf00fafbc60ac9c30802e6c922a/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/jetty/handler/servicetree/EntryServiceGetHandler.java#L40" rel="external nofollow noopener noreferrer" target="_blank"><code>#pathSpec()</code></a> ，路径定义，<code>&quot;/service/entry&quot;</code> 。</li><li>响应示例：<img src="http://www.iocoder.cn/images/SkyWalking/2020_11_05/02.png" alt=""></li><li><a href="https://github.com/YunaiV/skywalking/blob/3b31539e2e77baf00fafbc60ac9c30802e6c922a/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/jetty/handler/servicetree/EntryServiceGetHandler.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>#doGet()</code></a> 方法，代码如下：<ul><li>第 66 至 71 行：解析 <code>applicationId</code> 参数。</li><li>第 73 至 85 行：解析 <code>startTime</code> 和 <code>endTime</code> 参数。</li><li>第 88 至 99 行：解析 <code>from</code> 和 <code>size</code> 分页参数。 </li><li>第 73 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/3b31539e2e77baf00fafbc60ac9c30802e6c922a/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/service/ServiceTreeService.java#L57" rel="external nofollow noopener noreferrer" target="_blank"><code>ServiceTreeService#loadEntryService(...)</code></a> 方法，获得入口操作( EntryService )分页列表。代码如下：<ul><li>第 44 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/3b31539e2e77baf00fafbc60ac9c30802e6c922a/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/ServiceEntryEsUIDAO.java#L49" rel="external nofollow noopener noreferrer" target="_blank"><code>ServiceEntryEsUIDAO#load(...)</code></a> 方法，查询 ServiceEntry 分页 JSON 数组。</li><li>第 63 至 69 行：设置应用编码。</li></ul></li></ul></li></ul><h1 id="5-ServiceTreeGetByIdHandler"><a href="#5-ServiceTreeGetByIdHandler" class="headerlink" title="5. ServiceTreeGetByIdHandler"></a>5. ServiceTreeGetByIdHandler</h1><p><a href="https://github.com/YunaiV/skywalking/blob/7e453f0e8237685b7b46ddd390afce3b76b45123/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/jetty/handler/servicetree/ServiceTreeGetByIdHandler.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.ui.jetty.handler.servicetree.ServiceTreeGetByIdHandler</code></a> ，实现 JettyHandler 接口，获得指定操作的关联操作调用统计树列表的逻辑处理器。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/7e453f0e8237685b7b46ddd390afce3b76b45123/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/jetty/handler/servicetree/ServiceTreeGetByIdHandler.java#L40" rel="external nofollow noopener noreferrer" target="_blank"><code>#pathSpec()</code></a> ，路径定义，<code>&quot;/service/tree/entryServiceId&quot;</code> 。</li><li>响应示例：<img src="http://www.iocoder.cn/images/SkyWalking/2020_11_05/03.png" alt=""></li><li><a href="https://github.com/YunaiV/skywalking/blob/68b704ef2395067fdb135262089c5c3d316efee7/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/jetty/handler/instancehealth/InstanceHealthGetHandler.java#L52" rel="external nofollow noopener noreferrer" target="_blank"><code>#doGet()</code></a> 方法，代码如下： <ul><li>第 61 至 66 行：解析 <code>entryServiceId</code> 参数。 </li><li>第 60 至 74 行：解析 <code>startTime</code> 和 <code>endTime</code> 参数。</li><li>第 94 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/7e453f0e8237685b7b46ddd390afce3b76b45123/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/service/ServiceTreeService.java#L74" rel="external nofollow noopener noreferrer" target="_blank"><code>ServiceTreeService#loadServiceTree(entryServiceId, startTime, endTime)</code></a> 方法，获得指定操作的关联操作调用统计树列表，涉及 <strong>ServiceReference</strong> 数据表。代码比较简单易懂( 笔者太懒了 )，胖友自己阅读理解。<img src="http://www.iocoder.cn/images/SkyWalking/2020_11_05/04.png" alt=""></li></ul></li></ul><h1 id="6-彩蛋"><a href="#6-彩蛋" class="headerlink" title="6. 彩蛋"></a>6. 彩蛋</h1><p>水更第四发！</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_10_25/05.png" alt=""></p><p>胖友，分享一波朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/ui-4-operation/&quot;&gt;http://www.iocoder.cn/SkyWalking/ui-4-operation/&lt;/a&gt; 「芋道源码」欢迎转载，保留摘要，
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— 运维界面（三）之链路追踪视角</title>
    <link href="http://www.iocoder.cn/SkyWalking/ui-3-trace/"/>
    <id>http://www.iocoder.cn/SkyWalking/ui-3-trace/</id>
    <published>2020-10-31T16:00:00.000Z</published>
    <updated>2018-01-08T13:56:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/ui-3-trace/">http://www.iocoder.cn/SkyWalking/ui-3-trace/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/ui-3-trace/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/ui-3-trace/">2. ApplicationsGetHandler</a></li><li><a href="http://www.iocoder.cn/SkyWalking/ui-3-trace/">3. SegmentTopGetHandler</a></li><li><a href="http://www.iocoder.cn/SkyWalking/ui-3-trace/">4. TraceStackGetHandler</a></li><li><a href="http://www.iocoder.cn/SkyWalking/ui-3-trace/">5. SpanGetHandler</a></li><li><a href="http://www.iocoder.cn/SkyWalking/ui-3-trace/">6. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享<strong>运维界面的第三部分，链路追踪视角</strong>。</p><blockquote><p>SkyWalking WEBUI ：<a href="https://github.com/apache/incubator-skywalking-ui" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubator-skywalking-ui</a></p></blockquote><p>在我们打开 SkyWalking WEBUI 的 <code>Trace Stack</code> ( <code>trace/trace.html</code> ) 页时，如下图：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_11_01/01.png" alt=""></p><ul><li>以链路追踪为维度进行展示。</li><li>红色部分，应用筛选器，调用 <a href="#">「2. ApplicationsGetHandler」</a> 接口，获得应用列表。</li><li>紫色部分，TraceSegment 分页列表，调用 <a href="#">「3. SegmentTopGetHandler」</a> 接口，获得数据。</li><li>蓝色部分，【点击单条 TraceSegment】，<strong>一次完整</strong>的分布式链路追踪记录详情，调用 <a href="#">「5. TraceStackGetHandler」</a> 接口，获得数据。</li><li>黄色部分，【点击单个 Span】，单条 Span 记录详情，调用 <a href="#">「5. SpanGetHandler」</a> 接口，获得数据。</li></ul><blockquote><p>基情提示：运维界面相关 HTTP 接口，逻辑简单易懂，笔者写的会比较简略一些。 </p></blockquote><h1 id="2-ApplicationsGetHandler"><a href="#2-ApplicationsGetHandler" class="headerlink" title="2. ApplicationsGetHandler"></a>2. ApplicationsGetHandler</h1><p>同 <a href="http://www.iocoder.cn/SkyWalking/ui-2-instance/?self">《SkyWalking 源码分析 —— 运维界面（二）之应用实例视角》「3. ApplicationsGetHandler」</a> 相同。</p><h1 id="3-SegmentTopGetHandler"><a href="#3-SegmentTopGetHandler" class="headerlink" title="3. SegmentTopGetHandler"></a>3. SegmentTopGetHandler</h1><p><a href="https://github.com/YunaiV/skywalking/blob/826af725e7477b5d8d49a479a5cbbdee021c8306/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/jetty/handler/SegmentTopGetHandler.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.ui.jetty.handler.SegmentTopGetHandler</code></a> ，实现 JettyHandler 接口，获得 TraceSegment 分页列表的逻辑处理器。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/826af725e7477b5d8d49a479a5cbbdee021c8306/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/jetty/handler/SegmentTopGetHandler.java#L42" rel="external nofollow noopener noreferrer" target="_blank"><code>#pathSpec()</code></a> ，路径定义，<code>&quot;/segment/top&quot;</code> 。</li><li>响应示例：<img src="http://www.iocoder.cn/images/SkyWalking/2020_11_01/03.png" alt=""></li><li><a href="https://github.com/YunaiV/skywalking/blob/826af725e7477b5d8d49a479a5cbbdee021c8306/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/jetty/handler/SegmentTopGetHandler.java#L52" rel="external nofollow noopener noreferrer" target="_blank"><code>#doGet()</code></a> 方法，代码如下：<ul><li>第 62 至 73 行：解析 <code>startTime</code> 和 <code>endTime</code> 参数。</li><li>第 75 至 87 行：解析 <code>from</code> 和 <code>limit</code> <strong>分页</strong>参数。</li><li>第 90 至 97 行：解析 <code>minCost</code> 和 <code>maxCost</code> 参数。</li><li>第 100 至 103 行：解析 <code>globalTraceId</code> 参数。</li><li>第 106 至 109 行：解析 <code>operationName</code> 参数。</li><li>第 112 至 117 行：解析 <code>applicationId</code> 参数。</li><li>第 120 至 132 行：解析 <code>error</code> 参数。</li><li>第 135 至 141 行：解析 <code>sort</code> 排序<strong>键</strong>参数，倒序。</li><li>第 73 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/826af725e7477b5d8d49a479a5cbbdee021c8306/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/service/SegmentTopService.java#L53" rel="external nofollow noopener noreferrer" target="_blank"><code>SegmentTopService#load(...)</code></a> 方法，，获得 TraceSegment 分页列表。代码如下：<ul><li>第 59 至 62 行：若存在 <code>globalTraceId</code> 参数，调用 <a href="https://github.com/YunaiV/skywalking/blob/826af725e7477b5d8d49a479a5cbbdee021c8306/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/GlobalTraceEsUIDAO.java#L65" rel="external nofollow noopener noreferrer" target="_blank"><code>GlobalTraceEsUIDAO#getSegmentIds(globalTraceId)</code></a> 方法，查询对应的 TraceSegment 编号数组。<strong>为什么需要这么查询呢</strong>？在下面，我们会看到，实际查询的是 SegmentCost 表，该表不存在 <code>global_trace_id</code> ，所以需要查询到 <code>segment_id</code> 数组，作为查询条件。</li><li>第 65 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/826af725e7477b5d8d49a479a5cbbdee021c8306/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/SegmentCostEsUIDAO.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>SegmentCostEsUIDAO#loadTop(...)</code></a> 方法，查询 <strong>SegmentCost</strong> 数组。</li><li>第 68 至 77 行：循环 <strong>SegmentCost</strong> 数组，调用 <a href="https://github.com/YunaiV/skywalking/blob/826af725e7477b5d8d49a479a5cbbdee021c8306/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/GlobalTraceEsUIDAO.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>GlobalTraceEsUIDAO#getGlobalTraceId(segmentId)</code></a> 方法，获得每个 SegmentCost 对应的 <code>global_trace_id</code> 属性，并设置返回。</li></ul></li></ul></li></ul><h1 id="4-TraceStackGetHandler"><a href="#4-TraceStackGetHandler" class="headerlink" title="4. TraceStackGetHandler"></a>4. TraceStackGetHandler</h1><p><a href="https://github.com/YunaiV/skywalking/blob/e26853f280a23a9eadb8267963b75727a65ea31a/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/jetty/handler/TraceStackGetHandler.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.ui.jetty.handler.TraceStackGetHandler</code></a> ，实现 JettyHandler 接口，获取一次分布式链路追踪记录详情的逻辑处理器。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/e26853f280a23a9eadb8267963b75727a65ea31a/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/jetty/handler/TraceStackGetHandler.java#L40" rel="external nofollow noopener noreferrer" target="_blank"><code>#pathSpec()</code></a> ，路径定义，<code>&quot;/traceStack/globalTraceId&quot;</code> 。</li><li>响应示例：<img src="http://www.iocoder.cn/images/SkyWalking/2020_11_01/04.png" alt=""></li><li><a href="https://github.com/YunaiV/skywalking/blob/e26853f280a23a9eadb8267963b75727a65ea31a/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/jetty/handler/TraceStackGetHandler.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>#doGet()</code></a> 方法，代码如下：<ul><li>第 73 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/e26853f280a23a9eadb8267963b75727a65ea31a/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/service/TraceStackService.java#L59" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceStackService#load(globalTraceId)</code></a> 方法，基 <strong>GlobalTrace</strong> 和 <strong>Segment</strong> 表，获取一次分布式链路追踪记录详情的逻辑处理器。逻辑较为繁琐，笔者已经添加注释，胖友调试一下，很容易明白滴。<img src="http://www.iocoder.cn/images/SkyWalking/2020_11_01/05.png" alt=""></li></ul></li></ul><h1 id="5-SpanGetHandler"><a href="#5-SpanGetHandler" class="headerlink" title="5. SpanGetHandler"></a>5. SpanGetHandler</h1><p><a href="https://github.com/YunaiV/skywalking/blob/c3f55e55593158e065b9589855ca90e819558765/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/jetty/handler/SpanGetHandler.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.ui.jetty.handler.SpanGetHandler</code></a> ，实现 JettyHandler 接口，获得 TraceSegment 单个 Span 详细的逻辑处理器。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/c3f55e55593158e065b9589855ca90e819558765/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/jetty/handler/SpanGetHandler.java#L40" rel="external nofollow noopener noreferrer" target="_blank"><code>#pathSpec()</code></a> ，路径定义，<code>&quot;/span/spanId&quot;</code> 。</li><li>响应示例：<img src="http://www.iocoder.cn/images/SkyWalking/2020_11_01/02.png" alt=""></li><li><a href="https://github.com/YunaiV/skywalking/blob/c3f55e55593158e065b9589855ca90e819558765/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/jetty/handler/SpanGetHandler.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>#doGet()</code></a> 方法，代码如下：<ul><li>第 52 行：解析 <code>segmentId</code> 参数。</li><li>第 55 至 62 行：解析 <code>spanId</code> 参数。</li><li>第 73 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/c3f55e55593158e065b9589855ca90e819558765/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/service/SpanService.java#L54" rel="external nofollow noopener noreferrer" target="_blank"><code>SpanService#load(segmentId, spanId)</code></a> 方法，获得 TraceSegment 单个 Span 详细。代码如下：<ul><li>第 44 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/c3f55e55593158e065b9589855ca90e819558765/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/SegmentEsUIDAO.java#L45" rel="external nofollow noopener noreferrer" target="_blank"><code>SegmentEsUIDAO#load(segmentId)</code></a> 方法，获得 TraceSegment 。</li><li>第 58 至 139 行：循环获得的 TraceSegment 的 Span 数组，找到对应的 Span 记录，设置后返回。</li></ul></li></ul></li></ul><h1 id="6-彩蛋"><a href="#6-彩蛋" class="headerlink" title="6. 彩蛋"></a>6. 彩蛋</h1><p>水更第三发！</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_10_25/05.png" alt=""></p><p>胖友，分享一波朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/ui-3-trace/&quot;&gt;http://www.iocoder.cn/SkyWalking/ui-3-trace/&lt;/a&gt; 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;

      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— 运维界面（二）之应用实例视角</title>
    <link href="http://www.iocoder.cn/SkyWalking/ui-2-instance/"/>
    <id>http://www.iocoder.cn/SkyWalking/ui-2-instance/</id>
    <published>2020-10-27T16:00:00.000Z</published>
    <updated>2018-01-07T14:48:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/ui-2-instance/">http://www.iocoder.cn/SkyWalking/ui-2-instance/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/ui-2-instance/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/ui-2-instance/">2. AllInstanceLastTimeGetHandler</a></li><li><a href="http://www.iocoder.cn/SkyWalking/ui-2-instance/">3. ApplicationsGetHandler</a></li><li><a href="http://www.iocoder.cn/SkyWalking/ui-2-instance/">4. InstanceHealthGetHandler</a></li><li><a href="http://www.iocoder.cn/SkyWalking/ui-2-instance/">5. InstanceMetricGetRangeTimeBucketHandler</a></li><li><a href="http://www.iocoder.cn/SkyWalking/ui-2-instance/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享<strong>运维界面的第二部分，应用实例视角</strong>。</p><blockquote><p>SkyWalking WEBUI ：<a href="https://github.com/apache/incubator-skywalking-ui" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubator-skywalking-ui</a></p></blockquote><p>在我们打开 SkyWalking WEBUI 的 <code>Instance Override</code> ( <code>health/health.html</code> ) 页时，如下图：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_10_28/01.png" alt=""></p><ul><li>以应用实例为维度进行展示。</li><li>红色部分，时间进度条，调用 <a href="#">「2. AllInstanceLastTimeGetHandler」</a> 接口，获得应用实例最后心跳时间。大多情况下，我们进入该界面，看的是从最后心跳时间开始的应用调用情况。</li><li>绿色部分，应用列表，初始化以 [ 实例最后心跳时间前一小时 , 实例最后心跳时间 ] 调用 <a href="#">「3. ApplicationsGetHandler」</a> 接口，获得<strong>范围</strong>数据，而后每 4 秒刷新一次，数据范围向前走 4 秒( 时间进度条是走 2 次 2 秒 )，为 [ 实例最后心跳时间前一小时 + 四秒 , 实例最后心跳时间 + 四秒 ]。 </li><li>红色部分，【点击任意应用】，应用实例列表，调用 <a href="#">「4. InstanceHealthGetHandler」</a> 接口，获得<strong>当前时间</strong>数据，而后每 2 秒刷新一次。</li><li>通过进度条的【<strong>播放/暂停按钮</strong>】可以切换到暂停模式，切换时间范围，查看时间范围为一小时内的应用调用拓扑图。注意，一定要切换到【暂时模式】才可调整时间范围，在【播放模式】下，每次<strong>自动</strong>请求都会重设时间范围。</li></ul><p>在我们【点击任意应用实例】，打开 SkyWalking WEBUI 的 <code>Instance</code> ( <code>instance/instance.html</code> ) 页时，如下图：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_10_28/02.png" alt=""></p><ul><li>以<strong>单个</strong>应用实例为维度进行展示。</li><li>橘色部分，应用实例指标，初始化以 [ 打开页面时间前五分钟 , 打开页面时间 ] 调用 <a href="#">「5. InstanceMetricGetRangeTimeBucketHandler」</a> 接口，获得<strong>范围</strong>数据。</li><li>红色部分，【点击 auto 开关】，每 1 秒刷新一次，数据范围向前走 1 秒，为 [ 打开页面时间 + 一秒 , 打开页面时间 + 一秒 ]，获得<strong>每秒增量</strong>数据。</li></ul><blockquote><p>基情提示：运维界面相关 HTTP 接口，逻辑简单易懂，笔者写的会比较简略一些。 </p></blockquote><h1 id="2-AllInstanceLastTimeGetHandler"><a href="#2-AllInstanceLastTimeGetHandler" class="headerlink" title="2. AllInstanceLastTimeGetHandler"></a>2. AllInstanceLastTimeGetHandler</h1><p>同 <a href="http://www.iocoder.cn/SkyWalking/ui-1-application/?self">《SkyWalking 源码分析 —— 运维界面（一）之应用视角》「2. AllInstanceLastTimeGetHandler」</a> 相同。</p><h1 id="3-ApplicationsGetHandler"><a href="#3-ApplicationsGetHandler" class="headerlink" title="3. ApplicationsGetHandler"></a>3. ApplicationsGetHandler</h1><p><a href="https://github.com/YunaiV/skywalking/blob/a5db282a68747668356a1bc55e9227bd2b7869a0/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/jetty/handler/application/ApplicationsGetHandler.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.ui.jetty.handler.application.ApplicationsGetHandler</code></a> ，实现 JettyHandler 接口，获得应用列表逻辑处理器。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/a5db282a68747668356a1bc55e9227bd2b7869a0/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/jetty/handler/application/ApplicationsGetHandler.java#L40" rel="external nofollow noopener noreferrer" target="_blank"><code>#pathSpec()</code></a> ，路径定义，<code>&quot;applications&quot;</code> 。</li><li>响应示例：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_28/03.png" alt=""></li><li><a href="https://github.com/YunaiV/skywalking/blob/9f2dab1c61b49610eca0fc2634ee7af918ba7d1f/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/jetty/handler/time/AllInstanceLastTimeGetHandler.java#L53" rel="external nofollow noopener noreferrer" target="_blank"><code>#doGet()</code></a> 方法，代码如下：<ul><li>第 73 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/a5db282a68747668356a1bc55e9227bd2b7869a0/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/service/ApplicationService.java#L42" rel="external nofollow noopener noreferrer" target="_blank"><code>ApplicationService#getApplications(startTime, endTime)</code></a> 方法，以应用编号为聚合，获得应用实例数量数组。代码如下：<ul><li>第 44 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/a5db282a68747668356a1bc55e9227bd2b7869a0/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/InstanceEsUIDAO.java#L112" rel="external nofollow noopener noreferrer" target="_blank"><code>NodeComponentEsUIDAO#load(startTime, endTime)</code></a> 方法，以应用编号为聚合，获得应用实例数量 JSON 数组。</li><li>第 47 至 52 行：设置应用编码。</li></ul></li></ul></li></ul><h1 id="4-InstanceHealthGetHandler"><a href="#4-InstanceHealthGetHandler" class="headerlink" title="4. InstanceHealthGetHandler"></a>4. InstanceHealthGetHandler</h1><p><a href="https://github.com/YunaiV/skywalking/blob/68b704ef2395067fdb135262089c5c3d316efee7/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/jetty/handler/instancehealth/InstanceHealthGetHandler.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.ui.jetty.handler.instancehealth.InstanceHealthGetHandler</code></a> ，实现 JettyHandler 接口，获得应用的应用实例健康相关信息数组。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/68b704ef2395067fdb135262089c5c3d316efee7/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/jetty/handler/instancehealth/InstanceHealthGetHandler.java#L42" rel="external nofollow noopener noreferrer" target="_blank"><code>#pathSpec()</code></a> ，路径定义，<code>&quot;/instance/health/applicationId&quot;</code> 。</li><li>响应示例：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_28/04.png" alt=""></li><li><a href="https://github.com/YunaiV/skywalking/blob/68b704ef2395067fdb135262089c5c3d316efee7/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/jetty/handler/instancehealth/InstanceHealthGetHandler.java#L52" rel="external nofollow noopener noreferrer" target="_blank"><code>#doGet()</code></a> 方法，代码如下： <ul><li>第 58 至 62 行：解析 <code>timeBucket</code> 参数，秒级。</li><li>第 65 至 72 行：解析 <code>applicationIds</code> 参数，应用编号<strong>数组</strong>。 </li><li>第 75 至 79 行：返回字段设置。</li><li>第 82 至 85 行：循环应用编号数组，调用 <a href="https://github.com/YunaiV/skywalking/blob/68b704ef2395067fdb135262089c5c3d316efee7/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/service/InstanceHealthService.java#L76" rel="external nofollow noopener noreferrer" target="_blank"><code>InstanceHealthService#getInstances(timeBucket, applicationId)</code></a> 方法，获得应用的应用实例健康相关信息数组。代码如下：<ul><li>第 80 行：获得指定时间内的 <strong>5 秒内</strong>的数组，倒序。为什么？见下文的 InstPerformance 的查询。</li><li>第 81 至 82 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/68b704ef2395067fdb135262089c5c3d316efee7/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/InstanceEsUIDAO.java#L158" rel="external nofollow noopener noreferrer" target="_blank"><code>InstanceEsUIDAO#getInstances(applicationId, timeBucket)</code></a> 方法，查询查询半小时内有<strong>心跳</strong>的 Instance 数组。</li><li>第 90 行：<strong>循环</strong> Instance 数组，逐个查询应用实例的健康相关信息。</li><li>第 98 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/68b704ef2395067fdb135262089c5c3d316efee7/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/InstPerformanceEsUIDAO.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>InstPerformanceEsUIDAO#get(timeBuckets, instanceId)</code></a> 方法，查询应用实例<strong>五秒内</strong>的( <code>timeBuckets</code> )的 InstPerformance <strong>累加</strong>数据。<ul><li>第 100 至 105 行：基于 InstPerformance 数据，设置 <code>tps</code> 返回字段。</li><li>第 108 至 121 行：基于 InstPerformance 数据，设置 <code>avg</code> 和 <code>healthLevel</code> 返回数据。</li></ul></li><li>第 124 至 130 行：基于 Instance 数据，设置应用实例是否存活( 两分钟内是否有心跳 )。</li><li>第 133 至 135 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/68b704ef2395067fdb135262089c5c3d316efee7/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/GCMetricEsUIDAO.java#L56" rel="external nofollow noopener noreferrer" target="_blank"><code>GCMetricEsUIDAO#getGCCount(timeBuckets, instanceId)</code></a> 方法，查询应用实例<strong>五秒内</strong>的( <code>timeBuckets</code> )的 GCCount <strong>累加</strong>数据，设置 <code>ygc</code> 和 <code>ogc</code> 返回字段。</li></ul></li></ul></li></ul><h1 id="5-InstanceMetricGetRangeTimeBucketHandler"><a href="#5-InstanceMetricGetRangeTimeBucketHandler" class="headerlink" title="5. InstanceMetricGetRangeTimeBucketHandler"></a>5. InstanceMetricGetRangeTimeBucketHandler</h1><p><a href="https://github.com/YunaiV/skywalking/blob/ecee73223defd374e711e7d5f08fa8ae13e6bd97/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/jetty/handler/instancemetric/InstanceMetricGetRangeTimeBucketHandler.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.ui.jetty.handler.instancemetric.InstanceMetricGetRangeTimeBucketHandler</code></a> ，实现 JettyHandler 接口，获得应用实例指定时间范围内的 Metric 信息。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/ecee73223defd374e711e7d5f08fa8ae13e6bd97/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/jetty/handler/instancemetric/InstanceMetricGetRangeTimeBucketHandler.java#L42" rel="external nofollow noopener noreferrer" target="_blank"><code>#pathSpec()</code></a> ，路径定义，<code>&quot;/instance/jvm/instanceId/rangeBucket&quot;</code> 。</li><li>响应示例：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_28/05.png" alt=""></li><li><a href="https://github.com/YunaiV/skywalking/blob/68b704ef2395067fdb135262089c5c3d316efee7/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/jetty/handler/instancehealth/InstanceHealthGetHandler.java#L52" rel="external nofollow noopener noreferrer" target="_blank"><code>#doGet()</code></a> 方法，代码如下： <ul><li>第 60 至 74 行：解析 <code>startTimeBucket</code> 和 <code>endTimeBucket</code> 参数，秒级。</li><li>第 77 至 88 行：解析 <code>instanceId</code> 参数，应用实例编号。 </li><li>第 84 至 92 行：解析 <code>metricTypes</code> 数组。</li><li>第 94 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/ecee73223defd374e711e7d5f08fa8ae13e6bd97/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/service/InstanceJVMService.java#L101" rel="external nofollow noopener noreferrer" target="_blank"><code>InstanceJVMService#getInstanceJvmMetrics(instanceId, metricTypes, startTimeBucket, endTimeBucket)</code></a> 方法，获得应用实例指定时间范围内的 Metric 信息，涉及 GCMetric 、InstPerformanceMetric 、MemoryMetric 、MemoryPoolMetric 数据表。代码比较简单易懂( 笔者太懒了 )，胖友自己阅读理解。<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_28/06.png" alt=""></li></ul></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>水更第二发！</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_10_25/05.png" alt=""></p><p>胖友，分享一波朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/ui-2-instance/&quot;&gt;http://www.iocoder.cn/SkyWalking/ui-2-instance/&lt;/a&gt; 「芋道源码」欢迎转载，保留摘要，谢谢
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— 运维界面（一）之应用视角</title>
    <link href="http://www.iocoder.cn/SkyWalking/ui-1-application/"/>
    <id>http://www.iocoder.cn/SkyWalking/ui-1-application/</id>
    <published>2020-10-24T16:00:00.000Z</published>
    <updated>2018-01-07T06:58:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/ui-1-application/">http://www.iocoder.cn/SkyWalking/ui-1-application/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/ui-1-application/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/ui-1-application/">2. AllInstanceLastTimeGetHandler</a></li><li><a href="http://www.iocoder.cn/SkyWalking/ui-1-application/">3. TraceDagGetHandler</a></li><li><a href="http://www.iocoder.cn/SkyWalking/ui-1-application/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享<strong>运维界面的第一部分，应用视角</strong>。</p><blockquote><p>SkyWalking WEBUI ：<a href="https://github.com/apache/incubator-skywalking-ui" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubator-skywalking-ui</a></p></blockquote><p>在我们打开 SkyWalking WEBUI 的首页时，如下图：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_10_25/01.png" alt=""></p><ul><li>以应用为维度进行展示。</li><li>紫色部分，时间进度条，调用 <a href="#">「2. AllInstanceLastTimeGetHandler」</a> 接口，获得应用实例最后心跳时间。大多情况下，我们进入该界面，看的是从最后心跳时间开始的应用调用情况。</li><li>红色部分，应用调用拓扑图，初始化以 [ 实例最后心跳时间前一小时 , 实例最后心跳时间 ] 调用 <a href="#">「3. TraceDagGetHandler」</a> 接口，获得数据，而后每 2 秒刷新一次，30 次刷新后，即过了 1 分钟后，数据范围向前走一分钟，为 [ 实例最后心跳时间前一小时 + 一分钟 , 实例最后心跳时间 + 一分钟 ]。 </li><li>通过进度条的【<strong>播放/暂停按钮</strong>】可以切换到暂停模式，切换时间范围，查看时间范围为一小时内的应用调用拓扑图。注意，一定要切换到【暂时模式】才可调整时间范围，在【播放模式】下，每次<strong>自动</strong>请求都会重设时间范围。</li></ul><blockquote><p>基情提示：运维界面相关 HTTP 接口，逻辑简单易懂，笔者写的会比较简略一些。</p></blockquote><h1 id="2-AllInstanceLastTimeGetHandler"><a href="#2-AllInstanceLastTimeGetHandler" class="headerlink" title="2. AllInstanceLastTimeGetHandler"></a>2. AllInstanceLastTimeGetHandler</h1><p><a href="https://github.com/YunaiV/skywalking/blob/9f2dab1c61b49610eca0fc2634ee7af918ba7d1f/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/jetty/handler/time/AllInstanceLastTimeGetHandler.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.ui.jetty.handler.time.AllInstanceLastTimeGetHandler</code></a> ，实现 JettyHandler 接口，获得应用实例最后心跳时间处理器。代码如下：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/9f2dab1c61b49610eca0fc2634ee7af918ba7d1f/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/jetty/handler/time/AllInstanceLastTimeGetHandler.java#L43" rel="external nofollow noopener noreferrer" target="_blank"><code>#pathSpec()</code></a> ，路径定义，<code>&quot;/time/allInstance&quot;</code> 。</li><li>响应示例：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_25/02.png" alt=""></li><li><a href="https://github.com/YunaiV/skywalking/blob/9f2dab1c61b49610eca0fc2634ee7af918ba7d1f/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/jetty/handler/time/AllInstanceLastTimeGetHandler.java#L53" rel="external nofollow noopener noreferrer" target="_blank"><code>#doGet()</code></a> 方法，代码如下：<ul><li>第 55 至 59 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/9f2dab1c61b49610eca0fc2634ee7af918ba7d1f/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/service/TimeSynchronousService.java#L40" rel="external nofollow noopener noreferrer" target="_blank"><code>TimeSynchronousService#allInstanceLastTime()</code></a> 方法，获得应用实例最后心跳时间。<ul><li><a href="https://github.com/YunaiV/skywalking/blob/fe20d4fff8e2ebf4ad44c9e7ac455f69146c0b9c/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/InstanceEsUIDAO.java#L61" rel="external nofollow noopener noreferrer" target="_blank"><code>InstanceEsUIDAO#lastHeartBeatTime()</code></a></li></ul></li><li>第 61 至 65 行：减 5 秒，因为应用心跳是最频繁的，防止其他信息还没上传。</li><li>第 68 至 69 行：返回数据。 </li></ul></li></ul><h1 id="3-TraceDagGetHandler"><a href="#3-TraceDagGetHandler" class="headerlink" title="3. TraceDagGetHandler"></a>3. TraceDagGetHandler</h1><p><a href="https://github.com/YunaiV/skywalking/blob/9f2dab1c61b49610eca0fc2634ee7af918ba7d1f/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/jetty/handler/time/AllInstanceLastTimeGetHandler.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.ui.jetty.handler.TraceDagGetHandler</code></a> ，实现 JettyHandler 接口，获得应用拓扑图数据逻辑处理器。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/f32d6d88343ec18a3b32127bf9c4152e5dc9d4d1/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/jetty/handler/TraceDagGetHandler.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>#pathSpec()</code></a> ，路径定义，<code>&quot;traceDag&quot;</code> 。</li><li>响应示例：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_25/03.png" alt=""></li><li><a href="https://github.com/YunaiV/skywalking/blob/9f2dab1c61b49610eca0fc2634ee7af918ba7d1f/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/jetty/handler/time/AllInstanceLastTimeGetHandler.java#L53" rel="external nofollow noopener noreferrer" target="_blank"><code>#doGet()</code></a> 方法，代码如下：<ul><li>第 73 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/f32d6d88343ec18a3b32127bf9c4152e5dc9d4d1/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/jetty/handler/TraceDagGetHandler.java#L73" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceDagService#load(startTime, endTime)</code></a> 方法，获得应用拓扑图数据。代码如下：<ul><li>第 53 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/f32d6d88343ec18a3b32127bf9c4152e5dc9d4d1/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/NodeComponentEsUIDAO.java#L59" rel="external nofollow noopener noreferrer" target="_blank"><code>NodeComponentEsUIDAO#load(startTime, endTime)</code></a> 方法，获得 NodeComponent JSON 数组。</li><li>第 56 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/f32d6d88343ec18a3b32127bf9c4152e5dc9d4d1/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/NodeMappingEsUIDAO.java#L59" rel="external nofollow noopener noreferrer" target="_blank"><code>NodeMappingEsUIDAO#load(startTime, endTime)</code></a> 方法，获得 NodeMapping JSON 数组。</li><li>第 59 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/f32d6d88343ec18a3b32127bf9c4152e5dc9d4d1/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/NodeReferenceEsUIDAO.java#L68" rel="external nofollow noopener noreferrer" target="_blank"><code>NodeReferenceEsUIDAO#load(startTime, endTime)</code></a> 方法，获得 NodeReference JSON 数组。</li><li>第 62 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/f32d6d88343ec18a3b32127bf9c4152e5dc9d4d1/apm-collector/apm-collector-ui/collector-ui-jetty-provider/src/main/java/org/skywalking/apm/collector/ui/jetty/handler/TraceDagGetHandler.java#L48" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceDagDataBuilder#build(nodeCompArray, nodesMappingArray, resSumArray)</code></a> 方法，使用获得的 NodeComponent 、NodeMapping 、NodeReference 数据，构建应用拓扑图。逻辑较为繁琐，笔者已经添加注释，胖友调试一下，很容易明白滴。<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_25/04.png" alt=""></li></ul></li></ul></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>水更第一发！</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_10_25/05.png" alt=""></p><p>胖友，分享一波朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/ui-1-application/&quot;&gt;http://www.iocoder.cn/SkyWalking/ui-1-application/&lt;/a&gt; 「芋道源码」欢迎转载，保
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— JVM 指标的收集与存储</title>
    <link href="http://www.iocoder.cn/SkyWalking/jvm-collect/"/>
    <id>http://www.iocoder.cn/SkyWalking/jvm-collect/</id>
    <published>2020-10-19T16:00:00.000Z</published>
    <updated>2018-01-06T13:58:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/jvm-collect/">http://www.iocoder.cn/SkyWalking/jvm-collect/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/jvm-collect/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/jvm-collect/">2. Agent 收集 JVM 指标</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/jvm-collect/">2.1 JVMService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/jvm-collect/">2.2 CPU</a></li><li><a href="http://www.iocoder.cn/SkyWalking/jvm-collect/">2.3 Memory</a></li><li><a href="http://www.iocoder.cn/SkyWalking/jvm-collect/">2.4 MemoryPool</a></li><li><a href="http://www.iocoder.cn/SkyWalking/jvm-collect/">2.5 GC</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/jvm-collect/">3. Collector 存储 JVM 指标</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/jvm-collect/">3.1 JVMMetricsServiceHandler</a></li><li><a href="http://www.iocoder.cn/SkyWalking/jvm-collect/">3.2 CPU</a></li><li><a href="http://www.iocoder.cn/SkyWalking/jvm-collect/">3.3 Memory</a></li><li><a href="http://www.iocoder.cn/SkyWalking/jvm-collect/">3.4 MemoryPool</a></li><li><a href="http://www.iocoder.cn/SkyWalking/jvm-collect/">3.5 GC</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/jvm-collect/">4. 心跳</a></li><li><a href="http://www.iocoder.cn/SkyWalking/jvm-collect/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>SkyWalking JVM 指标的收集与存储</strong>。大体流程如下：</p><ul><li>Agent 每秒定时收集 JVM 指标到缓冲队列。</li><li>Agent 每秒定时将缓冲队列的 JVM 指标发送到 Collector 。</li><li>Collector 接收到 JVM 指标，异步批量存储到存储器( 例如，ES )。</li></ul><p>目前 JVM 指标包括<strong>四个维度</strong>：</p><ul><li>CPU</li><li>Memory</li><li>MemoryPool</li><li>GC</li></ul><p>SkyWalking UI 界面如下：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_10_20/02.png" alt=""></p><h1 id="2-Agent-收集-JVM-指标"><a href="#2-Agent-收集-JVM-指标" class="headerlink" title="2. Agent 收集 JVM 指标"></a>2. Agent 收集 JVM 指标</h1><h2 id="2-1-JVMService"><a href="#2-1-JVMService" class="headerlink" title="2.1 JVMService"></a>2.1 JVMService</h2><p><a href="https://github.com/YunaiV/skywalking/blob/4b7d7083ca9cd89437bcca6d0c5f67f3832d60dd/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/JVMService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.jvm.JVMService</code></a> ，实现 BootService 、Runnable 接口，JVM 指标服务，负责将 JVM 指标收集并发送给 Collector 。代码如下：</p><ul><li><code>queue</code> 属性，收集指标队列。</li><li><code>collectMetricFuture</code> 属性，收集指标定时任务。</li><li><code>sendMetricFuture</code> 属性，发送指标定时任务。</li><li><code>sender</code> 属性，发送器。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/4b7d7083ca9cd89437bcca6d0c5f67f3832d60dd/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/JVMService.java#L79" rel="external nofollow noopener noreferrer" target="_blank"><code>#beforeBoot()</code></a> 方法，初始化 <code>queue</code> ，<code>sender</code> 属性，并将自己添加到 GRPCChannelManager ，从而监听与 Collector 的连接状态。</p><p><a href="https://github.com/YunaiV/skywalking/blob/4b7d7083ca9cd89437bcca6d0c5f67f3832d60dd/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/JVMService.java#L86" rel="external nofollow noopener noreferrer" target="_blank"><code>boot</code></a> 方法，创建两个定时任务：</p><ul><li>第 88 至 90 行：创建收集指标定时任务，0 秒延迟，1 秒间隔，调用 <code>JVMService#run()</code> 方法。</li><li>第 92 至 94 行：创建发送指标定时任务，0 秒延迟，1 秒间隔，调用 <code>Sender#run()</code> 方法。</li></ul><h3 id="2-1-1-定时收集"><a href="#2-1-1-定时收集" class="headerlink" title="2.1.1 定时收集"></a>2.1.1 定时收集</h3><p><a href="https://github.com/YunaiV/skywalking/blob/4b7d7083ca9cd89437bcca6d0c5f67f3832d60dd/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/JVMService.java#L109" rel="external nofollow noopener noreferrer" target="_blank"><code>JVMService#run()</code></a> 方法，代码如下：</p><ul><li>第 110 至 111 行：应用实例注册后，才收集 JVM 指标。</li><li>第 116 至 122 行：创建 JVMMetric 对象。<ul><li>第 118 行：调用 <code>CPUProvider#getCpuMetric()</code> 方法，获得 GC 指标。</li><li>第 119 行：调用 <code>MemoryProvider#getMemoryMetricList()</code> 方法，获得 Memory 指标。</li><li>第 120 行：调用 <code>MemoryPoolProvider#getMemoryPoolMetricList()</code> 方法，获得 MemoryPool 指标。</li><li>第 121 行：调用 <code>GCProvider#getGCList()</code> 方法，获得 GC 指标。</li></ul></li><li>第 125 至 128 行：提交 JVMMetric 对象到收集指标队列。</li></ul><h3 id="2-1-2-定时发送"><a href="#2-1-2-定时发送" class="headerlink" title="2.1.2 定时发送"></a>2.1.2 定时发送</h3><p><a href="https://github.com/YunaiV/skywalking/blob/4b7d7083ca9cd89437bcca6d0c5f67f3832d60dd/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/JVMService.java#L135" rel="external nofollow noopener noreferrer" target="_blank"><code>JVMService.Sender</code></a> ，实现 Runnable 、GRPCChannelListener 接口，JVM 指标发送器。代码如下：</p><ul><li><code>status</code> 属性，连接状态。</li><li><code>stub</code> 属性，<strong>阻塞</strong> Stub 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/4b7d7083ca9cd89437bcca6d0c5f67f3832d60dd/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/JVMService.java#L171" rel="external nofollow noopener noreferrer" target="_blank"><code>#statusChanged(GRPCChannelStatus)</code></a> 方法，当连接成功时，创建<strong>阻塞</strong> Stub 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/4b7d7083ca9cd89437bcca6d0c5f67f3832d60dd/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/JVMService.java#L147" rel="external nofollow noopener noreferrer" target="_blank"><code>#run()</code></a> 方法，代码如下：<ul><li>第 148 至 151 行：应用实例注册后，并且连接中，才发送 JVM 指标。</li><li>第 153 至 155 行：调用 <code>#drainTo(Collection)</code> 方法，从队列移除所有 JVMMetric 到 <code>buffer</code> 数组。</li><li>第 157 至 162 行：使用 Stub ，<strong>批量</strong>发送到 Collector 。</li></ul></li></ul><h2 id="2-2-CPU"><a href="#2-2-CPU" class="headerlink" title="2.2 CPU"></a>2.2 CPU</h2><p><a href="https://github.com/YunaiV/skywalking/blob/d10357a372d8178ff205a2272d2cb7d57bc8f605/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/cpu/CPUProvider.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.jvm.cpu.CPUProvider</code></a> ，CPU 提供者，提供 <a href="https://github.com/YunaiV/skywalking/blob/d10357a372d8178ff205a2272d2cb7d57bc8f605/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/cpu/CPUProvider.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>#getCpuMetric()</code></a> 方法，采集 CPU 指标，如下图所示：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_20/05.png" alt=""></p><ul><li><code>usagePercent</code> ：JVM 进程占用 CPU 百分比。</li><li>第 51 行：调用 <code>CPUMetricAccessor#getCPUMetric()</code> 方法，获得 CPU 指标。</li></ul><p>在 <a href="https://github.com/YunaiV/skywalking/blob/d10357a372d8178ff205a2272d2cb7d57bc8f605/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/cpu/CPUProvider.java#L35" rel="external nofollow noopener noreferrer" target="_blank">CPUProvider 构造方法</a> 中，初始化 <code>cpuMetricAccessor</code> 数量，代码如下：</p><ul><li>第 37 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/4b7d7083ca9cd89437bcca6d0c5f67f3832d60dd/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/os/ProcessorUtil.java#L27" rel="external nofollow noopener noreferrer" target="_blank"><code>ProcessorUtil#getNumberOfProcessors()</code></a> 方法，获得 CPU 数量。</li><li>第 40 至 42 行：创建 SunCpuAccessor 对象。</li><li>第 44 至 46 行：发生异常，说明不支持，创建 NoSupportedCPUAccessor 对象。</li><li><strong>为什么需要使用 <code>ClassLoader#loadClass(className)</code> 方法呢</strong>？因为 SkyWalking Agent 是通过 JavaAgent 机制，实际未引入，所以通过该方式加载类。</li></ul><h3 id="2-2-1-CPUMetricAccessor"><a href="#2-2-1-CPUMetricAccessor" class="headerlink" title="2.2.1 CPUMetricAccessor"></a>2.2.1 CPUMetricAccessor</h3><p><a href="https://github.com/YunaiV/skywalking/blob/d10357a372d8178ff205a2272d2cb7d57bc8f605/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/cpu/CPUMetricAccessor.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.jvm.cpu.CPUMetricAccessor</code></a> ，CPU 指标访问器<strong>抽象类</strong>。代码如下：</p><ul><li><code>lastCPUTimeNs</code> 属性，获得进程占用 CPU 时长，单位：纳秒。</li><li><code>lastSampleTimeNs</code> 属性，最后采样时间，单位：纳秒。</li><li><code>cpuCoreNum</code> 属性，CPU 数量。</li><li><a href="https://github.com/YunaiV/skywalking/blob/d10357a372d8178ff205a2272d2cb7d57bc8f605/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/cpu/CPUMetricAccessor.java#L47" rel="external nofollow noopener noreferrer" target="_blank"><code>#init()</code></a> 方法，初始化 <code>lastCPUTimeNs</code> 、<code>lastSampleTimeNs</code> 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/d10357a372d8178ff205a2272d2cb7d57bc8f605/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/cpu/CPUMetricAccessor.java#L55" rel="external nofollow noopener noreferrer" target="_blank"><code>#getCpuTime()</code></a> 抽象方法，获得 CPU 占用时间，由子类完成。</li><li><a href="https://github.com/YunaiV/skywalking/blob/d10357a372d8178ff205a2272d2cb7d57bc8f605/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/cpu/CPUMetricAccessor.java#L57" rel="external nofollow noopener noreferrer" target="_blank"><code>#getCPUMetric()</code></a> 方法，获得 CPU 指标。放在和 SunCpuAccessor 一起分享。这里我先记得，JVM 进程占用 CPU 率的计算公式：<code>进程 CPU 占用总时间 / ( 进程启动总时间 * CPU 数量)</code> 。</li></ul><hr><p>CPUMetricAccessor 有两个子类，实际上文我们已经看到它的创建：</p><ul><li>SunCpuAccessor ，基于 SUN 提供的方法，获取 CPU 指标访问器。</li><li><a href="https://github.com/YunaiV/skywalking/blob/d10357a372d8178ff205a2272d2cb7d57bc8f605/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/cpu/NoSupportedCPUAccessor.java" rel="external nofollow noopener noreferrer" target="_blank">NoSupportedCPUAccessor</a> ，不支持的 CPU 指标访问器。因此，使用该类的情况下，获取不到具体的进程 CPU 占用率。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/d10357a372d8178ff205a2272d2cb7d57bc8f605/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/cpu/SunCpuAccessor.java#L31" rel="external nofollow noopener noreferrer" target="_blank">SunCpuAccessor 构造方法</a> ，代码如下：</p><ul><li>第 32 行：设置 CPU 数量。</li><li><p>第 33 行：获得 OperatingSystemMXBean 对象。通过该对象，在 <a href="https://github.com/YunaiV/skywalking/blob/d10357a372d8178ff205a2272d2cb7d57bc8f605/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/cpu/SunCpuAccessor.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>#getCpuTime()</code></a> 实现方法，调用 <a href="https://docs.oracle.com/javase/7/docs/jre/api/management/extension/com/sun/management/OperatingSystemMXBean.html#getProcessCpuTime(" rel="external nofollow noopener noreferrer" target="_blank"><code>OperatingSystemMXBean#getProcessCpuTime()</code></a>) 方法，获得 JVM 进程占用 CPU 总时长。</p><blockquote><p>long getProcessCpuTime()  </p><p>Returns the CPU time used by the process on which the Java virtual machine is running in nanoseconds. The returned value is of nanoseconds precision but not necessarily nanoseconds accuracy. This method returns -1 if the the platform does not support this operation.  </p><p><strong>Returns</strong>:<br>the CPU time used by the process in nanoseconds, or -1 if this operation is not supported.</p></blockquote></li><li><p>第 34 行：调用 <code>#init()</code> 方法，初始化 <code>lastCPUTimeNs</code> 、<code>lastSampleTimeNs</code> 。</p></li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/d10357a372d8178ff205a2272d2cb7d57bc8f605/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/cpu/CPUMetricAccessor.java#L57" rel="external nofollow noopener noreferrer" target="_blank"><code>#getCPUMetric()</code></a> 方法，获得 CPU 指标。代码如下：</p><ul><li>第 58 至 59 行：获得 JVM 进程占用 CPU 总时长。</li><li>第 64 行：<code>now - lastSampleTimeNs</code> ，获得 JVM 进程启动总时长。</li><li><strong>这里为什么相减呢</strong>？因为 CPUMetricAccessor 不是在 JVM 启动时就进行计算，通过相减，解决偏差。</li><li>第 63 至 64 行：计算 JVM 进程占用 CPU 率。</li></ul><h2 id="2-3-Memory"><a href="#2-3-Memory" class="headerlink" title="2.3 Memory"></a>2.3 Memory</h2><p><a href="https://github.com/YunaiV/skywalking/blob/ac31b37208b33a06616e580dfc71e2079531a2a6/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/memory/MemoryProvider.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.jvm.memory.MemoryProvider</code></a> ，Memory 提供者，提供 <a href="https://github.com/YunaiV/skywalking/blob/ac31b37208b33a06616e580dfc71e2079531a2a6/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/memory/MemoryProvider.java#L40" rel="external nofollow noopener noreferrer" target="_blank"><code>#getMemoryMetricList()</code></a> 方法，采集 Memory 指标，如下图所示：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_20/07.png" alt=""></p><ul><li>推荐阅读文章：<ul><li><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/management/MemoryUsage.html" rel="external nofollow noopener noreferrer" target="_blank">MemoryUsage</a></li><li><a href="http://blog.sina.com.cn/s/blog_ad7c19000102vjcw.html" rel="external nofollow noopener noreferrer" target="_blank">Java中监控程序内存的函数</a> </li><li><a href="http://zhanjindong.com/2016/03/02/jvm-memory-tunning-notes" rel="external nofollow noopener noreferrer" target="_blank">JVM内存调优相关的一些笔记（杂）</a></li></ul></li><li><code>isHeap</code> ：是否堆内内存。</li><li><code>init</code> ：初始化的内存数量。</li><li><code>max</code> ：最大的内存数量。</li><li><code>used</code> ：已使用的内存数量。</li><li><code>committed</code> ：可以使用的内存数量。</li><li>第 44 至 51 行：使用 MemoryMXBean 对象，获得堆内( Heap )内存。</li><li>第 54 至 61 行：使用 MemoryMXBean 对象，获得非堆内( None-Heap )内存。 </li></ul><h2 id="2-4-MemoryPool"><a href="#2-4-MemoryPool" class="headerlink" title="2.4 MemoryPool"></a>2.4 MemoryPool</h2><p><a href="https://github.com/YunaiV/skywalking/blob/868b01dbabccb8dd81031914d1536cb2393e9ab5/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/memorypool/MemoryPoolProvider.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.jvm.memorypool.MemoryPoolProvider</code></a> ，MemoryPool 提供者，提供 <a href="https://github.com/YunaiV/skywalking/blob/868b01dbabccb8dd81031914d1536cb2393e9ab5/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/memorypool/MemoryPoolProvider.java#L52" rel="external nofollow noopener noreferrer" target="_blank"><code>#getMemoryPoolMetricList()</code></a> 方法，采集 MemoryPool 指标<strong>数组</strong>，如下图：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_20/09.png" alt=""></p><ul><li>推荐阅读文章：<ul><li><a href="JVM堆内存和非堆内存">MemoryUsage</a></li></ul></li><li><code>type</code> ：内存区域类型。MemoryPool 和 Memory 的差别在于拆分的维度不同，如下图：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_20/11.png" alt=""></li><li><code>init</code> ：初始化的内存数量。</li><li><code>max</code> ：最大的内存数量。</li><li><code>used</code> ：已使用的内存数量。</li><li><code>committed</code> ：可以使用的内存数量。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/868b01dbabccb8dd81031914d1536cb2393e9ab5/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/memorypool/MemoryPoolProvider.java#L36" rel="external nofollow noopener noreferrer" target="_blank">MemoryPoolProvider 构造方法</a>，代码如下：</p><ul><li>第 38 行：获得 MemoryPoolMXBean 数组。每个 MemoryPoolMXBean 对象，代表上面的一个区域类型。</li><li>第 39 至 46 行：循环 MemoryPoolMXBean 数组，调用 <a href="https://github.com/YunaiV/skywalking/blob/868b01dbabccb8dd81031914d1536cb2393e9ab5/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/memorypool/MemoryPoolProvider.java#L56" rel="external nofollow noopener noreferrer" target="_blank"><code>#findByBeanName(name)</code></a> 方法，找到对应的 GC 算法，创建对应的 MemoryPoolMetricAccessor 对象。</li><li>第 47 至 49 行：未找到匹配的 GC 算法，创建 UnknownMemoryPool 对象。</li></ul><h3 id="2-4-1-MemoryPoolMetricAccessor"><a href="#2-4-1-MemoryPoolMetricAccessor" class="headerlink" title="2.4.1 MemoryPoolMetricAccessor"></a>2.4.1 MemoryPoolMetricAccessor</h3><p> <a href="https://github.com/YunaiV/skywalking/blob/868b01dbabccb8dd81031914d1536cb2393e9ab5/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/memorypool/MemoryPoolMetricAccessor.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.jvm.memorypool.MemoryPoolMetricAccessor</code></a> ，MemoryPool 指标访问器<strong>接口</strong>。</p><ul><li>定义了 <a href="https://github.com/YunaiV/skywalking/blob/868b01dbabccb8dd81031914d1536cb2393e9ab5/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/memorypool/MemoryPoolMetricAccessor.java#L30" rel="external nofollow noopener noreferrer" target="_blank"><code>#getMemoryPoolMetricList()</code></a> 接口，获得 MemoryPool 指标<strong>数组</strong>。</li></ul><p>MemoryPoolMetricAccessor 子类如下图：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_20/12.png" alt=""></p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/868b01dbabccb8dd81031914d1536cb2393e9ab5/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/memorypool/UnknownMemoryPool.java" rel="external nofollow noopener noreferrer" target="_blank">UnknownMemoryPool</a> ，未知的 MemoryPool 指标访问器实现类。每次 <a href="https://github.com/YunaiV/skywalking/blob/868b01dbabccb8dd81031914d1536cb2393e9ab5/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/memorypool/UnknownMemoryPool.java#L31" rel="external nofollow noopener noreferrer" target="_blank"><code>#getMemoryPoolMetricList()</code></a> 方法，返回  MemoryPool 指标<strong>数组</strong>，但是每个指标元素是无具体数据的。</li></ul><h3 id="2-4-2-MemoryPoolModule"><a href="#2-4-2-MemoryPoolModule" class="headerlink" title="2.4.2 MemoryPoolModule"></a>2.4.2 MemoryPoolModule</h3><p><a href="https://github.com/YunaiV/skywalking/blob/c94fca439b748760bb7561e4fa79f2673df171a3/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/memorypool/MemoryPoolModule.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.jvm.memorypool.MemoryPoolModule</code></a> ，实现 MemoryPoolMetricAccessor 接口，MemoryPool 指标访问器<strong>抽象类</strong>。不同 GC 算法之间，内存区域命名不同，通过如下<strong>六个</strong>方法抽象，分别对应不同内存区域，形成映射关系，屏蔽差异：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/c94fca439b748760bb7561e4fa79f2673df171a3/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/memorypool/MemoryPoolModule.java#L85" rel="external nofollow noopener noreferrer" target="_blank"><code>#getPermNames()</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/c94fca439b748760bb7561e4fa79f2673df171a3/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/memorypool/MemoryPoolModule.java#L87" rel="external nofollow noopener noreferrer" target="_blank"><code>#getCodeCacheNames()</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/c94fca439b748760bb7561e4fa79f2673df171a3/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/memorypool/MemoryPoolModule.java#L89" rel="external nofollow noopener noreferrer" target="_blank"><code>#getEdenNames()</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/c94fca439b748760bb7561e4fa79f2673df171a3/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/memorypool/MemoryPoolModule.java#L91" rel="external nofollow noopener noreferrer" target="_blank"><code>#getOldNames()</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/c94fca439b748760bb7561e4fa79f2673df171a3/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/memorypool/MemoryPoolModule.java#L93" rel="external nofollow noopener noreferrer" target="_blank"><code>#getSurvivorNames()</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/c94fca439b748760bb7561e4fa79f2673df171a3/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/memorypool/MemoryPoolModule.java#L95" rel="external nofollow noopener noreferrer" target="_blank"><code>#getMetaspaceNames()</code></a></li><li>胖友可以看看 MemoryPoolModule 子类的实现：<ul><li><a href="https://github.com/YunaiV/skywalking/blob/c94fca439b748760bb7561e4fa79f2673df171a3/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/memorypool/CMSCollectorModule.java" rel="external nofollow noopener noreferrer" target="_blank">CMSCollectorModule</a></li><li><a href="https://github.com/YunaiV/skywalking/blob/c94fca439b748760bb7561e4fa79f2673df171a3/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/memorypool/G1CollectorModule.java" rel="external nofollow noopener noreferrer" target="_blank">G1CollectorModule</a> </li><li><a href="https://github.com/YunaiV/skywalking/blob/c94fca439b748760bb7561e4fa79f2673df171a3/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/memorypool/ParallelCollectorModule.java" rel="external nofollow noopener noreferrer" target="_blank">ParallelCollectorModule</a></li><li><a href="https://github.com/YunaiV/skywalking/blob/c94fca439b748760bb7561e4fa79f2673df171a3/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/memorypool/SerialCollectorModule.java" rel="external nofollow noopener noreferrer" target="_blank">SerialCollectorModule</a></li></ul></li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/c94fca439b748760bb7561e4fa79f2673df171a3/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/memorypool/MemoryPoolModule.java#L41" rel="external nofollow noopener noreferrer" target="_blank"><code>#getMemoryPoolMetricList()</code></a> <strong>实现方法</strong>，代码如下：</p><ul><li>第 44 行：循环每个内存区域，收集每个 MemoryPool 指标。</li><li>第 47 至 62 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/c94fca439b748760bb7561e4fa79f2673df171a3/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/memorypool/MemoryPoolModule.java#L76" rel="external nofollow noopener noreferrer" target="_blank"><code>#contains(possibleNames, name)</code></a> 方法，逐个内存区域名字判断，获得对应的内存区域类型。</li><li>第 65 至 71 行：创建 MemoryUsage 对象，并添加到结果数组。</li></ul><h2 id="2-5-GC"><a href="#2-5-GC" class="headerlink" title="2.5 GC"></a>2.5 GC</h2><p>整体实现类似 <a href="#">「2.4 MemoryPool」</a> 。 </p><p><a href="https://github.com/YunaiV/skywalking/blob/73f4c2fb5fb7cf6eb533d61ba59afec66af2c9b6/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/gc/GCProvider.java#L30" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.jvm.memorypool.GCProvider</code></a> ，GC 提供者，提供 <a href="https://github.com/YunaiV/skywalking/blob/73f4c2fb5fb7cf6eb533d61ba59afec66af2c9b6/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/gc/GCProvider.java#L55" rel="external nofollow noopener noreferrer" target="_blank"><code>#getGCList()</code></a> 方法，采集 GC 指标<strong>数组</strong>，如下图：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_20/13.png" alt=""></p><ul><li><code>phrase</code> ：生代类型，包括新生代、老生代。</li><li><code>count</code> ：总回收次数。</li><li><code>time</code> ：总回收占用时间。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/73f4c2fb5fb7cf6eb533d61ba59afec66af2c9b6/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/gc/GCProvider.java#L37" rel="external nofollow noopener noreferrer" target="_blank">GCProvider 构造方法</a>，代码如下：</p><ul><li>第 38 行：获得 GarbageCollectorMXBean 数组。</li><li>第 39 至 46 行：循环 MemoryPoolMXBean 数组，调用 <a href="https://github.com/YunaiV/skywalking/blob/73f4c2fb5fb7cf6eb533d61ba59afec66af2c9b6/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/gc/GCProvider.java#L59" rel="external nofollow noopener noreferrer" target="_blank"><code>#findByBeanName(name)</code></a> 方法，找到对应的 GC 算法，创建对应的 GCMetricAccessor 对象。</li><li>第 47 至 49 行：未找到匹配的 GC 算法，创建 UnknowGC 对象。</li></ul><h3 id="2-5-1-GCMetricAccessor"><a href="#2-5-1-GCMetricAccessor" class="headerlink" title="2.5.1 GCMetricAccessor"></a>2.5.1 GCMetricAccessor</h3><p> <a href="https://github.com/YunaiV/skywalking/blob/73f4c2fb5fb7cf6eb533d61ba59afec66af2c9b6/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/gc/GCMetricAccessor.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.jvm.gc.GCMetricAccessor</code></a> ，GC 指标访问器<strong>接口</strong>。</p><ul><li>定义了 <a href="https://github.com/YunaiV/skywalking/blob/73f4c2fb5fb7cf6eb533d61ba59afec66af2c9b6/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/gc/GCMetricAccessor.java#L28" rel="external nofollow noopener noreferrer" target="_blank"><code>#getGCList()</code></a> 接口，获得 GC 指标<strong>数组</strong>。</li></ul><p>GCMetricAccessor 子类如下图：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_20/15.png" alt=""></p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/73f4c2fb5fb7cf6eb533d61ba59afec66af2c9b6/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/gc/UnknowGC.java" rel="external nofollow noopener noreferrer" target="_blank">UnknowGC</a> ，未知的 GC 指标访问器实现类。每次 <a href="https://github.com/YunaiV/skywalking/blob/73f4c2fb5fb7cf6eb533d61ba59afec66af2c9b6/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/gc/UnknowGC.java#L31" rel="external nofollow noopener noreferrer" target="_blank"><code>#getGCList()</code></a> 方法，返回  GC 指标<strong>数组</strong>，但是每个指标元素是无具体数据的。</li></ul><h3 id="2-5-2-GCModule"><a href="#2-5-2-GCModule" class="headerlink" title="2.5.2 GCModule"></a>2.5.2 GCModule</h3><p><a href="https://github.com/YunaiV/skywalking/blob/73f4c2fb5fb7cf6eb533d61ba59afec66af2c9b6/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/gc/GCModule.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.jvm.gc.GCModule</code></a> ，实现 GCMetricAccessor 接口，GC 指标访问器<strong>抽象类</strong>。不同 GC 算法之间，生代命名不同，通过如下<strong>两个</strong>方法抽象，分别对应两个生代，形成映射关系，屏蔽差异：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/73f4c2fb5fb7cf6eb533d61ba59afec66af2c9b6/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/gc/GCModule.java#L66" rel="external nofollow noopener noreferrer" target="_blank"><code>#getOldGCName()</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/73f4c2fb5fb7cf6eb533d61ba59afec66af2c9b6/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/gc/GCModule.java#L68" rel="external nofollow noopener noreferrer" target="_blank"><code>#getNewGCName()</code></a></li><li>胖友可以看看 GCModule 子类的实现：<ul><li><a href="https://github.com/YunaiV/skywalking/blob/73f4c2fb5fb7cf6eb533d61ba59afec66af2c9b6/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/gc/CMSGCModule.java" rel="external nofollow noopener noreferrer" target="_blank">CMSGCModule</a></li><li><a href="https://github.com/YunaiV/skywalking/blob/73f4c2fb5fb7cf6eb533d61ba59afec66af2c9b6/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/gc/G1GCModule.java" rel="external nofollow noopener noreferrer" target="_blank">G1GCModule</a> </li><li><a href="https://github.com/YunaiV/skywalking/blob/73f4c2fb5fb7cf6eb533d61ba59afec66af2c9b6/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/gc/ParallelGCModule.java" rel="external nofollow noopener noreferrer" target="_blank">ParallelGCModule</a></li><li><a href="https://github.com/YunaiV/skywalking/blob/73f4c2fb5fb7cf6eb533d61ba59afec66af2c9b6/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/gc/SerialGCModule.java" rel="external nofollow noopener noreferrer" target="_blank">SerialGCModule</a></li></ul></li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/73f4c2fb5fb7cf6eb533d61ba59afec66af2c9b6/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/jvm/gc/GCModule.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>#getGCList()</code></a> <strong>实现方法</strong>，代码如下：</p><ul><li>第 44 行：循环 GarbageCollectorMXBean 数组，收集每个 GC 指标。</li><li>第 47 至 62 行：获得生代类型。</li><li>第 65 至 71 行：创建 GC 对象，并添加到结果数组。</li></ul><h1 id="3-Collector-存储-JVM-指标"><a href="#3-Collector-存储-JVM-指标" class="headerlink" title="3. Collector 存储 JVM 指标"></a>3. Collector 存储 JVM 指标</h1><h2 id="3-1-JVMMetricsServiceHandler"><a href="#3-1-JVMMetricsServiceHandler" class="headerlink" title="3.1 JVMMetricsServiceHandler"></a>3.1 JVMMetricsServiceHandler</h2><p>我们先来看看 API 的定义，<a href="https://github.com/YunaiV/skywalking/blob/4b7d7083ca9cd89437bcca6d0c5f67f3832d60dd/apm-network/src/main/proto/JVMMetricsService.proto#L8" rel="external nofollow noopener noreferrer" target="_blank"><code>JVMMetricsService.proto</code></a> ，如下图所示：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_10_20/01.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-grpc/collector-agent-grpc-provider/src/main/java/org/skywalking/apm/collector/agent/grpc/handler/TraceSegmentServiceHandler.java#L47" rel="external nofollow noopener noreferrer" target="_blank"><code>JVMMetricsServiceHandler#collect(JVMMetrics, StreamObserver&lt;Downstream&gt;)</code></a>, 代码如下：</p><ul><li>第 60 行：<strong>循环</strong>接收到的 JVMMetric <strong>数组</strong>。</li><li>第 62 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/4b7d7083ca9cd89437bcca6d0c5f67f3832d60dd/apm-collector/apm-collector-agent-grpc/collector-agent-grpc-provider/src/main/java/org/skywalking/apm/collector/agent/grpc/handler/JVMMetricsServiceHandler.java#L77" rel="external nofollow noopener noreferrer" target="_blank"><code>#sendToInstanceHeartBeatService(...)</code></a> 方法，发送心跳，记录应用实例的最后心跳时间。因为目前 SkyWaling 主要用于 JVM 平台，通过每秒的 JVM 指标收集的同时，记录应用实例的最后心跳时间。</li><li>第 62 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/4b7d7083ca9cd89437bcca6d0c5f67f3832d60dd/apm-collector/apm-collector-agent-grpc/collector-agent-grpc-provider/src/main/java/org/skywalking/apm/collector/agent/grpc/handler/JVMMetricsServiceHandler.java#L91" rel="external nofollow noopener noreferrer" target="_blank"><code>#sendToCpuMetricService(...)</code></a> 方法，处理 CPU 数据。</li><li>第 64 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/4b7d7083ca9cd89437bcca6d0c5f67f3832d60dd/apm-collector/apm-collector-agent-grpc/collector-agent-grpc-provider/src/main/java/org/skywalking/apm/collector/agent/grpc/handler/JVMMetricsServiceHandler.java#L81" rel="external nofollow noopener noreferrer" target="_blank"><code>#sendToMemoryMetricService(...)</code></a> 方法，处理 Memory 数据。</li><li>第 66 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/4b7d7083ca9cd89437bcca6d0c5f67f3832d60dd/apm-collector/apm-collector-agent-grpc/collector-agent-grpc-provider/src/main/java/org/skywalking/apm/collector/agent/grpc/handler/JVMMetricsServiceHandler.java#L85" rel="external nofollow noopener noreferrer" target="_blank"><code>#sendToMemoryPoolMetricService(...)</code></a> 方法，处理 Memory Pool 数据。</li><li>第 68 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/4b7d7083ca9cd89437bcca6d0c5f67f3832d60dd/apm-collector/apm-collector-agent-grpc/collector-agent-grpc-provider/src/main/java/org/skywalking/apm/collector/agent/grpc/handler/JVMMetricsServiceHandler.java#L95" rel="external nofollow noopener noreferrer" target="_blank"><code>#sendToGCMetricService(...)</code></a> 方法，处理 GC 数据。</li><li>第 73 至 74 行：全部处理完成，返回成功。</li></ul><p>上述的 <code>#sendToXXX()</code> 方法，内部每个对应调用一个如下图 Service 提供的方法：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_20/04.png" alt=""></p><ul><li>每个 Service 的实现，对应一个数据实体和一个 Graph 对象，通过流式处理，最终存储到存储器( 例如 ES ) ，流程如下图：</li><li>具体的实现代码，我们放在下面的数据实体一起分享。</li></ul><h2 id="3-2-CPU"><a href="#3-2-CPU" class="headerlink" title="3.2 CPU"></a>3.2 CPU</h2><p><a href="https://github.com/YunaiV/skywalking/blob/aadff78dcde7c2e05dc8d29f3381032c1650137e/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/jvm/CpuMetric.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.jvm.CpuMetric</code></a> ，CPU 指标。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/aadff78dcde7c2e05dc8d29f3381032c1650137e/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/jvm/CpuMetricTable.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.jvm.CpuMetricTable</code></a> ， CpuMetric 表( <code>cpu_metric</code> )。字段如下：<ul><li><code>instance_id</code> ：应用实例编号。</li><li><code>usage_percent</code> ：CPU 占用率。</li><li><code>time_bucket</code> ：时间。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/3d1d1f5219205d38f58f1b59f0e81d81c038d2f1/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/CpuMetricEsPersistenceDAO.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.es.dao.CpuMetricEsPersistenceDAO</code></a> ，CpuMetric 的 EsDAO 。</li><li>在 ES 存储例子如下图： <img src="http://www.iocoder.cn/images/SkyWalking/2020_10_20/06.png" alt=""></li><li><a href="https://github.com/YunaiV/skywalking/blob/4b7d7083ca9cd89437bcca6d0c5f67f3832d60dd/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/jvm/CpuMetricService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.jvm.CpuMetricService</code></a> ，CPU 指标服务，调用 CPUMetric 对应的 <a href="https://github.com/YunaiV/skywalking/blob/4b7d7083ca9cd89437bcca6d0c5f67f3832d60dd/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/graph/JvmMetricStreamGraph.java#L66" rel="external nofollow noopener noreferrer" target="_blank"><code>Graph&lt;CPUMetric&gt;</code></a> 对象，流式处理，最终 CPUMetric 保存到存储器。</li><li><a href="https://github.com/YunaiV/skywalking/blob/4b7d7083ca9cd89437bcca6d0c5f67f3832d60dd/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/jvm/CpuMetricPersistenceWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.jvm.CpuMetricPersistenceWorker</code></a> , CPU 指标批量存储 Worker 。</li></ul><h2 id="3-3-Memory"><a href="#3-3-Memory" class="headerlink" title="3.3 Memory"></a>3.3 Memory</h2><p><a href="https://github.com/YunaiV/skywalking/blob/0051d648dc8e5435dd63666a34da81274f0a0e61/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/jvm/MemoryMetric.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.jvm.MemoryMetric</code></a> ，Memory 指标。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/0051d648dc8e5435dd63666a34da81274f0a0e61/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/jvm/MemoryMetricTable.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.jvm.MemoryMetricTable</code></a> ， MemoryMetric 表( <code>memory_metric</code> )。字段如下：<ul><li><code>instance_id</code> ：应用实例编号。</li><li><code>isHeap</code> ：是否堆内内存。</li><li><code>init</code> ：初始化的内存数量。</li><li><code>max</code> ：最大的内存数量。</li><li><code>used</code> ：已使用的内存数量。</li><li><code>committed</code> ：可以使用的内存数量。</li><li><code>time_bucket</code> ：时间。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/3d1d1f5219205d38f58f1b59f0e81d81c038d2f1/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/MemoryMetricEsPersistenceDAO.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.es.dao.MemoryMetricEsPersistenceDAO</code></a> ，MemoryMetric 的 EsDAO 。</li><li>在 ES 存储例子如下图： <img src="http://www.iocoder.cn/images/SkyWalking/2020_10_20/08.png" alt=""></li><li><a href="https://github.com/YunaiV/skywalking/blob/4b7d7083ca9cd89437bcca6d0c5f67f3832d60dd/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/jvm/MemoryMetricService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.jvm.MemoryMetricService</code></a> ，Memory 指标服务，调用 MemoryMetric 对应的 <a href="https://github.com/YunaiV/skywalking/blob/4b7d7083ca9cd89437bcca6d0c5f67f3832d60dd/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/graph/JvmMetricStreamGraph.java#L74" rel="external nofollow noopener noreferrer" target="_blank"><code>Graph&lt;MemoryMetric&gt;</code></a> 对象，流式处理，最终 MemoryMetric 保存到存储器。</li><li><a href="https://github.com/YunaiV/skywalking/blob/4b7d7083ca9cd89437bcca6d0c5f67f3832d60dd/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/jvm/MemoryMetricPersistenceWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.jvm.MemoryMetricPersistenceWorker</code></a> , Memory 指标批量存储 Worker 。</li></ul><h2 id="3-4-MemoryPool"><a href="#3-4-MemoryPool" class="headerlink" title="3.4 MemoryPool"></a>3.4 MemoryPool</h2><p><a href="https://github.com/YunaiV/skywalking/blob/0051d648dc8e5435dd63666a34da81274f0a0e61/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/jvm/MemoryPoolMetric.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.jvm.MemoryPoolMetric</code></a> ，MemoryPool 指标。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/c94fca439b748760bb7561e4fa79f2673df171a3/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/jvm/MemoryPoolMetricTable.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.jvm.MemoryPoolMetricTable</code></a> ， MemoryPool 表( <code>memory_pool_metric</code> )。字段如下：<ul><li><code>instance_id</code> ：应用实例编号。</li><li><code>pool_type</code> ：内存区域类型。</li><li><code>init</code> ：初始化的内存数量。</li><li><code>max</code> ：最大的内存数量。</li><li><code>used</code> ：已使用的内存数量。</li><li><code>committed</code> ：可以使用的内存数量。</li><li><code>time_bucket</code> ：时间。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/3d1d1f5219205d38f58f1b59f0e81d81c038d2f1/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/MemoryPoolMetricEsPersistenceDAO.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.es.dao.MemoryPoolMetricEsPersistenceDAO</code></a> ，MemoryPoolMetric 的 EsDAO 。</li><li>在 ES 存储例子如下图： <img src="http://www.iocoder.cn/images/SkyWalking/2020_10_20/10.png" alt=""></li><li><a href="https://github.com/YunaiV/skywalking/blob/4b7d7083ca9cd89437bcca6d0c5f67f3832d60dd/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/jvm/MemoryPoolMetricService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.jvm.MemoryMetricService</code></a> ，MemoryPoolMetric 指标服务，调用 MemoryPoolMetric 对应的 <a href="https://github.com/YunaiV/skywalking/blob/4b7d7083ca9cd89437bcca6d0c5f67f3832d60dd/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/graph/JvmMetricStreamGraph.java#L82" rel="external nofollow noopener noreferrer" target="_blank"><code>Graph&lt;MemoryPoolMetric&gt;</code></a> 对象，流式处理，最终 MemoryPoolMetric 保存到存储器。</li><li><a href="https://github.com/YunaiV/skywalking/blob/4b7d7083ca9cd89437bcca6d0c5f67f3832d60dd/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/jvm/MemoryMetricPersistenceWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.jvm.MemoryMetricPersistenceWorker</code></a> , MemoryPool 指标批量存储 Worker 。</li></ul><h2 id="3-5-GC"><a href="#3-5-GC" class="headerlink" title="3.5 GC"></a>3.5 GC</h2><p><a href="https://github.com/YunaiV/skywalking/blob/0051d648dc8e5435dd63666a34da81274f0a0e61/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/jvm/GCMetric.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.jvm.GCMetric</code></a> ，GC 指标。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/73f4c2fb5fb7cf6eb533d61ba59afec66af2c9b6/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/jvm/GCMetricTable.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.jvm.GCMetricTable</code></a> ， GCMetric 表( <code>gc_metric</code> )。字段如下：<ul><li><code>instance_id</code> ：应用实例编号。</li><li><code>phrase</code> ：生代类型，包括新生代、老生代。</li><li><code>count</code> ：总次数。</li><li><code>time</code> ：总时间。</li><li><code>time_bucket</code> ：时间。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/3d1d1f5219205d38f58f1b59f0e81d81c038d2f1/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/GCMetricEsPersistenceDAO.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.es.dao.GCMetricEsPersistenceDAO</code></a> ，GCMetric 的 EsDAO 。</li><li>在 ES 存储例子如下图： <img src="http://www.iocoder.cn/images/SkyWalking/2020_10_20/14.png" alt=""></li><li><a href="https://github.com/YunaiV/skywalking/blob/4b7d7083ca9cd89437bcca6d0c5f67f3832d60dd/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/jvm/GCMetricService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.jvm.GCMetricService</code></a> ，GCMetric 指标服务，调用 GCMetric 对应的 <a href="https://github.com/YunaiV/skywalking/blob/4b7d7083ca9cd89437bcca6d0c5f67f3832d60dd/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/graph/JvmMetricStreamGraph.java#L58" rel="external nofollow noopener noreferrer" target="_blank"><code>Graph&lt;GCMetric&gt;</code></a> 对象，流式处理，最终 GCMetric 保存到存储器。</li><li><a href="https://github.com/YunaiV/skywalking/blob/4b7d7083ca9cd89437bcca6d0c5f67f3832d60dd/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/jvm/MemoryMetricPersistenceWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.jvm.MemoryMetricPersistenceWorker</code></a> , MemoryPool 指标批量存储 Worker 。</li></ul><h1 id="4-心跳"><a href="#4-心跳" class="headerlink" title="4. 心跳"></a>4. 心跳</h1><p>Collector 在接收到 GC 指标上传后，调用 <a href="https://github.com/YunaiV/skywalking/blob/4b7d7083ca9cd89437bcca6d0c5f67f3832d60dd/apm-collector/apm-collector-agent-grpc/collector-agent-grpc-provider/src/main/java/org/skywalking/apm/collector/agent/grpc/handler/JVMMetricsServiceHandler.java#L77" rel="external nofollow noopener noreferrer" target="_blank"><code>JVMMetricsServiceHandler#sendToInstanceHeartBeatService(...)</code></a> 方法，发送心跳，记录应用实例的最后心跳时间。因为目前 SkyWaling 主要用于 JVM 平台，通过每秒的 JVM 指标收集的同时，记录应用实例的最后心跳时间。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/4b7d7083ca9cd89437bcca6d0c5f67f3832d60dd/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/jvm/InstanceHeartBeatService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.jvm.InstanceHeartBeatService</code></a> ，应用实例心跳服务，调用 Instance 对应的 <a href="https://github.com/YunaiV/skywalking/blob/4b7d7083ca9cd89437bcca6d0c5f67f3832d60dd/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/graph/JvmMetricStreamGraph.java#L90" rel="external nofollow noopener noreferrer" target="_blank"><code>Graph&lt;Instance&gt;</code></a> 对象，流式处理，最终更新 Instance 的最后<strong>心跳时间</strong>( <a href="https://github.com/YunaiV/skywalking/blob/73f4c2fb5fb7cf6eb533d61ba59afec66af2c9b6/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/register/InstanceTable.java#L42" rel="external nofollow noopener noreferrer" target="_blank"><code>heartbeat_time</code></a> )到存储器。</li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>比想象中冗长的文章，有些考验耐心，心疼 SkyWalking 开发者 30 秒。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_10_20/16.png" alt=""></p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/jvm-collect/&quot;&gt;http://www.iocoder.cn/SkyWalking/jvm-collect/&lt;/a&gt; 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector 存储 Trace 数据</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-store-trace/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-store-trace/</id>
    <published>2020-10-14T16:00:00.000Z</published>
    <updated>2018-01-05T15:21:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-store-trace/">http://www.iocoder.cn/SkyWalking/collector-store-trace/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-store-trace/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-store-trace/">2. SpanListener</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-store-trace/">3. GlobalTrace</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-store-trace/">4. InstPerformance</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-store-trace/">5. SegmentCost</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-store-trace/">6. NodeComponent</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-store-trace/">7. NodeMapping</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-store-trace/">8. NodeReference</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-store-trace/">9. ServiceEntry</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-store-trace/">10. ServiceReference</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-store-trace/">11. Segment</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-store-trace/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>分布式链路追踪系统，链路的追踪大体流程如下：</p><ol><li>Agent 收集 Trace 数据。</li><li>Agent 发送 Trace 数据给 Collector 。</li><li>Collector 接收 Trace 数据。</li><li><strong>Collector 存储 Trace 数据到存储器，例如，数据库</strong>。</li></ol><p>本文主要分享【第四部分】 <strong>SkyWalking Collector 存储 Trace 数据</strong>。</p><blockquote><p>友情提示：Collector 接收到 TraceSegment 的数据，对应的类是 Protobuf 生成的。考虑到更加易读易懂，本文使用 TraceSegment 相关的<strong>原始类</strong>。</p></blockquote><p>Collector 在接收到 Trace 数据后，经过<strong>流式处理</strong>，最终<strong>存储</strong>到存储器。如下图，<strong>红圈部分</strong>，为本文分享的内容：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_15/01.jpeg" alt=""></p><h1 id="2-SpanListener"><a href="#2-SpanListener" class="headerlink" title="2. SpanListener"></a>2. SpanListener</h1><p>在 <a href="http://www.iocoder.cn/SkyWalking/collector-receive-trace/">《SkyWalking 源码分析 —— Collector 接收 Trace 数据》</a> 一文中，我们看到 <a href="https://github.com/YunaiV/skywalking/blob/428190e783d887c8240546f321e76e0a6b5f5d18/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/SegmentParse.java#L86" rel="external nofollow noopener noreferrer" target="_blank"><code>SegmentParse#parse(UpstreamSegment, Source)</code></a> 方法中：</p><ul><li>在 <a href="https://github.com/YunaiV/skywalking/blob/428190e783d887c8240546f321e76e0a6b5f5d18/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/SegmentParse.java#L118" rel="external nofollow noopener noreferrer" target="_blank"><code>#preBuild(List&lt;UniqueId&gt;, SegmentDecorator)</code></a> 方法中，预构建的过程中，使用 Span 监听器们，从 TraceSegment 解析出不同的数据。</li><li>在<strong>预构建</strong>成功后，通知 Span 监听器们，去构建各自的数据，经过<strong>流式处理</strong>，最终<strong>存储</strong>到存储器。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/52e41bc200857d2eb1b285d046cb9d2dd646fb7b/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/SpanListener.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.parser.SpanListener</code></a> ，Span 监听器<strong>接口</strong>。</p><ul><li>定义了 <a href="https://github.com/YunaiV/skywalking/blob/52e41bc200857d2eb1b285d046cb9d2dd646fb7b/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/SpanListener.java#L28" rel="external nofollow noopener noreferrer" target="_blank"><code>#build()</code></a> 方法，构建数据，执行流式处理，最终存储到存储器。</li></ul><p>SpanListener 的子类如下图：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_15/02.png" alt=""></p><ul><li>第一层，通用接口层，定义了从 TraceSegment 解析数据的方法。<ul><li>① <a href="https://github.com/YunaiV/skywalking/blob/52e41bc200857d2eb1b285d046cb9d2dd646fb7b/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/GlobalTraceIdsListener.java" rel="external nofollow noopener noreferrer" target="_blank">GlobalTraceSpanListener</a> ：解析链路追踪全局编号数组( <code>TraceSegment.relatedGlobalTraces</code> )。</li><li>② <a href="https://github.com/YunaiV/skywalking/blob/52e41bc200857d2eb1b285d046cb9d2dd646fb7b/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/RefsListener.java" rel="external nofollow noopener noreferrer" target="_blank">RefsListener</a> ：解析父 Segment 指向数组( <code>TraceSegment.refs</code> )。</li><li>③ <a href="https://github.com/YunaiV/skywalking/blob/52e41bc200857d2eb1b285d046cb9d2dd646fb7b/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/FirstSpanListener.java" rel="external nofollow noopener noreferrer" target="_blank">FirstSpanListener</a> ：解析<strong>第一个</strong> Span (<code>TraceSegment.spans[0]</code>) 。</li><li>③ <a href="https://github.com/YunaiV/skywalking/blob/52e41bc200857d2eb1b285d046cb9d2dd646fb7b/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/EntrySpanListener.java" rel="external nofollow noopener noreferrer" target="_blank">EntrySpanListener</a> ：解析 EntrySpan (<code>TraceSegment.spans</code>)。</li><li>③ <a href="https://github.com/YunaiV/skywalking/blob/52e41bc200857d2eb1b285d046cb9d2dd646fb7b/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/LocalSpanListener.java" rel="external nofollow noopener noreferrer" target="_blank">LocalSpanListener</a> ：解析 LocalSpan (<code>TraceSegment.spans</code>)。</li><li>③ <a href="https://github.com/YunaiV/skywalking/blob/52e41bc200857d2eb1b285d046cb9d2dd646fb7b/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/ExitSpanListener.java" rel="external nofollow noopener noreferrer" target="_blank">ExitSpanListener</a> ：解析 ExitSpan (<code>TraceSegment.spans</code>)。</li></ul></li><li>第二层，业务实现层，每个实现类对应一个数据实体类，一个 Graph 对象。如下图所示：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_15/03.png" alt=""></li></ul><p>下面，我们以每个数据实体类为中心，逐个分享。</p><h1 id="3-GlobalTrace"><a href="#3-GlobalTrace" class="headerlink" title="3. GlobalTrace"></a>3. GlobalTrace</h1><p><a href="https://github.com/YunaiV/skywalking/blob/3d1d1f5219205d38f58f1b59f0e81d81c038d2f1/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/global/GlobalTrace.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.global.GlobalTrace</code></a> ，全局链路追踪，记录一次分布式链路追踪，包括的 TraceSegment 编号。</p><ul><li>GlobalTrace : TraceSegment = N : M ，一个 GlobalTrace 可以有多个 TraceSegment ，一个 TraceSegment 可以关联多个 GlobalTrace 。参见 <a href="http://www.iocoder.cn/SkyWalking/agent-collect-trace/?self">《SkyWalking 源码分析 —— Agent 收集 Trace 数据》「2. Trace」</a> 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/3d1d1f5219205d38f58f1b59f0e81d81c038d2f1/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/global/GlobalTraceTable.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.global.GlobalTraceTable</code></a> ， GlobalTrace 表( <code>global_trace</code> )。字段如下：<ul><li><code>global_trace_id</code> ：全局链路追踪编号。</li><li><code>segment_id</code> ：TraceSegment 链路编号。</li><li><code>time_bucket</code> ：时间。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/3d1d1f5219205d38f58f1b59f0e81d81c038d2f1/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/GlobalTraceEsPersistenceDAO.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.es.dao.GlobalTraceEsPersistenceDAO</code></a> ，GlobalTrace 的 EsDAO 。</li><li>在 ES 存储例子如下图： <img src="http://www.iocoder.cn/images/SkyWalking/2020_10_15/04.png" alt=""></li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/3d1d1f5219205d38f58f1b59f0e81d81c038d2f1/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/global/GlobalTraceSpanListener.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.trace.global.GlobalTraceSpanListener</code></a> ，<strong>GlobalTrace 的 SpanListener</strong> ，实现了 FirstSpanListener 、GlobalTraceIdsListener 接口，代码如下：</p><ul><li><code>globalTraceIds</code> 属性，全局链路追踪编号<strong>数组</strong>。</li><li><code>segmentId</code> 属性，TraceSegment 链路编号。</li><li><code>timeBucket</code> 属性，时间。</li><li><a href="https://github.com/YunaiV/skywalking/blob/3d1d1f5219205d38f58f1b59f0e81d81c038d2f1/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/global/GlobalTraceSpanListener.java#L60" rel="external nofollow noopener noreferrer" target="_blank"><code>#parseFirst(SpanDecorator, applicationId, instanceId, segmentId)</code></a> 方法，从 Span 中解析到 <code>segmentId</code> ，<code>timeBucket</code> 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/3d1d1f5219205d38f58f1b59f0e81d81c038d2f1/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/global/GlobalTraceSpanListener.java#L66" rel="external nofollow noopener noreferrer" target="_blank"><code>#parseGlobalTraceId(UniqueId)</code></a> 方法，解析全局链路追踪编号，添加到 <code>globalTraceIds</code> 数组。</li><li><a href="https://github.com/YunaiV/skywalking/blob/3d1d1f5219205d38f58f1b59f0e81d81c038d2f1/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/global/GlobalTraceSpanListener.java#L80" rel="external nofollow noopener noreferrer" target="_blank"><code>#build()</code></a> 方法，构建，代码如下：<ul><li>第 84 行：获取 GlobalTrace 对应的 <code>Graph&lt;GlobalTrace&gt;</code> 对象。</li><li>第 86 至 92 行：循环 <code>globalTraceIds</code> 数组，创建 GlobalTrace 对象，逐个调用 <code>Graph#start(application)</code> 方法，进行流式处理。在这过程中，会保存 GlobalTrace 到存储器。 </li></ul></li></ul><hr><p>在 <a href="https://github.com/YunaiV/skywalking/blob/52e41bc200857d2eb1b285d046cb9d2dd646fb7b/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/graph/TraceStreamGraph.java#L93" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceStreamGraph#createGlobalTraceGraph()</code></a> 方法中，我们可以看到 GlobalTrace 对应的 <code>Graph&lt;GlobalTrace&gt;</code> 对象的创建。</p><ul><li><p><a href="https://github.com/YunaiV/skywalking/blob/52e41bc200857d2eb1b285d046cb9d2dd646fb7b/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/global/GlobalTracePersistenceWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.trace.global.GlobalTracePersistenceWorker</code></a> ，继承 PersistenceWorker 抽象类，GlobalTrace <strong>批量</strong>保存 Worker 。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/52e41bc200857d2eb1b285d046cb9d2dd646fb7b/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/global/GlobalTracePersistenceWorker.java#L51" rel="external nofollow noopener noreferrer" target="_blank">Factory</a> 内部类，实现 AbstractLocalAsyncWorkerProvider 抽象类，在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（一）》「3.2.2 AbstractLocalAsyncWorker」</a> 有详细解析。</li><li><strong>PersistenceWorker</strong> ，在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（二）》「4. PersistenceWorker」</a> 有详细解析。</li><li><a href="https://github.com/YunaiV/skywalking/blob/52e41bc200857d2eb1b285d046cb9d2dd646fb7b/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/global/GlobalTracePersistenceWorker.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>#id()</code></a> 实现方法，返回 120 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/52e41bc200857d2eb1b285d046cb9d2dd646fb7b/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/global/GlobalTracePersistenceWorker.java#L43" rel="external nofollow noopener noreferrer" target="_blank"><code>#needMergeDBData()</code></a> 实现方法，返回 <code>false</code> ，存储时，不需要合并数据。GlobalTrace 只有新增操作，没有更新操作，因此无需合并数据。</li></ul></li></ul><h1 id="4-InstPerformance"><a href="#4-InstPerformance" class="headerlink" title="4. InstPerformance"></a>4. InstPerformance</h1><blockquote><p>旁白君：InstPerformance 和 GlobalTrace 整体比较相似，分享的会比较简洁一些。</p></blockquote><p><a href="https://github.com/YunaiV/skywalking/blob/0f8c38a8a35cbda777fa9a9bc5f51c8651ae4051/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/instance/InstPerformance.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.instance.InstPerformance</code></a> ，应用实例性能，记录应用实例<strong>每秒</strong>的请求总次数，请求总时长。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/0f8c38a8a35cbda777fa9a9bc5f51c8651ae4051/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/instance/InstPerformanceTable.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.instance.InstPerformanceTable</code></a> ， GlobalTrace 表( <code>global_trace</code> )。字段如下：<ul><li><code>application_id</code> ：应用编号。</li><li><code>instance_id</code> ：应用实例编号。</li><li><code>calls</code> ：调用总次数。</li><li><code>cost_total</code> ：消耗总时长。</li><li><code>time_bucket</code> ：时间。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/3d1d1f5219205d38f58f1b59f0e81d81c038d2f1/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/InstPerformanceEsPersistenceDAO.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.es.dao.InstPerformanceEsPersistenceDAO</code></a> ，InstPerformance 的 EsDAO 。</li><li>在 ES 存储例子如下图：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_15/05.png" alt=""></li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/0f8c38a8a35cbda777fa9a9bc5f51c8651ae4051/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/instance/InstPerformanceSpanListener.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.trace.instance.InstPerformanceSpanListener</code></a> ，<strong>InstPerformance 的 SpanListener</strong> ，实现了 FirstSpanListener 、EntrySpanListener 接口。</p><hr><p>在 <a href="https://github.com/YunaiV/skywalking/blob/52e41bc200857d2eb1b285d046cb9d2dd646fb7b/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/graph/TraceStreamGraph.java#L101" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceStreamGraph#createInstPerformanceGraph()</code></a> 方法中，我们可以看到 InstPerformance 对应的 <code>Graph&lt;InstPerformance&gt;</code> 对象的创建。</p><ul><li><p><a href="https://github.com/YunaiV/skywalking/blob/0f8c38a8a35cbda777fa9a9bc5f51c8651ae4051/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/instance/InstPerformancePersistenceWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.trace.instance.InstPerformancePersistenceWorker</code></a> ，继承 PersistenceWorker 抽象类，InstPerformance <strong>批量</strong>保存 Worker 。</p><ul><li>类似 GlobalTracePersistenceWorker ，… 省略其它类和方法。</li><li><a href="https://github.com/YunaiV/skywalking/blob/0f8c38a8a35cbda777fa9a9bc5f51c8651ae4051/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/instance/InstPerformancePersistenceWorker.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#needMergeDBData()</code></a> 实现方法，返回 <code>true</code> ，存储时，需要合并数据。<code>calls</code> 、<code>cost_total</code> 需要累加合并。</li></ul></li></ul><h1 id="5-SegmentCost"><a href="#5-SegmentCost" class="headerlink" title="5. SegmentCost"></a>5. SegmentCost</h1><blockquote><p>旁白君：SegmentCost 和 GlobalTrace 整体比较相似，分享的会比较简洁一些。</p></blockquote><p><a href="https://github.com/YunaiV/skywalking/blob/b8be916ac2bf7817544d6ff77a95a624bcc3efe6/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/segment/SegmentCost.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.segment.SegmentCost</code></a> ，TraceSegment 消耗时长，记录 TraceSegment 开始时间，结束时间，花费时长等等。</p><ul><li>SegmentCost : TraceSegment = 1 : 1 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/b8be916ac2bf7817544d6ff77a95a624bcc3efe6/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/segment/SegmentCostTable.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.instance.SegmentCostTable</code></a> ， SegmentCostTable 表( <code>segment_cost</code> )。字段如下：<ul><li><code>segment_id</code> ：TraceSegment 编号。</li><li><code>application_id</code> ：应用编号。</li><li><code>start_time</code> ：开始时间。</li><li><code>end_time</code> ：结束时间。</li><li><code>service_name</code> ：操作名。</li><li><code>cost</code> ：消耗时长。</li><li><code>time_bucket</code> ：时间( <code>yyyyMMddHHmm</code> )。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/3d1d1f5219205d38f58f1b59f0e81d81c038d2f1/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/SegmentCostEsPersistenceDAO.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.es.dao.SegmentCostEsPersistenceDAO</code></a> ，SegmentCost 的 EsDAO 。</li><li>在 ES 存储例子如下图：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_15/06.png" alt=""></li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/3d1d1f5219205d38f58f1b59f0e81d81c038d2f1/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/segment/SegmentCostSpanListener.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.trace.segment.SegmentCostSpanListener</code></a> ，<strong>SegmentCost 的 SpanListener</strong> ，实现了 FirstSpanListener 、EntrySpanListener 、ExitSpanListener 、LocalSpanListener 接口。</p><hr><p>在 <a href="https://github.com/YunaiV/skywalking/blob/52e41bc200857d2eb1b285d046cb9d2dd646fb7b/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/graph/TraceStreamGraph.java#L172" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceStreamGraph#createSegmentCostGraph()</code></a> 方法中，我们可以看到 SegmentCost 对应的 <code>Graph&lt;SegmentCost&gt;</code> 对象的创建。</p><ul><li><p><a href="https://github.com/YunaiV/skywalking/blob/b8be916ac2bf7817544d6ff77a95a624bcc3efe6/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/segment/SegmentCostPersistenceWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.trace.segment.SegmentCostPersistenceWorker</code></a> ，继承 PersistenceWorker 抽象类，InstPerformance <strong>批量</strong>保存 Worker 。</p><ul><li>类似 GlobalTracePersistenceWorker ，… 省略其它类和方法。</li></ul></li></ul><h1 id="6-NodeComponent"><a href="#6-NodeComponent" class="headerlink" title="6. NodeComponent"></a>6. NodeComponent</h1><p><a href="https://github.com/YunaiV/skywalking/blob/297c693e9e91200860a147ca41473f68d48d5955/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/node/NodeComponent.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.node.NodeComponent</code></a> ，节点组件。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/297c693e9e91200860a147ca41473f68d48d5955/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/node/NodeComponentTable.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.node.NodeComponentTable</code></a> ， NodeComponentTable 表( <code>node_component</code> )。字段如下：<ul><li><code>component_id</code> ：组件编号，参见 <a href="https://github.com/YunaiV/skywalking/blob/0f8c38a8a35cbda777fa9a9bc5f51c8651ae4051/apm-network/src/main/java/org/skywalking/apm/network/trace/component/ComponentsDefine.java" rel="external nofollow noopener noreferrer" target="_blank">ComponentsDefine</a> 的枚举。</li><li><code>peer_id</code> ：对等编号。每个组件，或是服务提供者，有服务地址；又或是服务消费者，有调用服务地址。这两者都脱离不开<strong>服务地址</strong>。SkyWalking 将<strong>服务地址</strong>作为 <code>applicationCode</code> ，注册到 Application 。因此，此处的 <code>peer_id</code> 实际上是，<strong>服务地址</strong>对应的应用编号。</li><li><code>time_bucket</code> ：时间( <code>yyyyMMddHHmm</code> )。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/3d1d1f5219205d38f58f1b59f0e81d81c038d2f1/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/NodeComponentEsPersistenceDAO.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.es.dao.NodeComponentEsPersistenceDAO</code></a> ，NodeComponent 的 EsDAO 。</li><li>在 ES 存储例子如下图：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_15/07.png" alt=""></li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/297c693e9e91200860a147ca41473f68d48d5955/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/node/NodeComponentSpanListener.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.trace.node.NodeComponentSpanListener</code></a> ，<strong>NodeComponent 的 SpanListener</strong> ，实现了 FirstSpanListener 、EntrySpanListener 、ExitSpanListener 接口，代码如下：</p><ul><li><code>nodeComponents</code> 属性，节点组件<strong>数组</strong>，一次 TraceSegment 可以经过个节点组件，例如 SpringMVC =&gt; MongoDB 。</li><li><code>segmentId</code> 属性，TraceSegment 链路编号。</li><li><code>timeBucket</code> 属性，时间( <code>yyyyMMddHHmm</code> )。</li><li><a href="https://github.com/YunaiV/skywalking/blob/297c693e9e91200860a147ca41473f68d48d5955/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/node/NodeComponentSpanListener.java#L65" rel="external nofollow noopener noreferrer" target="_blank"><code>#parseEntry(SpanDecorator, applicationId, instanceId, segmentId)</code></a> 方法，从 EntrySpan 中解析到 <code>segmentId</code> ，<code>applicationId</code> ，创建 NodeComponent 对象，添加到 <code>nodeComponents</code> 。<strong>注意</strong>，EntrySpan 使用 <code>applicationId</code> 作为 <code>peerId</code> 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/297c693e9e91200860a147ca41473f68d48d5955/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/node/NodeComponentSpanListener.java#L53" rel="external nofollow noopener noreferrer" target="_blank"><code>#parseExit(SpanDecorator, applicationId, instanceId, segmentId)</code></a> 方法，从 ExitSpan 中解析到 <code>segmentId</code> ，<code>peerId</code> ，创建 NodeComponent 对象，添加到 <code>nodeComponents</code> 。<strong>注意</strong>，ExitSpan 使用 <code>peerId</code> 作为 <code>peerId</code> 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/297c693e9e91200860a147ca41473f68d48d5955/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/node/NodeComponentSpanListener.java#L78" rel="external nofollow noopener noreferrer" target="_blank"><code>#parseFirst(SpanDecorator, applicationId, instanceId, segmentId)</code></a> 方法，从<strong>首个</strong> Span 中解析到 <code>timeBucket</code> 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/297c693e9e91200860a147ca41473f68d48d5955/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/node/NodeComponentSpanListener.java#L83" rel="external nofollow noopener noreferrer" target="_blank"><code>#build()</code></a> 方法，构建，代码如下：<ul><li>第 84 行：获取 NodeComponent 对应的 <code>Graph&lt;NodeComponent&gt;</code> 对象。</li><li>第 86 至 92 行：循环 <code>nodeComponents</code> 数组，逐个调用 <code>Graph#start(nodeComponent)</code> 方法，进行流式处理。在这过程中，会保存 NodeComponent 到存储器。 </li></ul></li></ul><hr><p>在 <a href="https://github.com/YunaiV/skywalking/blob/52e41bc200857d2eb1b285d046cb9d2dd646fb7b/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/graph/TraceStreamGraph.java#L109" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceStreamGraph#createNodeComponentGraph()</code></a> 方法中，我们可以看到 NodeComponent 对应的 <code>Graph&lt;NodeComponent&gt;</code> 对象的创建。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/52e41bc200857d2eb1b285d046cb9d2dd646fb7b/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/service/ServiceEntryAggregationWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.trace.node.NodeComponentAggregationWorker</code></a> ，继承 AggregationWorker 抽象类，NodeComponent 聚合 Worker 。<ul><li>NodeComponent 的编号生成规则为 <code>${timeBucket}_${componentId}_${peerId}</code> ，并且 <code>timeBucket</code> 是<strong>分钟级</strong> ，可以使用 AggregationWorker 进行聚合，合并相同操作，减小 Collector 和 ES 的压力。</li><li><a href="https://github.com/YunaiV/skywalking/blob/52e41bc200857d2eb1b285d046cb9d2dd646fb7b/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/service/ServiceEntryAggregationWorker.java#L40" rel="external nofollow noopener noreferrer" target="_blank">Factory</a> 内部类，实现 AbstractLocalAsyncWorkerProvider 抽象类，在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（一）》「3.2.2 AbstractLocalAsyncWorker」</a> 有详细解析。</li><li><strong>AggregationWorker</strong> ，在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（二）》「3. AggregationWorker」</a> 有详细解析。</li><li><a href="https://github.com/YunaiV/skywalking/blob/52e41bc200857d2eb1b285d046cb9d2dd646fb7b/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/service/ServiceEntryAggregationWorker.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><code>#id()</code></a> 实现方法，返回 106 。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/52e41bc200857d2eb1b285d046cb9d2dd646fb7b/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/service/ServiceEntryRemoteWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.trace.service.ServiceEntryRemoteWorker</code></a> ，继承 AbstractRemoteWorker 抽象类，应用注册远程 Worker 。<ul><li><a href="https://github.com/YunaiV/skywalking/blob/52e41bc200857d2eb1b285d046cb9d2dd646fb7b/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/service/ServiceEntryRemoteWorker.java#L50" rel="external nofollow noopener noreferrer" target="_blank">Factory</a> 内部类，实现 AbstractRemoteWorkerProvider 抽象类，在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（一）》「3.2.3 AbstractRemoteWorker」</a> 有详细解析。</li><li><strong>AbstractRemoteWorker</strong> ，在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（一）》「3.2.3 AbstractRemoteWorker」</a> 有详细解析。</li><li><a href="https://github.com/YunaiV/skywalking/blob/52e41bc200857d2eb1b285d046cb9d2dd646fb7b/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/service/ServiceEntryRemoteWorker.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>#id()</code></a> 实现方法，返回 10002 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/52e41bc200857d2eb1b285d046cb9d2dd646fb7b/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/service/ServiceEntryRemoteWorker.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#selector</code></a> 实现方法，返回 <code>Selector.HashCode</code> 。将<strong>相同编号</strong>的 NodeComponent 发给同一个 Collector 节点，统一处理。在 <a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/?self">《SkyWalking 源码分析 —— Collector Remote 远程通信服务》</a> 有详细解析。</li></ul></li><li><p><a href="https://github.com/YunaiV/skywalking/blob/52e41bc200857d2eb1b285d046cb9d2dd646fb7b/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/service/ServiceEntryPersistenceWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.trace.service.ServiceEntryPersistenceWorker</code></a> ，继承 PersistenceWorker 抽象类，NodeComponent <strong>批量</strong>保存 Worker 。</p><ul><li>类似 GlobalTracePersistenceWorker ，… 省略其它类和方法。</li><li><a href="https://github.com/YunaiV/skywalking/blob/52e41bc200857d2eb1b285d046cb9d2dd646fb7b/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/service/ServiceEntryPersistenceWorker.java#L43" rel="external nofollow noopener noreferrer" target="_blank"><code>#needMergeDBData()</code></a> 实现方法，返回 <code>true</code> ，存储时，需要合并数据。</li></ul></li></ul><h1 id="7-NodeMapping"><a href="#7-NodeMapping" class="headerlink" title="7. NodeMapping"></a>7. NodeMapping</h1><p><a href="https://github.com/YunaiV/skywalking/blob/ee9400fc51d6ae21b1053bb0d8cca7ad4d51efe5/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/node/NodeComponent.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.node.NodeComponent</code></a> ，节点匹配，用于匹配服务消费者与提供者。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/ee9400fc51d6ae21b1053bb0d8cca7ad4d51efe5/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/node/NodeMappingTable.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.node.NodeMappingTable</code></a> ， NodeMappingTable 表( <code>node_mapping</code> )。字段如下：<ul><li><code>application_id</code> ：服务消费者应用编号。</li><li><code>address_id</code> ：服务提供者应用编号。</li><li><code>time_bucket</code> ：时间( <code>yyyyMMddHHmm</code> )。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/3d1d1f5219205d38f58f1b59f0e81d81c038d2f1/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/NodeMappingEsPersistenceDAO.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.es.dao.NodeMappingEsPersistenceDAO</code></a> ，NodeMapping 的 EsDAO 。</li><li>在 ES 存储例子如下图：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_15/08.png" alt=""></li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/ee9400fc51d6ae21b1053bb0d8cca7ad4d51efe5/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/node/NodeMappingSpanListener.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.trace.node.NodeMappingSpanListener</code></a> ，<strong>NodeMapping 的 SpanListener</strong> ，实现了 FirstSpanListener 、RefsListener 接口，代码如下：</p><ul><li><code>nodeMappings</code> 属性，节点匹配<strong>数组</strong>，一次 TraceSegment 可以经过个节点组件，例如调用多次远程服务，或者数据库。</li><li><code>timeBucket</code> 属性，时间( <code>yyyyMMddHHmm</code> )。</li><li><a href="https://github.com/YunaiV/skywalking/blob/ee9400fc51d6ae21b1053bb0d8cca7ad4d51efe5/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/node/NodeMappingSpanListener.java#L52" rel="external nofollow noopener noreferrer" target="_blank"><code>#parseRef(SpanDecorator, applicationId, instanceId, segmentId)</code></a> 方法，从 TraceSegmentRef 中解析到 <code>applicationId</code> ，<code>peerId</code> ，创建 NodeMapping 对象，添加到 <code>nodeMappings</code> 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/ee9400fc51d6ae21b1053bb0d8cca7ad4d51efe5/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/node/NodeMappingSpanListener.java#L66" rel="external nofollow noopener noreferrer" target="_blank"><code>#parseFirst(SpanDecorator, applicationId, instanceId, segmentId)</code></a> 方法，从<strong>首个</strong> Span 中解析到<code>timeBucket</code> 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/ee9400fc51d6ae21b1053bb0d8cca7ad4d51efe5/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/node/NodeMappingSpanListener.java#L71" rel="external nofollow noopener noreferrer" target="_blank"><code>#build()</code></a> 方法，构建，代码如下：<ul><li>第 84 行：获取 NodeMapping 对应的 <code>Graph&lt;NodeMapping&gt;</code> 对象。</li><li>第 86 至 92 行：循环 <code>nodeMappings</code> 数组，逐个调用 <code>Graph#start(nodeMapping)</code> 方法，进行流式处理。在这过程中，会保存 NodeMapping 到存储器。 </li></ul></li></ul><hr><p>在 <a href="https://github.com/YunaiV/skywalking/blob/52e41bc200857d2eb1b285d046cb9d2dd646fb7b/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/graph/TraceStreamGraph.java#L120" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceStreamGraph#createNodeMappingGraph()</code></a> 方法中，我们可以看到 NodeMapping 对应的 <code>Graph&lt;NodeMapping&gt;</code> 对象的创建。</p><ul><li>和 NodeComponent 的 <code>Graph&lt;NodeComponent&gt;</code> 基本一致，胖友自己看下源码。</li><li><a href="https://github.com/YunaiV/skywalking/blob/ee9400fc51d6ae21b1053bb0d8cca7ad4d51efe5/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/node/NodeMappingAggregationWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.trace.node.NodeMappingAggregationWorker</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/ee9400fc51d6ae21b1053bb0d8cca7ad4d51efe5/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/node/NodeMappingRemoteWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.trace.node.NodeMappingRemoteWorker</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/ee9400fc51d6ae21b1053bb0d8cca7ad4d51efe5/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/node/NodeMappingPersistenceWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.trace.node.NodeMappingPersistenceWorker</code></a></li></ul><h1 id="8-NodeReference"><a href="#8-NodeReference" class="headerlink" title="8. NodeReference"></a>8. NodeReference</h1><p><a href="https://github.com/YunaiV/skywalking/blob/112bcba1a7543e3c86fcbfb49718f7e4f3f4638f/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/noderef/NodeReference.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.noderef.NodeReference</code></a> ，节点调用统计，用于记录服务消费者对服务提供者的调用，基于<strong>应用</strong>级别的，以<strong>分钟</strong>为时间最小粒度的聚合统计。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/112bcba1a7543e3c86fcbfb49718f7e4f3f4638f/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/noderef/NodeReferenceTable.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.noderef.NodeReference</code></a> ， NodeReference 表( <code>node_reference</code> )。字段如下：<ul><li><code>front_application_id</code> ：服务消费者应用编号。</li><li><code>behind_application_id</code> ：服务提供者应用编号。</li><li><code>s1_lte</code> ：( 0, 1000 ms ] 的调用次数。</li><li><code>s3_lte</code> ：( 1000, 3000 ms ] 的调用次数。</li><li><code>s5_lte</code> ：( 3000, 5000ms ] 的调用次数</li><li><code>s5_gt</code> ：( 5000, +∞ ] 的调用次数。</li><li><code>error</code> ：发生异常的调用次数。</li><li><code>summary</code> ：总共的调用次数。</li><li><code>time_bucket</code> ：时间( <code>yyyyMMddHHmm</code> )。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/3d1d1f5219205d38f58f1b59f0e81d81c038d2f1/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/NodeReferenceEsPersistenceDAO.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.es.dao.NodeReferenceEsPersistenceDAO</code></a> ，NodeReference 的 EsDAO 。</li><li>在 ES 存储例子如下图：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_15/09.png" alt=""></li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/112bcba1a7543e3c86fcbfb49718f7e4f3f4638f/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/noderef/NodeReferenceSpanListener.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.trace.noderef.NodeReferenceSpanListener</code></a> ，<strong>NodeReference 的 SpanListener</strong> ，实现了 EntrySpanListener 、ExitSpanListener 、RefsListener 接口，代码如下：</p><ul><li><code>references</code> 属性，<strong>父 TraceSegment</strong> 调用产生的 NodeReference 数组。</li><li><code>nodeReferences</code> 属性，NodeReference 数组，最终会包含 <code>references</code> 数组。</li><li><code>timeBucket</code> 属性，时间( <code>yyyyMMddHHmm</code> )。</li><li><a href="https://github.com/YunaiV/skywalking/blob/112bcba1a7543e3c86fcbfb49718f7e4f3f4638f/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/noderef/NodeReferenceSpanListener.java#L103" rel="external nofollow noopener noreferrer" target="_blank"><code>#parseRef(SpanDecorator, applicationId, instanceId, segmentId)</code></a> 方法，代码如下：<ul><li>第 106 至 109 行：使用父 TraceSegment 的应用编号作为服务<strong>消费者</strong>编号，自己的应用编号作为服务<strong>提供者</strong>应用编号，创建 NodeReference 对象。</li><li>第 111 行：将 NodeReference 对象，添加到 <code>references</code> 。<strong>注意</strong>，是 <code>references</code> ，而不是 <code>nodeReference</code> 。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/112bcba1a7543e3c86fcbfb49718f7e4f3f4638f/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/noderef/NodeReferenceSpanListener.java#L77" rel="external nofollow noopener noreferrer" target="_blank"><code>#parseEntry(SpanDecorator, applicationId, instanceId, segmentId)</code></a> 方法，代码如下：<ul><li>作为服务提供者，<strong>接受</strong>调用。 </li><li>——- <strong>父 TraceSegment 存在</strong> ——– </li><li>第 79 至 85 行：<code>references</code> 非空，说明被父 TraceSegment 调用。因此，循环 <code>references</code> 数组，设置 <code>id</code> ，<code>timeBucket</code> 属性( 因为 <code>timeBucket</code> 需要从 EntrySpan 中获取，所以 <code>#parseRef(...)</code> 的目的，就是临时存储父 TraceSegment 的应用编号到 <code>references</code> 中 )。 </li><li>第 87 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/112bcba1a7543e3c86fcbfb49718f7e4f3f4638f/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/noderef/NodeReferenceSpanListener.java#L122" rel="external nofollow noopener noreferrer" target="_blank"><code>#buildserviceSum(...)</code></a> 方法，设置调用次数，然后添加到 <code>nodeReferences</code> 中。</li><li>——- <strong>父 TraceSegment 不存在</strong> ——– </li><li>第 91 至 97 行：使用 <code>USER_ID</code> 的应用编号( 特殊，代表 “<strong>用户</strong>“ )作为服务<strong>消费者</strong>编号，自己的应用编号作为服务<strong>提供者</strong>应用编号，创建 NodeReference 对象。</li><li>第 99 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/112bcba1a7543e3c86fcbfb49718f7e4f3f4638f/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/noderef/NodeReferenceSpanListener.java#L122" rel="external nofollow noopener noreferrer" target="_blank"><code>#buildserviceSum(...)</code></a> 方法，设置调用次数，然后添加到 <code>nodeReferences</code> 中。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/112bcba1a7543e3c86fcbfb49718f7e4f3f4638f/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/noderef/NodeReferenceSpanListener.java#L62" rel="external nofollow noopener noreferrer" target="_blank"><code>#parseExit(SpanDecorator, applicationId, instanceId, segmentId)</code></a> 方法，代码如下：<ul><li>作为服务消费者，<strong>发起</strong>调用。  </li><li>第 64 至 71 行：使用自己的应用编号作为服务<strong>消费者</strong>编号，<code>peerId</code> 作为服务<strong>提供者</strong>应用编号，创建 NodeReference 对象。</li><li>第 73 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/112bcba1a7543e3c86fcbfb49718f7e4f3f4638f/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/noderef/NodeReferenceSpanListener.java#L122" rel="external nofollow noopener noreferrer" target="_blank"><code>#buildserviceSum(...)</code></a> 方法，设置调用次数，然后添加到 <code>nodeReferences</code> 中。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/112bcba1a7543e3c86fcbfb49718f7e4f3f4638f/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/noderef/NodeReferenceSpanListener.java#L114" rel="external nofollow noopener noreferrer" target="_blank"><code>#build()</code></a> 方法，构建，代码如下：<ul><li>第 84 行：获取 NodeReference 对应的 <code>Graph&lt;NodeReference&gt;</code> 对象。</li><li>第 86 至 92 行：循环 <code>nodeReferences</code> 数组，逐个调用 <code>Graph#start(nodeReference)</code> 方法，进行流式处理。在这过程中，会保存 NodeReference 到存储器。</li></ul></li></ul><hr><p>在 <a href="https://github.com/YunaiV/skywalking/blob/52e41bc200857d2eb1b285d046cb9d2dd646fb7b/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/graph/TraceStreamGraph.java#L131" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceStreamGraph#createNodeReferenceGraph()</code></a> 方法中，我们可以看到 NodeReference 对应的 <code>Graph&lt;NodeReference&gt;</code> 对象的创建。</p><ul><li>和 NodeComponent 的 <code>Graph&lt;NodeComponent&gt;</code> 基本一致，胖友自己看下源码。</li><li><a href="https://github.com/YunaiV/skywalking/blob/ee9400fc51d6ae21b1053bb0d8cca7ad4d51efe5/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/noderef/NodeReferenceAggregationWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.trace.noderef.NodeReferenceAggregationWorker</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/ee9400fc51d6ae21b1053bb0d8cca7ad4d51efe5/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/noderef/NodeReferenceRemoteWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.trace.noderef.NodeReferenceRemoteWorker</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/ee9400fc51d6ae21b1053bb0d8cca7ad4d51efe5/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/noderef/NodeReferencePersistenceWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.trace.noderef.NodeReferencePersistenceWorker</code></a></li></ul><h1 id="9-ServiceEntry"><a href="#9-ServiceEntry" class="headerlink" title="9. ServiceEntry"></a>9. ServiceEntry</h1><p><a href="https://github.com/YunaiV/skywalking/blob/d8e7d053381e7317d413188c4248be1dacf4e85a/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/service/ServiceEntry.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.service.ServiceEntry</code></a> ，入口操作。</p><ul><li>ServiceEntry <strong>只保存分布式链路的入口操作</strong>，不同于 ServiceName <strong>保存所有操作</strong>，即 ServiceEntry 是 ServiceName 的<strong>子集</strong>。<ul><li><strong>注意，子 TraceSegment 的入口操作也不记录</strong>。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/d8e7d053381e7317d413188c4248be1dacf4e85a/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/service/ServiceEntryTable.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.service.ServiceEntryTable</code></a> ， ServiceEntry 表( <code>service_entry</code> )。字段如下：<ul><li><code>application_id</code> ：应用编号。</li><li><code>entry_service_id</code> ：入口操作编号。</li><li><code>entry_service_name</code> ：入口操作名。</li><li><code>register_time</code> ：注册时间。</li><li><code>newest_time</code> ：最后调用时间。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/3d1d1f5219205d38f58f1b59f0e81d81c038d2f1/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/ServiceEntryEsPersistenceDAO.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.es.dao.ServiceEntryEsPersistenceDAO</code></a> ，ServiceEntry 的 EsDAO 。</li><li>在 ES 存储例子如下图：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_15/10.png" alt=""></li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/112bcba1a7543e3c86fcbfb49718f7e4f3f4638f/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/service/ServiceEntrySpanListener.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.trace.service.ServiceEntrySpanListener</code></a> ，<strong>ServiceEntry 的 SpanListener</strong> ，实现了 EntrySpanListener 、FirstSpanListener 、RefsListener 接口，代码如下：</p><ul><li><code>hasReference</code> 属性， 是否有 TraceSegmentRef 。</li><li><code>applicationId</code> 属性，应用编号。</li><li><code>entryServiceId</code> 属性，入口操作编号。</li><li><code>entryServiceName</code> 属性，入口操作名。</li><li><code>hasEntry</code> 属性，是否有 EntrySpan 。</li><li><code>timeBucket</code> 属性，时间( <code>yyyyMMddHHmm</code> )。</li><li><a href="https://github.com/YunaiV/skywalking/blob/d8e7d053381e7317d413188c4248be1dacf4e85a/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/service/ServiceEntrySpanListener.java#L75" rel="external nofollow noopener noreferrer" target="_blank"><code>#parseRef(SpanDecorator, applicationId, instanceId, segmentId)</code></a> 方法，是否有 TraceSegmentRef 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/d8e7d053381e7317d413188c4248be1dacf4e85a/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/service/ServiceEntrySpanListener.java#L89" rel="external nofollow noopener noreferrer" target="_blank"><code>#parseFirst(SpanDecorator, applicationId, instanceId, segmentId)</code></a> 方法，从<strong>首个</strong> Span 中解析到 <code>timeBucket</code> 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/d8e7d053381e7317d413188c4248be1dacf4e85a/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/service/ServiceEntrySpanListener.java#L75" rel="external nofollow noopener noreferrer" target="_blank"><code>#parseEntry(SpanDecorator, applicationId, instanceId, segmentId)</code></a> 方法，从 EntrySpan 中解析到 <code>applicationId</code> 、<code>entryServiceId</code> 、<code>entryServiceName</code> 、<code>hasEntry</code> 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/d8e7d053381e7317d413188c4248be1dacf4e85a/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/service/ServiceEntrySpanListener.java#L94" rel="external nofollow noopener noreferrer" target="_blank"><code>#build()</code></a> 方法，构建，代码如下：<ul><li>第 96 行：只保存分布式链路的入口操作。</li><li>第 98 至 103 行：创建 ServiceEntry 对象。</li><li>第 107 行：获取 ServiceEntry 对应的 <code>Graph&lt;ServiceEntry&gt;</code> 对象。</li><li>第 108 行：调用 <code>Graph#start(serviceEntry)</code> 方法，进行流式处理。在这过程中，会保存 ServiceEntry 到存储器。</li></ul></li></ul><hr><p>在 <a href="https://github.com/YunaiV/skywalking/blob/52e41bc200857d2eb1b285d046cb9d2dd646fb7b/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/graph/TraceStreamGraph.java#L142" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceStreamGraph#createServiceEntryGraph()</code></a> 方法中，我们可以看到 ServiceEntry 对应的 <code>Graph&lt;ServiceEntry&gt;</code> 对象的创建。</p><ul><li>和 NodeComponent 的 <code>Graph&lt;NodeComponent&gt;</code> 基本一致，胖友自己看下源码。</li><li><a href="https://github.com/YunaiV/skywalking/blob/ee9400fc51d6ae21b1053bb0d8cca7ad4d51efe5/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/service/ServiceEntryAggregationWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.trace.service.ServiceEntryAggregationWorker</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/ee9400fc51d6ae21b1053bb0d8cca7ad4d51efe5/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/service/ServiceEntryRemoteWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.trace.service.ServiceEntryRemoteWorker</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/ee9400fc51d6ae21b1053bb0d8cca7ad4d51efe5/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/service/ServiceEntryPersistenceWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.trace.service.ServiceEntryPersistenceWorker</code></a></li></ul><h1 id="10-ServiceReference"><a href="#10-ServiceReference" class="headerlink" title="10. ServiceReference"></a>10. ServiceReference</h1><p><a href="https://github.com/YunaiV/skywalking/blob/288d70975ed1c5f1ecfb7d51e2233ec75ad8d12a/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/serviceref/ServiceReference.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.serviceref.ServiceReference</code></a> ，入口操作调用统计，用于记录入口操作的调用，基于<strong>入口操作</strong>级别的，以<strong>分钟</strong>为时间最小粒度的聚合统计。</p><ul><li>和 NodeReference 类似。</li><li><strong>注意</strong>，此处的 “<strong>入口操作</strong>“ 不同于 ServiceEntry ，<strong>包含</strong>每一条 TraceSegment 的入口操作。</li><li><a href="https://github.com/YunaiV/skywalking/blob/288d70975ed1c5f1ecfb7d51e2233ec75ad8d12a/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/serviceref/ServiceReferenceTable.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.serviceref.ServiceReferenceTable</code></a> ， ServiceReference 表( <code>service_reference</code> )。字段如下：<ul><li><code>entry_service_id</code> ：入口操作编号。 </li><li><code>front_service_id</code> ：服务消费者操作编号。</li><li><code>behind_service_id</code> ：服务提供者操作编号。</li><li><code>s1_lte</code> ：( 0, 1000 ms ] 的调用次数。</li><li><code>s3_lte</code> ：( 1000, 3000 ms ] 的调用次数。</li><li><code>s5_lte</code> ：( 3000, 5000ms ] 的调用次数</li><li><code>s5_gt</code> ：( 5000, +∞ ] 的调用次数。</li><li><code>error</code> ：发生异常的调用次数。</li><li><code>summary</code> ：总共的调用次数。</li><li><code>cost_summary</code> ：总共的花费时间。</li><li><code>time_bucket</code> ：时间( <code>yyyyMMddHHmm</code> )。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/3d1d1f5219205d38f58f1b59f0e81d81c038d2f1/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/ServiceReference.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.es.dao.ServiceReference</code></a> ，ServiceReference 的 EsDAO 。</li><li>在 ES 存储例子如下图：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_15/11.png" alt=""></li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/33a9634fff31a299b0baab5ffba603a58d6ff371/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/serviceref/ServiceReferenceSpanListener.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.trace.segment.ServiceReferenceSpanListener</code></a> ，<strong>ServiceReference 的 SpanListener</strong> ，实现了 EntrySpanListener 、FirstSpanListener 、RefsListener 接口，代码如下：</p><ul><li><code>referenceServices</code> 属性，ReferenceDecorator 数组，记录 TraceSegmentRef 数组。</li><li><code>serviceId</code> 属性，入口操作编号。</li><li><code>startTime</code> 属性，开始时间。</li><li><code>endTime</code> 属性，结束时间。</li><li><code>isError</code> 属性，是否有错误。</li><li><code>hasEntry</code> 属性，是否有 SpanEntry 。</li><li><code>timeBucket</code> 属性，时间( <code>yyyyMMddHHmm</code> )。</li><li><a href="https://github.com/YunaiV/skywalking/blob/33a9634fff31a299b0baab5ffba603a58d6ff371/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/serviceref/ServiceReferenceSpanListener.java#L79" rel="external nofollow noopener noreferrer" target="_blank"><code>#parseRef(SpanDecorator, applicationId, instanceId, segmentId)</code></a> 方法，将 TraceSegmentRef 添加到 <code>referenceServices</code> 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/33a9634fff31a299b0baab5ffba603a58d6ff371/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/serviceref/ServiceReferenceSpanListener.java#L74" rel="external nofollow noopener noreferrer" target="_blank"><code>#parseFirst(SpanDecorator, applicationId, instanceId, segmentId)</code></a> 方法，从<strong>首个</strong> Span 中解析到 <code>timeBucket</code> 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/33a9634fff31a299b0baab5ffba603a58d6ff371/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/serviceref/ServiceReferenceSpanListener.java#L85" rel="external nofollow noopener noreferrer" target="_blank"><code>#parseEntry(SpanDecorator, applicationId, instanceId, segmentId)</code></a> 方法，从 EntrySpan 中解析 <code>serviceId</code> 、<code>startTime</code> 、<code>endTime</code> 、<code>isError</code> 、<code>hasEntry</code> 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/33a9634fff31a299b0baab5ffba603a58d6ff371/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/serviceref/ServiceReferenceSpanListener.java#L112" rel="external nofollow noopener noreferrer" target="_blank"><code>#build()</code></a> 方法，构建，代码如下：<ul><li>第 114 行：判断 <code>hasEntry = true</code> ，存在 EntrySpan 。</li><li>——— <strong>有 TraceSegmentRef</strong> ———</li><li>第 117 至 120 行：创建 ServiceReference 对象，其中：<ul><li><code>entryServiceId</code> ：TraceSegmentRef 的入口编号。</li><li><code>frontServiceId</code> ：TraceSegmentRef 的操作编号。</li><li><code>behindServiceId</code> ： 自己 EntrySpan 的操作编号。</li></ul></li><li>第 121 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/33a9634fff31a299b0baab5ffba603a58d6ff371/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/serviceref/ServiceReferenceSpanListener.java#L94" rel="external nofollow noopener noreferrer" target="_blank"><code>#calculateCost(...)</code></a> 方法，设置调用次数。</li><li>第 126 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/33a9634fff31a299b0baab5ffba603a58d6ff371/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/serviceref/ServiceReferenceSpanListener.java#L141" rel="external nofollow noopener noreferrer" target="_blank"><code>#sendToAggregationWorker(...)</code></a> 方法，发送 ServiceReference 给 AggregationWorker ，执行流式处理。</li><li>——— <strong>无 TraceSegmentRef</strong> ———</li><li>第 117 至 120 行：创建 ServiceReference 对象，其中：<ul><li><code>entryServiceId</code> ：自己 EntrySpan 的操作编号。</li><li><code>frontServiceId</code> ：<code>Const.NONE_SERVICE_ID</code> 对应的操作编号( 系统内置，代表【空】 )。</li><li><code>behindServiceId</code> ： 自己 EntrySpan 的操作编号。</li></ul></li><li>第 121 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/33a9634fff31a299b0baab5ffba603a58d6ff371/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/serviceref/ServiceReferenceSpanListener.java#L94" rel="external nofollow noopener noreferrer" target="_blank"><code>#calculateCost(...)</code></a> 方法，设置调用次数。</li><li>第 126 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/33a9634fff31a299b0baab5ffba603a58d6ff371/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/serviceref/ServiceReferenceSpanListener.java#L141" rel="external nofollow noopener noreferrer" target="_blank"><code>#sendToAggregationWorker(...)</code></a> 方法，发送 ServiceReference 给 AggregationWorker ，执行流式处理。</li></ul></li></ul><hr><p>在 <a href="https://github.com/YunaiV/skywalking/blob/52e41bc200857d2eb1b285d046cb9d2dd646fb7b/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/graph/TraceStreamGraph.java#L153" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceStreamGraph#createServiceReferenceGraph()</code></a> 方法中，我们可以看到 ServiceReference 对应的 <code>Graph&lt;ServiceReference&gt;</code> 对象的创建。</p><ul><li>和 NodeComponent 的 <code>Graph&lt;NodeComponent&gt;</code> 基本一致，胖友自己看下源码。</li><li><a href="https://github.com/YunaiV/skywalking/blob/ee9400fc51d6ae21b1053bb0d8cca7ad4d51efe5/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/serviceref/ServiceReferenceAggregationWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.trace.noderef.ServiceEntryAggregationWorker</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/ee9400fc51d6ae21b1053bb0d8cca7ad4d51efe5/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/serviceref/ServiceReferenceRemoteWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.trace.noderef.ServiceEntryRemoteWorker</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/ee9400fc51d6ae21b1053bb0d8cca7ad4d51efe5/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/serviceref/ServiceReferencePersistenceWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.trace.noderef.ServiceEntryPersistenceWorker</code></a></li></ul><h1 id="11-Segment"><a href="#11-Segment" class="headerlink" title="11. Segment"></a>11. Segment</h1><p>不同于上述所有数据实体，Segment 无需<strong>解析</strong>，直接使用 TraceSegment 构建，参见如下方法：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/0f8c38a8a35cbda777fa9a9bc5f51c8651ae4051/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/SegmentParse.java#L109" rel="external nofollow noopener noreferrer" target="_blank"><code>SegmentParse#parse(UpstreamSegment, Source)</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/0f8c38a8a35cbda777fa9a9bc5f51c8651ae4051/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/SegmentParse.java#L177" rel="external nofollow noopener noreferrer" target="_blank"><code>SegmentParse#buildSegment(id, dataBinary)</code></a></li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/3d1d1f5219205d38f58f1b59f0e81d81c038d2f1/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/global/GlobalTrace.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.segment.Segment</code></a> ，全局链路追踪，记录一次分布式链路追踪，包括的 TraceSegment 编号。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/25a830d4fed13ee2d62adb7ad7b35ada436bd6f6/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/segment/Segment.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.global.GlobalTraceTable</code></a> ， Segment 表( <code>segment</code> )。字段如下：<ul><li><code>_id</code> ：TraceSegment 编号。</li><li><code>data_binary</code> ：TraceSegment 链路编号。</li><li><code>time_bucket</code> ：时间( <code>yyyyMMddHHmm</code> )。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/3d1d1f5219205d38f58f1b59f0e81d81c038d2f1/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/SegmentEsPersistenceDAO.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.es.dao.SegmentEsPersistenceDAO</code></a> ，GlobalTrace 的 EsDAO 。</li><li>在 ES 存储例子如下图： <img src="http://www.iocoder.cn/images/SkyWalking/2020_10_15/12.png" alt=""></li></ul><hr><p>在 <a href="https://github.com/YunaiV/skywalking/blob/52e41bc200857d2eb1b285d046cb9d2dd646fb7b/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/graph/TraceStreamGraph.java#L164" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceStreamGraph#createSegmentGraph()</code></a> 方法中，我们可以看到 Segment 对应的 <code>Graph&lt;Segment&gt;</code> 对象的创建。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/ee9400fc51d6ae21b1053bb0d8cca7ad4d51efe5/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/segment/SegmentPersistenceWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.trace.segment.SegmentPersistenceWorker</code></a></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>抱歉，本文可能会存在一些错误或者细节没有扣到，烦请见谅。<br>胖友如果有疑惑，请给我的公众号留言，一起探讨。</p><p>大量类似的内容，笔者一天都处于昏昏沉沉的状态，中间有一块不小心替换错误，实在是苦闷而又几分枯燥，不得不佩服 SkyWalking 开发者的耐心。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_10_15/13.png" alt=""></p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-store-trace/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-store-trace/&lt;/a&gt; 「芋
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector 接收 Trace 数据</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-receive-trace/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-receive-trace/</id>
    <published>2020-10-09T16:00:00.000Z</published>
    <updated>2018-01-04T15:10:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-receive-trace/">http://www.iocoder.cn/SkyWalking/collector-receive-trace/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-receive-trace/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-receive-trace/">2. TraceSegmentServiceHandler</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-receive-trace/">2.1 TraceSegmentService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-receive-trace/">2.2 SegmentParse</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-receive-trace/">2.3 Standardization 标准化</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-receive-trace/">3. Buffer 文件</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-receive-trace/">3.1 初始化</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-receive-trace/">3.2 写入</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-receive-trace/">3.3 读取</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-receive-trace/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>分布式链路追踪系统，链路的追踪大体流程如下：</p><ol><li>Agent 收集 Trace 数据。</li><li>Agent 发送 Trace 数据给 Collector 。</li><li><strong>Collector 接收 Trace 数据</strong>。</li><li>Collector 存储 Trace 数据到存储器，例如，数据库。</li></ol><p>本文主要分享【第三部分】 <strong>SkyWalking Collector 接收 Trace 数据</strong>。</p><blockquote><p>友情提示：Collector 接收到 TraceSegment 的数据，对应的类是 Protobuf 生成的。考虑到更加易读易懂，本文使用 TraceSegment 相关的<strong>原始类</strong>。</p></blockquote><p>大体流程如下：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_10/01.png" alt=""></p><ul><li>Collector 接收到 TraceSegment 数据后，进行<strong>构建</strong>。</li><li>【蓝色流程】构建<strong>成功</strong>，进行流式处理，最终存储到存储器( 例如，ES / H2 )。</li><li>【粉色流程】构建<strong>失败</strong>，写入 Buffer 文件进行暂存。</li><li>【绿色流程】后台线程，定时读取 Buffer 文件，重新提交构建。</li></ul><p><strong>什么是构建</strong>？</p><p>从 TraceSegment <strong>数据</strong>中，会构建出更多的<strong>数据维度</strong>，如下图所示：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_10_10/02.png" alt=""></p><p>构建的过程，本文只分享<strong>调用</strong>的过程，具体怎么<strong>生成</strong>新的数据，数据的<strong>流式处理与存储</strong>，在 <a href="http://www.iocoder.cn/SkyWalking/collector-store-trace/?self">《SkyWalking 源码解析 —— Collector 存储 Trace 数据》</a> 详细解析。</p><p><strong>为什么构建会失败</strong>？</p><p>在 TraceSegment 里的数据结构，例如操作名( <code>operationName</code> )和操作编号( <code>operationId</code> ) ，在 <a href="http://www.iocoder.cn/SkyWalking/agent-collect-trace/?self">《SkyWalking 源码分析 —— Agent 收集 Trace 数据》</a> 中我们可以看到，考虑到网络传输，优先使用 <code>operationId</code> ，若不存在( 例如操作还未注册，或者注册了 Agent 未同步到本地 )，则使用 <code>operationName</code> 。</p><p>但是，Collector 构建过程时，要求的是 <code>operationId</code> ，如果传递的是 <code>operationName</code> 时，需要将 <code>operationName</code> 转换成 <code>operationId</code> 。若此时 <code>operationName</code> 未注册时，则无法获取到 <code>operationId</code> ，导致<strong>构建失败</strong>。</p><p>那么有胖友可能有疑惑，在构建过程中，注册 <code>operationName</code> 呢？答案是不行，<br>在 <a href="http://www.iocoder.cn/SkyWalking/agent-dictionary/?self">《SkyWalking 源码分析 —— Agent DictionaryManager 字典管理》「2.2 操作的同步 API」</a> 中，我们可以看到，<code>operationName</code> 的注册，是<strong>异步</strong>的过程。因而，即使构建的过程中，调用注册，也无法获得 <code>operationId</code> 。</p><p>涉及的逻辑点比较多，如果胖友理解不能，下面我们可以直接看代码。</p><h1 id="2-TraceSegmentServiceHandler"><a href="#2-TraceSegmentServiceHandler" class="headerlink" title="2. TraceSegmentServiceHandler"></a>2. TraceSegmentServiceHandler</h1><p>我们先来看看 API 的定义，<a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-network/src/main/proto/TraceSegmentService.proto#L9" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceSegmentService.proto</code></a> ，如下图所示：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_10_10/03.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-grpc/collector-agent-grpc-provider/src/main/java/org/skywalking/apm/collector/agent/grpc/handler/TraceSegmentServiceHandler.java#L47" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceSegmentServiceHandler#collect(Application, StreamObserver&lt;ApplicationMapping&gt;)</code></a>, 代码如下：</p><ul><li>第 51 行：调用 <code>ITraceSegmentService#send(UpstreamSegment)</code> 方法，处理<strong>一条</strong> TraceSegment 。</li></ul><h2 id="2-1-TraceSegmentService"><a href="#2-1-TraceSegmentService" class="headerlink" title="2.1 TraceSegmentService"></a>2.1 TraceSegmentService</h2><p><code>org.skywalking.apm.collector.agent.stream.service.trace.ITraceSegmentService</code> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> 接口，TraceSegment 服务接口。</p><ul><li>定义了 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-define/src/main/java/org/skywalking/apm/collector/agent/stream/service/trace/ITraceSegmentService.java#L31" rel="external nofollow noopener noreferrer" target="_blank"><code>#send(UpstreamSegment)</code></a> <strong>接口</strong>方法，处理<strong>一条</strong> TraceSegment 。</li></ul><p><code>org.skywalking.apm.collector.agent.stream.worker.trace.ApplicationIDService</code> ，实现 IApplicationIDService 接口，TraceSegment 服务实现类。</p><ul><li><p>实现了 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/TraceSegmentService.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>#send(UpstreamSegment)</code></a> 方法，代码如下：</p><ul><li>第 40 至 41 行：创建 SegmentParse 对象，后调用 <code>SegmentParse#parse(UpstreamSegment, Source)</code> 方法，解析并处理 TraceSegment 。</li></ul></li></ul><h2 id="2-2-SegmentParse"><a href="#2-2-SegmentParse" class="headerlink" title="2.2 SegmentParse"></a>2.2 SegmentParse</h2><p><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/SegmentParse.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.parser.SegmentParse</code></a> ，Segment 解析器。属性如下：</p><ul><li><code>spanListeners</code> 属性，Span 监听器集合。<strong>通过不同的监听器，对 TraceSegment 进行构建，生成不同的数据</strong>。在 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/SegmentParse.java#L72" rel="external nofollow noopener noreferrer" target="_blank"><code>#SegmentParse(ModuleManager)</code> 构造方法</a> ，会看到它的初始化。</li><li><code>segmentId</code> 属性，TraceSegment 编号，即 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegment.java#L47" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceSegment.traceSegmentId</code></a> 。</li><li><code>timeBucket</code> 属性，第一个 Span 的开始时间。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/SegmentParse.java#L86" rel="external nofollow noopener noreferrer" target="_blank"><code>#parse(UpstreamSegment, Source)</code></a> 方法，解析并处理 TraceSegment 。在该方法里，我们会看到，本文开头提到的【<strong>构造</strong>】。整个构造的过程，实际分成<strong>两步</strong>：1）预构建；2）执行构建。代码如下：</p><ul><li>第 88 至 89 行：从 <code>segment</code> 参数中，解析出 ：<ul><li><code>traceIds</code> ，关联的链路追踪<strong>全局编号</strong>。</li><li><code>segmentObject</code> ，TraceSegmentObject 对象。</li></ul></li><li>第 91 行：创建 SegmentDecorator 对象。该对象的用途，在 <a href="#">「2.3 Standardization 标准化」</a> 统一解析。</li><li>——– 构建失败 ——–</li><li>第 94 行：调用 <code>#preBuild(List&lt;UniqueId&gt;, SegmentDecorator)</code> 方法，<strong>预构建</strong>。</li><li>第 97 至 99 行：调用 <code>#writeToBufferFile()</code> 方法，将 TraceSegment 写入 Buffer 文件<strong>暂存</strong>。为什么会判断 <code>source == Source.Agent</code> 呢？<code>#parse(UpstreamSegment, Source)</code> 方法的调用，共有<strong>两个</strong> <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/SegmentParse.java#L256" rel="external nofollow noopener noreferrer" target="_blank">Source</a> ：<ul><li>目前我们看到 TraceSegmentService 的调用使用的是 <code>Source.Agent</code> 。</li><li>而后台线程，定时调用该方法重新构建使用的是 <code>Source.Buffer</code> ，如果不加盖判断，会预构建失败<strong>重复</strong>写入。</li></ul></li><li>第 100 行：返回 <code>false</code> ，表示构建失败。</li><li>——– 构建成功 ——–</li><li>第 106 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/SegmentParse.java#L199" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyListenerToBuild()</code></a> 方法，通知 Span 监听器们，<strong>执行构建</strong>各自的数据。在 <a href="http://www.iocoder.cn/SkyWalking/collector-store-trace/?self">《SkyWalking 源码解析 —— Collector 存储 Trace 数据》</a> 详细解析。</li><li>第 109 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/SegmentParse.java#L177" rel="external nofollow noopener noreferrer" target="_blank"><code>buildSegment(id, dataBinary)</code></a> 方法，<strong>执行构建</strong> TraceSegment 。</li><li>第 110 行：返回 <code>true</code> ，表示构建成功。</li><li>第 112 至 115 行：发生 InvalidProtocolBufferException 异常，返回 <code>false</code> ，表示构建失败。</li></ul><h3 id="2-2-1-预构建"><a href="#2-2-1-预构建" class="headerlink" title="2.2.1 预构建"></a>2.2.1 预构建</h3><p><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/SegmentParse.java#L118" rel="external nofollow noopener noreferrer" target="_blank"><code>#preBuild(List&lt;UniqueId&gt;, SegmentDecorator)</code></a> 方法，前置构建，用于<strong>通过不同的监听器，对 TraceSegment 进行构建，生成不同的数据</strong>。在该过程中，会发生我们在文章头所说的，”<strong>为什么构建会失败</strong>“。代码如下：</p><ul><li>第 120 至 128 行：拼接生成 <code>segmentId</code> 。</li><li>第 131 至 133 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/SegmentParse.java#L132" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyGlobalsListener(...)</code></a> 方法，使用 GlobalTraceSpanListener 处理链路追踪全局编号数组( <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegment.java#L70" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceSegment.relatedGlobalTraces</code></a> )。</li><li>第 139 至 147 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/SegmentParse.java#L239" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyRefsListener(...)</code></a> 方法，使用 RefsListener 处理父 Segment 指向数组( <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegment.java#L54" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceSegment.refs</code></a> )。<ul><li>第 140 至 144 行：调用 <code>ReferenceIdExchanger#exchange(ReferenceDecorator, applicationId)</code> 方法，将 TraceSegmentRef 未生成编号的属性，进行兑换处理。<strong>若兑换失败，返回构造失败</strong>。在 <a href="#">「2.3 Standardization 标准化」</a> 详细解析。</li></ul></li><li>第 149 至 172 行：处理 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegment.java#L60" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceSegment.spans</code></a> 属性。<ul><li>第 150 至 154 行：将 Span 未生成编号的属性，进行兑换处理。<strong>若兑换失败，返回构造失败</strong>。在 <a href="#">「2.3 Standardization 标准化」</a> 详细解析。</li><li>第 157 至 160 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/SegmentParse.java#L230" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyFirstListener(...)</code></a> ，使用 FirstSpanListener 处理<strong>第一个</strong> Span 。</li><li>第 164 行：若是 ExitSpan ，调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/SegmentParse.java#L230" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyExitListener(...)</code></a> ，使用 ExitSpanListener 处理。</li><li>第 166 行：若是 EntrySpan ，调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/SegmentParse.java#L212" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyEntryListener(...)</code></a> ，使用 EntrySpanListener 处理。</li><li>第 168 行：若是 LocalSpan ，调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/SegmentParse.java#L221" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyLocalListener(...)</code></a> ，使用 LocalSpanListener 处理。</li></ul></li><li>第 174 行：返回 <code>true</code> ，<strong>预构建成功</strong>。</li></ul><h3 id="2-2-2-写入-Buffer-文件"><a href="#2-2-2-写入-Buffer-文件" class="headerlink" title="2.2.2 写入 Buffer 文件"></a>2.2.2 写入 Buffer 文件</h3><p><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/SegmentParse.java#L191" rel="external nofollow noopener noreferrer" target="_blank"><code>#writeToBufferFile(id, upstreamSegment)</code></a> 方法，将 TraceSegment 写入 Buffer 文件。代码如下：</p><ul><li>第 193 行：创建 193 至 194 行：创建 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/SegmentStandardization.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.parser.standardization.SegmentStandardization</code></a> 对象，并设置 TraceSegment 属性。</li><li>第 195 行：获得 <code>TraceStreamGraph.SEGMENT_STANDARDIZATION_GRAPH_ID</code> 对象的 Graph 对象。在 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/graph/TraceStreamGraph.java#L85" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceStreamGraph#createSegmentStandardizationGraph()</code></a> 方法中，我们可以看到，该 Graph 对象只有一个 SegmentStandardizationWorker 。</li><li>第 196 行：调用 <code>Graph#start(INPUT)</code> 方法，执行<strong>该 Graph 实现的</strong>流式处理，将 TraceSegment 写到 Buffer 文件。</li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/SegmentStandardizationWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.parser.standardization.SegmentStandardizationWorker</code></a> ，继承 AbstractLocalAsyncWorker 抽象类，TraceSegment 标准化 Worker ，负责将接收到的 TraceSegment <strong>异步</strong>写到 Buffer 文件。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/SegmentStandardizationWorker.java#L59" rel="external nofollow noopener noreferrer" target="_blank">Factory</a> 内部类，实现 AbstractLocalAsyncWorkerProvider 抽象类，在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（一）》「3.2.2 AbstractLocalAsyncWorker」</a> 有详细解析。</li><li><strong>AbstractLocalAsyncWorker</strong> ，在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（一）》「3.2.2 AbstractLocalAsyncWorker」</a> 有详细解析。</li><li><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/SegmentStandardizationWorker.java#L47" rel="external nofollow noopener noreferrer" target="_blank"><code>#id()</code></a> 实现方法，返回 108 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/SegmentStandardizationWorker.java#L51" rel="external nofollow noopener noreferrer" target="_blank"><code>#onWork(SegmentStandardization)</code></a> 实现方法，将接收到的 TraceSegment <strong>异步</strong>写到 Buffer 文件。。代码如下：<ul><li>第 52 行：调用 <code>SegmentBufferManager#writeBuffer(UpstreamSegment)</code> 方法，将接收到的 TraceSegment 写到 Buffer 文件。在 <a href="#">「3. Buffer 文件」</a> 详细解析。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/SegmentStandardizationWorker.java#L65" rel="external nofollow noopener noreferrer" target="_blank"><code>Factory#workerInstance(ModuleManager)</code></a> 方法，创建 SegmentStandardizationWorker 后，会调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/SegmentStandardizationWorker.java#L75" rel="external nofollow noopener noreferrer" target="_blank"><code>#startTimer(SegmentStandardizationWorker)</code></a> 方法，创建定时任务。该定时任务调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/SegmentStandardizationWorker.java#L55" rel="external nofollow noopener noreferrer" target="_blank"><code>#flushAndSwitch()</code></a> 方法，定时将 Buffer 文件 flush 。目前 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/SegmentBufferManager.java#L139" rel="external nofollow noopener noreferrer" target="_blank"><code>SegmentBufferManager#flush()</code></a> 是个空方法。为什么不这里不需要 flush 呢？因为 <code>SegmentBufferManager#writeBuffer(UpstreamSegment)</code> <strong>已经进行 flush</strong> 。</li></ul><h2 id="2-3-Standardization-标准化"><a href="#2-3-Standardization-标准化" class="headerlink" title="2.3 Standardization 标准化"></a>2.3 Standardization 标准化</h2><p>本小节涉及到的类如下图：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_10/04.png" alt=""></p><p>我们先来说说，什么叫 standardization <strong>标准化</strong>？其实就是我们在文章开头说的”<strong>例如将</strong> <code>operationName</code> <strong>转换成</strong> <code>operationId</code>“。</p><h3 id="2-3-1-StandardBuilder"><a href="#2-3-1-StandardBuilder" class="headerlink" title="2.3.1 StandardBuilder"></a>2.3.1 StandardBuilder</h3><p><code>org.skywalking.apm.collector.agent.stream.parser.standardization.StandardBuilder</code> ，标准化 Builder 接口。</p><ul><li>定义了 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/StandardBuilder.java#L31" rel="external nofollow noopener noreferrer" target="_blank"><code>#toBuilder()</code></a> <strong>接口</strong>方法，转换成 Builder 。感觉这个接口方法<strong>怪怪的</strong>？不要捉急，等会看一个实现类就明白了。</li></ul><p>StandardBuilder 有三个实现类：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/SegmentDecorator.java" rel="external nofollow noopener noreferrer" target="_blank">SegmentDecorator</a> ，TraceSegment 装饰者。</li><li><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/ReferenceDecorator.java" rel="external nofollow noopener noreferrer" target="_blank">ReferenceDecorator</a> ，ReferenceDecorator 装饰者。</li><li><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/SpanDecorator.java" rel="external nofollow noopener noreferrer" target="_blank">SpanDecorator</a> ，Span 装饰者。</li></ul><p>怎么都是<strong>装饰者</strong>呢，而且恰好和一个数据结构对应？以 SpanDecorator 为例子，代码如下：</p><ul><li><code>spanObject</code> 属性，SpanObject ，Span 的 Protobuf 数据对象。</li><li><code>standardBuilder</code> 属性，SpanObject 的 Builder 对象。</li><li><code>isOrigin</code> 属性，是否是原始对象。<ul><li><code>isOrigin = true</code> ，使用 <code>spanObject</code>属性 。</li><li><code>isOrigin = false</code> ，使用 <code>standardBuilder</code> 属性。</li></ul></li><li>在 Protobuf 里，数据修改值时，需要使用对应的 Builder 对象。通过使用<strong>装饰者</strong>设计模式，对使用者屏蔽细节，调用也更加方便。下面在来看看如下方法，是不是就更加明白了：<ul><li><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/SpanDecorator.java#L165" rel="external nofollow noopener noreferrer" target="_blank"><code>#setOperationNameId(value)</code></a> </li><li><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/SpanDecorator.java#L172" rel="external nofollow noopener noreferrer" target="_blank"><code>#getOperationName()</code></a></li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/SpanDecorator.java#L195" rel="external nofollow noopener noreferrer" target="_blank"><code>#toBuilder()</code></a> <strong>实现</strong>方法，创建 SpanObject 对应的 Builder ，并修改 <code>isOrigin = false</code> 。另外，会调用 <code>standardBuilder</code> 属性的 <code>#toBuilder()</code> 方法，目前在项目里，此处的 <code>standardBuilder</code> 属性为 SegmentDecorator 。</li></ul><p>SegmentDecorator 、ReferenceDecorator 和 SpanDecorator 目的一致。</p><h3 id="2-3-2-IdExchanger"><a href="#2-3-2-IdExchanger" class="headerlink" title="2.3.2 IdExchanger"></a>2.3.2 IdExchanger</h3><p><code>org.skywalking.apm.collector.agent.stream.parser.standardization.IdExchanger</code> ，编号兑换器<strong>接口</strong>。</p><ul><li>定义了 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/IdExchanger.java#L35" rel="external nofollow noopener noreferrer" target="_blank"><code>#exchange(standardBuilder, applicationId)</code></a> <strong>接口</strong>方法，兑换 standardBuilder 里的属性，并返回是否兑换成功。</li></ul><p>IdExchanger 有三个实现类：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/ReferenceIdExchanger.java" rel="external nofollow noopener noreferrer" target="_blank">ReferenceIdExchanger</a> ：TraceSegmentRef 编号兑换器。</li><li><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/SpanIdExchanger.java" rel="external nofollow noopener noreferrer" target="_blank">SpanIdExchanger</a> ：Span 编号兑换器。</li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/ReferenceIdExchanger.java#L58" rel="external nofollow noopener noreferrer" target="_blank"><code>ReferenceIdExchanger#exchange(standardBuilder, applicationId)</code></a> 方法，代码如下：</p><ul><li>第 60 至 73 行：<a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegmentRef.java#L81" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceSegmentRef.entryOperationId</code></a> 为空，将 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegmentRef.java#L76" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceSegmentRef.entryOperationName</code></a> 进行兑换。<ul><li>第 61 行：调用 <code>ServiceNameService#getOrCreate(applicationId, serviceName)</code> 方法，根据应用编号和操作名获得或创建操作编号。</li><li>第 62 至 67 行：获得<strong>不到</strong>，因为创建的过程是异步的。返回 <code>false</code> 。</li><li>第 68 至 72 行：获得<strong>到</strong>，调用 <code>ReferenceDecorator#toBuilder()</code> 方法，创建 Builder ，然后设置操作编号。</li></ul></li><li>第 75 至 89 行：<a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegmentRef.java#L71" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceSegmentRef.parentApplicationInstanceId</code></a> 为空，将 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegmentRef.java#L90" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceSegmentRef.parentOperationName</code></a> 进行兑换。</li><li>第 92 至 104 行：<a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegmentRef.java#L76" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceSegmentRef.entryOperationName</code></a> 为空，将 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegmentRef.java#L62" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceSegmentRef.peerHost</code></a> 进行兑换。在【第 93 行】，我们可以看到，调用 <code>ApplicationIDService#getOrCreate(applicationCode)</code> 方法，将<strong>服务地址</strong>作为 <code>applicationCode</code> 使用。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/SpanIdExchanger.java#L54" rel="external nofollow noopener noreferrer" target="_blank"><code>SpanIdExchanger#exchange(standardBuilder, applicationId)</code></a> 方法，类似，已经添加代码注释，胖友自己阅读理解。</p><h1 id="3-Buffer-文件"><a href="#3-Buffer-文件" class="headerlink" title="3. Buffer 文件"></a>3. Buffer 文件</h1><p>本小节涉及到的类如下图：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_10/05.png" alt=""></p><p>我们先来看看 Buffer 包括哪些文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">yunai$ pwd</div><div class="line">/Users/yunai/Java/buffer</div><div class="line">yunai$ ls</div><div class="line">data_20171205004132.swoffset_20171205004132.sw</div></pre></td></tr></table></figure><ul><li>Data 文件，记录 TraceSegment 具体数据，通过 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/OffsetManager.java" rel="external nofollow noopener noreferrer" target="_blank">SegmentBufferManager</a> 管理。</li><li>Offset 文件，记录偏移，包括写入文件的名字和偏移，读取文件的名字和偏移，通过 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/SegmentBufferManager.java" rel="external nofollow noopener noreferrer" target="_blank">OffsetManager</a> 管理。</li><li>从命名上，我们可以看出，这<strong>两种</strong>文件，文件名字格式为 <code>类型_${时间}.sw</code> ，并且<strong>相同类型，同时可以存在多个</strong>。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/BufferFileConfig.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.buffer.BufferFileConfig</code></a> ，Buffer 文件配置 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/Offset.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.buffer.Offset</code></a> ，偏移 。</p><p>下面，我们来一起看看 Buffer 文件的初始化、写入、读取的三种操作过程。</p><h2 id="3-1-初始化"><a href="#3-1-初始化" class="headerlink" title="3.1 初始化"></a>3.1 初始化</h2><p><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/SegmentBufferManager.java#L54" rel="external nofollow noopener noreferrer" target="_blank"><code>SegmentBufferManager#initialize(ModuleManager)</code></a> 方法，初始化 Offset 文件、Data 文件、定期读取 Buffer 文件的任务。代码如下：</p><ul><li>第 58 行：调用 <code>OffsetManager#initialize()</code> 方法，初始化 Offset 文件。</li><li>第 60 至 63 行：创建 Buffer 文件夹成功( 意味着该文件夹不存在 )，调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/SegmentBufferManager.java#L113" rel="external nofollow noopener noreferrer" target="_blank"><code>#newDataFile()</code></a> ，创建 Data 文件。代码如下：<ul><li>第 116 至 119 行：创建<strong>新</strong>的 Data 文件。文件名格式为，<code>data_${yyyyMMddHHmmss}.sw</code> 。</li><li>第 121 行：调用 <code>OffsetManager#setWriteOffset(writeFileName, writeFileOffset)</code> 方法，设置 Offset 的<strong>写入</strong>的文件名和偏移。</li><li>第 124 至 126 行：关闭<strong>老</strong>的 Data 文件的 <code>outputStream</code> 。</li><li>第 129 至 130 行：创建<strong>新</strong>的 Data 文件的 <code>outputStream</code> 。</li></ul></li><li>第 66 至 77 行：获得 Offset 的<strong>写入</strong>的 Data 文件，并创建对应的 <code>outputStream</code> 。</li><li>第 80 行：调用 <code>SegmentBufferReader#initialize(ModuleManager)</code> 方法，初始化定期读取 Buffer 文件的任务。</li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/OffsetManager.java#L72" rel="external nofollow noopener noreferrer" target="_blank"><code>OffsetManager#initialize()</code></a> 方法，初始化 Offset 文件。代码如下：</p><ul><li>第 74 行：创建 Offer 对象。该对象包含了<strong>当前</strong>分别写入和读取的文件名与偏移量。</li><li>第 60 至 63 行：创建 Buffer 文件夹成功( 意味着该文件夹不存在 )，调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/OffsetManager.java#L112" rel="external nofollow noopener noreferrer" target="_blank"><code>#createOffsetFile()</code></a> ，创建 Data 文件。代码如下：<ul><li>第 114 至 116 行：创建<strong>新</strong>的 Offset 文件。文件名格式为，<code>offset_${yyyyMMddHHmmss}.sw</code> 。</li><li>第 118 至 121 行：设置 Offset 对象的写入和读取的文件名与偏移量都为<strong>空</strong>。在上面的方法，此处的【空】，在 Data 文件创建时，会重新设置 Offset 。</li><li>第 123 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/OffsetManager.java#L129" rel="external nofollow noopener noreferrer" target="_blank"><code>#flush()</code></a> 方法，写入 Offset 对象到 Offset 文件。代码如下： <ul><li>第 131 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/Offset.java#L49" rel="external nofollow noopener noreferrer" target="_blank"><code>Offset#serialize()</code></a> 方法，序列化读写偏移，格式为 <code>${读取文件名},${读取文件偏移量},${写入文件名},${写入文件偏移量}</code> 。</li><li>第 133 至 142 行：写入 Offset 对象到 Offset 文件。写入方式为<strong>整行</strong>，如下图所示：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_10/06.png" alt=""></li></ul></li></ul></li><li>第 82 至 94 行：获得所有 Offset 文件，删除老的 Offset 文件，保留最后一个。若不存在 Offset 文件，则调用 <code>#createOffsetFile()</code> 方法，创建<strong>新</strong>的 Offset 文件。</li><li>第 98 至 99 行：从 Offset 文件的<strong>最后一行</strong>读取，反序列化到 Offset 对象。</li><li>第 103 行：创建定义任务，延迟 10 秒，间隔 3 秒，调用 <code>#flush()</code> 方法，<strong>定时</strong>写入 Offset 对象到 Offset 文件。<strong>注意，所以 Offset 改变时，不是立即写入 Offset 文件，而是周期性刷盘</strong>。</li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/SegmentBufferReader.java#L52" rel="external nofollow noopener noreferrer" target="_blank"><code>SegmentBufferReader#initialize(ModuleManager)</code></a> 方法，初始化定期读取 Buffer 文件的任务。代码如下：</p><ul><li>第 56 行：创建定时任务，延迟 3 秒，间隔 3 秒，调用 <code>#preRead()</code> 方法，读取 Buffer 文件，将 TraceSegment 提交给 SegmentParse 重新解析与构建处理。</li></ul><h2 id="3-2-写入"><a href="#3-2-写入" class="headerlink" title="3.2 写入"></a>3.2 写入</h2><p><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/SegmentBufferManager.java#L91" rel="external nofollow noopener noreferrer" target="_blank"><code>SegmentBufferManager#writeBuffer(UpstreamSegment)</code></a> 方法，将 TraceSegment 写入 Buffer 文件，包括两个步骤：1）将 TraceSegment 写入 Data 文件；2）更新 Offset 文件的偏移。代码如下：</p><ul><li>第 94 至 95 行：调用 <code>AbstractMessageLite#writeDelimitedTo(OutputStream)</code> 方法，将 TraceSegment 写入 Data 文件。该方法包括 <strong>flush</strong> 操作，代码如下：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_10/07.png" alt=""></li><li>第 97 至 98 行：超过 Buffer <strong>单文件容量上限</strong>，调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/SegmentBufferManager.java#L113" rel="external nofollow noopener noreferrer" target="_blank"><code>#newDataFile()</code></a> ，创建 Data 文件。</li><li>第 99 至 102 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/OffsetManager.java#L186" rel="external nofollow noopener noreferrer" target="_blank"><code>OffsetManager#setWriteOffset(position)</code></a> 方法，设置 Offset 对象的写入偏移。</li></ul><h2 id="3-3-读取"><a href="#3-3-读取" class="headerlink" title="3.3 读取"></a>3.3 读取</h2><p><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/SegmentBufferReader.java#L59" rel="external nofollow noopener noreferrer" target="_blank"><code>SegmentBufferReader#preRead()</code></a> 方法，读取 Buffer 文件，将 TraceSegment 提交给 SegmentParse 重新解析与构建处理。<strong>另外该方法，会删除已经读取完成的 Data 文件</strong>。代码如下：</p><ul><li>——– 读取文件存在</li><li>该情况发生于，Data 文件未被读取完成</li><li>第 65 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/SegmentBufferReader.java#L88" rel="external nofollow noopener noreferrer" target="_blank"><code>#deleteTheDataFilesBeforeReadFile(readFileName)</code></a> 方法，删除比指定文件早创建的 Data 文件，<strong>基于文件名带有创建时间</strong>。</li><li>第 67 至 68 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/SegmentBufferReader.java#L130" rel="external nofollow noopener noreferrer" target="_blank"><code>#read()</code></a> 方法，读取 Buffer 文件，将 TraceSegment 提交给 SegmentParse 重新解析与构建处理。另外，返回 <code>true</code> ，文件被全部读取完成、处理并删除。返回 <code>false</code> ，文件未被全部读取完成。<ul><li>第 133 至 134 行：创建 FileInputStream 对象，并跳转到读取位置。</li><li>第 137 至 141 行：获取<strong>读取结束</strong>的位置。</li><li>第 143 至 159 行：<strong>循环读取处理</strong>，直到到达读取文件上限位置<ul><li>第 144 至 146 行：从 Data 文件，读取一条 TraceSegment 。</li><li>第 149 至 152 行：将 TraceSegment 提交给 SegmentParse 重新解析与构建处理。若解析处理失败，返回 <code>false</code> ，结束循环，等待下次读取处理。</li><li>第 155 至 158 行：设置 Offset 对象的读取偏移。</li></ul></li><li>第 161 至 165 行：<strong>全部读取处理完成，关闭 InputStream ，同时删除读取的 Data 文件</strong>。</li><li>第 166 至 169 行：发生 IOException 异常，返回 <code>false</code> 。</li><li>第 170 行：返回 <code>true</code> ，文件被全部读取完成、处理并删除。</li></ul></li><li>第 75 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/SegmentBufferReader.java#L110" rel="external nofollow noopener noreferrer" target="_blank"><code>#readEarliestCreateDataFile()</code></a> 方法，循环顺序读取 Data 文件，直到有一个没读完。<ul><li>第 112 至 118 行：若第一个 Data 文件和 Offset 读取的文件相同，返回。说明，在上一次 <code>#read()</code> 方法里，没有读完。</li><li>第 121 至 127 行：循环顺序调用 <code>#read(readFile, readFileOffset)</code> 方法，读取 Data 文件，直到有一个没读完。 </li></ul></li><li>——– 读取文件不存在 ——–</li><li>该情况发生于，Data 文件被全部读取完成，并且删除。</li><li>第 73 行：调用 <code>#deleteTheDataFilesBeforeReadFile(readFileName)</code> 方法，删除比指定文件早创建的 Data 文件。</li><li>第 75 行：调用 <code>#readEarliestCreateDataFile()</code> 方法，循环顺序读取 Data 文件，直到有一个没读完。</li><li>——– 没有可读取的文件 ——–</li><li>该情况发生于，Data 文件、Buffer 文件<strong>首次</strong>初始化创建，未设置可读文件名。</li><li>第 79 行：调用 <code>#readEarliestCreateDataFile()</code> 方法，循环顺序读取 Data 文件，直到有一个没读完。</li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>呼呼，即将开始 Trace 流式处理的文章，很嗨皮。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_10_10/08.png" alt=""></p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-receive-trace/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-receive-trace/&lt;/a
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Agent 发送 Trace 数据</title>
    <link href="http://www.iocoder.cn/SkyWalking/agent-send-trace/"/>
    <id>http://www.iocoder.cn/SkyWalking/agent-send-trace/</id>
    <published>2020-10-04T16:00:00.000Z</published>
    <updated>2018-01-02T12:51:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/agent-send-trace/">http://www.iocoder.cn/SkyWalking/agent-send-trace/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-send-trace/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-send-trace/">2. TraceSegmentServiceClient</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-send-trace/">2.1 实现 BootService 接口</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-send-trace/">2.2 实现 GRPCChannelListener 接口</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-send-trace/">2.3 实现 TracingContextListener 接口</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-send-trace/">2.4 实现 IConsumer 接口</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-send-trace/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>分布式链路追踪系统，链路的追踪大体流程如下：</p><ol><li>Agent 收集 Trace 数据。</li><li><strong>Agent 发送 Trace 数据给 Collector</strong> 。</li><li>Collector 接收 Trace 数据。</li><li>Collector 存储 Trace 数据到存储器，例如，数据库。</li></ol><p>本文主要分享【第二部分】 <strong>SkyWalking Agent 发送 Trace 数据</strong>。</p><p>考虑到减少<strong>外部组件</strong>的依赖，Agent 收集到 Trace 数据后，不是写入外部消息队列( 例如，Kafka )或者日志文件，而是 Agent 写入<strong>内存消息队列</strong>，<strong>后台线程</strong>【<strong>异步</strong>】发送给 Collector 。</p><p>本文涉及的类非常少，如下图所示：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_10_05/01.png" alt=""></p><h1 id="2-TraceSegmentServiceClient"><a href="#2-TraceSegmentServiceClient" class="headerlink" title="2. TraceSegmentServiceClient"></a>2. TraceSegmentServiceClient</h1><p><a href="https://github.com/YunaiV/skywalking/blob/0fe81f39054634a0b9a04fca41e6889f0e175b4a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/TraceSegmentServiceClient.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.remote.TraceSegmentServiceClient</code></a> ，TraceSegment 发送服务客户端。它是一个服务，也是一个客户端，负责将 TraceSegment <strong>异步</strong>发送到 Collector 。</p><p>我们先来看看 TraceSegmentServiceClient 的<strong>属性</strong>：</p><ul><li><code>TIMEOUT</code> <strong>静态</strong>属性，发送等待超时时长，单位：毫秒。</li><li><code>lastLogTime</code> 属性，最后打印日志时间。该属性主要用于开发调试。</li><li><code>segmentUplinkedCounter</code> 属性，TraceSegment 发送数量。</li><li><code>segmentAbandonedCounter</code> 属性，TraceSegment 被丢弃数量。在 Agent 未连接上 Collector 时，产生的 TraceSegment 将被丢弃。</li><li><code>carrier</code> 属性，内存队列。在 <a href="http://www.iocoder.cn/SkyWalking/data-carrier/?self">《SkyWalking 源码分析 —— DataCarrier 异步处理库》</a> 有对 DataCarrier 的详细解析。</li><li><code>serviceStub</code> 属性，<strong>非阻塞</strong> Stub 。</li><li><code>status</code> 属性，连接状态。</li></ul><p>下面，我们来介绍 TraceSegmentServiceClient 实现的<strong>接口</strong>以及对应的方法。</p><h2 id="2-1-实现-BootService-接口"><a href="#2-1-实现-BootService-接口" class="headerlink" title="2.1 实现 BootService 接口"></a>2.1 实现 BootService 接口</h2><p><a href="https://github.com/YunaiV/skywalking/blob/0fe81f39054634a0b9a04fca41e6889f0e175b4a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/TraceSegmentServiceClient.java#L85" rel="external nofollow noopener noreferrer" target="_blank"><code>#beforeBoot()</code></a> 方法，代码如下：</p><ul><li>第 86 行：调用 <code>GRPCChannelManager#addChannelListener(this)</code> 方法，将自己添加到 GRPCChannelManager 中，作为一个监听器，从而调用 <code>#statusChanged(GRPCChannelStatus)</code> 方法，实现对<strong>连接状态</strong>( <code>status</code> )的监听处理。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/0fe81f39054634a0b9a04fca41e6889f0e175b4a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/TraceSegmentServiceClient.java#L90" rel="external nofollow noopener noreferrer" target="_blank"><code>#boot()</code></a> 方法，代码如下：</p><ul><li>第 95 至 97 行：创建 DataCarrier 对象，作为<strong>内存队列</strong>，并设置自己作为消费者，从而调用 <code>#consume(List&lt;TraceSegment&gt; )</code> 方法，实现<strong>异步</strong>发送 TraceSegment 到 Collector 。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/0fe81f39054634a0b9a04fca41e6889f0e175b4a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/TraceSegmentServiceClient.java#L101" rel="external nofollow noopener noreferrer" target="_blank"><code>#afterBoot()</code></a> 方法，代码如下：</p><ul><li>第 102 行：调用 <code>TracingContext.ListenerManager#add(this)</code> 方法，将自己添加到 ListenerManager 中，作为一个监听器，从而调用 <code>#afterFinished(TraceSegment)</code> 方法，实现<strong>收集</strong>到新的 TraceSegment ，添加到内存队列。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/0fe81f39054634a0b9a04fca41e6889f0e175b4a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/TraceSegmentServiceClient.java#L106" rel="external nofollow noopener noreferrer" target="_blank"><code>#shutdown()</code></a> 方法，代码如下：</p><ul><li>第 107 行：调用 <code>DataCarrier#shutdownConsumers()</code> 方法，停止消费。</li></ul><h2 id="2-2-实现-GRPCChannelListener-接口"><a href="#2-2-实现-GRPCChannelListener-接口" class="headerlink" title="2.2 实现 GRPCChannelListener 接口"></a>2.2 实现 GRPCChannelListener 接口</h2><p><a href="https://github.com/YunaiV/skywalking/blob/0fe81f39054634a0b9a04fca41e6889f0e175b4a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/TraceSegmentServiceClient.java#L209" rel="external nofollow noopener noreferrer" target="_blank"><code>#statusChanged(GRPCChannelStatus)</code></a> 方法，代码如下：</p><ul><li>第 211 至 214 行：连接成功，创建 Stub 对象。</li><li>第 215 行：记录连接状态。</li></ul><h2 id="2-3-实现-TracingContextListener-接口"><a href="#2-3-实现-TracingContextListener-接口" class="headerlink" title="2.3 实现 TracingContextListener 接口"></a>2.3 实现 TracingContextListener 接口</h2><p><a href="https://github.com/YunaiV/skywalking/blob/0fe81f39054634a0b9a04fca41e6889f0e175b4a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/TraceSegmentServiceClient.java#L196" rel="external nofollow noopener noreferrer" target="_blank"><code>#afterFinished(TraceSegment)</code></a> 方法，代码如下：</p><ul><li>第 197 至 199 行：当 <code>TraceSegment.ignore = true</code> 时，忽略该 TraceSegment 。</li><li>第 201 行：提交 TraceSegment 到内存队列。</li></ul><h2 id="2-4-实现-IConsumer-接口"><a href="#2-4-实现-IConsumer-接口" class="headerlink" title="2.4 实现 IConsumer 接口"></a>2.4 实现 IConsumer 接口</h2><p><a href="https://github.com/YunaiV/skywalking/blob/0fe81f39054634a0b9a04fca41e6889f0e175b4a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/TraceSegmentServiceClient.java#L116" rel="external nofollow noopener noreferrer" target="_blank"><code>#consume(List&lt;TraceSegment&gt;)</code></a> 方法，代码如下：</p><ul><li>—— <strong>连接中</strong> ——</li><li>第 119 行：创建 <a href="https://github.com/YunaiV/skywalking/blob/0fe81f39054634a0b9a04fca41e6889f0e175b4a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/GRPCStreamServiceStatus.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.remote。GRPCStreamServiceStatus</code></a> 对象。</li><li>第 122 至 141 行：创建 StreamObserver 对象。在下面，我们可以看到 Agent 发送 TraceSegment 给 Collector 是<strong>非阻塞</strong>的方式，通过该对象，<strong>观察</strong>执行结果。<ul><li>第 130 行 || 第 139 行：当发生错误或者完成时，调用 <a href="https://github.com/YunaiV/skywalking/blob/0fe81f39054634a0b9a04fca41e6889f0e175b4a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/GRPCStreamServiceStatus.java#L44" rel="external nofollow noopener noreferrer" target="_blank"><code>GRPCStreamServiceStatus#finished()</code></a> 方法，<strong>标记完成</strong>。为什么呢？下面会看到。</li><li>第 134 行：调用 <code>GRPCChannelManager#reportError(Throwable)</code> 方法，汇报错误。如果是连接错误，GRPCChannelManager 会负责断开重连。</li></ul></li><li>第 144 至 151 行：逐条<strong>非阻塞</strong>发送 TraceSegment 请求。<ul><li>第 146 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/0fe81f39054634a0b9a04fca41e6889f0e175b4a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegment.java#L163" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceSegment#transform()</code></a> 方法，将 TraceSegment 转换成 <code>org.skywalking.apm.network.proto.UpstreamSegment</code> 对象，用于 gRPC 传输，参见 <a href="https://github.com/YunaiV/skywalking/blob/0fe81f39054634a0b9a04fca41e6889f0e175b4a/apm-network/src/main/proto/TraceSegmentService.proto#L14" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceSegmentService.proto</code></a> 的数据结构定义。<ul><li><a href="https://github.com/YunaiV/skywalking/blob/0fe81f39054634a0b9a04fca41e6889f0e175b4a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ids/DistributedTraceId.java#L65" rel="external nofollow noopener noreferrer" target="_blank"><code>DistributedTraceId#toUniqueId()</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/0fe81f39054634a0b9a04fca41e6889f0e175b4a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ids/ID.java#L120" rel="external nofollow noopener noreferrer" target="_blank"><code>ID#transform()</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/0fe81f39054634a0b9a04fca41e6889f0e175b4a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/AbstractTracingSpan.java#L262" rel="external nofollow noopener noreferrer" target="_blank"><code>AbstractTracingSpan#transform()</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/0fe81f39054634a0b9a04fca41e6889f0e175b4a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/ExitSpan.java#L129" rel="external nofollow noopener noreferrer" target="_blank"><code>ExitSpan#transform()</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/0fe81f39054634a0b9a04fca41e6889f0e175b4a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/LogDataEntity.java#L72" rel="external nofollow noopener noreferrer" target="_blank"><code>LogDataEntity#transform()</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/0fe81f39054634a0b9a04fca41e6889f0e175b4a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegmentRef.java#L160" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceSegmentRef#transform()</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/0fe81f39054634a0b9a04fca41e6889f0e175b4a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/util/KeyValuePair.java#L45" rel="external nofollow noopener noreferrer" target="_blank"><code>KeyValuePair#transform()</code></a></li></ul></li><li>第 154 行：调用 <code>StreamObserver#onCompleted()</code> 方法，标记全部请求发送完成。</li><li>第 157 至 159 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/0fe81f39054634a0b9a04fca41e6889f0e175b4a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/GRPCStreamServiceStatus.java#L51" rel="external nofollow noopener noreferrer" target="_blank"><code>GRPCStreamServiceStatus#wait4Finish(maxTimeout)</code></a> 方法，等待 Collector 处理完成。这就是为什么上面需要调用 <code>GRPCStreamServiceStatus#finished()</code> 方法。完成后，记录数量到 <code>segmentUplinkedCounter</code> 。<ul><li><strong>注意</strong>，此处若等待完成超时，TraceSegment <strong>依然</strong>在发送，或者被 Collector 处理中，直到最终的成功或失败。</li></ul></li></ul></li><li>—— <strong>未连接</strong> ——</li><li>第 161 行：记录数量到 <code>segmentAbandonedCounter</code> 。</li><li>—— <strong>ALL</strong> ——</li><li>调用 <a href="https://github.com/YunaiV/skywalking/blob/0fe81f39054634a0b9a04fca41e6889f0e175b4a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/TraceSegmentServiceClient.java#L170" rel="external nofollow noopener noreferrer" target="_blank"><code>#printUplinkStatus()</code></a> 方法，每三十秒，打印一次 segmentUplinkedCounter 和 segmentAbandonedCounter 数据。主要用于开发调试。另外，该方法会重置 <code>segmentUplinkedCounter</code> 和 <code>segmentAbandonedCounter</code> 计数。</li></ul><p>ps：目前 DataCarrier <strong>最长</strong>每 20 秒消费一次。</p><p><a href="https://github.com/YunaiV/skywalking/blob/0fe81f39054634a0b9a04fca41e6889f0e175b4a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/TraceSegmentServiceClient.java#L186" rel="external nofollow noopener noreferrer" target="_blank"><code>#onError(List&lt;TraceSegment&gt;, Throwable)</code></a> 方法，当消费发生<strong>异常</strong>时，打印日志。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>HOHO ，简单水更一篇，保持 Trace 相关的小系列文章，主题明确。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_10_05/02.jpeg" alt=""></p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/agent-send-trace/&quot;&gt;http://www.iocoder.cn/SkyWalking/agent-send-trace/&lt;/a&gt; 「芋道源码」欢迎转载，保
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Agent 收集 Trace 数据</title>
    <link href="http://www.iocoder.cn/SkyWalking/agent-collect-trace/"/>
    <id>http://www.iocoder.cn/SkyWalking/agent-collect-trace/</id>
    <published>2020-09-30T16:00:00.000Z</published>
    <updated>2018-01-02T09:13:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/agent-collect-trace/">http://www.iocoder.cn/SkyWalking/agent-collect-trace/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-collect-trace/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-collect-trace/">2. Trace</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-collect-trace/">2.1 ID</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-collect-trace/">2.2 AbstractSpan</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-collect-trace/">2.3 TraceSegmentRef</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-collect-trace/">2.4 TraceSegment</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-collect-trace/">3. Context</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-collect-trace/">3.1 ContextManager</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-collect-trace/">3.2 AbstractTracerContext</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-collect-trace/">3.3 SamplingService</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-collect-trace/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>分布式链路追踪系统，链路的追踪大体流程如下：</p><ol><li><strong>Agent 收集 Trace 数据</strong>。</li><li>Agent 发送 Trace 数据给 Collector 。</li><li>Collector 接收 Trace 数据。</li><li>Collector 存储 Trace 数据到存储器，例如，数据库。</li></ol><p>本文主要分享【第一部分】 <strong>SkyWalking Agent 收集 Trace 数据</strong>。文章的内容顺序如下：</p><ul><li>Trace 的数据结构</li><li>Context 收集 Trace 的方法</li></ul><p>不包括插件对 Context 收集的方法的<strong>调用</strong>，后续单独文章专门分享，胖友也可以阅读完本文后，自己去看 <a href="https://github.com/YunaiV/skywalking/tree/0830d985227c42f0e0f3787ebc99a2b197486b69/apm-sniffer/apm-sdk-plugin" rel="external nofollow noopener noreferrer" target="_blank"><code>apm-sdk-plugin</code></a> 的实现代码。</p><p>本文涉及到的代码如下图：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_10_01/01.png" alt=""></p><ul><li><strong>红框</strong>部分：Trace 的数据结构，在 <a href="#">「2. Trace」</a> 分享。</li><li><strong>黄框</strong>部分：Context 收集 Trace 的方法，在 <a href="#">「3. Context」</a> 分享。</li></ul><h1 id="2-Trace"><a href="#2-Trace" class="headerlink" title="2. Trace"></a>2. Trace</h1><blockquote><p>友情提示：胖友，请先行阅读 <a href="https://github.com/opentracing-contrib/opentracing-specification-zh/blob/master/specification.md" rel="external nofollow noopener noreferrer" target="_blank">《OpenTracing语义标准》</a> 。  </p><p>本小节，笔者认为胖友已经对 OpenTracing 有一定的理解。</p></blockquote><p><a href="https://github.com/YunaiV/skywalking/blob/2a75efbeddac2b9565816af0ab0873ec3d998424/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegment.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.trace.TraceSegment</code></a> ，是<strong>一次</strong>分布式链路追踪( Distributed Trace ) 的<strong>一段</strong>。</p><ul><li><strong>一条</strong> TraceSegment ，用于记录所在<strong>线程</strong>( Thread )的链路。</li><li><strong>一次</strong>分布式链路追踪，可以包含<strong>多条</strong> TraceSegment ，因为存在<strong>跨进程</strong>( 例如，RPC 、MQ 等等)，或者垮<strong>线程</strong>( 例如，并发执行、异步回调等等 )。</li></ul><p>TraceSegment 属性，如下：</p><ul><li><code>traceSegmentId</code> 属性，TraceSegment 的编号，全局唯一。在 <a href="#">「2.1 ID」</a> 详细解析。</li><li><code>refs</code> 属性，TraceSegmentRef <strong>数组</strong>，指向的<strong>父</strong> TraceSegment 数组。<ul><li><strong>为什么会有多个爸爸</strong>？下面统一讲。</li><li>TraceSegmentRef ，在 <a href="#">「2.3 TraceSegmentRef」</a> 详细解析。</li></ul></li><li><code>relatedGlobalTraces</code> 属性，关联的 DistributedTraceId <strong>数组</strong>。<ul><li><strong>为什么会有多个爸爸</strong>？下面统一讲。</li><li>DistributedTraceId ，在 <a href="#">「2.1.2 DistributedTraceId」</a> 详细解析。</li></ul></li><li><code>spans</code> 属性，包含的 Span <strong>数组</strong>。在 <a href="#">「2.2 AbstractSpan」</a> 详细解析。这是 TraceSegment 的<strong>主体</strong>，总的来说，TraceSegment 是 Span 数组的封装。</li><li><code>ignore</code> 属性，是否忽略该条 TraceSegment 。在一些情况下，我们会忽略 TraceSegment ，即不收集链路追踪，在下面 <a href="#">「3. Context」</a> 部分内容，我们将会看到这些情况。</li><li><code>isSizeLimited</code> 属性，Span 是否超过上限( <a href="https://github.com/YunaiV/skywalking/blob/2961e9f539286ef91af1ff1ef7681d0a06f156b0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/conf/Config.java#L56" rel="external nofollow noopener noreferrer" target="_blank"><code>Config.Agent.SPAN_LIMIT_PER_SEGMENT</code></a> )。超过上限，不在记录 Span 。</li></ul><p><strong>为什么会有多个爸爸</strong>？</p><ul><li>我们先来看看<strong>一个爸爸</strong>的情况，常见于 RPC 调用。例如，【服务 A】调用【服务 B】时，【服务 B】新建一个 TraceSegment 对象：<ul><li>将自己的 <code>refs</code> 指向【服务 A】的 TraceSegment 。</li><li>将自己的 <code>relatedGlobalTraces</code> 设置为 【服务 A】的 DistributedTraceId 对象。</li></ul></li><li>我们再来看看<strong>多个爸爸</strong>的情况，常见于 MQ / Batch 调用。例如，MQ 批量消费消息时，消息来自【多个服务】。每次批量消费时，【消费者】新建一个 TraceSegment 对象：<ul><li>将自己的 <code>refs</code> 指向【多个服务】的<strong>多个</strong> TraceSegment 。</li><li>将自己的 <code>relatedGlobalTraces</code> 设置为【多个服务】的<strong>多个</strong> DistributedTraceId 。</li></ul></li></ul><blockquote><p>友情提示：多个爸爸的故事，可能比较难懂，等胖友读完全文，在回过头想想。或者拿起来代码调试调试。</p></blockquote><p>下面，我们来具体看看 TraceSegment 的每个元素，最后，我们会回过头，在 <a href="#">「2.4 TraceSegment」</a> 详细解析它。</p><h2 id="2-1-ID"><a href="#2-1-ID" class="headerlink" title="2.1 ID"></a>2.1 ID</h2><p><a href="https://github.com/YunaiV/skywalking/blob/cc27e35d69d922ba8fa38fbe4e8cc4704960f602/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ids/ID.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.ids.ID</code></a> ，编号。从类的定义上，这是一个<strong>通用</strong>的编号，由三段整数组成。</p><p>目前使用 GlobalIdGenerator 生成，作为<strong>全局唯一编号</strong>。属性如下：</p><ul><li><code>part1</code> 属性，应用实例编号。</li><li><code>part2</code> 属性，线程编号。</li><li><code>part3</code> 属性，时间戳串，生成方式为 <code>${时间戳} * 10000 + 线程自增序列([0, 9999])</code> 。例如：15127007074950012 。具体生成方法的代码，在 GlobalIdGenerator 中详细解析。</li><li><code>encoding</code> 属性，编码后的字符串。格式为 <code>&quot;${part1}.${part2}.${part3}&quot;</code> 。例如，<code>&quot;12.35.15127007074950000&quot;</code> 。<ul><li>使用 <a href="https://github.com/YunaiV/skywalking/blob/cc27e35d69d922ba8fa38fbe4e8cc4704960f602/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ids/ID.java#L83" rel="external nofollow noopener noreferrer" target="_blank"><code>#encode()</code></a> 方法，编码编号。</li></ul></li><li><code>isValid</code> 属性，编号是否合法。<ul><li>使用 <a href="https://github.com/YunaiV/skywalking/blob/cc27e35d69d922ba8fa38fbe4e8cc4704960f602/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ids/ID.java#L56" rel="external nofollow noopener noreferrer" target="_blank"><code>ID(encodingString)</code></a> 构造方法，解析字符串，生成 ID 。</li></ul></li></ul><h3 id="2-1-1-GlobalIdGenerator"><a href="#2-1-1-GlobalIdGenerator" class="headerlink" title="2.1.1 GlobalIdGenerator"></a>2.1.1 GlobalIdGenerator</h3><p><a href="https://github.com/YunaiV/skywalking/blob/9db53fd95e1c4c10f0f7a939e4484d7e2102ad3f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ids/GlobalIdGenerator.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.ids.GlobalIdGenerator</code></a> ，全局编号生成器。</p><p><a href="https://github.com/YunaiV/skywalking/blob/9db53fd95e1c4c10f0f7a939e4484d7e2102ad3f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ids/GlobalIdGenerator.java#L62" rel="external nofollow noopener noreferrer" target="_blank"><code>#generate()</code></a> 方法，生成 ID 对象。代码如下：</p><ul><li>第 67 行：获得线程对应的 IDContext 对象。</li><li>第 69 至 73 行：生成 ID 对象。<ul><li>第 70 行：<code>ID.part1</code> 属性，应用编号实例。</li><li>第 71 行：<code>ID.part2</code> 属性，线程编号。</li><li>第 72 行：<code>ID.part3</code> 属性，调用 <a href="https://github.com/YunaiV/skywalking/blob/9db53fd95e1c4c10f0f7a939e4484d7e2102ad3f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ids/GlobalIdGenerator.java#L102" rel="external nofollow noopener noreferrer" target="_blank"><code>IDContext#nextSeq()</code></a> 方法，生成带有时间戳的序列号。</li></ul></li><li>ps ：代码比较易懂，已经添加完成注释。</li></ul><h3 id="2-1-2-DistributedTraceId"><a href="#2-1-2-DistributedTraceId" class="headerlink" title="2.1.2 DistributedTraceId"></a>2.1.2 DistributedTraceId</h3><p><a href="https://github.com/YunaiV/skywalking/blob/5fb841b3ae5b78f07d06c6186adf9a8c08295a07/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ids/DistributedTraceId.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.ids.DistributedTraceId</code></a> ，分布式链路追踪编号<strong>抽象类</strong>。</p><ul><li><code>id</code> 属性，全局编号。</li></ul><p>DistributedTraceId 有两个实现类：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/5fb841b3ae5b78f07d06c6186adf9a8c08295a07/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ids/NewDistributedTraceId.java" rel="external nofollow noopener noreferrer" target="_blank">org.skywalking.apm.agent.core.context.ids.NewDistributedTraceId</a> ，<strong>新建的</strong>分布式链路追踪编号。当全局链路追踪开始，创建 TraceSegment 对象的过程中，会调用 <a href="https://github.com/YunaiV/skywalking/blob/5fb841b3ae5b78f07d06c6186adf9a8c08295a07/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ids/NewDistributedTraceId.java#L30" rel="external nofollow noopener noreferrer" target="_blank"><code>DistributedTraceId()</code> 构造方法</a>，创建 DistributedTraceId 对象。该构造方法内部会调用 <code>GlobalIdGenerator#generate()</code> 方法，创建 ID 对象。</li><li><a href="https://github.com/YunaiV/skywalking/blob/5fb841b3ae5b78f07d06c6186adf9a8c08295a07/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ids/PropagatedTraceId.java" rel="external nofollow noopener noreferrer" target="_blank">org.skywalking.apm.agent.core.context.ids.PropagatedTraceId</a> ，<strong>传播的</strong>分布式链路追踪编号。例如，A 服务调用 B 服务时，A 服务会将 DistributedTraceId 对象带给 B 服务，B 服务会调用 <a href="https://github.com/YunaiV/skywalking/blob/5fb841b3ae5b78f07d06c6186adf9a8c08295a07/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ids/PropagatedTraceId.java#L30" rel="external nofollow noopener noreferrer" target="_blank"><code>PropagatedTraceId(String id)</code> 构造方法</a> ，创建 PropagatedTraceId 对象。该构造方法内部会解析 id ，生成 ID 对象。</li></ul><h3 id="2-1-3-DistributedTraceIds"><a href="#2-1-3-DistributedTraceIds" class="headerlink" title="2.1.3 DistributedTraceIds"></a>2.1.3 DistributedTraceIds</h3><p><a href="https://github.com/YunaiV/skywalking/blob/2961e9f539286ef91af1ff1ef7681d0a06f156b0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ids/DistributedTraceIds.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.ids.DistributedTraceIds</code></a> ，DistributedTraceId 数组的封装。</p><ul><li><code>relatedGlobalTraces</code> 属性，关联的 DistributedTraceId <strong>链式</strong>数组。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/ad259ad680df86296036910ede262765ffb44e5e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ids/DistributedTraceIds.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>#append(DistributedTraceId)</code></a> 方法，添加分布式链路追踪编号( DistributedTraceId )。代码如下：</p><ul><li>第 51 至 54 行：移除<strong>首个</strong> NewDistributedTraceId 对象。为什么呢？在 <a href="#">「2.4 TraceSegment」</a> 的构造方法中，会默认创建 NewDistributedTraceId 对象。在跨线程、或者跨进程的情况下时，创建的 TraceSegment 对象，需要指向父 Segment 的 DistributedTraceId ，所以需要移除默认创建的。</li><li>第 56 至 58 行：添加 DistributedTraceId 对象到数组。</li></ul><h2 id="2-2-AbstractSpan"><a href="#2-2-AbstractSpan" class="headerlink" title="2.2 AbstractSpan"></a>2.2 AbstractSpan</h2><p><a href="https://github.com/YunaiV/skywalking/blob/96fd1f0aacb995f725c446b1cfcdc3124058e6a6/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/AbstractSpan.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.trace.AbstractSpan</code></a> ，Span <strong>接口</strong>( 不是抽象类 )，定义了 Span 通用属性的接口方法：</p><ul><li><code>#getSpanId()</code> 方法，获得 Span 编号。一个整数，在 TraceSegment 内<strong>唯一</strong>，从 0 开始自增，在创建 Span 对象时生成。</li><li><code>#setOperationName(operationName)</code> 方法，设置操作名。<ul><li>操作名，定义如下：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_01/01.png" alt=""></li><li><code>#setOperationId(operationId)</code> 方法，设置操作编号。考虑到操作名是字符串，Agent 发送给 Collector 占用流量较大。因此，Agent 会将操作注册到 Collector ，生成操作编号。在 <a href="http://www.iocoder.cn/SkyWalking/agent-dictionary/?self">《SkyWalking 源码分析 —— Agent DictionaryManager 字典管理》</a> 有详细解析。</li></ul></li><li><p><code>#setComponent(Component)</code> 方法，设置 <a href="https://github.com/YunaiV/skywalking/blob/a51e197a78f82400edae5c33b523ba1cb5224b8f/apm-network/src/main/java/org/skywalking/apm/network/trace/component/Component.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.network.trace.component.Component</code></a> ，例如：MongoDB / SpringMVC / Tomcat 等等。目前，官方在 <a href="https://github.com/YunaiV/skywalking/blob/a51e197a78f82400edae5c33b523ba1cb5224b8f/apm-network/src/main/java/org/skywalking/apm/network/trace/component/ComponentsDefine.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.network.trace.component.ComponentsDefine</code></a> 定义了目前已经支持的 Component 。</p><ul><li><p><code>#setComponent(componentName)</code> 方法，直接设置 Component 名字。大多数情况下，我们不使用该方法。</p><blockquote><p>Only use this method in explicit instrumentation, like opentracing-skywalking-bridge.<br>It it higher recommend don’t use this for performance consideration.</p></blockquote></li></ul></li><li><p><code>#setLayer(SpanLayer)</code> 方法，设置 <a href="https://github.com/YunaiV/skywalking/blob/a51e197a78f82400edae5c33b523ba1cb5224b8f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/NoopSpan.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.trace.SpanLayer</code></a> 。目前有，DB 、RPC_FRAMEWORK 、HTTP 、MQ ，未来会增加 CACHE 。</p></li><li><p><code>#tag(key, value)</code> 方法，设置键值对的标签。可以调用多次，构成 Span 的标签集合。在 <a href="#">「2.2.1 Tag」</a> 详细解析。</p></li><li>日志相关<ul><li><code>#log(timestampMicroseconds, fields)</code> 方法，记录一条通用日志，包含 <code>fields</code> 键值对集合。</li><li><code>#log(Throwable)</code> 方法，记录一条异常日志，包含异常信息。 </li></ul></li><li><code>#errorOccurred()</code> 方法，标记发生异常。大多数情况下，配置 <code>#log(Throwable)</code> 方法一起使用。</li><li><code>#start()</code> 方法，开始 Span 。一般情况的实现，设置开始时间。</li><li><code>#isEntry()</code> 方法，是否是入口 Span ，在 <a href="#">「2.2.2.1 EntrySpan」</a> 详细解析。</li><li><code>#isExit()</code> 方法，是否是出口 Span ，在 <a href="#">「2.2.2.2 ExitSpan」</a> 详细解析。</li></ul><h3 id="2-2-1-Tag"><a href="#2-2-1-Tag" class="headerlink" title="2.2.1 Tag"></a>2.2.1 Tag</h3><h4 id="2-2-1-1-AbstractTag"><a href="#2-2-1-1-AbstractTag" class="headerlink" title="2.2.1.1 AbstractTag"></a>2.2.1.1 AbstractTag</h4><p><a href="https://github.com/YunaiV/skywalking/blob/e0c449745dfabe847b2e918d5352381f191a4469/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/tag/AbstractTag.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.tag.AbstractTag&lt;T&gt;</code></a> ，标签<strong>抽象类</strong>。注意，这个类的用途是将标签属性设置到 Span 上，或者说，它是设置 Span 的标签的<strong>工具类</strong>。代码如下：</p><ul><li><code>key</code> 属性，标签的键。</li><li><code>#set(AbstractSpan span, T tagValue)</code> <strong>抽象</strong>方法，设置 Span 的标签键 <code>key</code> 的值为 <code>tagValue</code> 。</li></ul><h4 id="2-2-1-2-StringTag"><a href="#2-2-1-2-StringTag" class="headerlink" title="2.2.1.2 StringTag"></a>2.2.1.2 StringTag</h4><p><a href="https://github.com/YunaiV/skywalking/blob/e0c449745dfabe847b2e918d5352381f191a4469/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/tag/StringTag.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.tag.StringTag</code></a> ，值类型为 String 的标签<strong>实现类</strong>。</p><ul><li><code>#set(AbstractSpan span, String tagValue)</code> <strong>实现</strong>方法，设置 Span 的标签键 <code>key</code> 的值为 <code>tagValue</code> 。</li></ul><h4 id="2-2-1-3-Tags"><a href="#2-2-1-3-Tags" class="headerlink" title="2.2.1.3 Tags"></a>2.2.1.3 Tags</h4><p><a href="https://github.com/YunaiV/skywalking/blob/e0c449745dfabe847b2e918d5352381f191a4469/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/tag/Tags.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.tag.Tags</code></a> ，<strong>常用</strong> Tag <strong>枚举类</strong>，内部定义了<strong>多个</strong> HTTP 、DB 相关的 StringTag 的静态变量。</p><p>在 <a href="https://github.com/opentracing-contrib/opentracing-specification-zh/blob/master/semantic_conventions.md#%E6%A0%87%E5%87%86%E7%9A%84span-tag-%E5%92%8C-log-field" rel="external nofollow noopener noreferrer" target="_blank">《opentracing-specification-zh —— 语义惯例》</a> 里，定义了标准的 Span Tag 。</p><h3 id="2-2-2-AbstractSpan-实现类"><a href="#2-2-2-AbstractSpan-实现类" class="headerlink" title="2.2.2 AbstractSpan 实现类"></a>2.2.2 AbstractSpan 实现类</h3><p>AbstractSpan 实现类如下图：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_01/03.png" alt=""></p><ul><li>左半边的 Span 实现类：<strong>有</strong>具体操作的 Span 。</li><li>右半边的 Span 实现类：<strong>无</strong>具体操作的 Span ，和左半边的 Span 实现类<strong>相对</strong>，用于不需要收集 Span 的场景。</li></ul><p>抛开右半边的 Span 实现类的特殊处理，Span 只有三种实现类：</p><ul><li>EntrySpan ：入口 Span</li><li>LocalSpan ：本地 Span</li><li>ExitSpan ：出口 Span</li></ul><p>下面，我们分小节逐步分享。</p><h4 id="2-2-2-1-AbstractTracingSpan"><a href="#2-2-2-1-AbstractTracingSpan" class="headerlink" title="2.2.2.1 AbstractTracingSpan"></a>2.2.2.1 AbstractTracingSpan</h4><p><a href="https://github.com/YunaiV/skywalking/blob/11b66b8d36943d6492f51c676b455f29c9c0abc6/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/AbstractTracingSpan.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.trace.AbstractTracingSpan</code></a> ，实现 AbstractSpan 接口，链路追踪 Span <strong>抽象类</strong>。</p><p>在创建 AbstractTracingSpan 时，会传入 <code>spanId</code> , <code>parentSpanId</code> , <code>operationName</code> / <code>operationId</code> 参数。参见构造方法：</p><ul><li><code>#AbstractTracingSpan(spanId, parentSpanId, operationName)</code></li><li><code>#AbstractTracingSpan(spanId, parentSpanId, operationId)</code></li></ul><hr><p>大部分是 setting / getting 方法，或者类似方法，已经添加注释，胖友自己阅读。</p><p><a href="https://github.com/YunaiV/skywalking/blob/11b66b8d36943d6492f51c676b455f29c9c0abc6/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/AbstractTracingSpan.java#L126" rel="external nofollow noopener noreferrer" target="_blank"><code>#finish(TraceSegment)</code></a> 方法，完成( 结束 ) Span ，将当前 Span ( 自己 )添加到 TraceSegment 。为什么会调用该方法，在 <a href="#">「3. Context」</a> 详细解析。</p><h4 id="2-2-2-2-StackBasedTracingSpan"><a href="#2-2-2-2-StackBasedTracingSpan" class="headerlink" title="2.2.2.2 StackBasedTracingSpan"></a>2.2.2.2 StackBasedTracingSpan</h4><p> <a href="https://github.com/YunaiV/skywalking/blob/c1e513b4581443e7ca720f4e9c91ad97cc6f0de1/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/StackBasedTracingSpan.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.trace.StackBasedTracingSpan</code></a> ，实现 AbstractTracingSpan 抽象类，基于<strong>栈</strong>的链路追踪 Span 抽象类。这种 Span 能够被多次调用 <code>#start(...)</code> 和 <code>#finish(...)</code> 方法，在类似堆栈的调用中。在 <a href="#">「2.2.2.2.1 EntrySpan」</a> 中详细举例子。代码如下：</p><ul><li><code>stackDepth</code> 属，<strong>栈</strong>深度。</li><li><a href="https://github.com/YunaiV/skywalking/blob/c1e513b4581443e7ca720f4e9c91ad97cc6f0de1/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/StackBasedTracingSpan.java#L52" rel="external nofollow noopener noreferrer" target="_blank"><code>#finish(TraceSegment)</code></a> <strong>实现</strong>方法，完成( 结束 ) Span ，将当前 Span ( 自己 )添加到 TraceSegment 。<strong>当且仅当 <code>stackDepth == 0</code> 时，添加成功</strong>。代码如下：<ul><li>第 53 至 73 行：栈深度为零，出栈成功。调用 <code>super#finish(TraceSegment)</code> 方法，完成( 结束 ) Span ，将当前 Span ( 自己 )添加到 TraceSegment 。<ul><li>第 55 至 72 行：当操作编号为空时，尝试使用操作名获得操作编号并设置。用于<strong>减少</strong> Agent 发送 Collector 数据的网络流量。</li></ul></li><li>第 74 至 76 行：栈深度非零，出栈失败。</li></ul></li></ul><h5 id="2-2-2-2-1-EntrySpan"><a href="#2-2-2-2-1-EntrySpan" class="headerlink" title="2.2.2.2.1 EntrySpan"></a>2.2.2.2.1 EntrySpan</h5><p><strong>重点</strong></p><p><a href="https://github.com/YunaiV/skywalking/blob/d36f6a47a208720f4caac9d9a8b7263bd36f2187/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/EntrySpan.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.trace.EntrySpan</code></a> ，实现 StackBasedTracingSpan 抽象类，<strong>入口</strong> Span ，用于服务提供者( Service Provider ) ，例如 Tomcat 。</p><p>EntrySpan 是 TraceSegment 的第一个 Span ，这也是为什么称为”<strong>入口</strong>“ Span 的原因。</p><p><strong>那么为什么 EntrySpan 继承 StackBasedTracingSpan</strong> ？</p><p>例如，我们常用的 SprintBoot 场景下，Agent 会在 SkyWalking 插件在 Tomcat 定义的方法切面，创建 EntrySpan 对象，也会在 SkyWalking 插件在 SpringMVC 定义的方法切面，创建 EntrySpan 对象。那岂不是出现<strong>两个</strong> EntrySpan ，一个 TraceSegment 出现了两个入口 Span ？</p><p>答案是当然不会！Agent 只会在第一个方法切面，生成 EntrySpan 对象，第二个方法切面，栈深度 <strong>+ 1</strong>。这也是上面我们看到的 <code>#finish(TraceSegment)</code> 方法，只在栈深度为零时，出栈成功。通过这样的方式，保持一个 TraceSegment 有且仅有一个 EntrySpan 对象。</p><p>当然，多个 TraceSegment 会有多个 EntrySpan 对象 ，例如【服务 A】远程调用【服务 B】。</p><p>另外，虽然 EntrySpan 在第一个服务提供者创建，EntrySpan 代表的是最后一个服务提供者，例如，上面的例子，EntrySpan 代表的是 Spring MVC 的方法切面。所以，<code>startTime</code> 和 <code>endTime</code> 以第一个为准，<code>componentId</code> 、<code>componentName</code> 、<code>layer</code> 、<code>logs</code> 、<code>tags</code> 、<code>operationName</code> 、<code>operationId</code> 等等以最后一个为准。并且，一般情况下，最后一个服务提供者的信息也会<strong>更加详细</strong>。</p><p><strong>ps</strong>：如上内容信息量较大，胖友可以对照着实现方法，在理解理解。HOHO ，良心笔者当然也是加了注释的。</p><p>如下是一个 EntrySpan 在 SkyWalking 展示的例子：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_01/04.png" alt=""></p><h5 id="2-2-2-2-2-ExitSpan"><a href="#2-2-2-2-2-ExitSpan" class="headerlink" title="2.2.2.2.2 ExitSpan"></a>2.2.2.2.2 ExitSpan</h5><p><strong>重点</strong></p><p><a href="https://github.com/YunaiV/skywalking/blob/958830d8db481b5b8a70498a09bc18eb7c721737/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/ExitSpan.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.trace.ExitSpan</code></a> ，继承 StackBasedTracingSpan 抽象类，<strong>出口</strong> Span ，用于服务消费者( Service Consumer ) ，例如 HttpClient 、MongoDBClient 。</p><hr><p>ExitSpan 实现 <a href="https://github.com/YunaiV/skywalking/blob/958830d8db481b5b8a70498a09bc18eb7c721737/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/WithPeerInfo.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.trace.WithPeerInfo</code></a> 接口，代码如下：</p><ul><li><code>peer</code> 属性，节点地址。</li><li><code>peerId</code> 属性，节点编号。</li></ul><p>如下是一个 ExitSpan 在 SkyWalking 展示的例子：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_01/05.png" alt=""></p><hr><p><strong>那么为什么 ExitSpan 继承 StackBasedTracingSpan</strong> ？</p><p>例如，我们可能在使用的 Dubbox 场景下，【Dubbox 服务 A】使用 HTTP 调用【Dubbox 服务 B】时，实际过程是，【Dubbox 服务 A】=》【HttpClient】=》【Dubbox 服务 B】。Agent 会在【Dubbox 服务 A】创建 ExitSpan 对象，也会在 【HttpClient】创建 ExitSpan 对象。那岂不是<strong>一次出口</strong>，出现<strong>两个</strong> ExitSpan ？</p><p>答案是当然不会！Agent 只会在【Dubbox 服务 A】，生成 EntrySpan 对象，第二个方法切面，栈深度 <strong>+ 1</strong>。这也是上面我们看到的 <code>#finish(TraceSegment)</code> 方法，只在栈深度为零时，出栈成功。通过这样的方式，保持<strong>一次出口</strong>有且仅有一个 ExitSpan 对象。</p><p>当然，一个 TraceSegment 会有多个 ExitSpan 对象 ，例如【服务 A】远程调用【服务 B】，然后【服务 A】再次远程调用【服务 B】，或者然后【服务 A】远程调用【服务 C】。</p><p>另外，虽然 ExitSpan 在第一个消费者创建，ExitSpan 代表的也是第一个服务提消费者，例如，上面的例子，ExitSpan 代表的是【Dubbox 服务 A】。</p><p><strong>ps</strong>：如上内容信息量较大，胖友可以对照着实现方法，在理解理解。HOHO ，良心笔者当然也是加了注释的。</p><h4 id="2-2-2-3-LocalSpan"><a href="#2-2-2-3-LocalSpan" class="headerlink" title="2.2.2.3 LocalSpan"></a>2.2.2.3 LocalSpan</h4><p><a href="https://github.com/YunaiV/skywalking/blob/96fd1f0aacb995f725c446b1cfcdc3124058e6a6/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/LocalSpan.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.trace.LocalSpan</code></a> ，继承 AbstractTracingSpan 抽象类，本地 Span ，用于一个普通方法的链路追踪，例如本地方法。</p><p>如下是一个 EntrySpan 在 SkyWalking 展示的例子：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_01/06.png" alt=""></p><h4 id="2-2-2-4-NoopSpan"><a href="#2-2-2-4-NoopSpan" class="headerlink" title="2.2.2.4 NoopSpan"></a>2.2.2.4 NoopSpan</h4><p><a href="https://github.com/YunaiV/skywalking/blob/f00d2f405ca23e89778febeb4ada7b389858f258/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/NoopSpan.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.trace.NoopSpan</code></a> ，实现 AbstractSpan 接口，<strong>无操作</strong>的 Span 。配置 IgnoredTracerContext 一起使用，在 IgnoredTracerContext 声明<a href="https://github.com/YunaiV/skywalking/blob/f00d2f405ca23e89778febeb4ada7b389858f258/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/IgnoredTracerContext.java#L37" rel="external nofollow noopener noreferrer" target="_blank">单例</a> ，以减少不收集 Span 时的对象创建，达到减少内存使用和 GC 时间。</p><h5 id="2-2-2-3-1-NoopExitSpan"><a href="#2-2-2-3-1-NoopExitSpan" class="headerlink" title="2.2.2.3.1 NoopExitSpan"></a>2.2.2.3.1 NoopExitSpan</h5><p><a href="https://github.com/YunaiV/skywalking/blob/f00d2f405ca23e89778febeb4ada7b389858f258/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/ExitSpan.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.trace.NoopExitSpan</code></a> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/958830d8db481b5b8a70498a09bc18eb7c721737/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/WithPeerInfo.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.trace.WithPeerInfo</code></a> 接口，继承 StackBasedTracingSpan 抽象类，<strong>出口</strong> Span ，无操作的<strong>出口</strong> Span 。和 ExitSpan <strong>相对</strong>，不记录服务消费者的出口 Span 。</p><h2 id="2-3-TraceSegmentRef"><a href="#2-3-TraceSegmentRef" class="headerlink" title="2.3 TraceSegmentRef"></a>2.3 TraceSegmentRef</h2><p><a href="https://github.com/YunaiV/skywalking/blob/49dc81a8bcaad1879b3a3be9917944b0b8b5a7a4/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegmentRef.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.trace.TraceSegmentRef</code></a> ，TraceSegment 指向，通过 <code>traceSegmentId</code> 和 <code>spanId</code> 属性，指向父级 TraceSegment 的指定 Span 。</p><ul><li><p><code>type</code> 属性，指向类型( <a href="https://github.com/YunaiV/skywalking/blob/49dc81a8bcaad1879b3a3be9917944b0b8b5a7a4/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegmentRef.java#L206" rel="external nofollow noopener noreferrer" target="_blank">SegmentRefType</a> ) 。不同的指向类型，使用不同的构造方法。</p><ul><li><code>CROSS_PROCESS</code> ，跨进程，例如远程调用，对应构造方法 <a href="https://github.com/YunaiV/skywalking/blob/49dc81a8bcaad1879b3a3be9917944b0b8b5a7a4/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegmentRef.java#L97" rel="external nofollow noopener noreferrer" target="_blank">#TraceSegmentRef(ContextCarrier)</a> 。 </li><li><code>CROSS_THREAD</code> ，跨线程，例如异步线程任务，对应构造方法 <a href="https://github.com/YunaiV/skywalking/blob/49dc81a8bcaad1879b3a3be9917944b0b8b5a7a4/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegmentRef.java#L123" rel="external nofollow noopener noreferrer" target="_blank">#TraceSegmentRef(ContextSnapshot)</a> 。</li><li>构造方法的代码，在 <a href="#">「3. Context」</a> 中，伴随着调用过程，一起解析。</li></ul></li><li><p><code>traceSegmentId</code> 属性，<strong>父</strong> TraceSegment 编号。<strong>重要</strong></p></li><li><code>spanId</code> 属性，<strong>父</strong> Span 编号。<strong>重要</strong></li><li><code>peerId</code> 属性，节点编号。<strong>注意，此处的节点编号就是应用( Application )编号</strong>。</li><li><code>peerHost</code> 属性，节点地址。</li><li><code>entryApplicationInstanceId</code> 属性，<strong>入口</strong>应用实例编号。例如，在一个分布式链路 <code>A-&gt;B-&gt;C</code> 中，此字段为 A 应用的实例编号。</li><li><code>parentApplicationInstanceId</code> 属性，<strong>父</strong>应用实例编号。</li><li><code>entryOperationName</code> 属性，<strong>入口</strong>操作名。</li><li><code>entryOperationId</code> 属性，<strong>入口</strong>操作编号。</li><li><code>parentOperationName</code> 属性，<strong>父</strong>操作名。</li><li><code>parentOperationId</code> 属性，<strong>父</strong>操作编号。</li></ul><h2 id="2-4-TraceSegment"><a href="#2-4-TraceSegment" class="headerlink" title="2.4 TraceSegment"></a>2.4 TraceSegment</h2><p>在看完了 TraceSegment 的各个元素，我们来看看 TraceSegment 内部实现的方法。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ad259ad680df86296036910ede262765ffb44e5e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegment.java#L79" rel="external nofollow noopener noreferrer" target="_blank">TraceSegment 构造方法</a>，代码如下：</p><ul><li>第 80 行：调用 <code>GlobalIdGenerator#generate()</code> 方法，生成 ID 对象，赋值给 <code>traceSegmentId</code> 。</li><li>第 81 行：创建 <code>spans</code> 数组。<ul><li><a href="https://github.com/YunaiV/skywalking/blob/ad259ad680df86296036910ede262765ffb44e5e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegment.java#L114" rel="external nofollow noopener noreferrer" target="_blank"><code>#archive(AbstractTracingSpan)</code></a> 方法，被 <code>AbstractSpan#finish(TraceSegment)</code> 方法调用，添加到 <code>spans</code> 数组。</li></ul></li><li>第 83 至 84 行：创建 DistributedTraceIds 对象，并添加 NewDistributedTraceId 到它。<ul><li><strong>注意</strong>，当 TraceSegment 是一次分布式链路追踪的<strong>首条</strong>记录，创建的 NewDistributedTraceId 对象，即为分布式链路追踪的<strong>全局编号</strong>。</li><li><a href="https://github.com/YunaiV/skywalking/blob/ad259ad680df86296036910ede262765ffb44e5e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegment.java#L104" rel="external nofollow noopener noreferrer" target="_blank"><code>#relatedGlobalTraces(DistributedTraceId)</code></a> 方法，添加 DistributedTraceId 对象。被 <code>TracingContext#continued(ContextSnapshot)</code> 或者 <code>TracingContext#extract(ContextCarrier)</code> 方法调用，在 <a href="#">「3. Context」</a> 详细解析。</li></ul></li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/ad259ad680df86296036910ede262765ffb44e5e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegment.java#L92" rel="external nofollow noopener noreferrer" target="_blank"><code>#ref(TraceSegmentRef)</code></a> 方法，添加 TraceSegmentRef 对象，到 <code>refs</code> 属性，即<strong>指向</strong>父 Segment 。</p><h1 id="3-Context"><a href="#3-Context" class="headerlink" title="3. Context"></a>3. Context</h1><p>在 <a href="#">「2. Trace」</a> 中，我们看了 Trace 的数据结构，本小节，我们一起来看看 Context 是怎么收集 Trace 数据的。</p><h2 id="3-1-ContextManager"><a href="#3-1-ContextManager" class="headerlink" title="3.1 ContextManager"></a>3.1 ContextManager</h2><p><code>org.skywalking.apm.agent.core.context.ContextManager</code> ，实现了 BootService 、TracingContextListener 、IgnoreTracerContextListener 接口，链路追踪上下文管理器。</p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/ad259ad680df86296036910ede262765ffb44e5e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ContextManager.java#L52" rel="external nofollow noopener noreferrer" target="_blank"><code>CONTEXT</code></a> <strong>静态</strong>属性，线程变量，存储 AbstractTracerContext 对象。为什么是<strong>线程变量</strong>呢？</p><p><strong>一个</strong> TraceSegment 对象，关联到<strong>一个</strong>线程，负责收集该线程的链路追踪数据，因此使用线程变量。</p><p>而<strong>一个</strong> AbstractTracerContext 会关联<strong>一个</strong> TraceSegment 对象，ContextManager 负责获取、创建、销毁 AbstractTracerContext 对象。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ad259ad680df86296036910ede262765ffb44e5e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ContextManager.java#L61" rel="external nofollow noopener noreferrer" target="_blank"><code>#getOrCreate(operationName, forceSampling)</code></a> <strong>静态</strong>方法，获取 AbstractTracerContext 对象。若不存在，进行<strong>创建</strong>。</p><ul><li><strong>要</strong>需要收集 Trace 数据的情况下，创建 <a href="https://github.com/YunaiV/skywalking/blob/ad259ad680df86296036910ede262765ffb44e5e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java" rel="external nofollow noopener noreferrer" target="_blank">TracingContext</a> 对象。</li><li><strong>不</strong>需要收集 Trace 数据的情况下，创建 <a href="https://github.com/YunaiV/skywalking/blob/ad259ad680df86296036910ede262765ffb44e5e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/IgnoredTracerContext.java" rel="external nofollow noopener noreferrer" target="_blank">IgnoredTracerContext</a> 对象。</li></ul><p>在下面的 <code>#createEntrySpan(...)</code> 、<code>#createLocalSpan(...)</code> 、<code>#createExitSpan(...)</code> 等等方法中，都会调用 AbstractTracerContext 提供的方法。这些方法的代码，我们放在 <a href="#">「3.2 AbstractTracerContext」</a> 一起解析，保证流程的整体性。</p><p>另外，ContextManager 封装了<strong>所有</strong> AbstractTracerContext 提供的方法，从而实现，外部调用者，例如 SkyWalking 的插件，只调用 ContextManager 的方法，而不调用 AbstractTracerContext 的方法。</p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/ad259ad680df86296036910ede262765ffb44e5e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ContextManager.java#L201" rel="external nofollow noopener noreferrer" target="_blank"><code>#boot()</code></a> <strong>实现</strong>方法，启动时，将自己注册到 <a href="">TracingContext.ListenerManager</a> 和 <a href="">IgnoredTracerContext.ListenerManager</a> 中，这样一次链路追踪上下文( Context )完成时，从而被回调如下方法，清理上下文：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/ad259ad680df86296036910ede262765ffb44e5e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ContextManager.java#L216" rel="external nofollow noopener noreferrer" target="_blank"><code>#afterFinished(TraceSegment)</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/ad259ad680df86296036910ede262765ffb44e5e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ContextManager.java#L221" rel="external nofollow noopener noreferrer" target="_blank"><code>#afterFinished(IgnoredTracerContext)</code></a></li></ul><h2 id="3-2-AbstractTracerContext"><a href="#3-2-AbstractTracerContext" class="headerlink" title="3.2 AbstractTracerContext"></a>3.2 AbstractTracerContext</h2><p><a href="https://github.com/YunaiV/skywalking/blob/2a75efbeddac2b9565816af0ab0873ec3d998424/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/AbstractTracerContext.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.AbstractTracerContext</code></a> ，链路追踪上下文<strong>接口</strong>。定义了如下方法：</p><ul><li><code>#getReadableGlobalTraceId()</code> 方法，获得<strong>关联</strong>的全局链路追踪编号。</li><li><code>#createEntrySpan(operationName)</code> 方法，创建 EntrySpan 对象。</li><li><code>#createLocalSpan(operationName)</code> 方法，创建 LocalSpan 对象。</li><li><code>#createExitSpan(operationName, remotePeer)</code> 方法，创建 ExitSpan 对象。</li><li><code>#activeSpan()</code> 方法，获得当前<strong>活跃</strong>的 Span 对象。</li><li><code>#stopSpan(AbstractSpan)</code> 方法，停止( 完成 )指定 AbstractSpan 对象。</li><li>——— 跨进程( cross-process ) ———</li><li><code>#inject(ContextCarrier)</code> 方法，将 Context <strong>注入</strong>到 ContextCarrier ，用于跨进程，<strong>传播</strong>上下文。</li><li><code>#extract(ContextCarrier)</code> 方法，将 ContextCarrier <strong>解压</strong>到 Context ，用于跨进程，<strong>接收</strong>上下文。</li><li>——— 跨线程( cross-thread ) ———</li><li><code>#capture()</code> 方法，将 Context <strong>快照</strong>到 ContextSnapshot ，用于跨线程，<strong>传播</strong>上下文。</li><li><code>#continued(ContextSnapshot)</code> 方法，将 ContextSnapshot <strong>解压</strong>到 Context ，用于跨线程，<strong>接收</strong>上下文。</li></ul><h3 id="3-2-1-TracingContext"><a href="#3-2-1-TracingContext" class="headerlink" title="3.2.1 TracingContext"></a>3.2.1 TracingContext</h3><p><code>org.skywalking.apm.agent.core.context.TracingContext</code> ，实现 AbstractTracerContext 接口，链路追踪上下文<strong>实现类</strong>。</p><ul><li><code>segment</code> 属性，上下文对应的 TraceSegment 对象。</li><li><code>activeSpanStack</code> 属性，AbstractSpan <strong>链表</strong>数组，收集当前<strong>活跃</strong>的 Span 对象。正如方法的调用与执行一样，在一个<strong>调用栈</strong>中，先执行的方法后结束。</li><li><code>spanIdGenerator</code> 属性，Span 编号自增序列。创建的 Span 的编号，通过该变量自增生成。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/2a75efbeddac2b9565816af0ab0873ec3d998424/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L79" rel="external nofollow noopener noreferrer" target="_blank">TracingContext 构造方法</a> ，代码如下：</p><ul><li>第 80 行：创建 TraceSegment 对象。</li><li>第 81 行：设置 <code>spanIdGenerator = 0</code> 。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/5eb4b28e18e8a47de10ec331a9667444d16f4933/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L79" rel="external nofollow noopener noreferrer" target="_blank"><code>#getReadableGlobalTraceId()</code></a> <strong>实现</strong>方法，获得 TraceSegment 的<strong>首个</strong> DistributedTraceId 作为返回。</p><h4 id="3-2-1-1-创建-EntrySpan"><a href="#3-2-1-1-创建-EntrySpan" class="headerlink" title="3.2.1.1 创建 EntrySpan"></a>3.2.1.1 创建 EntrySpan</h4><p>调用 <a href="https://github.com/YunaiV/skywalking/blob/5eb4b28e18e8a47de10ec331a9667444d16f4933/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ContextManager.java#L118" rel="external nofollow noopener noreferrer" target="_blank"><code>ContextManager#createEntrySpan(operationName, carrier)</code></a> 方法，创建 EntrySpan 对象。代码如下：</p><ul><li>第 121 至 131 行：调用 <code>#getOrCreate(operationName, forceSampling)</code> 方法，获取 AbstractTracerContext 对象。若不存在，进行创建。<ul><li>第 122 至 125 行：有<strong>传播</strong> Context 的情况下，<strong>强制</strong>收集 Trace 数据。</li><li>第 127 行：调用 <code>TracingContext#extract(ContextCarrier)</code> 方法，将 ContextCarrier <strong>解压</strong>到 Context ，<strong>跨进程</strong>，接收上下文。在 <a href="#">「3.2.3 ContextCarrier」</a> 详细解析。</li></ul></li><li>第 133 行：调用 <code>TracingContext#createEntrySpan(operationName)</code> 方法，创建 EntrySpan 对象。</li></ul><hr><p>调用 <a href="https://github.com/YunaiV/skywalking/blob/5eb4b28e18e8a47de10ec331a9667444d16f4933/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L230" rel="external nofollow noopener noreferrer" target="_blank"><code>TracingContext#createEntrySpan(operationName)</code></a> 方法，创建 EntrySpan 对象。代码如下：</p><ul><li>第 223 至 227 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/5eb4b28e18e8a47de10ec331a9667444d16f4933/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L500" rel="external nofollow noopener noreferrer" target="_blank"><code>#isLimitMechanismWorking()</code></a> 方法，判断 Span 数量<strong>超过上限</strong>，创建 NoopSpan 对象，并调用 <code>#push(AbstractSpan)</code> 方法，添加到 <code>activeSpanStack</code> 中。</li><li>第 229 至 231 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/5eb4b28e18e8a47de10ec331a9667444d16f4933/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L489" rel="external nofollow noopener noreferrer" target="_blank"><code>#peek()</code></a> 方法，获得当前活跃的 AbstractSpan 对象。</li><li>第 232 至 249 行：若<strong>父</strong> Span 对象不存在，创建 EntrySpan 对象。<ul><li>第 235 至 244 行：创建 EntrySpan 对象。</li><li>第 247 行：调用 <code>EntrySpan#start()</code> 方法，开始 EntrySpan 。</li><li>第 249 行：调用 <code>#push(AbstractSpan)</code> 方法，添加到 <code>activeSpanStack</code> 中。</li></ul></li><li>第 251 至 264 行：若<strong>父</strong> EntrySpan 对象存在，<strong>重新</strong>开始 EntrySpan 。参见 <a href="#">「2.2.2.2.1 EntrySpan」</a> 。</li><li>第 265 至 267 行：<code>&quot;The Entry Span can&#39;t be the child of Non-Entry Span&quot;</code> 。</li></ul><h4 id="3-2-1-2-创建-LocalSpan"><a href="#3-2-1-2-创建-LocalSpan" class="headerlink" title="3.2.1.2 创建 LocalSpan"></a>3.2.1.2 创建 LocalSpan</h4><p>调用 <a href="https://github.com/YunaiV/skywalking/blob/97777afc4975ee3bd466fd8870d7dbbc3da9ddd0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ContextManager.java#L136" rel="external nofollow noopener noreferrer" target="_blank"><code>ContextManager#createLocalSpan(operationName)</code></a> 方法，创建 LocalSpan 对象。</p><ul><li>第 138 行：调用 <code>#getOrCreate(operationName, forceSampling)</code> 方法，获取 AbstractTracerContext 对象。若不存在，进行创建。</li><li>第 140 行：调用 <code>TracingContext#createLocalSpan(operationName)</code> 方法，创建 LocalSpan 对象。</li></ul><hr><p>调用 <a href="https://github.com/YunaiV/skywalking/blob/97777afc4975ee3bd466fd8870d7dbbc3da9ddd0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L278" rel="external nofollow noopener noreferrer" target="_blank"><code>TracingContext#createLocalSpan(operationName)</code></a> 方法，创建 LocalSpan 对象。代码如下：</p><ul><li>第 280 至 283 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/5eb4b28e18e8a47de10ec331a9667444d16f4933/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L500" rel="external nofollow noopener noreferrer" target="_blank"><code>#isLimitMechanismWorking()</code></a> 方法，判断 Span 数量<strong>超过上限</strong>，创建 NoopSpan 对象，并调用 <code>#push(AbstractSpan)</code> 方法，添加到 <code>activeSpanStack</code> 中。</li><li>第 284 至 286 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/5eb4b28e18e8a47de10ec331a9667444d16f4933/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L489" rel="external nofollow noopener noreferrer" target="_blank"><code>#peek()</code></a> 方法，获得当前活跃的 AbstractSpan 对象。</li><li>第 288 至 300 行：创建 LocalSpan 对象。</li><li>第 302 行：调用 <code>LocalSpan#start()</code> 方法，开始 LocalSpan 。</li><li>第 304 行：调用 <code>#push(AbstractSpan)</code> 方法，添加到 <code>activeSpanStack</code> 中。</li></ul><h4 id="3-2-1-3-创建-ExitSpan"><a href="#3-2-1-3-创建-ExitSpan" class="headerlink" title="3.2.1.3 创建 ExitSpan"></a>3.2.1.3 创建 ExitSpan</h4><p>调用 <a href="https://github.com/YunaiV/skywalking/blob/97777afc4975ee3bd466fd8870d7dbbc3da9ddd0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ContextManager.java#L143" rel="external nofollow noopener noreferrer" target="_blank"><code>ContextManager#createExitSpan(operationName, carrier, remotePeer)</code></a> 方法，创建 ExitSpan 对象。</p><ul><li>第 148 行：调用 <code>#getOrCreate(operationName, forceSampling)</code> 方法，获取 AbstractTracerContext 对象。若不存在，进行创建。</li><li>第 150 行：调用 <code>TracingContext#createExitSpan(operationName, remotePeer)</code> 方法，创建 ExitSpan 对象。</li><li>第 160 行：<code>TracingContext#inject(ContextCarrier)</code> 方法，将 Context <strong>注入</strong>到 ContextCarrier ，<strong>跨进程</strong>，传播上下文。在 <a href="#">「3.2.3 ContextCarrier」</a> 详细解析。</li></ul><hr><p>调用 <a href="https://github.com/YunaiV/skywalking/blob/5eb4b28e18e8a47de10ec331a9667444d16f4933/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L230" rel="external nofollow noopener noreferrer" target="_blank"><code>TracingContext#createEntrySpan(operationName)</code></a> 方法，创建 ExitSpan 对象。代码如下：</p><ul><li>第 319 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/5eb4b28e18e8a47de10ec331a9667444d16f4933/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L489" rel="external nofollow noopener noreferrer" target="_blank"><code>#peek()</code></a> 方法，获得当前活跃的 AbstractSpan 对象。</li><li>第 320 至 322 行：若 ExitSpan 对象存在，直接使用，不重新创建。参见 <a href="#">「2.2.2.2.2 ExitSpan」</a> 。</li><li>第 324 至 377 行：创建 ExitSpan 对象，并添加到 <code>activeSpanStack</code> 中。<ul><li>第 327 行：根据 <code>remotePeer</code> 参数，查找 <code>peerId</code> 。<strong>注意</strong>，此处会创建一个 Application 对象，通过 ServiceMapping 表，和远程的 Application 进行<strong>匹配映射</strong>。后续有文章会分享这块。</li><li>第 322 至 324 行 || 第 335 至 358 行：判断 Span 数量<strong>超过上限</strong>，创建 NoopExitSpan 对象，并调用 <code>#push(AbstractSpan)</code> 方法，添加到 <code>activeSpanStack</code> 中。</li></ul></li><li>第 380 行：开始 ExitSpan 。</li></ul><h4 id="3-2-1-4-结束-Span"><a href="#3-2-1-4-结束-Span" class="headerlink" title="3.2.1.4 结束 Span"></a>3.2.1.4 结束 Span</h4><p>调用 <a href="https://github.com/YunaiV/skywalking/blob/85effa4f5752bdfe3efa43294293af0634a40626/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L316" rel="external nofollow noopener noreferrer" target="_blank"><code>ContextManager#stopSpan()</code></a> 方法，结束 Span 。代码如下：</p><ul><li>第 199 行：调用 <code>TracingContext#stopSpan(AbstractSpan)</code> 方法，结束 Span 。<strong>当所有活跃的 Span 都被结束后，当前线程的 TraceSegment 完成</strong>。</li></ul><hr><p>调用 <a href="https://github.com/YunaiV/skywalking/blob/7b39e952da408f722a53168e6d6a0cd7e7ff372f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L403" rel="external nofollow noopener noreferrer" target="_blank"><code>TracingContext#stopSpan(AbstractSpan)</code></a> 方法，结束 Span 。代码如下：</p><ul><li>第 405 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/5eb4b28e18e8a47de10ec331a9667444d16f4933/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L489" rel="external nofollow noopener noreferrer" target="_blank"><code>#peek()</code></a> 方法，获得当前活跃的 AbstractSpan 对象。</li><li>第 408 至 414 行：当 Span 为 AbstractTracingSpan 的子类，即记录链路追踪的 Span ，调用 <code>AbstractTracingSpan#finish(TraceSegment)</code> 方法，完成 Span 。<ul><li>当完成<strong>成功</strong>时，调用 <code>#pop()</code> 方法，移除出 <code>activeSpanStack</code> 。</li><li>当完成<strong>失败</strong>时，原因参见 <a href="#">「2.2.2.2 StackBasedTracingSpan」</a> 。</li></ul></li><li>第 416 至 419 行：当 Span 为 NoopSpan 的子类，即不记录链路追踪的 Span ，调用 <code>#pop()</code> 方法，移除出 <code>activeSpanStack</code> 。</li><li>第 425 至 427 行：当所有活跃的 Span 都被结束后，调用 <code>#finish()</code> 方法，当前线程的 TraceSegment 完成。</li></ul><hr><p>调用 <a href="https://github.com/YunaiV/skywalking/blob/7b39e952da408f722a53168e6d6a0cd7e7ff372f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L434" rel="external nofollow noopener noreferrer" target="_blank"><code>TracingContext#stopSpan(AbstractSpan)</code></a> 方法，完成 Context 。代码如下：</p><ul><li>第 436 行：调用 <code>TraceSegment#finish(isSizeLimited)</code> 方法，完成 TraceSegment 。</li><li>第 444 至 448 行：若满足条件，调用 <code>TraceSegment#setIgnore(true)</code> 方法，标记该 TraceSegment 忽略，不发送给 Collector 。<ul><li><code>!samplingService.trySampling()</code> ：不采样。 </li><li><code>!segment.hasRef()</code> ：无父 TraceSegment 指向。如果此处忽略采样，则会导致整条分布式链路追踪<strong>不完整</strong>。</li><li><code>segment.isSingleSpanSegment()</code> ：TraceSegment 只有<strong>一个</strong> Span 。</li><li>TODO 【4010】</li></ul></li><li>第 450 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/7b39e952da408f722a53168e6d6a0cd7e7ff372f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L476" rel="external nofollow noopener noreferrer" target="_blank"><code>TracingContext.ListenerManager#notifyFinish(TraceSegment)</code></a> 方法，通知监听器，一次 TraceSegment 完成。通过这样的方式，TraceSegment 会被 <a href="https://github.com/YunaiV/skywalking/blob/7b39e952da408f722a53168e6d6a0cd7e7ff372f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/TraceSegmentServiceClient.java#L157" rel="external nofollow noopener noreferrer" target="_blank">TraceSegmentServiceClient</a> <strong>异步</strong>发送给 Collector 。下一篇文章，我们详细分享发送的过程。</li></ul><h3 id="3-2-2-IgnoredTracerContext"><a href="#3-2-2-IgnoredTracerContext" class="headerlink" title="3.2.2 IgnoredTracerContext"></a>3.2.2 IgnoredTracerContext</h3><p><a href="https://github.com/YunaiV/skywalking/blob/7b39e952da408f722a53168e6d6a0cd7e7ff372f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/IgnoredTracerContext.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.IgnoredTracerContext</code></a> ，实现 AbstractTracerContext 接口，忽略( <strong>不记录</strong> )链路追踪的上下文。代码如下：</p><ul><li><code>NOOP_SPAN</code> <strong>静态</strong>属性，NoopSpan 单例。<ul><li>所有的创建 Span 方法，返回的都是该对象。</li></ul></li><li><code>stackDepth</code> 属性，栈深度。<ul><li>不同于 TracingContext 使用<strong>链式数组</strong>来处理 Span 的<strong>出入栈</strong>，IgnoredTracerContext 使用 <code>stackDepth</code> 来计数，从而实现<strong>出入栈</strong>的效果。</li></ul></li><li>通过这两个属性和相应<strong>空</strong>方法的实现，以减少 NoopSpan 时的对象创建，达到减少内存使用和 GC 时间。</li></ul><p>代码比较简单，胖友自己阅读该类的实现。</p><h3 id="3-2-3-ContextCarrier"><a href="#3-2-3-ContextCarrier" class="headerlink" title="3.2.3 ContextCarrier"></a>3.2.3 ContextCarrier</h3><p><a href="https://github.com/YunaiV/skywalking/blob/4c4c62d0d5ec2ce17e3d36cad0f6598247b582e1/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ContextCarrier.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.ContextCarrier</code></a> ，实现 <code>java.io.Serializable</code> 接口，<strong>跨进程</strong> Context 传输<strong>载体</strong>。</p><h4 id="3-2-3-1-解压"><a href="#3-2-3-1-解压" class="headerlink" title="3.2.3.1 解压"></a>3.2.3.1 解压</h4><p>我们来打开 <a href="https://github.com/YunaiV/skywalking/blob/4c4c62d0d5ec2ce17e3d36cad0f6598247b582e1/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegmentRef.java#L97" rel="external nofollow noopener noreferrer" target="_blank"><code>#TraceSegmentRef(ContextCarrier)</code></a> <strong>构造</strong>方法，该方法用于将 ContextCarrier 转换成 TraceSegmentRef ，对比下两者的属性，<strong>基本一致</strong>，差异如下：</p><ul><li><code>peerHost</code> 属性，节点地址。<ul><li>当字符串<strong>不</strong>以 <code>#</code> 号开头，代表节点编号，格式为 <code>${peerId}</code> ，例如 <code>&quot;123&quot;</code> 。</li><li>当字符串以 <code>#</code> 号开头，代表地址，格式为 <code>${peerHost}</code> ，例如 <code>&quot;192.168.16.1:8080&quot;</code> 。</li></ul></li><li><code>entryOperationName</code> 属性，入口操作名。<ul><li>当字符串<strong>不</strong>以 <code>#</code> 号开头，代表入口操作编号，格式为 <code>#${entryOperationId}</code> ，例如 <code>&quot;666&quot;</code> 。</li><li>当字符串以 <code>#</code> 号开头，代表入口操作名，格式为 <code>#${entryOperationName}</code> ，例如 <code>&quot;#user/login&quot;</code> 。</li></ul></li><li><code>parentOperationName</code> 属性，父操作名。类似 <code>entryOperationName</code> 属。</li><li><code>primaryDistributedTraceId</code> 属性，分布式链路追踪<strong>全局</strong>编号。<strong>它不在此处处理，而在 <code>TracingContext#extract(ContextCarrier)</code> 方法中</strong>。</li></ul><p>在 <a href="https://github.com/YunaiV/skywalking/blob/49dc81a8bcaad1879b3a3be9917944b0b8b5a7a4/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ContextManager.java#L127" rel="external nofollow noopener noreferrer" target="_blank"><code>ContextManager#createEntrySpan(operationName, carrier)</code></a> 方法中，当<strong>存在</strong> ContextCarrier 传递时，创建 Context 后，会将 ContextCarrier <strong>解压</strong>到 Context 中，以达到跨进程传播。<a href="https://github.com/YunaiV/skywalking/blob/4c4c62d0d5ec2ce17e3d36cad0f6598247b582e1/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L147" rel="external nofollow noopener noreferrer" target="_blank"><code>TracingContext#extract(ContextCarrier)</code></a> 方法，代码如下：</p><ul><li>第 148 行：将 ContextCarrier 转换成 TraceSegmentRef 对象，调用 <code>TraceSegment#ref(TraceSegmentRef)</code> 方法，进行指向父 TraceSegment。</li><li>第 149 行：调用 <code>TraceSegment#relatedGlobalTraces(DistributedTraceId)</code> 方法，将传播的分布式链路追踪<strong>全局</strong>编号，添加到 TraceSegment 中，进行指向<strong>全局</strong>编号。</li></ul><p>另外，ContextManager <strong>单独</strong>提供 <a href="https://github.com/YunaiV/skywalking/blob/49dc81a8bcaad1879b3a3be9917944b0b8b5a7a4/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ContextManager.java#L161" rel="external nofollow noopener noreferrer" target="_blank"><code>#extract(ContextCarrier)</code></a> 方法，将<strong>多个</strong> ContextCarrier 注入到<strong>一个</strong> Context 中，从而解决”<strong>多个爸爸</strong>“的场景，例如 RocketMQ 插件的 <a href="https://github.com/YunaiV/skywalking/blob/49dc81a8bcaad1879b3a3be9917944b0b8b5a7a4/apm-sniffer/apm-sdk-plugin/rocketMQ-4.x-plugin/src/main/java/org/skywalking/apm/plugin/rocketMQ/v4/AbstractMessageConsumeInterceptor.java#L56" rel="external nofollow noopener noreferrer" target="_blank"><code>AbstractMessageConsumeInterceptor#beforeMethod(...)</code></a> 方法。</p><h4 id="3-2-3-2-注入"><a href="#3-2-3-2-注入" class="headerlink" title="3.2.3.2 注入"></a>3.2.3.2 注入</h4><p>在 <a href="https://github.com/YunaiV/skywalking/blob/4c4c62d0d5ec2ce17e3d36cad0f6598247b582e1/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ContextManager.java#L152" rel="external nofollow noopener noreferrer" target="_blank"><code>ContextManager#createExitSpan(operationName, carrier, remotePeer)</code></a> 方法中，当<strong>需要</strong> Context <strong>跨进程</strong>传递时，将 Context <strong>注入</strong>到 ContextCarrier 中，为 <a href="#">「3.2.3.3 传输」</a> 做准备。<a href="https://github.com/YunaiV/skywalking/blob/23c2146c134e0ef0a37a43758a1e04727de7697a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L87" rel="external nofollow noopener noreferrer" target="_blank"><code>TracingContext#inject(ContextCarrier)</code></a> 方法，代码比较易懂，胖友自己阅读理解。</p><h4 id="3-2-3-3-传输"><a href="#3-2-3-3-传输" class="headerlink" title="3.2.3.3 传输"></a>3.2.3.3 传输</h4><blockquote><p>友情提示：胖友，请先阅读 <a href="https://github.com/apache/incubator-skywalking/blob/master/docs/cn/Skywalking-Cross-Process-Propagation-Headers-Protocol-CN-v1.md" rel="external nofollow noopener noreferrer" target="_blank">《Skywalking Cross Process Propagation Headers Protocol》</a> 。</p></blockquote><p><a href="https://github.com/YunaiV/skywalking/blob/dd6d9bff2d160f3aa60bc0be5152c49ecc9d94a4/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/CarrierItem.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.CarrierItem</code></a> ，传输载体<strong>项</strong>。代码如：</p><ul><li><code>headKey</code> 属性，Header 键。</li><li><code>headValue</code> 属性，Header 值。</li><li><code>next</code> 属性，下一个项。</li></ul><p>CarrierItem 有两个子类：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/dd6d9bff2d160f3aa60bc0be5152c49ecc9d94a4/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/CarrierItemHead.java" rel="external nofollow noopener noreferrer" target="_blank">CarrierItemHead</a> ：Carrier 项的头( Head )，即首个元素。</li><li><a href="https://github.com/YunaiV/skywalking/blob/dd6d9bff2d160f3aa60bc0be5152c49ecc9d94a4/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/SW3CarrierItem.java" rel="external nofollow noopener noreferrer" target="_blank">SW3CarrierItem</a> ：<code>header = sw3</code> ，用于传输 ContextCarrier 。</li></ul><p>如下是 Dubbo 插件，使用 CarrierItem 的代码例子：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_01/07.png" alt=""></p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/dd6d9bff2d160f3aa60bc0be5152c49ecc9d94a4/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ContextCarrier.java#L110" rel="external nofollow noopener noreferrer" target="_blank"><code>ContextCarrier#serialize()</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/dd6d9bff2d160f3aa60bc0be5152c49ecc9d94a4/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ContextCarrier.java#L131" rel="external nofollow noopener noreferrer" target="_blank"><code>ContextCarrier#deserialize(text)</code></a></li></ul><h3 id="3-2-4-ContextSnapshot"><a href="#3-2-4-ContextSnapshot" class="headerlink" title="3.2.4 ContextSnapshot"></a>3.2.4 ContextSnapshot</h3><p><a href="https://github.com/YunaiV/skywalking/blob/dd6d9bff2d160f3aa60bc0be5152c49ecc9d94a4/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ContextSnapshot.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.ContextSnapshot</code></a> ，<strong>跨线程</strong> Context 传递<strong>快照</strong>。和 ContextCarrier 基本一致，由于不需要<strong>跨进程传输</strong>，可以少<strong>传递</strong>一些属性：</p><ul><li><code>parentApplicationInstanceId</code> </li><li><code>peerHost</code></li></ul><p>ContextSnapshot 和 ContextCarrier 比较类似，笔者就列举一些方法：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/dd6d9bff2d160f3aa60bc0be5152c49ecc9d94a4/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegmentRef.java#L126" rel="external nofollow noopener noreferrer" target="_blank"><code>#TraceSegmentRef(ContextSnapshot)</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/23c2146c134e0ef0a37a43758a1e04727de7697a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L163" rel="external nofollow noopener noreferrer" target="_blank"><code>TracingContext#capture()</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/23c2146c134e0ef0a37a43758a1e04727de7697a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L205" rel="external nofollow noopener noreferrer" target="_blank"><code>TracingContext#continued(ContextSnapshot)</code></a></li></ul><h2 id="3-3-SamplingService"><a href="#3-3-SamplingService" class="headerlink" title="3.3 SamplingService"></a>3.3 SamplingService</h2><p><a href="https://github.com/YunaiV/skywalking/blob/7b39e952da408f722a53168e6d6a0cd7e7ff372f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/sampling/SamplingService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.sampling.SamplingService</code></a> ，实现 Service 接口，Agent 抽样服务。该服务的作用是，如何对 TraceSegment 抽样收集。考虑到如果每条 TraceSegment 都进行追踪，会带来一定的 CPU ( 用于序列化与反序列化 ) 和网络的开销。通过配置 <code>Config.Agent.SAMPLE_N_PER_3_SECS</code> 属性，设置<strong>每三秒</strong>，收集 TraceSegment 的条数。默认情况下，不开启抽样服务，即全部收集。</p><p>代码如下：</p><ul><li><code>on</code> 属性，是否开启抽样服务。</li><li><code>samplingFactorHolder</code> 属性，抽样计数器。通过定时任务，每三秒重置一次。</li><li><code>scheduledFuture</code> 属性，定时任务。</li><li><code>#boot()</code> <strong>实现</strong>方法，若开启抽样服务( <code>Config.Agent.SAMPLE_N_PER_3_SECS &gt; 0</code> ) 时，创建定时任务，每三秒，调用一次 <code>#resetSamplingFactor()</code> 方法，重置计数器。</li><li><code>#trySampling()</code> 方法，若开启抽样服务，判断是否超过每三秒的抽样<strong>上限</strong>。若不是，返回 <code>true</code> ，并增加计数器。否则，返回 <code>false</code> 。</li><li><code>#forceSampled()</code> 方法，<strong>强制</strong>增加计数器加一。一般情况下，该方法用于链路追踪上下文传播时，被调用服务必须记录链路，参见调用处的<a href="https://github.com/YunaiV/skywalking/blob/7b39e952da408f722a53168e6d6a0cd7e7ff372f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ContextManager.java#L123" rel="external nofollow noopener noreferrer" target="_blank">代码</a>。</li><li><code>#resetSamplingFactor()</code> 方法，重置计数器。</li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>元旦很认真( 硬憋 )出一篇”硬货”。哈哈哈。</p><p>由于篇幅较长，内容略多，如果有错误的或者解释不清晰的，烦请胖友斧正。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_10_01/08.png" alt=""></p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/agent-collect-trace/&quot;&gt;http://www.iocoder.cn/SkyWalking/agent-collect-trace/&lt;/a&gt; 「芋道源码」
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Agent DictionaryManager 字典管理</title>
    <link href="http://www.iocoder.cn/SkyWalking/agent-dictionary/"/>
    <id>http://www.iocoder.cn/SkyWalking/agent-dictionary/</id>
    <published>2020-09-27T16:00:00.000Z</published>
    <updated>2017-12-27T12:55:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/agent-dictionary/">http://www.iocoder.cn/SkyWalking/agent-dictionary/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-dictionary/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-dictionary/">2. Collector 同步相关 API</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-dictionary/">2.1 应用的同步 API</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-dictionary/">2.2 操作的同步 API</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-dictionary/">3. Agent 调用同步 API</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-dictionary/">3.1 DictionaryManager</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-dictionary/">3.2 PossibleFound</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-dictionary/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Agent DictionaryManager 字典管理</strong>。先来简单了解下字典的定义和用途：</p><ul><li>字典实际上是一个 Map 映射。目前 Agent 上有两种字典：应用编码与应用编号的映射，操作名与操作编号的映射。<ul><li>应用的定义：例如，Tomcat 启动的应用，或者程序里访问的 MongoDB 、MySQL 都可以认为是应用。</li><li>操作的定义：例如，访问的 URL 地址，Mongo 的执行操作。</li></ul></li><li>Agent 在每次上传调用链路 Segment 给 Collector 时，Segment 里面需要包含应用和操作相关信息。考虑到减少网络流量，应用编号少于应用编号，操作编号少于操作名。</li></ul><p>Agent 字典，会<strong>定时</strong>从 Collector 【<strong>同步</strong>】<strong>需要</strong>( <em>需要的定义，下文代码会看到</em> )的字典。</p><p>下面，我们分成两个小节，分别从 API 的<strong>实现</strong>与<strong>调用</strong>，分享代码的具体实现。</p><h1 id="2-Collector-同步相关-API"><a href="#2-Collector-同步相关-API" class="headerlink" title="2. Collector 同步相关 API"></a>2. Collector 同步相关 API</h1><p>Collector 同步相关 API 相关有四个接口：</p><ul><li>2.1 应用的同步 API</li><li>2.2 操作的同步 API</li></ul><p>API 处理的流程大体如下：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_25/01.png" alt=""></p><h2 id="2-1-应用的同步-API"><a href="#2-1-应用的同步-API" class="headerlink" title="2.1 应用的同步 API"></a>2.1 应用的同步 API</h2><p>应用的同步 API ，实际使用的是<strong>应用的注册 API</strong>，在 <a href="http://www.iocoder.cn/SkyWalking/register/?self">「2.1 应用的注册 API」</a> 有详细解析。</p><h2 id="2-2-操作的同步-API"><a href="#2-2-操作的同步-API" class="headerlink" title="2.2 操作的同步 API"></a>2.2 操作的同步 API</h2><p>我们先来看看 API 的定义，<a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-network/src/main/proto/DiscoveryService.proto#L11" rel="external nofollow noopener noreferrer" target="_blank"><code>DiscoveryService</code></a> ，如下图所示：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_28/01.png" alt=""></p><p>整体代码和 <a href="#">「2.1 应用的同步 API」</a> 非常相似，所以本小节，更多的是提供代码的链接地址。</p><h3 id="2-2-1-ServiceNameDiscoveryServiceHandler-discovery-…"><a href="#2-2-1-ServiceNameDiscoveryServiceHandler-discovery-…" class="headerlink" title="2.2.1 ServiceNameDiscoveryServiceHandler#discovery(…)"></a>2.2.1 ServiceNameDiscoveryServiceHandler#discovery(…)</h3><p><a href="https://github.com/YunaiV/skywalking/blob/0830d985227c42f0e0f3787ebc99a2b197486b69/apm-collector/apm-collector-agent-grpc/collector-agent-grpc-provider/src/main/java/org/skywalking/apm/collector/agent/grpc/handler/ServiceNameDiscoveryServiceHandler.java#L49" rel="external nofollow noopener noreferrer" target="_blank"><code>ServiceNameDiscoveryServiceHandler#discovery(ServiceNameCollection, StreamObserver&lt;ServiceNameMappingCollection&gt;)</code></a>，根据操作名数组，查找操作编号数组。</p><h3 id="2-2-2-IServiceNameService-getOrCreate-…"><a href="#2-2-2-IServiceNameService-getOrCreate-…" class="headerlink" title="2.2.2 IServiceNameService#getOrCreate(…)"></a>2.2.2 IServiceNameService#getOrCreate(…)</h3><p><code>org.skywalking.apm.collector.agent.stream.service.register.IServiceNameService</code> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> 接口，操作名服务接口。</p><ul><li>定义了 <a href="https://github.com/YunaiV/skywalking/blob/a4db2c4dd5e2adc861e7fb9e9b7b7ffdc57dfb88/apm-collector/apm-collector-agent-stream/collector-agent-stream-define/src/main/java/org/skywalking/apm/collector/agent/stream/service/register/IInstanceIDService.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>#getOrCreate(applicationId, serviceName)</code></a> <strong>接口</strong>方法，根据应用编号 + 操作名字，获取或创建操作名( ServiceName )，并获得操作编号。</li></ul><p><code>org.skywalking.apm.collector.agent.stream.worker.register.ServiceNameService</code> ，实现 IServiceNameService 接口，操作名服务实现类。</p><ul><li>实现了 <a href="https://github.com/YunaiV/skywalking/blob/0830d985227c42f0e0f3787ebc99a2b197486b69/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ServiceNameService.java#L64" rel="external nofollow noopener noreferrer" target="_blank"><code>#getOrCreate(applicationId, serviceName)</code></a> 方法。</li></ul><h3 id="2-2-3-Graph-start-ServiceName"><a href="#2-2-3-Graph-start-ServiceName" class="headerlink" title="2.2.3 Graph#start(ServiceName)"></a>2.2.3 Graph#start(ServiceName)</h3><p>在 <a href="https://github.com/YunaiV/skywalking/blob/a9873b9bf07882746bd30f29b3c64f4b44887bf2/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/graph/RegisterStreamGraph.java#L79" rel="external nofollow noopener noreferrer" target="_blank"><code>#createServiceNameRegisterGraph()</code></a> 方法中，我们可以看到 ServiceName 对应的 <code>Graph&lt;ServiceName&gt;</code> 对象的创建。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/a9873b9bf07882746bd30f29b3c64f4b44887bf2/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ServiceNameRegisterRemoteWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.register.ServiceNameRegisterRemoteWorker</code></a> ，继承 AbstractRemoteWorker 抽象类，操作名注册远程 Worker 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/0830d985227c42f0e0f3787ebc99a2b197486b69/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ServiceNameRegisterSerialWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.register.ServiceNameRegisterSerialWorker</code></a> ，继承 AbstractLocalAsyncWorker 抽象类，异步保存应用 Worker 。<ul><li>相同于 Application ，ServiceName 的操作编号，从 <code>&quot;1&quot;</code> <strong>双向</strong>递增。 </li><li><a href="https://github.com/YunaiV/skywalking/blob/a4db2c4dd5e2adc861e7fb9e9b7b7ffdc57dfb88/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/ServiceNameEsRegisterDAO.java#L52" rel="external nofollow noopener noreferrer" target="_blank">ServiceNameEsRegisterDAO#save(ServiceName)</a></li></ul></li></ul><h3 id="2-2-4-ServiceName"><a href="#2-2-4-ServiceName" class="headerlink" title="2.2.4 ServiceName"></a>2.2.4 ServiceName</h3><p><a href="https://github.com/YunaiV/skywalking/blob/a9873b9bf07882746bd30f29b3c64f4b44887bf2/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/register/ServiceName.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.register.ServiceName</code></a> ，操作名。例如记录在 ES 如下图：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_28/02.png" alt=""></p><h1 id="3-Agent-调用同步-API"><a href="#3-Agent-调用同步-API" class="headerlink" title="3. Agent 调用同步 API"></a>3. Agent 调用同步 API</h1><p>在 <a href="#">《SkyWalking 源码分析 —— 应用于应用实例的注册》「3. Agent 调用注册 API」</a> 一文中，在 <a href="https://github.com/YunaiV/skywalking/blob/bb8cb1b7dcb428c161f225f0b5d57441105f84c0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/AppAndServiceRegisterClient.java#L170" rel="external nofollow noopener noreferrer" target="_blank">【第 170 至 173 行】的代码</a>，我们可以看到，AppAndServiceRegisterClient 会定时从 Collector 同步所有字典信息。</p><h2 id="3-1-DictionaryManager"><a href="#3-1-DictionaryManager" class="headerlink" title="3.1 DictionaryManager"></a>3.1 DictionaryManager</h2><p><a href="https://github.com/YunaiV/skywalking/blob/0830d985227c42f0e0f3787ebc99a2b197486b69/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/dictionary/DictionaryManager.java#L27" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.dictionary.DictionaryManager</code></a> ，字典管理器。目前管理有两种字典：</p><ul><li>ApplicationDictionary</li><li>OperationNameDictionary</li></ul><h3 id="3-1-ApplicationDictionary"><a href="#3-1-ApplicationDictionary" class="headerlink" title="3.1 ApplicationDictionary"></a>3.1 ApplicationDictionary</h3><p><code>org.skywalking.apm.agent.core.dictionary.ApplicationDictionary</code> ，应用字典。</p><ul><li><code>INSTANCE</code> 枚举属性，单例。</li><li><code>applicationDictionary</code> 属性，应用编码与应用编号的映射。</li><li><code>unRegisterApplications</code> 属性，未知应用编码集合。Agent 会定时从 Collector 同步。这也是文章开头说的，“<strong>需要</strong>”的定义。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/0830d985227c42f0e0f3787ebc99a2b197486b69/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/dictionary/ApplicationDictionary.java#L56" rel="external nofollow noopener noreferrer" target="_blank"><code>#find(applicationCode)</code></a> 方法，根据应用编码，查询应用编号。</p><ul><li>第 57 行：根据应用编码，从 <code>applicationDictionary</code> 中，查询应用编号。</li><li>第 58 至 59 行：当应用编号查找到时，返回 Found 。Found 会在下文详细解析。</li><li>第 61 至 64 行：当应用编号查找不到时，添加到 <code>unRegisterApplications</code> 中，返回 NotFound 。NotFound 会在下文详细解析。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/0830d985227c42f0e0f3787ebc99a2b197486b69/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/dictionary/ApplicationDictionary.java#L74" rel="external nofollow noopener noreferrer" target="_blank"><code>#syncRemoteDictionary(ApplicationRegisterServiceGrpc.ApplicationRegisterServiceBlockingStub)</code></a> 方法，调用 <a href="#">「2.1 应用的同步 API」</a> ，从 Collector 同步 <code>unRegisterApplications</code> 对应的应用编号集合。</p><h3 id="3-2-OperationNameDictionary"><a href="#3-2-OperationNameDictionary" class="headerlink" title="3.2 OperationNameDictionary"></a>3.2 OperationNameDictionary</h3><p><code>org.skywalking.apm.agent.core.dictionary.OperationNameDictionary</code> ，操作名字典。</p><p>和 ApplicationDictionary 基本类似，胖友点击 <a href="https://github.com/YunaiV/skywalking/blob/0830d985227c42f0e0f3787ebc99a2b197486b69/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/dictionary/OperationNameDictionary.java" rel="external nofollow noopener noreferrer" target="_blank">代码</a> ，自己阅读理解。</p><h1 id="3-2-PossibleFound"><a href="#3-2-PossibleFound" class="headerlink" title="3.2 PossibleFound"></a>3.2 PossibleFound</h1><p>在分享 PossibleFound 之前，我们先来看一段代码，了解该类的意图：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_28/03.png" alt=""></p><ul><li>我们在使用 <code>XXXXDictionary#find(xxx)</code> 方法时，返回的会是 Found 或者 NotFound 。这两个类本身是<strong>互斥</strong>的，并且继承 PossibleFound 。在 PossibleFound 提供 <code>#doInCondition(method01, method02)</code> 方法，<strong>优雅</strong>的处理两种情况。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/0830d985227c42f0e0f3787ebc99a2b197486b69/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/dictionary/PossibleFound.java#L26" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.dictionary.PossibleFound</code></a> ，<strong>抽象类</strong>，代码如下：</p><ul><li><code>found</code> 属性，是否找到。</li><li><code>value</code> 属性，找到的结果。</li><li><a href="https://github.com/YunaiV/skywalking/blob/0830d985227c42f0e0f3787ebc99a2b197486b69/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/dictionary/Found.java#L26" rel="external nofollow noopener noreferrer" target="_blank">org.skywalking.apm.agent.core.dictionary.Found</a> 实现 PossibleFound 类，<code>found = true</code> 并且 <code>value</code> 为找到的值。</li><li><a href="https://github.com/YunaiV/skywalking/blob/0830d985227c42f0e0f3787ebc99a2b197486b69/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/dictionary/NotFound.java#L26" rel="external nofollow noopener noreferrer" target="_blank">org.skywalking.apm.agent.core.dictionary.NotFound</a> 实现 PossibleFound 类，<code>found = false</code> 并且 <code>value</code> 不赋值。</li><li><a href="https://github.com/YunaiV/skywalking/blob/0830d985227c42f0e0f3787ebc99a2b197486b69/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/dictionary/PossibleFound.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#doInCondition(Found, NotFound)</code></a> 方法，根据查找结果，执行不同的逻辑，【无返回】。<ul><li>第一个参数，<a href="https://github.com/YunaiV/skywalking/blob/0830d985227c42f0e0f3787ebc99a2b197486b69/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/dictionary/PossibleFound.java#L72" rel="external nofollow noopener noreferrer" target="_blank"><code>PossibleFound.Found</code></a> 接口，Found 时的处理逻辑接口。</li><li>第二个参数，<a href="https://github.com/YunaiV/skywalking/blob/0830d985227c42f0e0f3787ebc99a2b197486b69/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/dictionary/PossibleFound.java#L79" rel="external nofollow noopener noreferrer" target="_blank"><code>PossibleFound.NotFound</code></a> 接口，NotFound 时的处理逻辑接口。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/0830d985227c42f0e0f3787ebc99a2b197486b69/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/dictionary/PossibleFound.java#L61" rel="external nofollow noopener noreferrer" target="_blank"><code>#doInCondition(FoundAndObtain, NotFoundAndObtain)</code></a> 方法，根据查找结果，执行不同的逻辑，【有返回】。<ul><li>第一个参数，<a href="https://github.com/YunaiV/skywalking/blob/0830d985227c42f0e0f3787ebc99a2b197486b69/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/dictionary/PossibleFound.java#L86" rel="external nofollow noopener noreferrer" target="_blank"><code>PossibleFound.FoundAndObtain</code></a> 接口，Found 时的处理逻辑接口。</li><li>第二个参数，<a href="https://github.com/YunaiV/skywalking/blob/0830d985227c42f0e0f3787ebc99a2b197486b69/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/dictionary/PossibleFound.java#L93" rel="external nofollow noopener noreferrer" target="_blank"><code>PossibleFound.NotFoundAndObtain</code></a> 接口，NotFound 时的处理逻辑接口。</li></ul></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>写水文，好枯燥。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_28/04.png" alt=""></p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🙂🙂🙂关注&lt;strong&gt;微信公众号：【芋道源码】&lt;/strong&gt;
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— 应用于应用实例的注册</title>
    <link href="http://www.iocoder.cn/SkyWalking/register/"/>
    <id>http://www.iocoder.cn/SkyWalking/register/</id>
    <published>2020-09-24T16:00:00.000Z</published>
    <updated>2018-01-01T11:45:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/register/">http://www.iocoder.cn/SkyWalking/register/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/register/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/register/">2. Collector 注册相关 API</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/register/">2.1 应用的注册 API</a></li><li><a href="http://www.iocoder.cn/SkyWalking/register/">2.2 应用实例的正常注册 API</a></li><li><a href="http://www.iocoder.cn/SkyWalking/register/">2.3 应用实例的恢复注册 API</a></li><li><a href="http://www.iocoder.cn/SkyWalking/register/">2.4 应用实例的心跳 API</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/register/">3. Agent 调用注册 API</a></li><li><a href="http://www.iocoder.cn/SkyWalking/register/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>应用与应用实例的注册</strong>。先来简单了解下注册的整体流程：</p><ul><li>应用启动，Agent 向 Collector 注册<strong>应用</strong>。</li><li>注册应用成功后，Agent 向 Collector 注册应用<strong>实例</strong>。</li></ul><p>下面，我们分成两个小节，分别从 API 的<strong>实现</strong>与<strong>调用</strong>，分享代码的具体实现。</p><blockquote><p>友情提示：推荐阅读 <a href="https://github.com/apache/incubator-skywalking/blob/master/docs/cn/How-to-communicate-with-the-collector-CN.md" rel="external nofollow noopener noreferrer" target="_blank">《探针与Collector间通讯协议》</a> 。</p></blockquote><h1 id="2-Collector-注册相关-API"><a href="#2-Collector-注册相关-API" class="headerlink" title="2. Collector 注册相关 API"></a>2. Collector 注册相关 API</h1><p>Collector 注册相关 API 相关有四个接口：</p><ul><li>2.1 应用的注册 API</li><li>2.2 应用实例的正常注册 API </li><li>2.3 应用实例的恢复注册 API</li><li>2.4 应用实例的心跳 API</li></ul><p>API 处理的流程大体如下：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_25/01.png" alt=""></p><ul><li>绿框部分，【2.3】【2.4】两个 API ，直接 Service 调用 DAO 方法，无需经过 Graph / Stream 相关方法。</li></ul><h2 id="2-1-应用的注册-API"><a href="#2-1-应用的注册-API" class="headerlink" title="2.1 应用的注册 API"></a>2.1 应用的注册 API</h2><p>我们先来看看 API 的定义，<a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-network/src/main/proto/ApplicationRegisterService.proto#L9" rel="external nofollow noopener noreferrer" target="_blank"><code>ApplicationRegisterService.proto</code></a> ，如下图所示：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_25/02.png" alt=""></p><ul><li>其中，KeyWithIntegerValue 数据类型，在 <a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-network/src/main/proto/KeyWithIntegerValue.proto" rel="external nofollow noopener noreferrer" target="_blank"><code>KeyWithIntegerValue.proto</code></a> 中定义。</li></ul><h3 id="2-1-1-ApplicationRegisterServiceHandler-register-…"><a href="#2-1-1-ApplicationRegisterServiceHandler-register-…" class="headerlink" title="2.1.1 ApplicationRegisterServiceHandler#register(…)"></a>2.1.1 ApplicationRegisterServiceHandler#register(…)</h3><p><a href="https://github.com/YunaiV/skywalking/blob/b4b2ff52a7dccd000264677a7a6bbb2285a8cd53/apm-collector/apm-collector-agent-grpc/collector-agent-grpc-provider/src/main/java/org/skywalking/apm/collector/agent/grpc/handler/ApplicationRegisterServiceHandler.java#L49" rel="external nofollow noopener noreferrer" target="_blank"><code>ApplicationRegisterServiceHandler#register(Application, StreamObserver&lt;ApplicationMapping&gt;)</code></a>, 代码如下：</p><ul><li>第 51 行：获得请求的应用编码( <code>applicationCode</code> )<strong>数组</strong>。</li><li>第 54 至 64 行：循环应用编码数组，<strong>获取</strong>或<strong>创建</strong>应用。<ul><li>第 57 行：调用 <code>IApplicationIDService#getOrCreate(applicationCode)</code> 方法，<strong>获取</strong>或<strong>创建</strong>应用，最终获得应用编号( <code>applicationId</code> )。</li><li>第 60 至 63 行：获得到应用编号( <code>applicationId != 0</code> )，则添加到响应。<strong>为什么会存在获得不到的情况呢</strong>？在下文中，我们会看到，实际<strong>异步</strong>保存应用，所以会存在获取失败的情况。当获取失败，调用方( 例如 Agent )可以重新发起该请求进行注册应用，从而在异步保存应用，获取到应用编号。</li><li>第 67 至 68 行：响应。</li></ul></li></ul><h3 id="2-1-2-IApplicationIDService-getOrCreate-…"><a href="#2-1-2-IApplicationIDService-getOrCreate-…" class="headerlink" title="2.1.2 IApplicationIDService#getOrCreate(…)"></a>2.1.2 IApplicationIDService#getOrCreate(…)</h3><p><code>org.skywalking.apm.collector.agent.stream.service.register.IApplicationIDService</code> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> 接口，应用编号服务接口。</p><ul><li>定义了 <a href="https://github.com/YunaiV/skywalking/blob/a9873b9bf07882746bd30f29b3c64f4b44887bf2/apm-collector/apm-collector-agent-stream/collector-agent-stream-define/src/main/java/org/skywalking/apm/collector/agent/stream/service/register/IApplicationIDService.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><code>#getOrCreate(applicationCode)</code></a> <strong>接口</strong>方法，根据应用编码获取或创建应用，并获得应用编号。</li></ul><p><code>org.skywalking.apm.collector.agent.stream.worker.register.ApplicationIDService</code> ，实现 IApplicationIDService 接口，应用编号服务实现类。</p><ul><li><p>实现了 <a href="https://github.com/YunaiV/skywalking/blob/a9873b9bf07882746bd30f29b3c64f4b44887bf2/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationIDService.java#L64" rel="external nofollow noopener noreferrer" target="_blank"><code>#getOrCreate(applicationCode)</code></a> 方法，代码如下：</p><ul><li>第 66 行：调用 <code>ApplicationCacheService#get(applicationCode)</code> 方法，从<strong>缓存</strong>中获取应用编号。在 <a href="http://www.iocoder.cn/SkyWalking/collector-cache-module/?self">《SkyWalking 源码分析 —— Collector Cache 缓存组件》</a> 有详细解析。</li><li>第 69 至 76 行：当获取不到应用编号时，获取 Application 对应的 <code>Graph&lt;Application&gt;</code> 对象，调用 <code>Graph#start(application)</code> 方法，进行流式处理。在这过程中，会保存应用到存储器。</li><li>第 77 行：返回应用编号。</li></ul></li></ul><h3 id="2-1-3-Graph-start-application"><a href="#2-1-3-Graph-start-application" class="headerlink" title="2.1.3 Graph#start(application)"></a>2.1.3 Graph#start(application)</h3><p>在 <a href="https://github.com/YunaiV/skywalking/blob/a9873b9bf07882746bd30f29b3c64f4b44887bf2/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/graph/RegisterStreamGraph.java#L57" rel="external nofollow noopener noreferrer" target="_blank"><code>#createApplicationRegisterGraph()</code></a> 方法中，我们可以看到 Application 对应的 <code>Graph&lt;Application&gt;</code> 对象的创建。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/a9873b9bf07882746bd30f29b3c64f4b44887bf2/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationRegisterRemoteWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.register.ApplicationRegisterRemoteWorker</code></a> ，继承 AbstractRemoteWorker 抽象类，应用注册远程 Worker 。<ul><li><a href="https://github.com/YunaiV/skywalking/blob/a9873b9bf07882746bd30f29b3c64f4b44887bf2/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationRegisterRemoteWorker.java#L55" rel="external nofollow noopener noreferrer" target="_blank">Factory</a> 内部类，实现 AbstractRemoteWorkerProvider 抽象类，在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（一）》「3.2.3 AbstractRemoteWorker」</a> 有详细解析。</li><li><strong>AbstractRemoteWorker</strong> ，在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（一）》「3.2.3 AbstractRemoteWorker」</a> 有详细解析。</li><li><a href="https://github.com/YunaiV/skywalking/blob/a9873b9bf07882746bd30f29b3c64f4b44887bf2/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationRegisterRemoteWorker.java#L42" rel="external nofollow noopener noreferrer" target="_blank"><code>#id()</code></a> 实现方法，返回 10006 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/a9873b9bf07882746bd30f29b3c64f4b44887bf2/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationRegisterRemoteWorker.java#L51" rel="external nofollow noopener noreferrer" target="_blank"><code>#selector</code></a> 实现方法，返回 <code>Selector.ForeverFirst</code> 。在 <a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/?self">《SkyWalking 源码分析 —— Collector Remote 远程通信服务》</a> 有详细解析。</li><li><a href="https://github.com/YunaiV/skywalking/blob/a9873b9bf07882746bd30f29b3c64f4b44887bf2/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationRegisterRemoteWorker.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#onWork(Application)</code></a> 实现方法，调用 <code>Next#execute(message)</code> 方法，提交数据给下面的节点，继续流式处理。</li><li>总结：ApplicationRegisterRemoteWorker ，使用 Collector 集群的第一个节点( <a href="https://github.com/YunaiV/skywalking/blob/b4b2ff52a7dccd000264677a7a6bbb2285a8cd53/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteClient.java#L194" rel="external nofollow noopener noreferrer" target="_blank">按照 <code>ip</code> 排序</a> ) 进行后续的流式处理，即，保存应用。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/a9873b9bf07882746bd30f29b3c64f4b44887bf2/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationRegisterSerialWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.register.ApplicationRegisterSerialWorker</code></a> ，继承 AbstractLocalAsyncWorker 抽象类，异步保存应用 Worker 。<ul><li><a href="https://github.com/YunaiV/skywalking/blob/a9873b9bf07882746bd30f29b3c64f4b44887bf2/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationRegisterSerialWorker.java#L84" rel="external nofollow noopener noreferrer" target="_blank">Factory</a> 内部类，实现 AbstractLocalAsyncWorkerProvider 抽象类，在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（一）》「3.2.2 AbstractLocalAsyncWorker」</a> 有详细解析。</li><li><strong>AbstractLocalAsyncWorker</strong> ，在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（一）》「3.2.2 AbstractLocalAsyncWorker」</a> 有详细解析。</li><li><a href="https://github.com/YunaiV/skywalking/blob/a9873b9bf07882746bd30f29b3c64f4b44887bf2/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationRegisterSerialWorker.java#L52" rel="external nofollow noopener noreferrer" target="_blank"><code>#id()</code></a> 实现方法，返回 101 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/69ec2bb309f4fe3cdbda56587a6193be933c4388/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationRegisterSerialWorker.java#L56" rel="external nofollow noopener noreferrer" target="_blank"><code>#onWork(Application)</code></a> 实现方法，保存应用( Application )。代码如下( 以 ES 作为 DAO 实现为例子 )：<ul><li>第 58 行：调用 <code>ApplicationCacheService#get(applicationCode)</code> 方法，从<strong>缓存</strong>中获取应用编号。</li><li>第 60 行：当获取不到应用编号时，使用 <code>applicationCode</code> 创建应用并保存。</li><li>第 62 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/69ec2bb309f4fe3cdbda56587a6193be933c4388/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/ApplicationEsRegisterDAO.java#L49" rel="external nofollow noopener noreferrer" target="_blank"><code>ApplicationH2RegisterDAO#getMinApplicationId()</code></a> 方法，获得 Application 记录的应用编号的<strong>最小值</strong>。</li><li>——— 分隔 ———</li><li>第 63 行：当 <code>min == 0</code> 时，说明没有 Application 记录。</li><li>第 64 至 68 行：创建<strong>第一条</strong>、<strong>特殊</strong>的 Application 记录。该记录 <code>applicationId = 1</code> ，<code>applicationCode = User</code> ，用于表示用户发起请求。在 SkyWaling UI 中，我们可以看到该条 Application 记录如下图：<img src="http://www.iocoder.cn/images/SkyWalking/2020_09_25/03.png" alt=""></li><li>第 70 至 74 行：创建当前请求的对应的 Application 记录，并且 <code>applicationId = -1</code> 。</li><li>——— 分隔 ———</li><li>第 76 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/69ec2bb309f4fe3cdbda56587a6193be933c4388/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/ApplicationEsRegisterDAO.java#L45" rel="external nofollow noopener noreferrer" target="_blank"><code>ApplicationH2RegisterDAO#getMaxApplicationId()</code></a> 方法，获得 Application 记录的应用编号的<strong>最大值</strong>。</li><li>第 77 行：调用 <code>IdAutoIncrement#increment(min, max)</code> 方法，获得应用编号。该方法较为有趣，在下文详细解析。</li><li>第 79 至 82 行：创建当前请求的对应的 Application 记录。</li><li>——— 分隔 ———</li><li>第 85 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/69ec2bb309f4fe3cdbda56587a6193be933c4388/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/ApplicationEsRegisterDAO.java#L53" rel="external nofollow noopener noreferrer" target="_blank"><code>ApplicationEsRegisterDAO#save(Application)</code></a> 方法，保存应用。</li></ul></li></ul></li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/69ec2bb309f4fe3cdbda56587a6193be933c4388/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/IdAutoIncrement.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><code>IdAutoIncrement#increment(min, max)</code></a> 方法，<strong>双向</strong>均匀自增。可能看起来比较奇怪，以上文 Application 的调用举例子：</p><table><thead><tr><th>min</th><th>max</th><th>result</th><th>applicationCode</th></tr></thead><tbody><tr><td>0</td><td>/</td><td>1</td><td>User</td></tr><tr><td>0</td><td>/</td><td>-1</td><td>应用 A</td></tr><tr><td>-1</td><td>1</td><td>2</td><td>应用 B</td></tr><tr><td>-1</td><td>2</td><td>-2</td><td>应用 C</td></tr><tr><td>-2</td><td>2</td><td>3</td><td>应用 D</td></tr></tbody></table><ul><li>【User】和【应用 A】是直接获得 <code>result</code> ，不调用 <code>#increment(min, max)</code>  方法。</li><li>总的来说，我们可以看到，以 <code>min + max = 0</code> 为中心点( 实际以 <code>0</code> 为中心点)， <strong>双向</strong>均匀自增。</li></ul><p>TODO 【4007】</p><h3 id="2-1-4-Application"><a href="#2-1-4-Application" class="headerlink" title="2.1.4 Application"></a>2.1.4 Application</h3><p><a href="https://github.com/YunaiV/skywalking/blob/69ec2bb309f4fe3cdbda56587a6193be933c4388/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/register/Application.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.register.Application</code></a> ，应用。例如记录在 ES 如下图：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_25/05.png" alt=""></p><h2 id="2-2-应用实例的正常注册-API"><a href="#2-2-应用实例的正常注册-API" class="headerlink" title="2.2 应用实例的正常注册 API"></a>2.2 应用实例的正常注册 API</h2><p>我们先来看看 API 的定义，<a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-network/src/main/proto/InstanceDiscoveryService.proto#L11" rel="external nofollow noopener noreferrer" target="_blank"><code>InstanceDiscoveryService</code></a> ，如下图所示：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_25/04.png" alt=""></p><p>整体代码和 <a href="#">「2.1 应用的注册 API」</a> 非常相似，所以本小节，更多的是提供代码的链接地址。</p><h3 id="2-2-1-InstanceDiscoveryServiceHandler-register-…"><a href="#2-2-1-InstanceDiscoveryServiceHandler-register-…" class="headerlink" title="2.2.1 InstanceDiscoveryServiceHandler#register(…)"></a>2.2.1 InstanceDiscoveryServiceHandler#register(…)</h3><p><a href="https://github.com/YunaiV/skywalking/blob/69ec2bb309f4fe3cdbda56587a6193be933c4388/apm-collector/apm-collector-agent-grpc/collector-agent-grpc-provider/src/main/java/org/skywalking/apm/collector/agent/grpc/handler/InstanceDiscoveryServiceHandler.java#L54" rel="external nofollow noopener noreferrer" target="_blank"><code>InstanceDiscoveryServiceHandler#register(ApplicationInstance, StreamObserver&lt;ApplicationInstanceMapping&gt;)</code></a>，注册应用实例。</p><h3 id="2-2-2-IInstanceIDService-getOrCreate-…"><a href="#2-2-2-IInstanceIDService-getOrCreate-…" class="headerlink" title="2.2.2 IInstanceIDService#getOrCreate(…)"></a>2.2.2 IInstanceIDService#getOrCreate(…)</h3><p><code>org.skywalking.apm.collector.agent.stream.service.register.IInstanceIDService</code> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> 接口，应用实例编号服务接口。</p><ul><li>定义了 <a href="https://github.com/YunaiV/skywalking/blob/a4db2c4dd5e2adc861e7fb9e9b7b7ffdc57dfb88/apm-collector/apm-collector-agent-stream/collector-agent-stream-define/src/main/java/org/skywalking/apm/collector/agent/stream/service/register/IInstanceIDService.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>#getOrCreate(applicationCode)</code></a> <strong>接口</strong>方法，根据应用编号 + AgentUUID，获取或创建应用实例，并获得应用编号。</li></ul><p><code>org.skywalking.apm.collector.agent.stream.worker.register.InstanceIDService</code> ，实现 IInstanceIDService 接口，应用编号服务实现类。</p><ul><li>实现了 <a href="https://github.com/YunaiV/skywalking/blob/a4db2c4dd5e2adc861e7fb9e9b7b7ffdc57dfb88/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/InstanceIDService.java#L74" rel="external nofollow noopener noreferrer" target="_blank"><code>#getOrCreate(applicationCode)</code></a> 方法。</li></ul><h3 id="2-2-3-Graph-start-instance"><a href="#2-2-3-Graph-start-instance" class="headerlink" title="2.2.3 Graph#start(instance)"></a>2.2.3 Graph#start(instance)</h3><p>在 <a href="https://github.com/YunaiV/skywalking/blob/a9873b9bf07882746bd30f29b3c64f4b44887bf2/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/graph/RegisterStreamGraph.java#L68" rel="external nofollow noopener noreferrer" target="_blank"><code>#createInstanceRegisterGraph()</code></a> 方法中，我们可以看到 Instance 对应的 <code>Graph&lt;Instance&gt;</code> 对象的创建。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/a9873b9bf07882746bd30f29b3c64f4b44887bf2/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/InstanceRegisterRemoteWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.register.InstanceRegisterRemoteWorker</code></a> ，继承 AbstractRemoteWorker 抽象类，应用实例注册远程 Worker 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/a9873b9bf07882746bd30f29b3c64f4b44887bf2/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationRegisterSerialWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.worker.register.ApplicationRegisterSerialWorker</code></a> ，继承 AbstractLocalAsyncWorker 抽象类，异步保存应用 Worker 。<ul><li>不同 Application ，Instance 的应用实例编号，从 <code>&quot;1&quot;</code> <strong>正向</strong>递增。 </li><li><a href="https://github.com/YunaiV/skywalking/blob/a4db2c4dd5e2adc861e7fb9e9b7b7ffdc57dfb88/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/InstanceEsRegisterDAO.java#L53" rel="external nofollow noopener noreferrer" target="_blank">InstanceEsRegisterDAO#save(Instance)</a></li></ul></li></ul><h3 id="2-2-4-Instance"><a href="#2-2-4-Instance" class="headerlink" title="2.2.4 Instance"></a>2.2.4 Instance</h3><p><a href="https://github.com/YunaiV/skywalking/blob/69ec2bb309f4fe3cdbda56587a6193be933c4388/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/register/Instance.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.register.Instance</code></a> ，应用实例。例如记录在 ES 如下图：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_25/06.png" alt=""></p><h2 id="2-3-应用实例的恢复注册-API"><a href="#2-3-应用实例的恢复注册-API" class="headerlink" title="2.3 应用实例的恢复注册 API"></a>2.3 应用实例的恢复注册 API</h2><p>我们先来看看 API 的定义，<a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-network/src/main/proto/InstanceDiscoveryService.proto#L17" rel="external nofollow noopener noreferrer" target="_blank"><code>InstanceDiscoveryService.proto</code></a> ，如下图所示：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_25/07.png" alt=""></p><ul><li>其中，Downstream 数据类型，在 <a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-network/src/main/proto/Downstream.proto" rel="external nofollow noopener noreferrer" target="_blank"><code>Downstream.proto</code></a> 中定义。</li></ul><p>一般情况下，Agent 在注册应用时候成功后，如果因为各种原因原因和 Collector 断开了 gRPC Channel 连接( 例如，网络 )，恢复连接后，需要调用该 API ，进行<strong>恢复</strong>注册。</p><h3 id="2-3-1-InstanceDiscoveryServiceHandler-recover-…"><a href="#2-3-1-InstanceDiscoveryServiceHandler-recover-…" class="headerlink" title="2.3.1 InstanceDiscoveryServiceHandler#recover(…)"></a>2.3.1 InstanceDiscoveryServiceHandler#recover(…)</h3><p><a href="https://github.com/YunaiV/skywalking/blob/9a01c67f47efc07b9754c77198324cb2d5bb212d/apm-collector/apm-collector-agent-grpc/collector-agent-grpc-provider/src/main/java/org/skywalking/apm/collector/agent/grpc/handler/InstanceDiscoveryServiceHandler.java#L69" rel="external nofollow noopener noreferrer" target="_blank"><code>InstanceDiscoveryServiceHandler#recover(ApplicationInstanceRecover, StreamObserver&lt;Downstream&gt;)</code></a>, 代码如下：</p><ul><li>第 71 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/9a01c67f47efc07b9754c77198324cb2d5bb212d/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/util/TimeBucketUtils.java#L51" rel="external nofollow noopener noreferrer" target="_blank"><code>TimeBucketUtils#getSecondTimeBucket(time)</code></a> 方法，将 <code>registerTime</code> 转成 timeBucket 。</li><li>第 73 行：调用 <code>IInstanceIDService#recover(instanceId, applicationId, registerTime, osInfo)</code> 方法，恢复注册应用实例。</li><li>第 75 至 76 行：响应。</li></ul><h3 id="2-3-2-IInstanceIDService-recover-…"><a href="#2-3-2-IInstanceIDService-recover-…" class="headerlink" title="2.3.2 IInstanceIDService#recover(…)"></a>2.3.2 IInstanceIDService#recover(…)</h3><p><a href="https://github.com/YunaiV/skywalking/blob/bb8cb1b7dcb428c161f225f0b5d57441105f84c0/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/InstanceIDService.java#L95" rel="external nofollow noopener noreferrer" target="_blank"><code>InstanceIDService#recover(instanceId, applicationId, registerTime, osInfo)</code></a> <strong>实现</strong>方法，恢复注册。代码如下：</p><ul><li>第 96 至 103 行：创建 Instance 对象，用于下面更新操作。<ul><li>第 99 行： TODO 【4008】</li></ul></li><li>第 106 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/a4db2c4dd5e2adc861e7fb9e9b7b7ffdc57dfb88/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/InstanceEsRegisterDAO.java#L53" rel="external nofollow noopener noreferrer" target="_blank">InstanceEsRegisterDAO#save(Instance)</a> 方法，更新应用实例。</li></ul><h2 id="2-4-应用实例的心跳-API"><a href="#2-4-应用实例的心跳-API" class="headerlink" title="2.4 应用实例的心跳 API"></a>2.4 应用实例的心跳 API</h2><p>我们先来看看 API 的定义，<a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-network/src/main/proto/InstanceDiscoveryService.proto#L14" rel="external nofollow noopener noreferrer" target="_blank"><code>InstanceDiscoveryService.proto</code></a> ，如下图所示：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_25/08.png" alt=""></p><ul><li>其中，Downstream 数据类型，在 <a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-network/src/main/proto/Downstream.proto" rel="external nofollow noopener noreferrer" target="_blank"><code>Downstream.proto</code></a> 中定义。</li></ul><p>一般情况下，Agent 在注册应用时候成功后，定时向 Collector 发送<strong>心跳</strong>，记录应用存活。</p><h3 id="2-4-1-InstanceDiscoveryServiceHandler-heartbeat-…"><a href="#2-4-1-InstanceDiscoveryServiceHandler-heartbeat-…" class="headerlink" title="2.4.1 InstanceDiscoveryServiceHandler#heartbeat(…)"></a>2.4.1 InstanceDiscoveryServiceHandler#heartbeat(…)</h3><p><a href="#">InstanceDiscoveryServiceHandler#heartbeat(ApplicationInstanceHeartbeat, StreamObserver<org.skywalking.apm.network.proto.downstream>)</org.skywalking.apm.network.proto.downstream></a> ，目前该方法暂未实现。实现后，会首先调用一个 Service 方法，而后调用 <a href="https://github.com/YunaiV/skywalking/blob/bb8cb1b7dcb428c161f225f0b5d57441105f84c0/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/InstanceEsRegisterDAO.java#L68" rel="external nofollow noopener noreferrer" target="_blank"><code>InstanceEsRegisterDAO#updateHeartbeatTime(instanceId, heartbeatTime)</code></a> 方法，记录应用实例的心跳时间。</p><h1 id="3-Agent-调用注册-API"><a href="#3-Agent-调用注册-API" class="headerlink" title="3. Agent 调用注册 API"></a>3. Agent 调用注册 API</h1><p><a href="https://github.com/YunaiV/skywalking/blob/bb8cb1b7dcb428c161f225f0b5d57441105f84c0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/AppAndServiceRegisterClient.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.remote.AppAndServiceRegisterClient</code></a> ，实现 BootService 、GRPCChannelListener 、Runnable 、TracingContextListener 接口，注册应用与实例的客户端。该客户端会调用上述所有 API 。</p><ul><li><code>PROCESS_UUID</code> <strong>静态</strong>属性，Agent UUID ，使用 <strong>UUID</strong> 算法生成，去除多余 <code>&quot;-&quot;</code> 。</li><li>———- 分割线 ———-</li><li><code>status</code> 属性，gRPC 连接状态。</li><li><code>applicationRegisterServiceBlockingStub</code> / <code>instanceDiscoveryServiceBlockingStub</code> / <code>serviceNameDiscoveryServiceBlockingStub</code> 属性，对应 gRPC 提供 API 的<strong>阻塞</strong> Stub 。</li><li><code>needRegisterRecover</code> 属性，是否需要发起恢复的注册。</li><li>如上五个属性，在 <a href="https://github.com/YunaiV/skywalking/blob/bb8cb1b7dcb428c161f225f0b5d57441105f84c0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/AppAndServiceRegisterClient.java#L79" rel="external nofollow noopener noreferrer" target="_blank"><code>#statusChanged(GRPCChannelStatus)</code></a> <strong>实现</strong>方法，根据 gRPC 连接状态的变更，创建或销毁 Stub 。</li><li>在 <a href="https://github.com/YunaiV/skywalking/blob/bb8cb1b7dcb428c161f225f0b5d57441105f84c0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/AppAndServiceRegisterClient.java#L103" rel="external nofollow noopener noreferrer" target="_blank"><code>#boot()</code></a> <strong>实现</strong>方法，将自己作为监听器( 因为实现了 GRPCChannelListener 接口 )添加到 GRPCChannelManager 中，从而监听 gRPC Channel 的状态。在 <a href="http://www.iocoder.cn/SkyWalking/agent-remote-manager/?self">《SkyWalking 源码分析 —— Agent Remote 远程通信服务》</a> 有详细解析。</li><li>———- 分割线 ———-</li><li><code>applicationRegisterFuture</code> 属性，注册应用与实例的定时任务。</li><li><a href="https://github.com/YunaiV/skywalking/blob/bb8cb1b7dcb428c161f225f0b5d57441105f84c0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/AppAndServiceRegisterClient.java#L103" rel="external nofollow noopener noreferrer" target="_blank"><code>#boot()</code></a> <strong>实现</strong>方法，创建 <code>applicationRegisterFuture</code> 。该定时任务<strong>无初始化延迟</strong>，每 <code>Config.Collector.APP_AND_SERVICE_REGISTER_CHECK_INTERVAL</code> ( 默认：3 s ) 执行一次 <code>#run()</code> 方法。</li><li>———- 分割线 ———-</li><li><code>lastSegmentTime</code> 属性，最后记录 Segment 的时间。</li><li><a href="https://github.com/YunaiV/skywalking/blob/bb8cb1b7dcb428c161f225f0b5d57441105f84c0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/AppAndServiceRegisterClient.java#L186" rel="external nofollow noopener noreferrer" target="_blank"><code>#afterFinished()</code></a> <strong>实现</strong>方法，记录 Segment 最后的时间。</li><li><a href="https://github.com/YunaiV/skywalking/blob/bb8cb1b7dcb428c161f225f0b5d57441105f84c0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/AppAndServiceRegisterClient.java#L103" rel="external nofollow noopener noreferrer" target="_blank"><code>#afterBoot()</code></a> <strong>实现</strong>方法，将自己作为监听器( 因为实现了 TracingContextListener 接口 )添加到 GRPCChannelManager 中，从而监听 Segment 的记录。在 <a href="http://www.iocoder.cn/SkyWalking/agent-collect-trace/?self">《SkyWalking 源码分析 —— Agent 收集 Trace 数据》</a> 有详细解析。</li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/bb8cb1b7dcb428c161f225f0b5d57441105f84c0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/AppAndServiceRegisterClient.java#L120" rel="external nofollow noopener noreferrer" target="_blank"><code>#run()</code></a> <strong>实现</strong>方法，执行应用的注册，应用实例的正常注册、恢复注册、心跳的逻辑。</p><ul><li>第 123 行：循环，当 gRPC 处于<strong>连接中</strong>，并且需要重试( <code>shouldTry</code> )。可能对 <code>shouldTry</code> 会比较疑惑？该变量用于，应用的注册成功后，重新标记 <code>shouldTry = true</code> ，继续执行应用实例的注册。</li><li>第 126 至 135 行：当本地<strong>应用编号</strong>为空时，说明应用暂未注册，调用 <a href="#">「2.1 应用的注册 API」</a> 。</li><li>第 138 至 148 行：当本地<strong>应用实例编号</strong>为空时，说明应用实例暂未注册，调用 <a href="#">「2.2 应用实例的正常注册 API」</a> 。</li><li>第 150 至 158 行：当需要发起恢复注册时，即 gRPC Channel 断开后重连成功，调用 <a href="#">「2.3 应用实例的恢复注册 API」</a> 。</li><li>第 159 至 167 行：当<strong>现在时间</strong>超过 <code>lastSegmentTime</code> <strong>一分钟</strong>，调用 <a href="#">「2.4 应用实例的心跳 API」</a> 。</li><li>第 170 至 173 行：同步应用字典、操作字典。在 <a href="http://www.iocoder.cn/SkyWalking/agent-dictionary/?">《SkyWalking 源码分析 —— Agent DictionaryManager 字典管理》</a> 详细解析。</li><li>第 178 至 180 行：当发生异常时，调用 <code>GRPCChannelManager#reportError(t)</code> 方法，处理异常，例如请求超时。</li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>😈 距离 Segment 已经不远了。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_25/09.png" alt=""></p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/register/&quot;&gt;http://www.iocoder.cn/SkyWalking/register/&lt;/a&gt; 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;ul&gt;
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Agent Remote 远程通信服务</title>
    <link href="http://www.iocoder.cn/SkyWalking/agent-remote-manager/"/>
    <id>http://www.iocoder.cn/SkyWalking/agent-remote-manager/</id>
    <published>2020-09-19T16:00:00.000Z</published>
    <updated>2017-12-26T03:21:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/agent-remote-manager/">http://www.iocoder.cn/SkyWalking/agent-remote-manager/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-remote-manager/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-remote-manager/">2. GRPCChannelManager</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-remote-manager/">3. GRPCChannelListener</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-remote-manager/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>SkyWalking Agent Remote 远程通信服务</strong>。该服务用于 Agent 和Collector 集群的通信。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_20/01.png" alt=""></p><p>在 <a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/?self">《SkyWalking 源码分析 —— Collector Naming Server 命名服务》</a> 一文中，我们已经看到，Agent 使用<strong>定时轮询</strong>，从 Collector Naming Server 中，获得 Collector 集群的 Collector Agent gRPC Server 的<strong>所有地址</strong>。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_20/02.jpeg" alt=""></p><ul><li><strong>红框</strong>部分，即为 Agent 和Collector 集群的通信部分。</li><li>另外，Collector 也提供 <a href="https://github.com/YunaiV/skywalking/tree/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-collector/apm-collector-agent-jetty" rel="external nofollow noopener noreferrer" target="_blank">Collector Agent Jetty Server</a> ，目前暂不使用。相比来说，<a href="https://github.com/YunaiV/skywalking/tree/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-collector/apm-collector-agent-grpc" rel="external nofollow noopener noreferrer" target="_blank">Collector Agent gRPC Server</a> 性能更优。</li></ul><h1 id="2-GRPCChannelManager"><a href="#2-GRPCChannelManager" class="headerlink" title="2. GRPCChannelManager"></a>2. GRPCChannelManager</h1><p><code>org.skywalking.apm.agent.core.remote.GRPCChannelManager</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/ac6c98c1732d6aa62b9d244369478654411ac203/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/boot/BootService.java" rel="external nofollow noopener noreferrer" target="_blank">BootService</a> 、Runnable <strong>接口</strong>，gRPC Channel 管理器。GRPCChannelManager 负责管理与 Collector Agent gRPC Server 集群的<strong>连接的管理</strong>，<strong>提供给其他服务使用</strong>。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/GRPCChannelManager.java#L54" rel="external nofollow noopener noreferrer" target="_blank"><code>managedChannel</code></a> 属性，连接 gRPC Server 的 Channel 。<strong>同一时间，GRPCChannelManager 只连接一个 Collector Agent gRPC Server 节点，并且在 Channel 不因为各种网络问题断开的情况下，持续保持</strong>。</li><li><a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/GRPCChannelManager.java#L58" rel="external nofollow noopener noreferrer" target="_blank"><code>connectCheckFuture</code></a> 属性，定时重连 gRPC Server 的<strong>定时任务</strong>。</li><li><a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/GRPCChannelManager.java#L63" rel="external nofollow noopener noreferrer" target="_blank"><code>reconnect</code></a> 属性，是否重连。当 Channel 未连接需要连接，或者 Channel 断开需要重连时，标记 <code>reconnect = true</code> 。后台线程会根据该标识进行连接( 重连 )。</li><li><a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/GRPCChannelManager.java#L68" rel="external nofollow noopener noreferrer" target="_blank"><code>listeners</code></a> 属性，监听器( <code>org.skywalking.apm.agent.core.remote.GRPCChannelListener</code> ) 数组。使用 Channel 的其他服务，注册监听器到 GRPCChannelManager 上，从而根据连接状态( <code>org.skywalking.apm.agent.core.remote.GRPCChannelStatus</code> )，实现自定义逻辑。 </li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/GRPCChannelManager.java#L76" rel="external nofollow noopener noreferrer" target="_blank"><code>#boot()</code></a> <strong>实现</strong>方法，调用 <code>ScheduledExecutorService#scheduleAtFixedRate(...)</code> 方法，创建定时任务。该定时任务<strong>无初始化延迟</strong>，每 <code>Config.GRPC_CHANNEL_CHECK_INTERVAL</code> ( 默认：30 s ) 执行一次 <code>#run()</code> 方法。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/GRPCChannelManager.java#L97" rel="external nofollow noopener noreferrer" target="_blank"><code>#run()</code></a> <strong>实现</strong>方法，执行 Channel 的连接( 重连 )逻辑。代码如下：</p><ul><li>第 99 行：当 <code>reconnect = true</code> 时，才执行连接( 重连 )。</li><li>第 100 行：当本地已经获取到 Collector Agent gRPC Server 集群地址时，参见 <a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/?self">《SkyWalking 源码分析 —— Collector Naming Server 命名服务》</a> 。</li><li>第 101 至 106 行：<strong>随机选择</strong>准备链接的 Collector Agent gRPC Server 。</li><li>第 107 至 113 行：创建 Channel 并进行连接。此处主要是 gRPC 的 API 使用，不熟悉的胖友，请 Google 下进行了解了解。</li><li>第 115 至 117 行：连接<strong>成功</strong>，标记 <code>reconnect = false</code> ，这样，下次执行 <code>#run()</code> 方法不会重连。而后，调用 <a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/GRPCChannelManager.java#L160" rel="external nofollow noopener noreferrer" target="_blank"><code>#notify(GRPCChannelStatus.CONNECTED)</code></a> 方法，通知监听器连接成功。</li><li>第 118 至 121 行：连接<strong>成功</strong>，不标记 <code>reconnect</code> ，这样，下次执行 <code>#run()</code> 方法会继续重连。而后，调用 <a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/GRPCChannelManager.java#L160" rel="external nofollow noopener noreferrer" target="_blank"><code>#notify(GRPCChannelStatus.DISCONNECT)</code></a> 方法，通知监听器连接处于断开状态。</li><li>第 124 至 126 行：连接<strong>异常</strong>，不标记 <code>reconnect</code> ，这样，下次执行 <code>#run()</code> 方法会继续重连。而后，调用 <a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/GRPCChannelManager.java#L160" rel="external nofollow noopener noreferrer" target="_blank"><code>#notify(GRPCChannelStatus.DISCONNECT)</code></a> 方法，通知监听器连接处于断开状态。</li></ul><p>实际使用中，Channel 可能因为各种原因断开，那么 GRPCChannelManager 是怎么检测的呢？在使用 Channel 的<strong>其他服务</strong>，当使用 Channel 时发生异常，调用 <a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/GRPCChannelManager.java#L149" rel="external nofollow noopener noreferrer" target="_blank"><code>#reportError(Throwable)</code></a> 方法，判断是否为网络异常( <a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/GRPCChannelManager.java#L176" rel="external nofollow noopener noreferrer" target="_blank"><code>#isNetworkError(Throwable)</code></a> ) 。若是，标记 <code>reconnect = true</code> ，等待后台进行重连。</p><h1 id="3-GRPCChannelListener"><a href="#3-GRPCChannelListener" class="headerlink" title="3. GRPCChannelListener"></a>3. GRPCChannelListener</h1><p><code>org.skywalking.apm.agent.core.remote.GRPCChannelListener</code> ，gRPC Channel 的监听器<strong>接口</strong>，定义了 <a href="https://github.com/YunaiV/skywalking/blob/ba73b05b99a05bb67fd485188a6c6e0a4ad5fe57/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/GRPCChannelListener.java#L33" rel="external nofollow noopener noreferrer" target="_blank"><code>#statusChanged(GRPCChannelStatus)</code></a> ，通知 gRPC Channel 状态变更。</p><p>GRPCChannelListener 实现类如下图，后续文章会详细解析。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_20/03.png" alt=""></p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>“水”文一篇，哈哈哈。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_20/04.png" alt=""></p><p>胖友，分享一波朋友圈可好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/agent-remote-manager/&quot;&gt;http://www.iocoder.cn/SkyWalking/agent-remote-manager/&lt;/a&gt; 「芋道源
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— DataCarrier 异步处理库</title>
    <link href="http://www.iocoder.cn/SkyWalking/data-carrier/"/>
    <id>http://www.iocoder.cn/SkyWalking/data-carrier/</id>
    <published>2020-09-14T16:00:00.000Z</published>
    <updated>2017-12-25T12:46:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/data-carrier/">http://www.iocoder.cn/SkyWalking/data-carrier/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/data-carrier/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/data-carrier/">2. buffer</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/data-carrier/">2.1 Buffer</a></li><li><a href="http://www.iocoder.cn/SkyWalking/data-carrier/">2.2 Channels</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/data-carrier/">3. partition</a></li><li><a href="http://www.iocoder.cn/SkyWalking/data-carrier/">4. consumer</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/data-carrier/">4.1 IConsumer</a></li><li><a href="http://www.iocoder.cn/SkyWalking/data-carrier/">4.2 ConsumerThread</a></li><li><a href="http://www.iocoder.cn/SkyWalking/data-carrier/">4.3 ConsumerPool</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/data-carrier/">4. DataCarrier</a></li><li><a href="http://www.iocoder.cn/SkyWalking/data-carrier/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>SkyWalking DataCarrier 异步处理库</strong>。</p><p>基于生产者消费者的模式，大体结构如下图：<img src="http://www.iocoder.cn/images/SkyWalking/2020_09_15/01.png" alt=""></p><ul><li>实际项目中，没有 Producer 这个类。所以本文提到的 Producer ，更多的是一种<strong>角色</strong>。</li></ul><p>下面我们来看看整体的项目结构，如下图所示 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_09_15/02.png" alt=""></p><h1 id="2-buffer"><a href="#2-buffer" class="headerlink" title="2. buffer"></a>2. buffer</h1><p><code>org.skywalking.apm.commons.datacarrier.buffer</code> 包，主要包含 Channels 、Buffer 两个类。Channels 是 Buffer 数组的封装。</p><h2 id="2-1-Buffer"><a href="#2-1-Buffer" class="headerlink" title="2.1 Buffer"></a>2.1 Buffer</h2><p><code>org.skywalking.apm.commons.datacarrier.buffer.Buffer</code> ，缓存区。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/buffer/Buffer.java#L35" rel="external nofollow noopener noreferrer" target="_blank"><code>buffer</code></a> 属性，缓冲数组。Producer 保存的数据到 <code>buffer</code> 里。</li><li><a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/buffer/Buffer.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>strategy</code></a> ，缓冲策略( <a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/buffer/BufferStrategy.java#L26" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.commons.datacarrier.buffer.BufferStrategy</code></a> ) 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/buffer/Buffer.java#L43" rel="external nofollow noopener noreferrer" target="_blank"><code>index</code></a> 属性，递增位置( <a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/common/AtomicRangeInteger.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.commons.datacarrier.common.AtomicRangeInteger</code></a> )。</li></ul><p>Buffer 在保存数据时，把 <code>buffer</code> 作为一个 “<strong>环</strong>“，使用 <code>index</code> 记录最后存储的位置，不断向下，<strong>循环</strong>存储到 <code>buffer</code> 中。通过这样的方式，带来良好的存储性能，避免扩容问题。But ，存储会存在冲突的问题：<code>buffer</code> 写入位置，暂未被消费，已经存在值。此时，根据不同的 BufferStrategy 进行处理。整体流程见 <a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/buffer/Buffer.java#L61" rel="external nofollow noopener noreferrer" target="_blank"><code>#save(data)</code></a> 方法。</p><p>当 Buffer 被 Consumer 消费时，被调用 <a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/buffer/Buffer.java#L88" rel="external nofollow noopener noreferrer" target="_blank"><code>#obtain(start, end)</code></a> 方法，获得数据并清空。为什么会带 <code>start</code> 、<code>end</code> 方法参数呢？下文揭晓答案。</p><h2 id="2-2-Channels"><a href="#2-2-Channels" class="headerlink" title="2.2 Channels"></a>2.2 Channels</h2><p><code>org.skywalking.apm.commons.datacarrier.buffer.Channels</code> ，内嵌<strong>多个</strong> Buffer 的通道。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/buffer/Channels.java#L37" rel="external nofollow noopener noreferrer" target="_blank"><code>bufferChannels</code></a> 属性，Buffer 数组。</li><li><a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/buffer/Channels.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>dataPartitioner</code></a> 属性，数据分区( <a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/partition/IDataPartitioner.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.commons.datacarrier.partition.IDataPartitioner</code></a> )。</li><li><a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/buffer/Buffer.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>strategy</code></a> 属性，缓冲策略( <a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/buffer/Channels.java#L42" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.commons.datacarrier.buffer.BufferStrategy</code></a> ) 。</li></ul><p>Channels 在保存数据时，相比 Buffer ，从 <code>buffer</code> 变成了多 <code>buffer</code> ，因此需要先选一个 <code>buffer</code> 。通过使用不同的 IDataPartitioner 实现类，进行 Buffer 的选择。当缓冲策略为 <code>BufferStrategy.IF_POSSIBLE</code> 时，根据 IDataPartitioner 定义的重试次数，进行多次保存数据直到成功。整体流程见 <a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/buffer/Channels.java#L62" rel="external nofollow noopener noreferrer" target="_blank"><code>#save(data)</code></a> 方法。</p><h1 id="3-partition"><a href="#3-partition" class="headerlink" title="3. partition"></a>3. partition</h1><p><a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/partition/IDataPartitioner.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.commons.datacarrier.partition.IDataPartitioner</code></a> ，数据分配者<strong>接口</strong>。定义了如下方法：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/partition/IDataPartitioner.java#L37" rel="external nofollow noopener noreferrer" target="_blank"><code>#partition(total, data)</code></a> <strong>接口</strong>方法，获得数据被分配的分区位置。</li><li><a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/partition/IDataPartitioner.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#maxRetryCount()</code></a> <strong>接口</strong>方法，获得最大重试次数。</li></ul><p>IDataPartitioner 目前有两个子类实现：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/partition/ProducerThreadPartitioner.java" rel="external nofollow noopener noreferrer" target="_blank">ProducerThreadPartitioner</a> ，基于线程编号分配策略的数据分配者实现类。</li><li><a href="https://github.com/YunaiV/skywalking/blob/98217271d1b4d2075871b3e262c9b99bb9c1f657/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/partition/SimpleRollingPartitioner.java" rel="external nofollow noopener noreferrer" target="_blank">SimpleRollingPartitioner</a> ，基于顺序分配策略的数据分配者实现类。</li></ul><h1 id="4-consumer"><a href="#4-consumer" class="headerlink" title="4. consumer"></a>4. consumer</h1><p><code>org.skywalking.apm.commons.datacarrier.consumer</code> 包，主要包含 ConsumerPool 、ConsumerThread 、IConsumer 三个类。</p><ul><li>ConsumerThread 使用 IConsumer ，消费数据</li><li>ConsumerPool 是 ConsumerThread 的线程池封装</li></ul><h2 id="4-1-IConsumer"><a href="#4-1-IConsumer" class="headerlink" title="4.1 IConsumer"></a>4.1 IConsumer</h2><p><code>org.skywalking.apm.commons.datacarrier.consumer.IConsumer</code> ，消费者接口。定义了如下方法：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/IConsumer.java#L33" rel="external nofollow noopener noreferrer" target="_blank"><code>#init()</code></a> <strong>接口</strong>方法，初始化消费者。</li><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/IConsumer.java#L40" rel="external nofollow noopener noreferrer" target="_blank"><code>#consume(List&lt;T&gt;)</code></a> <strong>接口</strong>方法，批量消费消息。</li><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/IConsumer.java#L48" rel="external nofollow noopener noreferrer" target="_blank"><code>#onError(List&lt;T&gt;, Throwable)</code></a> <strong>接口</strong>方法，处理当消费发生异常。</li><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/IConsumer.java#L53" rel="external nofollow noopener noreferrer" target="_blank"><code>#onExit()</code></a> <strong>接口</strong>方法，处理当消费结束。此处的结束时，ConsumerThread 关闭。</li></ul><p>我们在使用时，自定义 Consumer 类，实现 IConsumer 接口。例如：<a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteClient.java#L93" rel="external nofollow noopener noreferrer" target="_blank">RemoteMessageConsumer</a> 。</p><h2 id="4-2-ConsumerThread"><a href="#4-2-ConsumerThread" class="headerlink" title="4.2 ConsumerThread"></a>4.2 ConsumerThread</h2><p><code>org.skywalking.apm.commons.datacarrier.consumer.ConsumerThread</code> ，继承 <code>java.lang.Thread</code> ，消费线程。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/ConsumerThread.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><code>running</code></a> 属性，是否运行中。</li><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/ConsumerThread.java#L40" rel="external nofollow noopener noreferrer" target="_blank"><code>consumer</code></a> 属性，消费者对象。</li><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/ConsumerThread.java#L44" rel="external nofollow noopener noreferrer" target="_blank"><code>dataSources</code></a> 属性，消费消息的数据源( <a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/ConsumerThread.java#L139" rel="external nofollow noopener noreferrer" target="_blank">DataSource</a> )数组。一个 ConsumerThread ，可以消费多个 Buffer ，并且单个 Buffer 消费的分区范围可配置，即一个 Buffer 可以被多个 ConsumerThread 同时无冲突的消费。在 <a href="#">「4.3 ConsumerPool」</a> 详细解析 ConsumerThread 分配 Buffer 的方式。<ul><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/ConsumerThread.java#L60" rel="external nofollow noopener noreferrer" target="_blank"><code>#addDataSource(sourceBuffer, start, end)</code></a> 方法，添加 Buffer 部分范围。</li><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/ConsumerThread.java#L69" rel="external nofollow noopener noreferrer" target="_blank"><code>#addDataSource(sourceBuffer)</code></a> 方法，添加 Buffer 全部范围。</li></ul></li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/ConsumerThread.java#L74" rel="external nofollow noopener noreferrer" target="_blank"><code>#run()</code></a> <strong>实现</strong>方法，<strong>不断</strong>、<strong>批量</strong>的消费数据。代码如下：</p><ul><li>第 78 至 88 行：<strong>不断</strong>消费，直到线程关闭( <a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/ConsumerThread.java#L130" rel="external nofollow noopener noreferrer" target="_blank"><code>#shutdown()</code></a> )。<ul><li>第 80 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/ConsumerThread.java#L103" rel="external nofollow noopener noreferrer" target="_blank"><code>#consume()</code></a> 方法，<strong>批量</strong>消费数据。</li><li>第 82 至 87 行：当未消费到数据，说明 <code>dataSources</code> 为空，等待 20 ms ，避免 CPU 空跑。</li></ul></li><li>第 93 行：当线程关闭，调用 <code>#consume()</code> 方法，消费完 <code>dataSources</code> 剩余的数据。</li><li>第 95 行：调用 <code>IConsumer#onExit()</code> 方法，处理当消费结束。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/ConsumerThread.java#L103" rel="external nofollow noopener noreferrer" target="_blank"><code>#consume()</code></a> 方法，<strong>批量</strong>消费数据。代码如下：</p><ul><li>第 107 至 117 行：从 <code>dataSources</code> 中，获取要消费的数据。</li><li>第 120 至 126 行：当有数据可消费时，调用 <code>IConsumer#consume(List&lt;T&gt;)</code> 方法。当消费发生异常时，调用 <code>IConsumer#onError(List&lt;T&gt;, Throwable)</code> 方法。</li><li>第 127 行：返回是否有消费数据。</li></ul><h2 id="4-3-ConsumerPool"><a href="#4-3-ConsumerPool" class="headerlink" title="4.3 ConsumerPool"></a>4.3 ConsumerPool</h2><p><code>org.skywalking.apm.commons.datacarrier.consumer.ConsumerPool</code> ，消费者池，提供了对 Channels 启动<strong>指定数量</strong>的 ConsumerThread 进行消费。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/ConsumerPool.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>running</code></a> 属性，是否运行中。</li><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/ConsumerPool.java#L43" rel="external nofollow noopener noreferrer" target="_blank"><code>consumerThreads</code></a> 属性，ConsumerThread 数组，通过构造方法的 <code>num</code> 参数进行指定。</li><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/ConsumerPool.java#L47" rel="external nofollow noopener noreferrer" target="_blank"><code>channels</code></a> 属性，<strong>数据</strong>通道。</li><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/ConsumerPool.java#L51" rel="external nofollow noopener noreferrer" target="_blank"><code>lock</code></a> 属性，锁。保证 ConsumerPool 启动或关闭时的线程安全。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/ConsumerPool.java#L96" rel="external nofollow noopener noreferrer" target="_blank"><code>#begin()</code></a> 方法，启动 ConsumerPool ，进行数据消费。代码如下：</p><ul><li>第 97 至 99 行：正在运行中，直接返回。</li><li>第 101 行：获得锁。</li><li>第 104 行：调用 <code>#allocateBuffer2Thread()</code> 方法，将 <code>channels</code> 的<strong>多个</strong> Buffer ，分配给 <code>consumerThreads</code> 的<strong>多个</strong> ConsumerThread。</li><li>第 107 至 109 行：启动每个 ConsumerThread ，开始消费。</li><li>第 112 行：标记正在运行中。</li><li>第 114 行：释放锁。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/ConsumerPool.java#L166" rel="external nofollow noopener noreferrer" target="_blank"><code>close()</code></a> 方法，关闭 ConsumerPool 。代码如下：</p><ul><li>第 168 行：获得锁。</li><li>第 169 行：标记不在运行中。</li><li>第 170 至 172 行：关闭每个 ConsumerThread ，结束消费。</li><li>第 174 行：释放锁。</li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/consumer/ConsumerPool.java#L122" rel="external nofollow noopener noreferrer" target="_blank"><code>#allocateBuffer2Thread()</code></a> 方法，将 <code>channels</code> 的<strong>多个</strong> Buffer ，分配给 <code>consumerThreads</code> 的<strong>多个</strong> ConsumerThread。一共会有三种情况：</p><ul><li><p>Buffer 数量<strong>等于</strong> ConsumerThread 数量，这个十分好分配，一比一。</p></li><li><p>Buffer 数量<strong>大于</strong> ConsumerThread 数量，那么按照 Buffer 数量 <code>%</code> ConsumerThread 数量进行分组，分配给 ConsumerThread ，如下图所示：<img src="http://www.iocoder.cn/images/SkyWalking/2020_09_15/03.png" alt=""></p></li><li><p>Buffer 数量<strong>大于</strong> ConsumerThread 数量，那么按照 ConsumerThread 数量 <code>%</code> Buffer 数量进行分组，分配给 Buffer 。其中，一个 Buffer 会被<strong>均分</strong>给多个 ConsumerThread ，如下图所示：<img src="http://www.iocoder.cn/images/SkyWalking/2020_09_15/04.png" alt=""></p><ul><li>这个就是为什么 Buffer 里面，提供了 <a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/buffer/Buffer.java#L88" rel="external nofollow noopener noreferrer" target="_blank"><code>Buffer#obtain(start, end)</code></a> 方法的原因。</li></ul></li></ul><h1 id="4-DataCarrier"><a href="#4-DataCarrier" class="headerlink" title="4. DataCarrier"></a>4. DataCarrier</h1><p><code>org.skywalking.apm.commons.datacarrier.DataCarrier</code> ，DataCarrier 异步处理库的<strong>入口程序</strong>。通过创建 DataCarrier 对象，使用<strong>生产者消费者的模式</strong>，执行异步执行逻辑。</p><p><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/DataCarrier.java#L53" rel="external nofollow noopener noreferrer" target="_blank">构造方法</a> ，代码如下：</p><ul><li><p><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/DataCarrier.java#L47" rel="external nofollow noopener noreferrer" target="_blank"><code>channels</code></a> 属性，<strong>数据</strong>通道。在构造方法中，我们可以看到默认使用 SimpleRollingPartitioner 作为数据分区分配者，使用 <code>BufferStrategy.BLOCKING</code> 作为缓冲策略。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/DataCarrier.java#L66" rel="external nofollow noopener noreferrer" target="_blank"><code>#setPartitioner(IDataPartitioner)</code></a> 方法，设置数据分区分配者。</li><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/DataCarrier.java#L77" rel="external nofollow noopener noreferrer" target="_blank"><code>#setBufferStrategy(BufferStrategy)</code></a> 方法，设置缓冲策略。</li></ul></li><li><p><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/DataCarrier.java#L53" rel="external nofollow noopener noreferrer" target="_blank"><code>channelSize</code></a> 方法参数，通道大小。</p></li><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/DataCarrier.java#L53" rel="external nofollow noopener noreferrer" target="_blank"><code>bufferSize</code></a> 方法参数，缓冲区大小。</li></ul><p><strong>设置消费者和消费线程数量</strong>：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/DataCarrier.java#L107" rel="external nofollow noopener noreferrer" target="_blank"><code>#consume(Class&lt;? extends IConsumer&lt;T&gt;&gt;, num)</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/DataCarrier.java#L124" rel="external nofollow noopener noreferrer" target="_blank"><code>#consume(IConsumer&lt;T&gt;, num)</code></a></li></ul><p><strong>生产消息</strong></p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/DataCarrier.java#L88" rel="external nofollow noopener noreferrer" target="_blank"><code>#produce(data)</code></a></li></ul><p><strong>关闭消费</strong></p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/fbdce6d3c0fe456629a2eef40184a3dbc9df812c/apm-commons/apm-datacarrier/src/main/java/org/skywalking/apm/commons/datacarrier/DataCarrier.java#L138" rel="external nofollow noopener noreferrer" target="_blank"><code>#shutdownConsumers()</code></a></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>本文的图，画的真难看，来自自己的吐槽，哈哈哈。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_15/05.png" alt=""></p><p>胖友，分享一波朋友圈可好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/data-carrier/&quot;&gt;http://www.iocoder.cn/SkyWalking/data-carrier/&lt;/a&gt; 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector Remote 远程通信服务</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-remote-module/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-remote-module/</id>
    <published>2020-09-09T16:00:00.000Z</published>
    <updated>2017-12-25T12:45:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">http://www.iocoder.cn/SkyWalking/collector-remote-module/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">2. collector-remote-define</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">2.1 RemoteModule</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">2.2 RemoteSenderService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">2.3 RemoteClientService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">2.4 RemoteClient</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">2.5 CommonRemoteDataRegisterService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">2.6 RemoteSerializeService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">2.7 RemoteSerializeService</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">3. collector-remote-grpc-provider</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">3.1 RemoteModuleGRPCProvider</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">3.2 GRPCRemoteSenderService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">3.3 GRPCRemoteClientService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">3.4 GRPCRemoteClient</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">3.5 RemoteCommonServiceHandler</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">3.6 GRPCRemoteSerializeService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">3.7 GRPCRemoteDeserializeService</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">4. collector-remote-grpc-provider</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-remote-module/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>SkyWalking Collector Remote 远程通信服务</strong>。该服务用于 Collector 集群内部通信。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_10/04.png" alt=""></p><p>目前集群内部通信的目的，跨节点的流式处理。Remote Module <strong>应用</strong>在 SkyWalking 架构图如下位置( <strong>红框</strong> ) ：</p><blockquote><p>FROM <a href="https://github.com/apache/incubating-skywalking" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubating-skywalking</a><br><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_10/01.jpeg" alt=""></p></blockquote><p>下面我们来看看整体的项目结构，如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_10/02.png" alt=""></p><ul><li><code>collector-remote-define</code> ：定义远程通信接口。</li><li><code>collector-remote-kafka-provider</code> ：基于 Kafka 的远程通信实现。<em>目前暂未完成</em>。</li><li><code>collector-remote-grpc-provider</code> ：基于 <a href="https://grpc.io/" rel="external nofollow noopener noreferrer" target="_blank">Google gRPC</a> 的远程通信实现。<strong>生产环境目前使用</strong></li></ul><p>下面，我们从<strong>接口到实现</strong>的顺序进行分享。</p><h1 id="2-collector-remote-define"><a href="#2-collector-remote-define" class="headerlink" title="2. collector-remote-define"></a>2. collector-remote-define</h1><p><code>collector-remote-define</code> ：定义远程通信接口。项目结构如下 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_10/03.png" alt=""></p><p>整体流程如下图：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_10/05.png" alt=""></p><p>我们按照整个流程的处理顺序，逐个解析涉及到的类与接口。</p><h2 id="2-1-RemoteModule"><a href="#2-1-RemoteModule" class="headerlink" title="2.1 RemoteModule"></a>2.1 RemoteModule</h2><p><code>org.skywalking.apm.collector.remote.RemoteModule</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java" rel="external nofollow noopener noreferrer" target="_blank">Module</a> 抽象类，远程通信 Module 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/RemoteModule.java#L34" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回模块名为 <code>&quot;remote&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/RemoteModule.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>#services()</code></a> <strong>实现</strong>方法，返回 Service 类名：RemoteSenderService 、RemoteDataRegisterService 。</p><h2 id="2-2-RemoteSenderService"><a href="#2-2-RemoteSenderService" class="headerlink" title="2.2 RemoteSenderService"></a>2.2 RemoteSenderService</h2><p><code>org.skywalking.apm.collector.remote.service.RemoteSenderService</code> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> 接口，远程发送服务<strong>接口</strong>，定义了 <a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/RemoteSenderService.java#L40" rel="external nofollow noopener noreferrer" target="_blank"><code>#send(graphId, nodeId, data, selector)</code></a> <strong>接口</strong>方法，调用 RemoteClient ，发送数据。</p><ul><li><code>graphId</code> 方法参数，Graph 编号。通过 <code>graphId</code> ，可以查找到对应的 Graph 对象。<ul><li>Graph 在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（一）》「2. apm-collector-core/graph」</a> 有详细解析。</li></ul></li><li><code>nodeId</code> 方法参数，Worker 编号。通过 <code>workerId</code> ，可以查找在 Graph 对象中的 Worker 对象，从而 Graph 中的流式处理。<ul><li>Worker 在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（一）》「3. apm-collector-stream」</a> 有详细解析。</li></ul></li><li><code>data</code> 方法参数，Data 数据对象。例如，流式处理的具体数据对象。<ul><li>Data 在 <a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">《SkyWalking 源码分析 —— Collector Storage 存储组件》「2. apm-collector-core」</a> 有详细解析。</li></ul></li><li><code>selector</code> 方法参数，<a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/Selector.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.remote.service.Selector</code></a> 选择器对象。根据 Selector 对象，使用对应的<strong>负载均衡</strong>策略，选择集群内的 Collector 节点，发送数据。</li><li><a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/RemoteSenderService.java#L45" rel="external nofollow noopener noreferrer" target="_blank">RemoteSenderService.Mode</a> 返回值，发送模式分成 <code>Remote</code> 和 <code>Local</code> 两种方式。前者，发送数据到远程的 Collector 节点；后者，发送数据到本地，即本地处理，参见 <a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/RemoteWorkerRef.java#L58" rel="external nofollow noopener noreferrer" target="_blank"><code>RemoteWorkerRef#in(message)</code></a> 方法。</li></ul><h2 id="2-3-RemoteClientService"><a href="#2-3-RemoteClientService" class="headerlink" title="2.3 RemoteClientService"></a>2.3 RemoteClientService</h2><p><code>org.skywalking.apm.collector.remote.service.RemoteClientService</code> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> 接口，远程客户端服务<strong>接口</strong>，定义了 <a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/RemoteClientService.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>#create(host, port, channelSize, bufferSize)</code></a> <strong>接口</strong>方法，创建 RemoteClient 对象。</p><h2 id="2-4-RemoteClient"><a href="#2-4-RemoteClient" class="headerlink" title="2.4 RemoteClient"></a>2.4 RemoteClient</h2><p><code>org.skywalking.apm.collector.remote.service.RemoteClient</code> ，继承 <code>java.lang.Comparable</code> 接口，远程客户端<strong>接口</strong>。定义了如下接口方法：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/RemoteClient.java#L42" rel="external nofollow noopener noreferrer" target="_blank"><code>#push(graphId, nodeId, data, selector)</code></a> <strong>接口</strong>方法，发送数据。</li><li><a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/RemoteClient.java#L33" rel="external nofollow noopener noreferrer" target="_blank"><code>#getAddress()</code></a> <strong>接口</strong>方法，返回客户端连接的远程 Collector 地址。</li><li><a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/RemoteClient.java#L44" rel="external nofollow noopener noreferrer" target="_blank"><code>#equals(address)</code></a> <strong>接口</strong>方法，判断 RemoteClient 是否连接了指定的地址。</li></ul><h2 id="2-5-CommonRemoteDataRegisterService"><a href="#2-5-CommonRemoteDataRegisterService" class="headerlink" title="2.5 CommonRemoteDataRegisterService"></a>2.5 CommonRemoteDataRegisterService</h2><p>在说 CommonRemoteDataRegisterService 之前，首先来说下 CommonRemoteDataRegisterService 的意图。</p><p>在上文中，我们可以看到发送给 Collector 是 Data 对象，而 <a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/Data.java" rel="external nofollow noopener noreferrer" target="_blank">Data</a> 是数据的<strong>抽象类</strong>，在具体反序列化 Data 对象之前，程序是无法得知它是 Data 的哪个实现对象。这个时候，我们可以给 Data 对象的每个实现类，生成一个对应的<strong>数据协议编号</strong>。</p><ul><li>在发送数据之前，序列化 Data 对象时，增加该 Data 对应的协议编号，一起发送。</li><li>在接收数据之后，反序列化数据时，根据协议编号，创建 Data 对应的实现类对象。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/CommonRemoteDataRegisterService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.remote.service.CommonRemoteDataRegisterService</code></a> ，通用远程数据注册服务。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/CommonRemoteDataRegisterService.java#L40" rel="external nofollow noopener noreferrer" target="_blank"><code>id</code></a> 属性，数据协议自增编号。</li><li><a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/CommonRemoteDataRegisterService.java#L44" rel="external nofollow noopener noreferrer" target="_blank"><code>dataClassMapping</code></a> 属性，数据类型( Class&lt;? extends Data&gt; )与<strong>数据协议编号</strong>的映射。</li><li><a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/CommonRemoteDataRegisterService.java#L48" rel="external nofollow noopener noreferrer" target="_blank"><code>dataInstanceCreatorMapping</code></a> 属性，<strong>数据协议编号</strong>与数据对象创建器( RemoteDataInstanceCreator )的映射。</li></ul><h3 id="2-5-1-RemoteDataRegisterService"><a href="#2-5-1-RemoteDataRegisterService" class="headerlink" title="2.5.1 RemoteDataRegisterService"></a>2.5.1 RemoteDataRegisterService</h3><p><code>org.skywalking.apm.collector.remote.service.RemoteDataRegisterService</code> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> 接口，远程客户端服务<strong>接口</strong>，定义了 <a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/RemoteDataRegisterService.java#L37" rel="external nofollow noopener noreferrer" target="_blank"><code>#register(Class&lt;? extends Data&gt;, RemoteDataInstanceCreator)</code></a> <strong>接口</strong>方法，注册数据类型对应的远程数据创建器( <a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/RemoteDataRegisterService.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>RemoteDataRegisterService.RemoteDataInstanceCreator</code></a> )对象。</p><p>CommonRemoteDataRegisterService 实现了 RemoteDataRegisterService 接口，<a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/CommonRemoteDataRegisterService.java#L56" rel="external nofollow noopener noreferrer" target="_blank"><code>#register(Class&lt;? extends Data&gt;, RemoteDataInstanceCreator)</code></a> <strong>实现</strong>方法。</p><p>另外，<a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/AgentStreamRemoteDataRegister.java#L42" rel="external nofollow noopener noreferrer" target="_blank">AgentStreamRemoteDataRegister</a> 会调用 <a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/RemoteDataRegisterService.java#L37" rel="external nofollow noopener noreferrer" target="_blank"><code>RemoteDataRegisterService#register(Class&lt;? extends Data&gt;, RemoteDataInstanceCreator)</code></a> 方法，注册每个数据类型的 RemoteDataInstanceCreator 对象。注意，例如 <code>Application::new</code> 是 RemoteDataInstanceCreator 的<strong>匿名实现类</strong>。</p><h3 id="2-5-2-RemoteDataIDGetter"><a href="#2-5-2-RemoteDataIDGetter" class="headerlink" title="2.5.2 RemoteDataIDGetter"></a>2.5.2 RemoteDataIDGetter</h3><p><code>org.skywalking.apm.collector.remote.service.RemoteDataIDGetter</code> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> 接口，远程数据协议编号获取器<strong>接口</strong>，定义了 <a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/RemoteDataIDGetter.java#L37" rel="external nofollow noopener noreferrer" target="_blank"><code>#getRemoteDataId(Class&lt;? extends Data&gt;)</code></a> <strong>接口</strong>方法，根据数据类型获取数据协议编号。</p><p>CommonRemoteDataRegisterService 实现了 RemoteDataIDGetter 接口，<a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/CommonRemoteDataRegisterService.java#L67" rel="external nofollow noopener noreferrer" target="_blank"><code>#getRemoteDataId(Class&lt;? extends Data&gt;)</code></a> <strong>实现</strong>方法。</p><h3 id="2-5-3-RemoteDataInstanceCreatorGetter"><a href="#2-5-3-RemoteDataInstanceCreatorGetter" class="headerlink" title="2.5.3 RemoteDataInstanceCreatorGetter"></a>2.5.3 RemoteDataInstanceCreatorGetter</h3><p><code>org.skywalking.apm.collector.remote.service.RemoteDataInstanceCreatorGetter</code> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> 接口，远程数据创建器的获取器<strong>接口</strong>，定义了 <a href="https://github.com/YunaiV/skywalking/blob/f70019926200139f9fe235ade9aaf7724ab72c8b/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/RemoteDataInstanceCreatorGetter.java#L35" rel="external nofollow noopener noreferrer" target="_blank"><code>#getInstanceCreator(remoteDataId</code></a> <strong>接口</strong>方法，根据数据协议编号获得远程数据创建器( RemoteDataInstanceCreator )。</p><p>CommonRemoteDataRegisterService 实现了 RemoteDataInstanceCreatorGetter 接口，<a href="https://github.com/YunaiV/skywalking/blob/f70019926200139f9fe235ade9aaf7724ab72c8b/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/CommonRemoteDataRegisterService.java#L75" rel="external nofollow noopener noreferrer" target="_blank"><code>#getInstanceCreator(remoteDataId)</code></a> <strong>实现</strong>方法。</p><h2 id="2-6-RemoteSerializeService"><a href="#2-6-RemoteSerializeService" class="headerlink" title="2.6 RemoteSerializeService"></a>2.6 RemoteSerializeService</h2><p><code>org.skywalking.apm.collector.remote.service.RemoteSerializeService</code> ，远程通信序列化服务<strong>接口</strong>，定义了 <a href="https://github.com/YunaiV/skywalking/blob/f70019926200139f9fe235ade9aaf7724ab72c8b/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/RemoteSerializeService.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><code>#serialize(Data)</code></a> <strong>接口</strong>方法，序列化数据，生成 Builder 对象。</p><h2 id="2-7-RemoteSerializeService"><a href="#2-7-RemoteSerializeService" class="headerlink" title="2.7 RemoteSerializeService"></a>2.7 RemoteSerializeService</h2><p><code>org.skywalking.apm.collector.remote.service.RemoteDeserializeService</code> ，远程通信序反列化服务<strong>接口</strong>，定义了 <a href="https://github.com/YunaiV/skywalking/blob/f70019926200139f9fe235ade9aaf7724ab72c8b/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/RemoteDeserializeService.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><code>#deserialize(RemoteData, Data)</code></a> <strong>接口</strong>方法，反序列化传输数据。</p><h1 id="3-collector-remote-grpc-provider"><a href="#3-collector-remote-grpc-provider" class="headerlink" title="3. collector-remote-grpc-provider"></a>3. collector-remote-grpc-provider</h1><p><code>collector-remote-grpc-provider</code> ，基于 <a href="https://grpc.io/" rel="external nofollow noopener noreferrer" target="_blank">Google gRPC</a> 的远程通信实现。</p><p>项目结构如下 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_09_10/06.png" alt=""></p><p><strong>默认配置</strong>，在 <a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-core/src/main/resources/application-default.yml#L14" rel="external nofollow noopener noreferrer" target="_blank"><code>application-default.yml</code></a> <strong>已经</strong>配置如下：</p><figure class="highlight"><table><tr><td class="code"><pre><div class="line">remote:</div><div class="line">  gRPC:</div><div class="line">    host: localhost</div><div class="line">    port: 11800</div></pre></td></tr></table></figure><h2 id="3-1-RemoteModuleGRPCProvider"><a href="#3-1-RemoteModuleGRPCProvider" class="headerlink" title="3.1 RemoteModuleGRPCProvider"></a>3.1 RemoteModuleGRPCProvider</h2><p><a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/RemoteModuleGRPCProvider.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.remote.grpc.RemoteModuleGRPCProvider</code></a> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java" rel="external nofollow noopener noreferrer" target="_blank">ModuleProvider</a> <strong>抽象类</strong>，基于 gRPC 的组件服务提供者实现类。</p><p><a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/RemoteModuleGRPCProvider.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回组件服务提供者名为 <code>&quot;gRPC&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/RemoteModuleGRPCProvider.java#L42" rel="external nofollow noopener noreferrer" target="_blank"><code>module()</code></a> <strong>实现</strong>方法，返回组件类为 RemoteModule 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/RemoteModuleGRPCProvider.java#L81" rel="external nofollow noopener noreferrer" target="_blank"><code>#requiredModules()</code></a> <strong>实现</strong>方法，返回依赖组件为 <code>cluster</code> 、<code>gRPC_manager</code> 。</p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/RemoteModuleGRPCProvider.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#prepare(Properties)</code></a> <strong>实现</strong>方法，执行准备阶段逻辑。</p><ul><li>第 53 至 56 行 ：创建 CommonRemoteDataRegisterService 、GRPCRemoteSenderService 对象，并调用 <code>#registerServiceImplementation()</code> <strong>父类</strong>方法，注册到 <code>services</code> 。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/RemoteModuleGRPCProvider.java#L59" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> <strong>实现</strong>方法，执行启动阶段逻辑。</p><ul><li>Server 相关<ul><li>第 65 行：创建 gRPC Server 对象。 </li><li>第 67 行：注册 RemoteCommonServiceHandler 对象到 gRPC Server 上，用于接收 gRPC 请求后的处理。</li><li><a href="http://www.iocoder.cn/SkyWalking/collector-server-component/?self">《SkyWalking 源码分析 —— Collector Server Component 服务器组件》「3. gRPC 实现」</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-grpc-server-module/?self">《SkyWalking 源码分析 —— Collector gRPC Server Manager》</a></li></ul></li><li>注册发现相关<ul><li>第 70 至 71 行：创建 <a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/RemoteModuleGRPCRegistration.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.remote.grpc.RemoteModuleGRPCRegistration</code></a> 对象，将自己注册到集群管理。这样，自己可以被 Collector 集群节点发现，从而被调用。</li><li>第 73 至 74 行：注册 GRPCRemoteSenderService 对象到集群管理。这样，自己可以监听到 Collector 集群节点的加入或离开，从而调用。</li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/?self">《SkyWalking 源码分析 —— Collector Cluster 集群管理》</a> </li></ul></li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/RemoteModuleGRPCProvider.java#L77" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyAfterCompleted()</code></a> <strong>实现</strong>方法，方法为空。</p><h2 id="3-2-GRPCRemoteSenderService"><a href="#3-2-GRPCRemoteSenderService" class="headerlink" title="3.2 GRPCRemoteSenderService"></a>3.2 GRPCRemoteSenderService</h2><p><code>org.skywalking.apm.collector.remote.grpc.service.GRPCRemoteSenderService</code> ，继承 ClusterModuleListener 抽象类，实现 RemoteSenderService 接口，基于 gPRC 的远程发送服务实现类。</p><h3 id="3-2-1-注册发现"><a href="#3-2-1-注册发现" class="headerlink" title="3.2.1 注册发现"></a>3.2.1 注册发现</h3><p>通过继承 ClusterModuleListener 抽象类，实现了监听 Collector 集群节点的加入或离开。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteSenderService.java#L51" rel="external nofollow noopener noreferrer" target="_blank"><code>remoteClients</code></a> 属性，连接 Collector 集群节点的客户端数组。每个 Collector 集群节点，对应一个客户端。</li><li><a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteSenderService.java#L96" rel="external nofollow noopener noreferrer" target="_blank"><code>#path()</code></a> <strong>实现</strong>方法，返回监听的目录 <code>&quot;/&quot; + RemoteModule.NAME + &quot;/&quot; + RemoteModuleGRPCProvider.NAME</code> 。Collector 集群中，每个节点的 Remote Server 都会注册到该目录下。</li><li><a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteSenderService.java#L100" rel="external nofollow noopener noreferrer" target="_blank"><code>#serverJoinNotify(serverAddress)</code></a> <strong>实现</strong>方法，当新的节点加入，<strong>创建</strong>新的客户端连接。</li><li><a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteSenderService.java#L114" rel="external nofollow noopener noreferrer" target="_blank"><code>#serverQuitNotify(serverAddress)</code></a> <strong>实现</strong>方法，当老的节点离开，<strong>移除</strong>对应的客户端连接。</li></ul><h2 id="3-2-2-负载均衡"><a href="#3-2-2-负载均衡" class="headerlink" title="3.2.2 负载均衡"></a>3.2.2 负载均衡</h2><p>RemoteModuleGRPCProvider 基于不同的选择器 ( <a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/Selector.java#L26" rel="external nofollow noopener noreferrer" target="_blank">Selector</a> ) ，提供不同的客户端选择( <a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/selector/RemoteClientSelector.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.remote.grpc.service.selector.RemoteClientSelector</code></a> )实现 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_09_10/07.png" alt=""></p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteSenderService.java#L53" rel="external nofollow noopener noreferrer" target="_blank"><code>hashCodeSelector</code></a> 属性，<a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/selector/HashCodeSelector.java" rel="external nofollow noopener noreferrer" target="_blank">HashCodeSelector</a> ，基于数据的哈希码。</li><li><a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteSenderService.java#L54" rel="external nofollow noopener noreferrer" target="_blank"><code>foreverFirstSelector</code></a> 属性，<a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/selector/ForeverFirstSelector.java" rel="external nofollow noopener noreferrer" target="_blank">ForeverFirstSelector</a> ，基于客户端数组的顺序，选择第一个。</li><li><a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteSenderService.java#L55" rel="external nofollow noopener noreferrer" target="_blank"><code>rollingSelector</code></a> 属性，<a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/selector/RollingSelector.java" rel="external nofollow noopener noreferrer" target="_blank">RollingSelector</a> ，基于客户端数组的顺序，顺序向下选择。</li><li><a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteSenderService.java#L59" rel="external nofollow noopener noreferrer" target="_blank"><code>#send(graphId, nodeId, data, selector)</code></a> 方法，代码如下：<ul><li>第 63 、66 、69 行：根据选择器，调用 <code>RemoteClientSelector#select(clients, data)</code> 方法，选择客户端。</li><li>第 64 、67 、70 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteSenderService.java#L75" rel="external nofollow noopener noreferrer" target="_blank"><code>#sendToRemoteWhenNotSelf(remoteClient, graphId, nodeId, data)</code></a> 方法，发送请求数据。<ul><li>第 76 至 77 行：当选择的客户端连接的是本地时，不发送数据，交给本地处理，参见 <a href="https://github.com/YunaiV/skywalking/blob/5e2eb23f33136c979e5056dbe32e880b130d0901/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/RemoteWorkerRef.java#L58" rel="external nofollow noopener noreferrer" target="_blank"><code>RemoteWorkerRef#in(message)</code></a> 方法。</li><li>第 78 至 81 行：当选择的客户端连接的是远程时，调用 <code>RemoteClient#push(graphId, nodeId, data)</code> 方法，发送数据。</li></ul></li></ul></li></ul><h2 id="3-3-GRPCRemoteClientService"><a href="#3-3-GRPCRemoteClientService" class="headerlink" title="3.3 GRPCRemoteClientService"></a>3.3 GRPCRemoteClientService</h2><p><code>org.skywalking.apm.collector.remote.grpc.service.GRPCRemoteClientService</code> ，实现 RemoteClientService <strong>接口</strong>，基于 gRPC 的远程客户端服务实现类。</p><p><a href="https://github.com/YunaiV/skywalking/blob/0a289e159f472983a0b6f6df6bd62c675e4f0846/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteClientService.java#L44" rel="external nofollow noopener noreferrer" target="_blank"><code>#create(host, port, channelSize, bufferSize)</code></a> <strong>实现</strong>方法，创建 GRPCRemoteClient 对象。</p><h2 id="3-4-GRPCRemoteClient"><a href="#3-4-GRPCRemoteClient" class="headerlink" title="3.4 GRPCRemoteClient"></a>3.4 GRPCRemoteClient</h2><blockquote><p>友情提示：本小节会涉及较多 gRPC 相关的知识，建议不熟悉的胖友自己 Google ，补充下姿势。</p></blockquote><p><code>org.skywalking.apm.collector.remote.grpc.service.GRPCRemoteClient</code> ，实现 RemoteClient <strong>接口</strong>，基于 gRPC 的远程客户端实现类。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/4cb80651dee25e985f974d691467a0a53d7dfbe9/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteClient.java#L48" rel="external nofollow noopener noreferrer" target="_blank"><code>client</code></a> 属性，GRPCClient 对象。相比来说，GRPCRemoteClient 偏业务的封装，内部调用 GRPCClient 对象。</li><li><a href="https://github.com/YunaiV/skywalking/blob/4cb80651dee25e985f974d691467a0a53d7dfbe9/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteClient.java#L52" rel="external nofollow noopener noreferrer" target="_blank"><code>carrier</code></a> 属性，DataCarrier 对象，本地消息队列。GRPCRemoteClient 在被调用发送数据时，先提交到本地队列，异步消费进行发送到远程 Collector 节点。DataCarrier 在 <a href="http://www.iocoder.cn/SkyWalking/data-carrier/?self">《SkyWalking 源码分析 —— DataCarrier 异步处理库》</a> 详细解析。<ul><li>第 63 行：调用 <code>DataCarrier#consume(IConsumer, num)</code> 方法，设置消费者为 RemoteMessageConsumer 对象。</li></ul></li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/4cb80651dee25e985f974d691467a0a53d7dfbe9/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteClient.java#L70" rel="external nofollow noopener noreferrer" target="_blank"><code>#push(graphId, nodeId, data)</code></a> <strong>实现</strong>方法，<strong>异步</strong>发送消息到远程 Collector 。</p><ul><li>第 73 行：调用 <code>RemoteDataIDGetter#getRemoteDataId(Class&lt;? extends Data&gt;)</code> 方法，获得<strong>数据协议编号</strong>。</li><li>第 76 至 80 行：创建传输数据( RemoteMessage.Builder ) 对象。RemoteMessage 通过 <a href="https://github.com/google/protobuf" rel="external nofollow noopener noreferrer" target="_blank">Protobuf</a> 创建定义，如下图所示：<img src="http://www.iocoder.cn/images/SkyWalking/2020_09_10/08.png" alt=""></li><li>第 83 行：调用 <code>DataCarrier#produce(data)</code> 方法，发送数据到本地队列。 </li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/4cb80651dee25e985f974d691467a0a53d7dfbe9/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteClient.java#L93" rel="external nofollow noopener noreferrer" target="_blank">RemoteMessageConsumer</a> ，<strong>批量</strong>消费本地队列的数据，逐条发送数据到远程 Collector 节点。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/4cb80651dee25e985f974d691467a0a53d7dfbe9/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteClient.java#L98" rel="external nofollow noopener noreferrer" target="_blank"><code>#consume(List&lt;RemoteMessage&gt;)</code></a> <strong>实现</strong>方法，代码如下：<ul><li>第 100 行：创建 <a href="https://github.com/YunaiV/skywalking/blob/4cb80651dee25e985f974d691467a0a53d7dfbe9/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteClient.java#L118" rel="external nofollow noopener noreferrer" target="_blank">StreamObserver</a> 对象。StreamObserver 主要是 gPRC 相关的 API 的调用。</li><li>第 101 至 103 行：调用 <code>io.grpc.stub.StreamObserver#onNext(RemoteMessage)</code> 方法，逐条发送数据。</li><li>第 106 行：调用 <code>io.grpc.stub.StreamObserver#onCompleted()</code> 方法，全部请求数据发送<strong>完成</strong>。</li></ul></li></ul><h2 id="3-5-RemoteCommonServiceHandler"><a href="#3-5-RemoteCommonServiceHandler" class="headerlink" title="3.5 RemoteCommonServiceHandler"></a>3.5 RemoteCommonServiceHandler</h2><p><code>org.skywalking.apm.collector.remote.grpc.handler.RemoteCommonServiceHandler</code> ，实现 <code>org.skywalking.apm.collector.server.grpc.GRPCHandler</code> 接口，继承 RemoteCommonServiceGrpc.RemoteCommonServiceImplBase <strong>抽象类</strong>，远程通信通用逻辑处理器。</p><p>其中，RemoteCommonServiceGrpc.RemoteCommonServiceImplBase 在 <code>RemoteCommonService.proto</code> 文件的定义如下图：<img src="http://www.iocoder.cn/images/SkyWalking/2020_09_10/09.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/ece7d2e156d4434edcc6ef08a5ed79e2a7b39fa1/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/handler/RemoteCommonServiceHandler.java#L55" rel="external nofollow noopener noreferrer" target="_blank"><code>#call(StreamObserver&lt;Empty&gt;)</code></a> <strong>实现</strong>方法，代码如下：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/ece7d2e156d4434edcc6ef08a5ed79e2a7b39fa1/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/handler/RemoteCommonServiceHandler.java#L57" rel="external nofollow noopener noreferrer" target="_blank"><code>#onNext(RemoteMessage)</code></a> 方法，处理每一条消息，代码如下：<ul><li>第 65 行：调用 <code>RemoteDataInstanceCreatorGetter#getInstanceCreator(remoteDataId)</code> 方法，获得<strong>数据协议编号</strong>对应的 RemoteDataInstanceCreator 对象。然后，调用 <code>RemoteDataInstanceCreator#createInstance(id)</code> 方法，创建<strong>数据协议编号</strong>对应的 Data 实现类对应的对象。</li><li>第 70 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/ece7d2e156d4434edcc6ef08a5ed79e2a7b39fa1/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/GraphManager.java#L60" rel="external nofollow noopener noreferrer" target="_blank"><code>GraphManager#findGraph(graphId)</code></a> 方法，获得 <code>graphId</code> 对应的 Graph 对象。然后，调动 <a href="https://github.com/YunaiV/skywalking/blob/ece7d2e156d4434edcc6ef08a5ed79e2a7b39fa1/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/GraphNodeFinder.java#L52" rel="external nofollow noopener noreferrer" target="_blank"><code>GraphNodeFinder#findNext(nodeId)</code></a> 方法，获得 Next 对象。</li><li>第 71 行：调用 <code>Next#execute(Data)</code> 方法，继续流式处理。</li></ul></li></ul><h2 id="3-6-GRPCRemoteSerializeService"><a href="#3-6-GRPCRemoteSerializeService" class="headerlink" title="3.6 GRPCRemoteSerializeService"></a>3.6 GRPCRemoteSerializeService</h2><p><a href="https://github.com/YunaiV/skywalking/blob/ece7d2e156d4434edcc6ef08a5ed79e2a7b39fa1/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteSerializeService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.remote.grpc.service.GRPCRemoteSerializeService</code></a> ，实现 RemoteSerializeService 接口，基于 gRPC 的远程通信序列化服务实现类。</p><h2 id="3-7-GRPCRemoteDeserializeService"><a href="#3-7-GRPCRemoteDeserializeService" class="headerlink" title="3.7 GRPCRemoteDeserializeService"></a>3.7 GRPCRemoteDeserializeService</h2><p><a href="https://github.com/YunaiV/skywalking/blob/ece7d2e156d4434edcc6ef08a5ed79e2a7b39fa1/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/GRPCRemoteDeserializeService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.remote.grpc.service.GRPCRemoteDeserializeService</code></a> ，实现 GRPCRemoteDeserializeService 接口，基于 gRPC 的远程通信反序列化服务实现类。</p><h1 id="4-collector-remote-grpc-provider"><a href="#4-collector-remote-grpc-provider" class="headerlink" title="4. collector-remote-grpc-provider"></a>4. collector-remote-grpc-provider</h1><p><code>collector-remote-kafka-provider</code> ：基于 Kafka 的远程通信实现。</p><p><em>目前暂未完成</em>。</p><p>TODO 【4005】collector-remote-grpc-provider</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>写的有丢丢烦躁，不清晰或者错误的地方，胖友望见谅。</p><p>欢迎微信我一起交流。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_10/10.png" alt=""></p><p>胖友，分享一波朋友圈可好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-remote-module/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-remote-module/&lt;/a
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector Cache 缓存组件</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-cache-module/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-cache-module/</id>
    <published>2020-09-04T16:00:00.000Z</published>
    <updated>2017-12-24T03:14:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-cache-module/">http://www.iocoder.cn/SkyWalking/collector-cache-module/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-cache-module/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cache-module/">2. collector-cache-define</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-cache-module/">2.1 CacheModule</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cache-module/">2.2 ApplicationCacheService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cache-module/">2.3 InstanceCacheService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cache-module/">2.4 ServiceNameCacheService</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cache-module/">3. collector-cache-guava-provider</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-cache-module/">3.1 CacheModuleGuavaProvider</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cache-module/">3.2 ApplicationCacheGuavaService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cache-module/">3.3 InstanceCacheGuavaService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cache-module/">3.4 ServiceNameCacheGuavaService</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cache-module/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>SkyWalking Collector Cache Module</strong>，缓存组件。该组件用于缓存 Application 、Instance 、ServiceName 等<strong>常用</strong>且<strong>不变</strong>的数据，以提升性能。</p><blockquote><p>友情提示：本文内容较为简单，胖友可快速阅读。</p></blockquote><p>Cache Module 在 SkyWalking 架构图处于如下位置( <strong>红框</strong> ) ：</p><blockquote><p>FROM <a href="https://github.com/apache/incubating-skywalking" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubating-skywalking</a><br><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_05/01.jpeg" alt=""></p></blockquote><p>下面我们来看看整体的项目结构，如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_05/02.png" alt=""></p><ul><li><code>collector-cache-define</code> ：定义缓存组件接口。</li><li><code>collector-cache-guava-provider</code> ：基于 <a href="https://github.com/google/guava" rel="external nofollow noopener noreferrer" target="_blank">Google Guava</a> 的缓存组件实现。</li></ul><p>下面，我们从<strong>接口到实现</strong>的顺序进行分享。</p><h1 id="2-collector-cache-define"><a href="#2-collector-cache-define" class="headerlink" title="2. collector-cache-define"></a>2. collector-cache-define</h1><p><code>collector-cache-define</code> ：定义队列组件接口。项目结构如下 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_05/03.png" alt=""></p><h2 id="2-1-CacheModule"><a href="#2-1-CacheModule" class="headerlink" title="2.1 CacheModule"></a>2.1 CacheModule</h2><p><code>org.skywalking.apm.collector.cache.CacheModule</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java" rel="external nofollow noopener noreferrer" target="_blank">Module</a> 抽象类，缓存 Module 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ed68f92bf1f5ac397c0bb0a5cc23fa4f3e3c32d1/apm-collector/apm-collector-cache/collector-cache-define/src/main/java/org/skywalking/apm/collector/cache/CacheModule.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回模块名为 <code>&quot;cache&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ed68f92bf1f5ac397c0bb0a5cc23fa4f3e3c32d1/apm-collector/apm-collector-cache/collector-cache-define/src/main/java/org/skywalking/apm/collector/cache/CacheModule.java#L40" rel="external nofollow noopener noreferrer" target="_blank"><code>#services()</code></a> <strong>实现</strong>方法，返回 Service 类名：ApplicationCacheService 、InstanceCacheService 、ServiceIdCacheService 、ServiceNameCacheService 。</p><h2 id="2-2-ApplicationCacheService"><a href="#2-2-ApplicationCacheService" class="headerlink" title="2.2 ApplicationCacheService"></a>2.2 ApplicationCacheService</h2><p><a href="https://github.com/YunaiV/skywalking/blob/ed68f92bf1f5ac397c0bb0a5cc23fa4f3e3c32d1/apm-collector/apm-collector-cache/collector-cache-define/src/main/java/org/skywalking/apm/collector/cache/service/ApplicationCacheService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.cache.service.ApplicationCacheService</code></a> ，应用数据缓存服务<strong>接口</strong>。</p><ul><li>Table ：<a href="https://github.com/YunaiV/skywalking/blob/ed68f92bf1f5ac397c0bb0a5cc23fa4f3e3c32d1/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/register/ApplicationTable.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.register.ApplicationTable</code></a></li><li>Data ：<a href="https://github.com/YunaiV/skywalking/blob/ed68f92bf1f5ac397c0bb0a5cc23fa4f3e3c32d1/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/register/Application.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.register.Application</code></a></li></ul><h2 id="2-3-InstanceCacheService"><a href="#2-3-InstanceCacheService" class="headerlink" title="2.3 InstanceCacheService"></a>2.3 InstanceCacheService</h2><p><a href="https://github.com/YunaiV/skywalking/blob/a1667a9ecf4eecf77cc2390f0af709c3b1bb7e4b/apm-collector/apm-collector-cache/collector-cache-define/src/main/java/org/skywalking/apm/collector/cache/service/InstanceCacheService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.cache.service.InstanceCacheService</code></a> ，应用实例数据缓存服务<strong>接口</strong>。</p><ul><li>Table ：<a href="https://github.com/YunaiV/skywalking/blob/a1667a9ecf4eecf77cc2390f0af709c3b1bb7e4b/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/register/InstanceTable.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.register.InstanceTable</code></a></li><li>Data ：<a href="https://github.com/YunaiV/skywalking/blob/a1667a9ecf4eecf77cc2390f0af709c3b1bb7e4b/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/register/Instance.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.register.Instance</code></a></li></ul><h2 id="2-4-ServiceNameCacheService"><a href="#2-4-ServiceNameCacheService" class="headerlink" title="2.4 ServiceNameCacheService"></a>2.4 ServiceNameCacheService</h2><p><a href="https://github.com/YunaiV/skywalking/blob/a859f4751203d73f10f30bb7c9cf2adfdecf955c/apm-collector/apm-collector-cache/collector-cache-define/src/main/java/org/skywalking/apm/collector/cache/service/ServiceNameCacheService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.cache.service.ServiceNameCacheService</code></a> ，服务名数据缓存服务<strong>接口</strong>。<br><a href="https://github.com/YunaiV/skywalking/blob/a859f4751203d73f10f30bb7c9cf2adfdecf955c/apm-collector/apm-collector-cache/collector-cache-define/src/main/java/org/skywalking/apm/collector/cache/service/ServiceIdCacheService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.cache.service.ServiceIdCacheService</code></a> ，服务编号数据缓存服务<strong>接口</strong>。</p><ul><li>Table ：<a href="https://github.com/YunaiV/skywalking/blob/a859f4751203d73f10f30bb7c9cf2adfdecf955c/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/register/ServiceNameTable.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.register.ServiceNameTable</code></a></li><li>Data ：<a href="https://github.com/YunaiV/skywalking/blob/a859f4751203d73f10f30bb7c9cf2adfdecf955c/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/register/ServiceName.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table.register.ServiceName</code></a></li></ul><h1 id="3-collector-cache-guava-provider"><a href="#3-collector-cache-guava-provider" class="headerlink" title="3. collector-cache-guava-provider"></a>3. collector-cache-guava-provider</h1><p><code>collector-cache-guava-provider</code> ，基于 <a href="https://github.com/google/guava" rel="external nofollow noopener noreferrer" target="_blank">Google Guava</a> 的缓存组件实现。</p><p>项目结构如下 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_09_05/04.png" alt=""></p><p><strong>默认配置</strong>，在 <a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-core/src/main/resources/application-default.yml#L5" rel="external nofollow noopener noreferrer" target="_blank"><code>application-default.yml</code></a> <strong>已经</strong>配置如下：</p><figure class="highlight"><table><tr><td class="code"><pre><div class="line">cache:</div><div class="line">  guava:</div></pre></td></tr></table></figure><h2 id="3-1-CacheModuleGuavaProvider"><a href="#3-1-CacheModuleGuavaProvider" class="headerlink" title="3.1 CacheModuleGuavaProvider"></a>3.1 CacheModuleGuavaProvider</h2><p><code>org.skywalking.apm.collector.cache.guava.CacheModuleGuavaProvider</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java" rel="external nofollow noopener noreferrer" target="_blank">ModuleProvider</a> <strong>抽象类</strong>，基于 Guava 的缓存组件服务提供者。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ed68f92bf1f5ac397c0bb0a5cc23fa4f3e3c32d1/apm-collector/apm-collector-cache/collector-cache-guava-provider/src/main/java/org/skywalking/apm/collector/cache/guava/CacheModuleGuavaProvider.java#L44" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回组件服务提供者名为 <code>&quot;guava&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ed68f92bf1f5ac397c0bb0a5cc23fa4f3e3c32d1/apm-collector/apm-collector-cache/collector-cache-guava-provider/src/main/java/org/skywalking/apm/collector/cache/guava/CacheModuleGuavaProvider.java#L48" rel="external nofollow noopener noreferrer" target="_blank"><code>module()</code></a> <strong>实现</strong>方法，返回组件类为 CacheModule 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ed68f92bf1f5ac397c0bb0a5cc23fa4f3e3c32d1/apm-collector/apm-collector-cache/collector-cache-guava-provider/src/main/java/org/skywalking/apm/collector/cache/guava/CacheModuleGuavaProvider.java#L66" rel="external nofollow noopener noreferrer" target="_blank"><code>#requiredModules()</code></a> <strong>实现</strong>方法，返回依赖组件为空。</p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/ed68f92bf1f5ac397c0bb0a5cc23fa4f3e3c32d1/apm-collector/apm-collector-cache/collector-cache-guava-provider/src/main/java/org/skywalking/apm/collector/cache/guava/CacheModuleGuavaProvider.java#L52" rel="external nofollow noopener noreferrer" target="_blank"><code>#prepare(Properties)</code></a> <strong>实现</strong>方法，执行准备阶段逻辑。</p><ul><li>第 44 行 ：创建 ApplicationCacheGuavaService 、InstanceCacheGuavaService 、ServiceIdCacheGuavaService 、ServiceNameCacheGuavaService 对象，并调用 <code>#registerServiceImplementation()</code> <strong>父类</strong>方法，注册到 <code>services</code> 。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/ed68f92bf1f5ac397c0bb0a5cc23fa4f3e3c32d1/apm-collector/apm-collector-cache/collector-cache-guava-provider/src/main/java/org/skywalking/apm/collector/cache/guava/CacheModuleGuavaProvider.java#L59" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> <strong>实现</strong>方法，方法为空。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ed68f92bf1f5ac397c0bb0a5cc23fa4f3e3c32d1/apm-collector/apm-collector-cache/collector-cache-guava-provider/src/main/java/org/skywalking/apm/collector/cache/guava/CacheModuleGuavaProvider.java#L62" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyAfterCompleted()</code></a> <strong>实现</strong>方法，方法为空。</p><h2 id="3-2-ApplicationCacheGuavaService"><a href="#3-2-ApplicationCacheGuavaService" class="headerlink" title="3.2 ApplicationCacheGuavaService"></a>3.2 ApplicationCacheGuavaService</h2><p><a href="https://github.com/YunaiV/skywalking/blob/ed68f92bf1f5ac397c0bb0a5cc23fa4f3e3c32d1/apm-collector/apm-collector-cache/collector-cache-guava-provider/src/main/java/org/skywalking/apm/collector/cache/guava/service/ApplicationCacheGuavaService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.cache.guava.service.ApplicationCacheGuavaService</code></a> ，实现 ApplicationCacheService 接口，基于 Guava 的应用数据缓存服务<strong>实现类</strong>。</p><ul><li>EsDAO ：<a href="https://github.com/YunaiV/skywalking/blob/ed68f92bf1f5ac397c0bb0a5cc23fa4f3e3c32d1/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/ApplicationEsCacheDAO.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.es.dao.ApplicationEsCacheDAO</code></a></li></ul><h2 id="3-3-InstanceCacheGuavaService"><a href="#3-3-InstanceCacheGuavaService" class="headerlink" title="3.3 InstanceCacheGuavaService"></a>3.3 InstanceCacheGuavaService</h2><p><a href="https://github.com/YunaiV/skywalking/blob/a1667a9ecf4eecf77cc2390f0af709c3b1bb7e4b/apm-collector/apm-collector-cache/collector-cache-guava-provider/src/main/java/org/skywalking/apm/collector/cache/guava/service/InstanceCacheGuavaService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.cache.guava.service.InstanceCacheGuavaService</code></a> ，实现 InstanceCacheService 接口，基于 Guava 的应用实例数据缓存服务<strong>实现类</strong>。</p><ul><li>EsDAO ：<a href="https://github.com/YunaiV/skywalking/blob/a1667a9ecf4eecf77cc2390f0af709c3b1bb7e4b/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/InstanceEsCacheDAO.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.es.dao.InstanceEsCacheDAO</code></a></li></ul><h2 id="3-4-ServiceNameCacheGuavaService"><a href="#3-4-ServiceNameCacheGuavaService" class="headerlink" title="3.4 ServiceNameCacheGuavaService"></a>3.4 ServiceNameCacheGuavaService</h2><p><a href="https://github.com/YunaiV/skywalking/blob/a859f4751203d73f10f30bb7c9cf2adfdecf955c/apm-collector/apm-collector-cache/collector-cache-guava-provider/src/main/java/org/skywalking/apm/collector/cache/guava/service/ServiceIdCacheGuavaService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.cache.guava.service.ServiceNameCacheGuavaService</code></a> ，实现 ServiceNameCacheService 接口，基于 Guava 的服务名数据缓存服务<strong>实现类</strong>。<br><a href="https://github.com/YunaiV/skywalking/blob/a859f4751203d73f10f30bb7c9cf2adfdecf955c/apm-collector/apm-collector-cache/collector-cache-guava-provider/src/main/java/org/skywalking/apm/collector/cache/guava/service/ServiceNameCacheGuavaService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.cache.guava.service.ServiceIdCacheGuavaService</code></a> ，实现 ServiceNameCacheService 接口，基于 Guava 的服务编号数据缓存服务<strong>实现类</strong>。</p><ul><li>EsDAO ：<a href="https://github.com/YunaiV/skywalking/blob/a859f4751203d73f10f30bb7c9cf2adfdecf955c/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/ServiceNameEsCacheDAO.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.es.dao.ServiceNameEsCacheDAO</code></a></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>真的是一篇水文，都写的无从下手，只好罗列了相关的类。见谅。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_05/05.png" alt=""></p><p>胖友，分享一波朋友圈可好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-cache-module/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-cache-module/&lt;/a&gt; 
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（二）</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-streaming-second/</id>
    <published>2020-08-31T16:00:00.000Z</published>
    <updated>2017-12-23T23:23:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">http://www.iocoder.cn/SkyWalking/collector-streaming-second/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">2. Data</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">2.1 Collection</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">2.2 DataCollection</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">2.3 Window</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">2.4 DataCache</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">3. AggregationWorker</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">4. PersistenceWorker</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">4.1 WorkerCreateListener</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">4.2 PersistenceTimer</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文接 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（一）》</a> ，主要分享 <strong>Collector Streaming 流式处理的第二部分</strong>。主要包含如下部分：<img src="http://www.iocoder.cn/images/SkyWalking/2020_09_01/01.png" alt=""></p><ul><li>AggregationWorker ：聚合处理数据，后提交 Data 到 Next 节点们处理。</li><li>PersistenceWorker ：聚合处理数据，后存储 Data 。</li></ul><h1 id="2-Data"><a href="#2-Data" class="headerlink" title="2. Data"></a>2. Data</h1><p>AggregationWorker 和 PersistenceWorker ，都先<strong>聚合</strong>处理数据，在进行各自的后续处理。那么聚合处理的数据结果，需要有<strong>容器</strong>进行缓存暂存：</p><ul><li><code>org.skywalking.apm.collector.core.cache</code> ：接口</li><li><code>org.skywalking.apm.collector.stream.worker.impl.data</code> ：实现</li></ul><p>类图如下：<img src="http://www.iocoder.cn/images/SkyWalking/2020_09_01/02.png" alt=""></p><ul><li>Collection ：数据采集，提供有读、写<strong>两个状态</strong>的数据容器。</li><li>Window ：窗口( 😈这个解释怪怪的 )，内有<strong>两个 Collection</strong>。<ul><li>一个 Collection ，负责写入<strong>数据</strong>数据</li><li>一个 Collection ，负责读出<strong>处理</strong>数据</li><li>当写的 Collection <strong>符合处理的条件</strong>，读写 Collection 切换</li></ul></li></ul><h2 id="2-1-Collection"><a href="#2-1-Collection" class="headerlink" title="2.1 Collection"></a>2.1 Collection</h2><p><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Collection.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.core.cache.Collection</code></a> ，数据采集<strong>接口</strong>。</p><ul><li>数据相关 ：<code>#collection()</code> / <code>#size()</code> / <code>#clear()</code></li><li>读相关 ：<code>#reading()</code> / <code>#isReading()</code> / <code>#finishReading()</code></li><li>写相关 ：<code>#writing()</code> / <code>#isWriting()</code> / <code>#finishWriting()</code></li></ul><h2 id="2-2-DataCollection"><a href="#2-2-DataCollection" class="headerlink" title="2.2 DataCollection"></a>2.2 DataCollection</h2><p><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/data/DataCollection.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.stream.worker.impl.data.DataCollection</code></a> ，实现 Collection 接口，数据采集实现类，使用 <a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/data/DataCollection.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>Map&lt;String, Data&gt;</code></a> 作为数据容器。</p><h2 id="2-3-Window"><a href="#2-3-Window" class="headerlink" title="2.3 Window"></a>2.3 Window</h2><p><code>org.skywalking.apm.collector.core.cache.Window</code> ，窗口<strong>抽象类</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L50" rel="external nofollow noopener noreferrer" target="_blank">构造方法</a> ，代码如下：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L44" rel="external nofollow noopener noreferrer" target="_blank"><code>windowDataA</code></a> 属性，窗口数据A 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L48" rel="external nofollow noopener noreferrer" target="_blank"><code>windowDataB</code></a> 属性，窗口数据B 。</li><li>通过 <a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L61" rel="external nofollow noopener noreferrer" target="_blank"><code>#collectionInstance()</code></a> <strong>抽象</strong>方法，创建窗口数据( Collection )对象。</li><li><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>pointer</code></a> 属性，数据指向 <code>windowDataA</code> 或 <code>windowDataA</code>。<ul><li><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L111" rel="external nofollow noopener noreferrer" target="_blank"><code>#getCurrent()</code></a> 方法，获得<strong>现</strong>数据指向，即 <code>pointer</code> 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L118" rel="external nofollow noopener noreferrer" target="_blank"><code>#getLast()</code></a> 方法，获得<strong>原</strong>数据指向，即<strong>非</strong> <code>pointer</code> 。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L33" rel="external nofollow noopener noreferrer" target="_blank"><code>windowSwitch</code></a> 属性，窗口切换计数。</li></ul><hr><p><strong>切换 Collection 相关</strong>，方法如下：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L68" rel="external nofollow noopener noreferrer" target="_blank"><code>#trySwitchPointer()</code></a> 方法，返回是否可以切换 Collection 。可以切换需要满足如下条件：<ul><li>只有<strong>一个调用方</strong>申请切换，通过 <code>windowSwitch</code> 属性进行计数。</li><li><strong>原</strong>数据指向<strong>不处于正在读取状态</strong>。如果切换，一边读一边写，可能会有并发问题。</li><li>无论是否可以切换 Collection ，需要调用 <a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L75" rel="external nofollow noopener noreferrer" target="_blank"><code>#trySwitchPointerFinally()</code></a> 方法，<strong>释放</strong> <code>windowSwitch</code> 的计数。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L82" rel="external nofollow noopener noreferrer" target="_blank"><code>#switchPointer()</code></a> 方法，切换数据指向，并标记<strong>原</strong>数据指向的 Collection <strong>正在读取中</strong>。</li><li><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L129" rel="external nofollow noopener noreferrer" target="_blank"><code>#finishReadingLast()</code></a> 方法，清空<strong>原</strong>数据指向的 Collection 数据，并标记<strong>原</strong>数据指向的 Collection <strong>完成读取</strong>( <strong>不在正在读取中</strong> )。</li></ul><hr><p><strong>写 Collection 相关</strong>，方法如下：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L98" rel="external nofollow noopener noreferrer" target="_blank"><code>#getCurrentAndWriting()</code></a> 方法，获得<strong>现</strong>数据指向，并标记<strong>正在写入中</strong>。通过<strong>正在写入</strong>标记，切换 Collection 完成后，可以判断该 Collection 正在写入中，<strong>若是，等待不在写入中，开始数据读取并处理</strong>。</li></ul><h2 id="2-4-DataCache"><a href="#2-4-DataCache" class="headerlink" title="2.4 DataCache"></a>2.4 DataCache</h2><p><code>org.skywalking.apm.collector.stream.worker.impl.data.DataCache</code> ，实现 Window 抽象类，数据缓存。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/e6e1a7899e7b0e674a61f323447d4b66cffa8136/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/data/DataCache.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><code>#collectionInstance()</code></a> <strong>实现</strong>方法，创建 DataCollection 对象。</li><li><a href="https://github.com/YunaiV/skywalking/blob/e6e1a7899e7b0e674a61f323447d4b66cffa8136/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/data/DataCache.java#L82" rel="external nofollow noopener noreferrer" target="_blank"><code>#currentCollectionSize()</code></a> 方法，获得当前数据指向( 写入 Collection )的数据数量。</li></ul><hr><p><strong>写 Collection 相关</strong>，方法如下：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/e6e1a7899e7b0e674a61f323447d4b66cffa8136/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/data/DataCache.java#L73" rel="external nofollow noopener noreferrer" target="_blank"><code>#writing()</code></a> 方法，调用 <code>#getCurrentAndWriting()</code> 方法，开始写入。即，获得<strong>现</strong>数据指向，并标记<strong>正在写入中</strong>。<ul><li><a href="https://github.com/YunaiV/skywalking/blob/e6e1a7899e7b0e674a61f323447d4b66cffa8136/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/data/DataCache.java#L34" rel="external nofollow noopener noreferrer" target="_blank"><code>lockedDataCollection</code></a> 属性，写入的窗口数据。</li><li><a href="https://github.com/YunaiV/skywalking/blob/e6e1a7899e7b0e674a61f323447d4b66cffa8136/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/data/DataCache.java#L66" rel="external nofollow noopener noreferrer" target="_blank"><code>#put(id, data)</code></a> 方法，向 <code>lockedDataCollection</code> 属性，写入 Data 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/e6e1a7899e7b0e674a61f323447d4b66cffa8136/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/data/DataCache.java#L56" rel="external nofollow noopener noreferrer" target="_blank"><code>#get(id)</code></a> 方法，向 <code>lockedDataCollection</code> 属性，根据 ID 获得 Data 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/e6e1a7899e7b0e674a61f323447d4b66cffa8136/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/data/DataCache.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#containsKey(id)</code></a> 方法，向 <code>lockedDataCollection</code> 属性，根据 ID 判断 Data 是否存在 。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/e6e1a7899e7b0e674a61f323447d4b66cffa8136/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/data/DataCache.java#L89" rel="external nofollow noopener noreferrer" target="_blank"><code>#finishWriting()</code></a> 方法，完成写入。即，标记 <code>lockedDataCollection</code> <strong>不在正在写入中</strong>。</li></ul><h1 id="3-AggregationWorker"><a href="#3-AggregationWorker" class="headerlink" title="3. AggregationWorker"></a>3. AggregationWorker</h1><p><code>org.skywalking.apm.collector.stream.worker.impl.AggregationWorker</code> ，实现 AbstractLocalAsyncWorker 抽象类，<strong>异步聚合</strong> Worker，负责聚合处理数据，后提交 Data 到 Next 节点们处理。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ccd030f6b449954fccc7be4e19c15290e8affc77/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/AggregationWorker.java#L47" rel="external nofollow noopener noreferrer" target="_blank"><strong>构造方法</strong></a> ，代码如下：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/ccd030f6b449954fccc7be4e19c15290e8affc77/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/AggregationWorker.java#L41" rel="external nofollow noopener noreferrer" target="_blank"><code>dataCache</code></a> 属性，数据缓存。</li><li><a href="https://github.com/YunaiV/skywalking/blob/ccd030f6b449954fccc7be4e19c15290e8affc77/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/AggregationWorker.java#L45" rel="external nofollow noopener noreferrer" target="_blank"><code>messageNum</code></a> 属性，消息计数。当超过一定数量( 目前是 100 )，重置计数归零。</li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/ccd030f6b449954fccc7be4e19c15290e8affc77/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/AggregationWorker.java#L52" rel="external nofollow noopener noreferrer" target="_blank"><code>#onWork(message)</code></a> <strong>实现</strong>方法，聚合处理数据，当满足条件时，提交 Data 到 Next 节点们处理。</p><ul><li>第 53 行：<code>messageNum</code> 计数增加。</li><li>第 56 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/ccd030f6b449954fccc7be4e19c15290e8affc77/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/AggregationWorker.java#L97" rel="external nofollow noopener noreferrer" target="_blank"><code>#aggregate(message)</code></a> 方法，聚合消息到数据。</li><li>第 59 至 62 行：<code>messageNum &gt;= 100</code> 时，调用 <a href="https://github.com/YunaiV/skywalking/blob/ccd030f6b449954fccc7be4e19c15290e8affc77/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/AggregationWorker.java#L70" rel="external nofollow noopener noreferrer" target="_blank"><code>#sendToNext()</code></a> ，提交缓存数据的<strong>读 Collection 的数据</strong>给 Next 节点们继续处理。</li><li>第 65 至 67 行：<code>messageNum.endOfBatch == true</code> 时，当消息是批处理的最后一条时，调用 <a href="https://github.com/YunaiV/skywalking/blob/ccd030f6b449954fccc7be4e19c15290e8affc77/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/AggregationWorker.java#L70" rel="external nofollow noopener noreferrer" target="_blank"><code>#sendToNext()</code></a> ，提交缓存数据的<strong>读 Collection 的数据</strong>给 Next 节点们继续处理。</li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/ccd030f6b449954fccc7be4e19c15290e8affc77/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/AggregationWorker.java#L70" rel="external nofollow noopener noreferrer" target="_blank"><code>#sendToNext()</code></a> 方法，提交缓存数据的<strong>读 Collection 的数据</strong>给 Next 节点们继续处理。</p><ul><li>第 72 行：<strong>直接</strong>调用 <code>Window#switchPointer()</code> 方法，切换数据指针，并标记<strong>原</strong>指向正在读取中。这里并未先调用 <code>Window#trySwitchPointer()</code> 方法，<strong>是否会有并发问题</strong>？目前这里是<strong>异步单线程</strong>，所以不会有问题，参见 <a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/?self">《SkyWalking 源码分析 —— Collector Queue 队列组件》</a> 。另外，在 <a href="#">「4. PersistenceWorker」</a> 会看到并发的情况处理。</li><li>第 74 至 80 行：等待<strong>原</strong>指向不在读取中。</li><li>第 82 至 85 行：提交数据给 Next 节点们继续处理。</li><li>第 87 行：标记<strong>原</strong>指向完成读取。</li></ul><h1 id="4-PersistenceWorker"><a href="#4-PersistenceWorker" class="headerlink" title="4. PersistenceWorker"></a>4. PersistenceWorker</h1><p><code>org.skywalking.apm.collector.stream.worker.impl.PersistenceWorker</code> ，实现 AbstractLocalAsyncWorker 抽象类，<strong>异步批量存储</strong> Worker，负责聚合处理数据，后存储 Data 。</p><p>考虑到需要保证存储的时效性，PersistenceWorker 使用 PersistenceTimer ，定时存储 Data ，在 <a href="#">「4.2 PersistenceWorker」</a> 详细解析。</p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/ccd030f6b449954fccc7be4e19c15290e8affc77/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/AggregationWorker.java#L47" rel="external nofollow noopener noreferrer" target="_blank"><strong>构造方法</strong></a> ，代码如下：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/bf563461e75b6717d7b4589d7c3f579acf305541/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/PersistenceWorker.java#L49" rel="external nofollow noopener noreferrer" target="_blank"><code>dataCache</code></a> 属性，数据缓存。</li><li><a href="https://github.com/YunaiV/skywalking/blob/bf563461e75b6717d7b4589d7c3f579acf305541/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/PersistenceWorker.java#L53" rel="external nofollow noopener noreferrer" target="_blank"><code>batchDAO</code></a> 属性，批量操作 DAO ，在 <a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/?self">《SkyWalking 源码分析 —— Collector Storage 存储组件》</a> 有详细解析。</li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/bf563461e75b6717d7b4589d7c3f579acf305541/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/PersistenceWorker.java#L186" rel="external nofollow noopener noreferrer" target="_blank"><code>#needMergeDBData()</code></a> <strong>抽象</strong>方法，存储时，是否需要合并数据。一些 Data 只有新增操作，没有更新操作。</p><p><a href="https://github.com/YunaiV/skywalking/blob/bf563461e75b6717d7b4589d7c3f579acf305541/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/PersistenceWorker.java#L181" rel="external nofollow noopener noreferrer" target="_blank"><code>#persistenceDAO()</code></a> <strong>抽象</strong>方法，获得 Data 对应的持久化 DAO 接口的<strong>实现类</strong>对象。</p><p>上述两个<strong>抽象</strong>方法，用于 <a href="https://github.com/YunaiV/skywalking/blob/bf563461e75b6717d7b4589d7c3f579acf305541/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/PersistenceWorker.java#L121" rel="external nofollow noopener noreferrer" target="_blank"><code>#prepareBatch(dataMap)</code></a> 方法，生成批量操作对象数组，最终调用 <code>IBatchDAO#batchPersistence(List&lt;?&gt;)</code> 方法，通过执行批量操作对象数组，实现批量持久化数据，在 <a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/?self">《SkyWalking 源码分析 —— Collector Storage 存储组件》</a> 有详细解析。</p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/bf563461e75b6717d7b4589d7c3f579acf305541/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/PersistenceWorker.java#L71" rel="external nofollow noopener noreferrer" target="_blank"><code>#onWork(message)</code></a> <strong>实现</strong>方法，当满足条件时存储 Data ，而后聚合数据。这点和 AggregationWorker 相反的，因为要考虑并发问题。代码如下：</p><ul><li>第 72 行：调用 <code>DataCache#currentCollectionSize()</code> 方法，获得当前写入 Collection 的数据数量，判断是否超过 5000 。<ul><li>第 75 行：调用 <code>DataCache#trySwitchPointer()</code> 方法，<strong>判断</strong>是否可以切换 Collection 。通过该判断，保证和 PersistenceTimer 一起时，不会出现<strong>并发问题</strong>。</li><li>第 77 行：调用 <code>Window#switchPointer()</code> 方法，切换数据指针，并标记<strong>原</strong>指向正在读取中。</li><li>第 80 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/bf563461e75b6717d7b4589d7c3f579acf305541/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/PersistenceWorker.java#L100" rel="external nofollow noopener noreferrer" target="_blank"><code>#buildBatchCollection()</code></a> 方法，创建批量操作对象数组。该方法和 <code>AggregationWorker#sendToNext()</code> 方法<strong>基本类似</strong>。</li><li>第 83 行：调用 <code>IBatchDAO#batchPersistence(List&lt;?&gt;)</code> 方法，通过执行批量操作对象数组，实现批量持久化数据。</li><li>第 86 行：调用 <code>DataCache#trySwitchPointerFinally()</code> 方法，<strong>释放</strong> <code>DataCache.windowSwitch</code> 的计数。</li></ul></li><li>第 91 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/bf563461e75b6717d7b4589d7c3f579acf305541/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/PersistenceWorker.java#L164" rel="external nofollow noopener noreferrer" target="_blank"><code>#aggregate(message)</code></a> 方法，聚合数据。该方法和 <code>AggregationWorker#aggregate(message)</code> 方法<strong>基本相似</strong>。</li></ul><h2 id="4-1-WorkerCreateListener"><a href="#4-1-WorkerCreateListener" class="headerlink" title="4.1 WorkerCreateListener"></a>4.1 WorkerCreateListener</h2><p><code>org.skywalking.apm.collector.stream.worker.base.WorkerCreateListener</code> ，Worker 创建监听器。</p><p>Worker 在创建时，会调用 <a href="https://github.com/YunaiV/skywalking/blob/bf563461e75b6717d7b4589d7c3f579acf305541/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/WorkerCreateListener.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><code>WorkerCreateListener#addWorker</code></a> 方法，记录所有的 PersistenceWorker 对象。</p><p><strong>记录下来有什么用呢</strong>？在 <a href="https://github.com/YunaiV/skywalking/blob/bf563461e75b6717d7b4589d7c3f579acf305541/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/AgentStreamBootStartup.java#L47" rel="external nofollow noopener noreferrer" target="_blank">AgentStreamBootStartup</a> 启动时，创建 PersistenceTimer 对象，并将 WorkerCreateListener 记录的 PersistenceWorker 对象集合<strong>传递</strong>给 PersistenceTimer 对象。这样，PersistenceTimer 能够”<strong>访问</strong>“到 PersistenceWorker 对象们的 DataCache ，<strong>定时</strong>存储数据。</p><h2 id="4-2-PersistenceTimer"><a href="#4-2-PersistenceTimer" class="headerlink" title="4.2 PersistenceTimer"></a>4.2 PersistenceTimer</h2><p><code>org.skywalking.apm.collector.stream.timer.PersistenceTimer</code> ，持久化定时任务，负责<strong>定时</strong>、<strong>批量</strong>存储 PersistenceWorker 缓存的数据。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ec95c9966b7e013c8a44ea2e0f748ad339363ce3/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/timer/PersistenceTimer.java#L43" rel="external nofollow noopener noreferrer" target="_blank"><code>#start(IBatchDAO, List&lt;PersistenceWorker&gt;)</code></a> 方法，创建延迟 1 秒，每 1 秒执行一次 <code>#extractDataAndSave()</code> 方法的定时任务，用于<strong>定时</strong>、<strong>批量</strong>存储 PersistenceWorker 缓存的数据。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ec95c9966b7e013c8a44ea2e0f748ad339363ce3/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/timer/PersistenceTimer.java#L52" rel="external nofollow noopener noreferrer" target="_blank"><code>#extractDataAndSave(IBatchDAO, List&lt;PersistenceWorker&gt;)</code></a> 方法，代码如下：</p><ul><li><p>第 55 至 68 行：获得所有 PersistenceWorker 读 Collection 缓存的数据。</p><ul><li>第 60 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/ec95c9966b7e013c8a44ea2e0f748ad339363ce3/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/PersistenceWorker.java#L61" rel="external nofollow noopener noreferrer" target="_blank"><code>PersistenceWorker#flushAndSwitch()</code></a> 切换数据指针，即切换读写 Collection 。</li><li>第 62 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/ec95c9966b7e013c8a44ea2e0f748ad339363ce3/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/PersistenceWorker.java#L100" rel="external nofollow noopener noreferrer" target="_blank"><code>PersistenceWorker#buildBatchCollection()</code></a> 方法，创建批量操作对象数组。</li><li><strong>怎么保证并发安全</strong>？通过 <code>Window#trySwitchPointer()</code> 方法，保证读 Collection <strong>正在被读取中</strong>时，PersistenceWorker 和 PersistenceTimer 有且仅有一个切换队列，读取数据。当读取完成后，调用 <code>Window#finishReadingLast()</code> 方法，清空原数据指向，并标记原数据指向完成正在读取中。</li></ul></li><li><p>第 71 行：调用 <code>IBatchDAO#batchPersistence(List&lt;?&gt;)</code> 方法，执行批量操作，进行存储。</p></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>呼呼，终于把流式处理给写完了，如果写的不详细或者不合适的，胖友看到麻烦告知笔者，谢谢。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_01/03.png" alt=""></p><p>胖友，分享一波朋友圈可好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-streaming-second/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-streaming-seco
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（一）</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-streaming-first/</id>
    <published>2020-08-24T16:00:00.000Z</published>
    <updated>2018-01-01T11:48:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/">http://www.iocoder.cn/SkyWalking/collector-streaming-first/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/">2. apm-collector-core/graph</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/">2.1 Graph 创建</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/">2.2 Graph 启动</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/">3. apm-collector-stream</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/">3.1 WayToNode 实现类</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/">3.2 NodeProcessor 实现类</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Collector Streaming 流式处理</strong>。主要包含如下部分：</p><ul><li><p><code>apm-collector-core</code> 模块的 <code>graph</code> 包，提供<strong>最精简</strong>、<strong>单节点</strong>的流式处理的封装。如下图所示：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/01.png" alt=""></p></li><li><p><code>apm-collector-stream</code> 模块，在 <code>graph</code> 包的基础上，提供<strong>异步</strong>、<strong>跨节点</strong>等等的流式处理的封装。如下图所示：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/02.png" alt=""></p></li></ul><blockquote><p>免打脸大保健：笔者对流式处理非常不了解，本文可能是一本正经的胡说八道。考虑到笔者是靠脸吃饭（颜值我只服我红雷哥），所以读者老爷请爱护下笔者。</p></blockquote><p>Collector Streaming 在 SkyWalking 架构图处于如下位置( <strong>红框</strong> ) ：</p><blockquote><p>FROM <a href="https://github.com/apache/incubating-skywalking" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubating-skywalking</a><br><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/03.jpeg" alt=""></p></blockquote><p>OK，下面来一本正经的代码走起！</p><h1 id="2-apm-collector-core-graph"><a href="#2-apm-collector-core-graph" class="headerlink" title="2. apm-collector-core/graph"></a>2. apm-collector-core/graph</h1><p>整体类图如下：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/04.png" alt=""></p><p>看起来略复杂，不要方，我们先来看一个流式大数据处理框架 Apache Storm 的说明：</p><blockquote><p>FROM <a href="http://www.csdn.net/article/2015-03-09/2824135" rel="external nofollow noopener noreferrer" target="_blank">《流式大数据处理的三种框架：Storm，Spark和Samza》</a><br>在 <a href="https://storm.apache.org/" rel="external nofollow noopener noreferrer" target="_blank">Storm</a> 中，先要设计一个用于实时计算的图状结构，我们称之为拓扑（topology）。这个拓扑将会被提交给集群，由集群中的主控节点（master node）分发代码，将任务分配给工作节点（worker node）执行。</p></blockquote><ul><li>Graph ：定义了一个<strong>数据</strong>在<strong>各个</strong> Node 的处理拓扑图。</li><li>WayToNode ：提交<strong>数据</strong>给 Node 的<strong>方式</strong>。</li><li>Node ：节点，包含一个 NodeProcessor 和 一个 Next 。 <ul><li>NodeProcessor ：Node 处理器，处理<strong>数据</strong>。</li><li>Next ：包含 WayToNode 数组，即 Node 提交<strong>数据</strong>给 Next 的 Node <strong>数组</strong>的<strong>方式</strong>。</li></ul></li></ul><p>整体交互流程如下：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/05.png" alt=""></p><ul><li><strong>粉色</strong>箭头：当数据进来时，提交给 Grpah 。按照定义的拓扑图，使用 NodeWay 提交给 Node ，NodeProcessor 进行处理。</li><li><strong>蓝色</strong>箭头：当 NodeProcessor 处理完成后，Next <strong>逐个</strong>使用 NodeWay <strong>数组</strong>提交给下面的 Node ，继续处理。<ul><li>ps ：<strong>注意</strong>，这块流程，根据不同的 NodeProcessor 的实现类会有不同，<strong>蓝色</strong>箭头的过程，只是<strong>其中的一种</strong>，下面会详细解析。</li></ul></li></ul><p>整体顺序图如下：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/06.png" alt=""></p><ul><li>DirectWay 是 WayToNode <strong>接口</strong>的一种实现，正如其名，<strong>直接</strong>提交数据给 Node 。在 <a href="#">「3. apm-collector-stream」</a> 会看到其他实现，例如提交到其他服务器节点的 Node，从而实现跨服务器节点的流式处理。</li><li>AbstractWorker 在 <code>apm-collector-stream</code> 模块，是 NodeProcessor <strong>接口</strong>的一种实现，处理提交给 Node 的数据。在 <code>#onWork(message)</code> <strong>抽象</strong>方法里，子类可以实现该方法，根据自身需求，是否调用 <code>#onNext(message)</code> 方法，Next 逐个使用 NodeWay 数组提交给下面的 Node ，继续处理。</li></ul><hr><p>下面，我们来详细分别看看如下逻辑的详细代码实现：</p><ul><li>Graph 创建</li><li>Graph 启动</li></ul><h2 id="2-1-Graph-创建"><a href="#2-1-Graph-创建" class="headerlink" title="2.1 Graph 创建"></a>2.1 Graph 创建</h2><p>创建 Graph 的顺序图如下：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/07.png" alt=""></p><ul><li>第一步，调用 <code>GraphManager#createIfAbsent(graphId, input)</code> 方法( <code>input</code> 参数没用 )，创建一个 Graph 对象。</li><li>第二步，调用 <code>Graph#addNode(WayToNode)</code> 方法，创建该 Graph 的<strong>首个</strong> Node 对象。</li><li>第三步，调用 <code>Node#addNext(WayToNode)</code> 方法，创建该 Node 的下一个 Node 对象。</li></ul><p>如下是 <code>collector-agent-stream-provider</code> 模块，<code>TraceStreamGraph#createServiceReferenceGraph()</code> 方法的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createServiceReferenceGraph</span><span class="params">()</span> </span>&#123;</div><div class="line">    QueueCreatorService&lt;ServiceReference&gt; queueCreatorService = moduleManager.find(QueueModule.NAME).getService(QueueCreatorService.class);</div><div class="line">    RemoteSenderService remoteSenderService = moduleManager.find(RemoteModule.NAME).getService(RemoteSenderService.class);</div><div class="line"></div><div class="line">    Graph&lt;ServiceReference&gt; graph = GraphManager.INSTANCE.createIfAbsent(SERVICE_REFERENCE_GRAPH_ID, ServiceReference.class);</div><div class="line">    graph.addNode(<span class="keyword">new</span> ServiceReferenceAggregationWorker.Factory(moduleManager, queueCreatorService).create(workerCreateListener))</div><div class="line">        .addNext(<span class="keyword">new</span> ServiceReferenceRemoteWorker.Factory(moduleManager, remoteSenderService, SERVICE_REFERENCE_GRAPH_ID).create(workerCreateListener))</div><div class="line">        .addNext(<span class="keyword">new</span> ServiceReferencePersistenceWorker.Factory(moduleManager, queueCreatorService).create(workerCreateListener));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>让我们来看看每个方法的具体代码实现。</p><hr><p><strong>第一步</strong></p><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/GraphManager.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>GraphManager#createIfAbsent(graphId, input)</code></a> 方法，创建一个 Graph 对象，并添加到 Graph 映射。代码如下：</p><ul><li><code>INSTANCE</code> 属性，单例。</li><li><code>allGraphs</code> 属性，Graph 映射。其中映射的 KEY 为<strong>每个</strong> Graph 全局唯一编号。在 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/graph/JvmMetricStreamGraph.java" rel="external nofollow noopener noreferrer" target="_blank">JvmMetricStreamGraph</a> 、<a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/graph/RegisterStreamGraph.java" rel="external nofollow noopener noreferrer" target="_blank">RegisterStreamGraph</a> 、<a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/graph/TraceStreamGraph.java" rel="external nofollow noopener noreferrer" target="_blank">TraceStreamGraph</a> 类中，枚举了实际使用的 Graph 编号们。</li><li>第 50 至 58 行：当 Graph 映射里不存在指定 Graph 编号时，创建 Graph 对象，并返回。</li></ul><hr><p><strong>第二步</strong></p><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/Graph.java#L56" rel="external nofollow noopener noreferrer" target="_blank"><code>Graph#addNode(WayToNode)</code></a> 方法，创建该 Graph 的<strong>首个</strong> Node 对象。代码如下：</p><ul><li><code>id</code> 属性，Graph 编号。</li><li><code>entryWay</code>，<strong>首个</strong>提交数据给 Node 的方式。</li><li>第 58 行 ：将方法参数 <code>entryWay</code> 赋值给 <code>this.entryWay</code> 属性。在下分享的 <code>Graph#start(input)</code> 方法里，我们会看到这是 Graph 启动的入口，<strong>首个</strong>提交给 Node 的方式。</li><li>第 60 至 62 行 ：调用 <code>WayToNode#buildDestination(Graph)</code> 方法，创建 Node 对象，并<strong>返回该 Node</strong> 。在上文中，我们已经说过创建的 Node 对象，为该 Graph 的<strong>首个</strong> Node 。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/WayToNode.java#L41" rel="external nofollow noopener noreferrer" target="_blank"><code>WayToNode#buildDestination()</code></a> 方法，创建该 <strong>WayToNode</strong> 的 Node 对象。代码如下：</p><ul><li><code>destination</code> 属性，目标 Node 。即该 WayToNode 提交<strong>数据</strong>到的 Node 。</li><li><code>destinationHandler</code> 属性，目标 Node 的处理器。见 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/WayToNode.java#L47" rel="external nofollow noopener noreferrer" target="_blank"><code>#out(INPUT)</code></a> 方法。</li><li>第 42 行：创建 Node 对象。<ul><li>目前，<code>destinationHandler</code> 属性，除了用于创建 Node 对象，无其他用途。</li></ul></li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/Node.java#L40" rel="external nofollow noopener noreferrer" target="_blank">Node <code>构造方法</code></a> 方法，代码如下：</p><ul><li><code>nodeProcessor</code> 属性，节点处理器。</li><li><code>next</code> 属性，包含 WayToNode 数组，即 Node 提交数据给 Next 的 Node 数组的方式。</li><li>第 44 行：调用 <code>Graph#checkForNewNode(Node)</code> 方法，校验 Node 的 NodeProcessor 在其 Graph 里，<strong>编号唯一</strong>。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/Graph.java#L71" rel="external nofollow noopener noreferrer" target="_blank"><code>Graph#checkForNewNode(Node)</code></a> 方法，校验 Node 的 NodeProcessor 在 Graph 里，<strong>编号唯一</strong>，代码如下：</p><ul><li><code>nodeIndex</code> 属性，处理器编号与 Node 的映射。其中映射的 KEY 为 <code>NodeProcessor#id()</code> 。 </li><li>第 72 至 78 行：校验 Node 的 NodeProcessor 在 Graph 里，<strong>编号唯一</strong>。</li></ul><hr><p><strong>第三步</strong></p><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/Node.java#L51" rel="external nofollow noopener noreferrer" target="_blank"><code>Node#addNext(WayToNode)</code></a> 方法，创建该 Node 的下一个 Node 对象。代码如下：</p><ul><li>第 54 行：调用 <code>WayToNode#buildDestination(Graph)</code> 方法，创建该 Node 的下面的 Node 对象。</li><li>第 56 行：添加创建的 Node 对象到 <code>next</code> 属性。</li><li>第 58 行：返回创建的 Node 对象。</li></ul><h2 id="2-2-Graph-启动"><a href="#2-2-Graph-启动" class="headerlink" title="2.2 Graph 启动"></a>2.2 Graph 启动</h2><p>创建 Graph 的顺序图如下：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/08.png" alt=""></p><table><thead><tr><th>数据流向</th><th>FROM</th><th>TO</th><th>逻辑</th></tr></thead><tbody><tr><td>第一步</td><td>Graph</td><td>WayToNode</td><td></td></tr><tr><td>第二步</td><td>WayToNode</td><td>Node</td><td></td></tr><tr><td>第三步</td><td>Node</td><td>NodeProcessor</td><td></td></tr><tr><td>第四步</td><td>NodeProcessor</td><td>Next</td><td>根据具体实现，若到 Next ，重复第一步</td></tr></tbody></table><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/09.png" alt=""></p><hr><p><strong>第一步</strong></p><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/Graph.java#L48" rel="external nofollow noopener noreferrer" target="_blank"><code>Graph#start(input)</code></a> 方法，启动 Graph ，处理数据。代码如下：</p><ul><li>第 49 行：调用 <code>WayToNode#in(input)</code> 方法，输入数据给 WayToNode 。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/WayToNode.java#L45" rel="external nofollow noopener noreferrer" target="_blank"><code>WayToNode#in(input)</code></a> <strong>抽象</strong>方法，以 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/DirectWay.java#L29" rel="external nofollow noopener noreferrer" target="_blank"><code>DirectWay#in(input)</code></a> <strong>实现</strong>方法举例子，代码如下：</p><ul><li>第 30 行：调用 <code>super#out(input)</code> 方法，<strong>直接</strong>输出数据，调用 <code>Node#execute(input)</code> 方法，提交数据给 Node ，进行处理。</li></ul><hr><p><strong>第二步</strong></p><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/Node.java#L62" rel="external nofollow noopener noreferrer" target="_blank"><code>Node#execute</code></a> 方法，调用 <code>NodeProcessor#process(input, next)</code> 方法，处理数据。</p><hr><p><strong>第三步</strong></p><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/NodeProcessor.java#L34" rel="external nofollow noopener noreferrer" target="_blank"><code>NodeProcessor#process(input, next)</code></a> <strong>接口</strong>方法，以 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/AbstractWorker.java#L62" rel="external nofollow noopener noreferrer" target="_blank"><code>AbstractWorker#process(input, next)</code></a> <strong>实现</strong>方法举例子，代码如下：</p><ul><li>第 64 行：将方法参数 <code>next</code> 赋值给 <code>this.next</code> 属性。<code>this.next</code> 属性，用于封装的 <code>#onNext(OUTPUT)</code> 方法，提交数据给当前 Node 的 Next ( 下面的 Node 们 )继续处理数据。</li><li>第 67 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/AbstractWorker.java#L60" rel="external nofollow noopener noreferrer" target="_blank"><code>#onWork</code></a> <strong>抽象</strong>方法，处理数据。当 AbstractWorker <strong>抽象类</strong>的实现类需要继续讲数据提交给 Next 时，需要在 <code>#onWork</code> 方法里，调用 <code>#onNext(OUTPUT)</code> 方法，例如 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationRegisterRemoteWorker.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>ApplicationRegisterRemoteWorker#onWork(Application)</code></a> 。</li></ul><hr><p><strong>第四步</strong></p><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/Next.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>Next#execute(INPUT)</code></a> 方法，<strong>循环</strong> WayToNode 数组，输入数据给 WayNode ，相当于”<strong>重回</strong>“【第一步】。</p><h1 id="3-apm-collector-stream"><a href="#3-apm-collector-stream" class="headerlink" title="3. apm-collector-stream"></a>3. apm-collector-stream</h1><p>在文章的开头，我们提到了 <code>apm-collector-stream</code> 模块，在 <code>graph</code> 包的基础上，提供<strong>异步</strong>、<strong>跨节点</strong>等等的流式处理的封装。主要在 WayToNode 、NodeProcessor 的实现类上做文章。</p><h2 id="3-1-WayToNode-实现类"><a href="#3-1-WayToNode-实现类" class="headerlink" title="3.1 WayToNode 实现类"></a>3.1 WayToNode 实现类</h2><p>整体类图如下：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/10.png" alt=""></p><h3 id="3-1-1-WorkerRef"><a href="#3-1-1-WorkerRef" class="headerlink" title="3.1.1 WorkerRef"></a>3.1.1 WorkerRef</h3><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/WorkerRef.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.stream.worker.base.WorkerRef</code></a> ，Worker 引用<strong>抽象类</strong>。</p><p>在 <code>apm-collector-stream</code> 模块里，我们会发现类的命名从 Node / NodeProcessor 转向了 Worker ？<strong>这是为什么呢</strong>？关于这一点，我们特意<del>采访</del>( 请教 )了官方大佬。</p><blockquote><p>Worker 更具业务含义<br>Node / Processor 更偏技术含义</p></blockquote><p>目前，WorkerRef 无具体的方法。</p><h3 id="3-1-2-LocalAsyncWorkerRef"><a href="#3-1-2-LocalAsyncWorkerRef" class="headerlink" title="3.1.2 LocalAsyncWorkerRef"></a>3.1.2 LocalAsyncWorkerRef</h3><p><code>org.skywalking.apm.collector.stream.worker.base.LocalAsyncWorkerRef</code> ，异步 Worker 引用<strong>实现类</strong>，提供了<strong>异步</strong>的流式处理封装。</p><p>我们回到 <a href="#">「2.2 Graph 创建」</a> 的【第一步】。</p><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/LocalAsyncWorkerRef.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>LocalAsyncWorkerRef#in(INPUT)</code></a> 方法，代码如下：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/LocalAsyncWorkerRef.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><code>queueEventHandler</code></a> 属性，队列事件处理器。在 <a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/?self">《SkyWalking 源码分析 —— Collector Queue 队列组件》</a> 我们会详细解析它的代码实现，这里只简单介绍下。</li><li>第 47 行：将输入的数据，作为”<strong>事件</strong>“，提交到队列事件处理器中，不再执行后续逻辑。此后，队列事件处理器，会在<strong>后台</strong>处理到该”<strong>事件</strong>“( 数据 )，回调 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/LocalAsyncWorkerRef.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>LocalAsyncWorkerRef#execute</code></a> 方法，从而提交数据到 Worker ( Node )。详细参见 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-queue/collector-queue-disruptor-provider/src/main/java/org/skywalking/apm/collector/queue/disruptor/base/DisruptorEventHandler.java#L54" rel="external nofollow noopener noreferrer" target="_blank">DisruptorEventHandler#onEvent(…)</a> 方法。</li></ul><p><strong>那么为什么会回调呢</strong>？LocalAsyncWorkerRef 实现了 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-queue/collector-queue-define/src/main/java/org/skywalking/apm/collector/queue/base/QueueExecutor.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.queue.base.QueueExecutor</code></a> 接口，它自身被设置到 QueueEventHandler 中， 作为”<strong>事件</strong>“的执行器。</p><p>整体流程如下：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/11.png" alt=""></p><h3 id="3-1-3-RemoteWorkerRef"><a href="#3-1-3-RemoteWorkerRef" class="headerlink" title="3.1.3 RemoteWorkerRef"></a>3.1.3 RemoteWorkerRef</h3><p><code>org.skywalking.apm.collector.stream.worker.base.RemoteWorkerRef</code> ，远程 Worker 引用<strong>实现类</strong>，提供了<strong>远程跨节点</strong>的流式处理的封装。</p><p>我们再回到 <a href="#">「2.2 Graph 创建」</a> 的【第一步】。</p><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/RemoteWorkerRef.java#L53" rel="external nofollow noopener noreferrer" target="_blank"><code>RemoteWorkerRef#in(INPUT)</code></a> 方法，代码如下：</p><ul><li><code>remoteSenderService</code> 属性，远程发送服务。在 <a href="http://www.iocoder.cn/SkyWalking/collector-remote-module?self">《SkyWalking 源码分析 —— Collector Remote 远程通信服务》「3.2 GRPCRemoteSenderService」</a> 我们会详细解析它的代码实现，这里只简单介绍下。</li><li><code>remoteWorker</code> 属性，远程 Worker 。在下文会详细分享它的实现。</li><li>第 56 行：调用 <code>RemoteSenderService#send(...)</code> 方法，根据远程 Worker 的 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/Selector.java" rel="external nofollow noopener noreferrer" target="_blank">Selector 选择器</a>，选择一个 Worker 进行发送。</li><li>第 58 至 60 行：当选择的 Worker 为本地模式( <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/RemoteSenderService.java#L36" rel="external nofollow noopener noreferrer" target="_blank">Mode</a> )时，调用 <code>#out(INPUT)</code> 方法，提交数据到本地的 Worker ( Node )。</li></ul><h2 id="3-2-NodeProcessor-实现类"><a href="#3-2-NodeProcessor-实现类" class="headerlink" title="3.2 NodeProcessor 实现类"></a>3.2 NodeProcessor 实现类</h2><p>整体类图如下：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/12.png" alt=""></p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/23c2146c134e0ef0a37a43758a1e04727de7697a/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/Provider.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.stream.worker.base.Provider</code></a> ，Worker 供应者<strong>接口</strong>，用于创建 Worker 和 WorkerRef 对象的<strong>工厂</strong>。</li></ul><h3 id="3-2-1-AbstractWorker"><a href="#3-2-1-AbstractWorker" class="headerlink" title="3.2.1 AbstractWorker"></a>3.2.1 AbstractWorker</h3><p>AbstractWorker 的代码实现，在 <a href="#">「2.2 Graph 启动」</a> 已经详细解析。</p><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/AbstractWorkerProvider.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.stream.worker.base.AbstractWorkerProvider</code></a> ，Worker 供应者<strong>抽象类</strong>，定义了 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/AbstractWorkerProvider.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#workerInstance(ModuleManager)</code></a> <strong>抽象</strong>方法，用于创建 Worker 对象。</p><h3 id="3-2-2-AbstractLocalAsyncWorker"><a href="#3-2-2-AbstractLocalAsyncWorker" class="headerlink" title="3.2.2 AbstractLocalAsyncWorker"></a>3.2.2 AbstractLocalAsyncWorker</h3><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/AbstractLocalAsyncWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.stream.worker.base.AbstractLocalAsyncWorker</code></a> ，异步 Worker <strong>抽象类</strong>。</p><p>目前，AbstractLocalAsyncWorker 无具体的方法。</p><p>实际使用时，继承 AbstractLocalAsyncWorker 类，实现 <code>#work(INPUT)</code> 方法，例如：<a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationRegisterSerialWorker.java#L56" rel="external nofollow noopener noreferrer" target="_blank">ApplicationRegisterSerialWorker</a> 。</p><hr><p><code>org.skywalking.apm.collector.stream.worker.base.AbstractLocalAsyncWorkerProvider</code> ，LocalAsyncWorker 供应者<strong>抽象类</strong>。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/AbstractLocalAsyncWorkerProvider.java#L35" rel="external nofollow noopener noreferrer" target="_blank"><code>queueCreatorService</code></a> 属性，队列创建服务，用于创建 QueueEventHandler 对象。</li><li><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/AbstractLocalAsyncWorkerProvider.java#L40" rel="external nofollow noopener noreferrer" target="_blank"><code>#queueSize()</code></a> <strong>抽象</strong>方法，声明队列大小。</li><li><a href=""><code>#create(WorkerCreateListener)</code></a> <strong>实现</strong>方法，创建 AbstractLocalAsyncWorker 和 LocalAsyncWorkerRef 对象。<ul><li>第 51 行：创建 AbstractLocalAsyncWorker <strong>实现类</strong>的对象。参见 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationRegisterSerialWorker.java#L90" rel="external nofollow noopener noreferrer" target="_blank">ApplicationRegisterSerialWorker.Factory#workerInstance(ModuleManager)</a> 方法。</li><li>第 54 行：添加 AbstractLocalAsyncWorker 到 WorkerCreateListener ( Worker 创建监听器 )。WorkerCreateListener 在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（二）》「4.1 WorkerCreateListener」</a> 详细解析。</li><li>第 57 行：创建 LocalAsyncWorkerRef 对象。</li><li>第 60 行：调用 <code>QueueCreatorService#create(...)</code> 方法，创建 QueueEventHandler 对象，<strong>并设置 LocalAsyncWorkerRef 作为它的执行器</strong>。</li><li>第 63 行：设置 LocalAsyncWorkerRef 的 QueueEventHandler 属性。</li></ul></li></ul><h3 id="3-2-3-AbstractRemoteWorker"><a href="#3-2-3-AbstractRemoteWorker" class="headerlink" title="3.2.3 AbstractRemoteWorker"></a>3.2.3 AbstractRemoteWorker</h3><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/AbstractRemoteWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.stream.worker.base.AbstractRemoteWorker</code></a> ，远程 Worker <strong>抽象类</strong>，定义了 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/AbstractRemoteWorker.java#L45" rel="external nofollow noopener noreferrer" target="_blank"><code>#selector()</code></a> <strong>抽象</strong>方法，获得选择器。RemoteSenderService 根据选择器，调用 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/selector/RemoteClientSelector.java#L31" rel="external nofollow noopener noreferrer" target="_blank"><code>RemoteClientSelector#select(...)</code></a> 方法，选择好远程节点，而后进行发送数据。</p><p>实际使用时，继承 AbstractLocalAsyncWorker 类，实现 <code>#work(INPUT)</code> 方法，例如：<a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationRegisterRemoteWorker.java" rel="external nofollow noopener noreferrer" target="_blank">ApplicationRegisterRemoteWorker</a> 。</p><hr><p><code>org.skywalking.apm.collector.stream.worker.base.AbstractRemoteWorkerProvider</code> ，AbstractRemoteWorker 供应者<strong>抽象类</strong>。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/AbstractRemoteWorkerProvider.java#L40" rel="external nofollow noopener noreferrer" target="_blank"><code>remoteSenderService</code></a> 属性，远程发送服务。</li><li><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/AbstractRemoteWorkerProvider.java#L56" rel="external nofollow noopener noreferrer" target="_blank"><code>#create(WorkerCreateListener)</code></a> <strong>实现</strong>方法，创建 AbstractRemoteWorker 和 RemoteWorkerRef 对象。<ul><li>第 58 行：创建 AbstractRemoteWorker <strong>实现类</strong>的对象。参见 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationRegisterRemoteWorker.java#L61" rel="external nofollow noopener noreferrer" target="_blank">ApplicationRegisterRemoteWorker.Factory#workerInstance(ModuleManager)</a> 方法。</li><li>第 61 行：添加 AbstractLocalAsyncWorker 到 WorkerCreateListener ( Worker 创建监听器 )。WorkerCreateListener 在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（二）》「4.1 WorkerCreateListener」</a> 详细解析。</li><li>第 64 行：创建 RemoteWorkerRef 对象。</li></ul></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>呼呼，蛮嗨皮的。卡了一个周末，差点又堕落了。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/13.png" alt=""></p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-streaming-first/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-streaming-first
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
</feed>
