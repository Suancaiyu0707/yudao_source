<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>芋道源码 —— 纯源码解析BLOG</title>
  
  <subtitle>愿半生编码，如一生老友！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.iocoder.cn/"/>
  <updated>2017-11-05T03:06:40.000Z</updated>
  <id>http://www.iocoder.cn/</id>
  
  <author>
    <name>芋道源码</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RxJava 源码解析 —— Observable#lift(Operator)</title>
    <link href="http://www.iocoder.cn/RxJava/observable-lift-operator/"/>
    <id>http://www.iocoder.cn/RxJava/observable-lift-operator/</id>
    <published>2019-01-28T16:00:00.000Z</published>
    <updated>2017-11-05T03:06:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/RxJava/observable-subscribe-on-scheduler/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 RxJava 1.2.X 版本</strong></p><p>本系列写作目的，为了辅助 Hystrix 的理解，因此会较为零散与琐碎，望见谅见谅。</p><ul><li><a href="http://www.iocoder.cn/RxJava/observable-lift-operator/">1. 概述</a></li><li><a href="http://www.iocoder.cn/RxJava/observable-lift-operator/">2. 示例</a></li><li><a href="http://www.iocoder.cn/RxJava/observable-lift-operator/">3. 原理</a></li><li><a href="http://www.iocoder.cn/RxJava/observable-lift-operator/">4. 源码</a><ul><li><a href="http://www.iocoder.cn/RxJava/observable-lift-operator/">4.1 Operator</a></li><li><a href="http://www.iocoder.cn/RxJava/observable-lift-operator/">4.2 Observable#lift(Operator)</a></li><li><a href="http://www.iocoder.cn/RxJava/observable-lift-operator/">4.3 OnSubscribeLift</a></li></ul></li><li><a href="http://www.iocoder.cn/RxJava/observable-lift-operator/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p><code>Observable#lift(Operator)</code> 方法，RxJava 中<strong>所有</strong>操作符的<strong>基础</strong>，不清晰的理解，后面会是懵逼脸状。</p><p>怎么解释这个方法呢？笔者暂时没有想好。搜了下互联网上相关的文章，也没找到合适的寿命。But ，这不影响我们对该方法的理解。</p><h1>2. 示例</h1><p>下面我们先一起来看<strong>第一段示例</strong> ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">   Observable.just(<span class="string">"1"</span>, <span class="string">"2"</span>)</div><div class="line">           .subscribe(o -&gt; System.out.println(<span class="string">"subscriber ："</span> + o));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p>输出如下 ：</p><p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">subscriber ：1</div><div class="line">subscriber ：2</div></pre></td></tr></table></figure></p></li></ul><p><strong>第二段示例</strong> ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">   Observable.just(<span class="string">"1"</span>, <span class="string">"2"</span>)</div><div class="line">           .lift(<span class="keyword">new</span> Observable.Operator&lt;String, String&gt;() &#123;</div><div class="line">               <span class="meta">@Override</span></div><div class="line">               <span class="keyword">public</span> Subscriber&lt;? <span class="keyword">super</span> String&gt; call(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber) &#123;</div><div class="line">                   <span class="keyword">return</span> <span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</div><div class="line">                       <span class="meta">@Override</span></div><div class="line">                       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">                       &#125;</div><div class="line"></div><div class="line">                       <span class="meta">@Override</span></div><div class="line">                       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line"></div><div class="line">                       &#125;</div><div class="line"></div><div class="line">                       <span class="meta">@Override</span></div><div class="line">                       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">                           System.out.println(<span class="string">"operator ："</span> + s);</div><div class="line">                           subscriber.onNext(s);</div><div class="line">                       &#125;</div><div class="line">                   &#125;;</div><div class="line">               &#125;</div><div class="line">           &#125;)</div><div class="line">           .subscribe(o -&gt; System.out.println(<span class="string">"subscriber ："</span> + o));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p>输出如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">operator ：<span class="number">1</span></div><div class="line">subscriber ：<span class="number">1</span></div><div class="line">operator ：<span class="number">2</span></div><div class="line">subscriber ：<span class="number">2</span></div></pre></td></tr></table></figure></p></li></ul><ul><li><p><code>Observable#lift(Operator)</code> 方法，返回一个<strong>新的</strong> Subscriber ，对<strong>传递进来</strong>的 Subscriber 形成<strong>代理</strong>，对 <code>#onNext()</code> / <code>#onCompleted()</code> / <code>#onError()</code> 方法进行拦截。<strong>这就是 <code>Observable#lift(Operator)</code> 的实现原理</strong>。如果我们去掉 <code>subscriber.onNext(s)</code> 部分代码，则输出如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">operator ：<span class="number">1</span></div><div class="line">operator ：<span class="number">2</span></div></pre></td></tr></table></figure></p></li></ul><h1>3. 原理</h1><p>OK ，下面在用一张图来理解下 <code>Observable#lift(Operator)</code> 的<strong>原理</strong> ：</p><p><img src="http://www.iocoder.cn/images/RxJava/2019_01_29/01.png" alt=""></p><h1>4. 源码</h1><p>开始我们的源码旅程。</p><h2>4.1 Operator</h2><p><code>rx.Observable.Operator</code> ，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Func1</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">Function</span> </span>&#123;</div><div class="line">    <span class="function">R <span class="title">call</span><span class="params">(T t)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Operator</span>&lt;<span class="title">R</span>, <span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Func1</span>&lt;<span class="title">Subscriber</span>&lt;? <span class="title">super</span> <span class="title">R</span>&gt;, <span class="title">Subscriber</span>&lt;? <span class="title">super</span> <span class="title">T</span>&gt;&gt; </span>&#123;</div><div class="line">    <span class="comment">// cover for generics insanity</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>T <code>t</code> ：传递来的 Subscriber ，上图<strong>粉色</strong>的 Subscriber 。</li><li>R ：返回一个<strong>新</strong>的 Subscriber ，上图<strong>绿色</strong>的 Subscriber 。</li></ul><h2>4.2 Observable#lift(Operator)</h2><p><code>Observable#lift(Operator)</code> 方法，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">lift</span><span class="params">(<span class="keyword">final</span> Operator&lt;? extends R, ? <span class="keyword">super</span> T&gt; operator)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> create(<span class="keyword">new</span> OnSubscribeLift&lt;T, R&gt;(onSubscribe, operator));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(OnSubscribe&lt;T&gt; f)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Observable&lt;T&gt;(RxJavaHooks.onCreate(f));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>使用 <code>operator</code> ( Operator ) + <code>onSubscribe</code> ( OnSubscribe )，生成<strong>新</strong>的 <code>onSubscribe</code> ( OnSubscribe【OnSubscribeLift】 ) ，从而生成<strong>新</strong>的 Observable 。</li><li>OnSubscribeLift 在 <a href="#">「4.3 OnSubscribeLift」</a> 详细解析。</li></ul><h2>4.3 OnSubscribeLift</h2><p>OnSubscribeLift ，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OnSubscribeLift</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">OnSubscribe</span>&lt;<span class="title">R</span>&gt; </span>&#123;</div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>:     <span class="keyword">final</span> OnSubscribe&lt;T&gt; parent;</div><div class="line"> <span class="number">4</span>: </div><div class="line"> <span class="number">5</span>:     <span class="keyword">final</span> Operator&lt;? extends R, ? <span class="keyword">super</span> T&gt; operator;</div><div class="line"> <span class="number">6</span>: </div><div class="line"> <span class="number">7</span>:     <span class="function"><span class="keyword">public</span> <span class="title">OnSubscribeLift</span><span class="params">(OnSubscribe&lt;T&gt; parent, Operator&lt;? extends R, ? <span class="keyword">super</span> T&gt; operator)</span> </span>&#123;</div><div class="line"> <span class="number">8</span>:         <span class="keyword">this</span>.parent = parent;</div><div class="line"> <span class="number">9</span>:         <span class="keyword">this</span>.operator = operator;</div><div class="line"><span class="number">10</span>:     &#125;</div><div class="line"><span class="number">11</span>: </div><div class="line"><span class="number">12</span>:     <span class="meta">@Override</span></div><div class="line"><span class="number">13</span>:     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> R&gt; o)</span> </span>&#123;</div><div class="line"><span class="number">14</span>:         <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">15</span>:             Subscriber&lt;? <span class="keyword">super</span> T&gt; st = RxJavaHooks.onObservableLift(operator).call(o);</div><div class="line"><span class="number">16</span>:             <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">17</span>:                 <span class="comment">// new Subscriber created and being subscribed with so 'onStart' it</span></div><div class="line"><span class="number">18</span>:                 st.onStart();</div><div class="line"><span class="number">19</span>:                 parent.call(st);</div><div class="line"><span class="number">20</span>:             &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"><span class="number">21</span>:                 <span class="comment">// localized capture of errors rather than it skipping all operators</span></div><div class="line"><span class="number">22</span>:                 <span class="comment">// and ending up in the try/catch of the subscribe method which then</span></div><div class="line"><span class="number">23</span>:                 <span class="comment">// prevents onErrorResumeNext and other similar approaches to error handling</span></div><div class="line"><span class="number">24</span>:                 Exceptions.throwIfFatal(e);</div><div class="line"><span class="number">25</span>:                 st.onError(e);</div><div class="line"><span class="number">26</span>:             &#125;</div><div class="line"><span class="number">27</span>:         &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"><span class="number">28</span>:             Exceptions.throwIfFatal(e);</div><div class="line"><span class="number">29</span>:             <span class="comment">// if the lift function failed all we can do is pass the error to the final Subscriber</span></div><div class="line"><span class="number">30</span>:             <span class="comment">// as we don't have the operator available to us</span></div><div class="line"><span class="number">31</span>:             o.onError(e);</div><div class="line"><span class="number">32</span>:         &#125;</div><div class="line"><span class="number">33</span>:     &#125;</div><div class="line"><span class="number">34</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>可能有胖友对 <code>Observable#subscribe(Subscriber)</code> 方法的<strong>调用链</strong>不是很熟悉，在<strong>第 15 行</strong>打<strong>断点</strong>，调用连如下图 ：<img src="http://www.iocoder.cn/images/RxJava/2019_01_29/02.png" alt=""></li><li>第 15 行 ：调用 <code>Operator#call()</code> 方法，创建<strong>新</strong>的 Subscriber 。</li><li>第 18 行 ：调用 <code>Subscriber#onStart()</code> 方法，因为<strong>新</strong>的 Subscriber 被订阅。</li><li>第 19 行 ：调用 <code>OnSubscribe#call(Subscriber)</code> 方法，<strong>继续订阅</strong>。</li></ul><h1>666. 彩蛋</h1><p>是不是非常清晰！聪慧如你！</p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/RxJava/observable-subscribe-on-scheduler/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 RxJava 1.2.X 版本&lt;/stron
      
    
    </summary>
    
      <category term="RxJava" scheme="http://www.iocoder.cn/categories/RxJava/"/>
    
    
  </entry>
  
  <entry>
    <title>RxJava 源码解析 —— Observable#subscribeOn(Scheduler)</title>
    <link href="http://www.iocoder.cn/RxJava/observable-subscribe-on-scheduler/"/>
    <id>http://www.iocoder.cn/RxJava/observable-subscribe-on-scheduler/</id>
    <published>2019-01-21T16:00:00.000Z</published>
    <updated>2017-11-02T07:50:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/RxJava/observable-subscribe-on-scheduler/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 RxJava 1.2.X 版本</strong></p><p>本系列写作目的，为了辅助 Hystrix 的理解，因此会较为零散与琐碎，望见谅见谅。</p><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><p><code>Observable#subscribeOn(Scheduler)</code> 方法，用途如下 ：</p><blockquote><p>FROM <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/SubscribeOn.html" rel="external nofollow noopener noreferrer" target="_blank">《ReactiveX文档中文翻译 —— SubscribeOn》</a><br>指定 Observable <strong>自身</strong>在哪个调度器上执行<br><img src="http://www.iocoder.cn/images/RxJava/2019_01_22/01.png" alt=""><br>很多 ReactiveX 实现都使用调度器 <code>&quot;Scheduler&quot;</code> 来管理多线程环境中Observable 的转场。你可以使用 SubscribeOn 操作符指定 Observable 在一个特定的调度器上运转。</p></blockquote><p>从概念上可能比较模糊，或者我们换一种说法 ：</p><blockquote><p>FROM <a href="http://gank.io/post/560e15be2dca930e00da1083#toc_14" rel="external nofollow noopener noreferrer" target="_blank">《给 Android 开发者的 RxJava 详解》「 3. 线程控制 —— Scheduler (一) 」</a><code>#subscribeOn()</code> ：指定 <code>#subscribe()</code> 所发生的线程，即 <code>Observable.OnSubscribe</code> 被激活时所处的线程。<strong>或者叫做事件产生的线程</strong>。</p></blockquote><p>来来来，一起瞅瞅源码，更加清理的理解。<code>Observable#subscribeOn(Scheduler)</code> 方法，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Observable.java</span></div><div class="line"></div><div class="line"><span class="keyword">final</span> OnSubscribe&lt;T&gt; onSubscribe;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Observable</span><span class="params">(OnSubscribe&lt;T&gt; f)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.onSubscribe = f;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> ScalarSynchronousObservable) &#123;</div><div class="line">        <span class="keyword">return</span> ((ScalarSynchronousObservable&lt;T&gt;)<span class="keyword">this</span>).scalarScheduleOn(scheduler);</div><div class="line">   &#125;</div><div class="line">    <span class="keyword">return</span> create(<span class="keyword">new</span> OperatorSubscribeOn&lt;T&gt;(<span class="keyword">this</span>, scheduler));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(OnSubscribe&lt;T&gt; f)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Observable&lt;T&gt;(RxJavaHooks.onCreate(f));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>ScalarSynchronousObservable ，跳过，不在本文范围内。</li><li>创建 OperatorSubscribeOn 对象，将 Observable ( <code>this</code> ) 和 Scheduler ( <code>scheduler</code> ) 传入。</li></ul><hr><p>OperatorSubscribeOn 类，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OperatorSubscribeOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">OnSubscribe</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>:     <span class="keyword">final</span> Scheduler scheduler;</div><div class="line"> <span class="number">4</span>:     <span class="keyword">final</span> Observable&lt;T&gt; source;</div><div class="line"> <span class="number">5</span>: </div><div class="line"> <span class="number">6</span>:     <span class="function"><span class="keyword">public</span> <span class="title">OperatorSubscribeOn</span><span class="params">(Observable&lt;T&gt; source, Scheduler scheduler)</span> </span>&#123;</div><div class="line"> <span class="number">7</span>:         <span class="keyword">this</span>.scheduler = scheduler;</div><div class="line"> <span class="number">8</span>:         <span class="keyword">this</span>.source = source;</div><div class="line"> <span class="number">9</span>:     &#125;</div><div class="line"><span class="number">10</span>: </div><div class="line"><span class="number">11</span>:     <span class="meta">@Override</span></div><div class="line"><span class="number">12</span>:     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span> </span>&#123;</div><div class="line"><span class="number">13</span>:         <span class="keyword">final</span> Worker inner = scheduler.createWorker();</div><div class="line"><span class="number">14</span>:         subscriber.add(inner);</div><div class="line"><span class="number">15</span>: </div><div class="line"><span class="number">16</span>:         inner.schedule(<span class="keyword">new</span> Action0() &#123;</div><div class="line"><span class="number">17</span>:             <span class="meta">@Override</span></div><div class="line"><span class="number">18</span>:             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">19</span>:                 <span class="keyword">final</span> Thread t = Thread.currentThread();</div><div class="line"><span class="number">20</span>: </div><div class="line"><span class="number">21</span>:                 Subscriber&lt;T&gt; s = <span class="keyword">new</span> Subscriber&lt;T&gt;(subscriber) &#123;</div><div class="line"><span class="number">22</span>:                     <span class="meta">@Override</span></div><div class="line"><span class="number">23</span>:                     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</div><div class="line"><span class="number">24</span>:                         subscriber.onNext(t);</div><div class="line"><span class="number">25</span>:                     &#125;</div><div class="line"><span class="number">26</span>: </div><div class="line"><span class="number">27</span>:                     <span class="meta">@Override</span></div><div class="line"><span class="number">28</span>:                     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line"><span class="number">29</span>:                         <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">30</span>:                             subscriber.onError(e);</div><div class="line"><span class="number">31</span>:                         &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">32</span>:                             inner.unsubscribe();</div><div class="line"><span class="number">33</span>:                         &#125;</div><div class="line"><span class="number">34</span>:                     &#125;</div><div class="line"><span class="number">35</span>: </div><div class="line"><span class="number">36</span>:                     <span class="meta">@Override</span></div><div class="line"><span class="number">37</span>:                     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">38</span>:                         <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">39</span>:                             subscriber.onCompleted();</div><div class="line"><span class="number">40</span>:                         &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">41</span>:                             inner.unsubscribe();</div><div class="line"><span class="number">42</span>:                         &#125;</div><div class="line"><span class="number">43</span>:                     &#125;</div><div class="line"><span class="number">44</span>: </div><div class="line"><span class="number">45</span>:                     <span class="meta">@Override</span></div><div class="line"><span class="number">46</span>:                     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProducer</span><span class="params">(<span class="keyword">final</span> Producer p)</span> </span>&#123;</div><div class="line"><span class="number">47</span>:                         subscriber.setProducer(<span class="keyword">new</span> Producer() &#123;</div><div class="line"><span class="number">48</span>:                             <span class="meta">@Override</span></div><div class="line"><span class="number">49</span>:                             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> n)</span> </span>&#123;</div><div class="line"><span class="number">50</span>:                                 <span class="keyword">if</span> (t == Thread.currentThread()) &#123;</div><div class="line"><span class="number">51</span>:                                     p.request(n);</div><div class="line"><span class="number">52</span>:                                 &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">53</span>:                                     inner.schedule(<span class="keyword">new</span> Action0() &#123;</div><div class="line"><span class="number">54</span>:                                         <span class="meta">@Override</span></div><div class="line"><span class="number">55</span>:                                         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">56</span>:                                             p.request(n);</div><div class="line"><span class="number">57</span>:                                         &#125;</div><div class="line"><span class="number">58</span>:                                     &#125;);</div><div class="line"><span class="number">59</span>:                                 &#125;</div><div class="line"><span class="number">60</span>:                             &#125;</div><div class="line"><span class="number">61</span>:                         &#125;);</div><div class="line"><span class="number">62</span>:                     &#125;</div><div class="line"><span class="number">63</span>:                 &#125;;</div><div class="line"><span class="number">64</span>: </div><div class="line"><span class="number">65</span>:                 source.unsafeSubscribe(s);</div><div class="line"><span class="number">66</span>:             &#125;</div><div class="line"><span class="number">67</span>:         &#125;);</div><div class="line"><span class="number">68</span>:     &#125;</div><div class="line"><span class="number">69</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p><code>scheduler</code>，<code>source</code> 属性就不用说了，上文我们已经看到。</p></li><li><p>可能有同学对 <code>OnSubscribe#call(Subscriber)</code> 方法的调用链路不太熟悉，我们手撸一个实例，并且打个断点感受下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RxDemo11</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        Observable.just(<span class="string">"1"</span>, <span class="string">"2"</span>)</div><div class="line">                .subscribeOn(Schedulers.newThread()) <span class="comment">// Scheduler 开启新线程</span></div><div class="line">                .subscribe(s -&gt; System.out.println(s)); <span class="comment">// Subscriber 打印</span></div><div class="line">        Thread.sleep(Long.MAX_VALUE); <span class="comment">// Scheduler 异步，Sleep 等待</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>在<strong>第 13 行</strong>处打断点，方法的调用链路如下图 ：<img src="http://www.iocoder.cn/images/RxJava/2019_01_22/02.png" alt=""></li></ul></li><li><p>第 13 行 ：使用 Scheduler 创建 Worker 。在 <a href="http://www.iocoder.cn/RxJava/scheduler/?self">《RxJava 源码解析 —— Scheduler》</a> 有详细解析。</p></li><li><p>第 14 行 ：将 Worker 添加到 <code>subscriber.subscriptions</code> 里。Worker 类实现了 <code>rx.Subscription</code> <strong>接口</strong>。</p></li><li><p>第 16 至 66 行 ：使用 Worker 执行操作。例如 Scheduler 为 NewThreadScheduler 时，此处的 Worker 对应 NewThreadWorker ，执行操作时使用<strong>新线程</strong>，而不是当前线程。</p><ul><li>第 19 行 ：获取执行操作的当前线程，用于第 50 行的判断。</li><li>第 21 至 63 行 ：创建<strong>新的</strong> Subscriber 。比较关键的是 <code>#setProducer()</code> 方法，判断 <code>#request()</code> 时，线程是否是 <code>t</code> ( Worker 的线程 )，如果不是，重新使用 Worker 执行 <code>#request()</code> 方法。通过这样的方式，达到上文所说的 <em>&quot;指定 <code>#subscribe()</code> 所发生的线程，即 <code>Observable.OnSubscribe</code> 被激活时所处的线程。<strong>或者叫做事件产生的线程</strong>。&quot;</em>。</li></ul></li><li><p>第 65 行 ：调用 <code>Observable#unsafeSubscribe(...)</code> 方法，<strong>继续订阅逻辑</strong>。</p></li><li><p>另外，想要触发<strong>第 53 行</strong>的情况，示例代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RxDemo10</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        Observable.defer(() -&gt; Observable.just(<span class="string">"1"</span>, <span class="string">"2"</span>)</div><div class="line">                    .subscribeOn(Schedulers.newThread()) <span class="comment">// Scheduler</span></div><div class="line">                )</div><div class="line">                .subscribeOn(Schedulers.newThread()) <span class="comment">// Scheduler</span></div><div class="line">                .subscribe(s -&gt; System.out.println(s));</div><div class="line">        Thread.sleep(Long.MAX_VALUE); <span class="comment">// Scheduler 异步，Sleep 等待</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/RxJava/observable-subscribe-on-scheduler/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 RxJava 1.2.X 版本&lt;/stron
      
    
    </summary>
    
      <category term="RxJava" scheme="http://www.iocoder.cn/categories/RxJava/"/>
    
    
  </entry>
  
  <entry>
    <title>RxJava 源码解析 —— Scheduler</title>
    <link href="http://www.iocoder.cn/RxJava/scheduler/"/>
    <id>http://www.iocoder.cn/RxJava/scheduler/</id>
    <published>2019-01-14T16:00:00.000Z</published>
    <updated>2017-11-01T18:55:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/RxJava/scheduler/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 RxJava 1.2.X 版本</strong></p><p>本系列写作目的，为了辅助 Hystrix 的理解，因此会较为零散与琐碎，望见谅见谅。</p><ul><li><a href="http://www.iocoder.cn/RxJava/scheduler/">1. Scheduler</a></li><li><a href="http://www.iocoder.cn/RxJava/scheduler/">2. Worker</a></li><li><a href="http://www.iocoder.cn/RxJava/scheduler/">3. 默认调度器实现</a></li><li><a href="http://www.iocoder.cn/RxJava/scheduler/">4. 操作符与调度器</a></li><li><a href="http://www.iocoder.cn/RxJava/scheduler/">5. 使用示例</a></li><li><a href="http://www.iocoder.cn/RxJava/scheduler/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. Scheduler</h1><p><code>rx.Scheduler</code> ，<strong>抽象类</strong>，一个可以调度工作单元( <code>rx.Scheduler.Worker</code> )<strong>们</strong>的对象。</p><blockquote><p>FROM <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/Scheduler.html" rel="external nofollow noopener noreferrer" target="_blank">《ReactiveX文档中文翻译 —— Scheduler》</a><br>如果你想给 Observable 操作符链添加<strong>多线程</strong>功能，你可以指定操作符( 或者特定的Observable )在特定的调度器( Scheduler )上执行。</p></blockquote><blockquote><p>某些 ReactiveX 的 Observable 操作符有一些变体，它们可以接受一个 Scheduler 参数。这个参数指定操作符将它们的部分或全部任务放在一个特定的调度器上执行。</p></blockquote><blockquote><p><strong>使用 ObserveOn 和 SubscribeOn 操作符</strong>，你可以让 Observable 在一个特定的调度器上执行。</p><ul><li>ObserveOn 指示一个 Observable 在一个特定的调度器上调用观察者的 onNext , onError 和 onCompleted 方法。</li><li>SubscribeOn 更进一步，它指示 Observable 将全部的处理过程( 包括发射数据和通知 )放在特定的调度器上执行。</li></ul></blockquote><ul><li><a href="https://github.com/ReactiveX/RxJava/blob/5b2394c9ee91f298661fff5e043744c84b425808/src/main/java/rx/Observable.java#L10404" rel="external nofollow noopener noreferrer" target="_blank"><code>Observable#subscribeOn(Scheduler)</code></a> ，在 <a href="http://www.iocoder.cn/RxJava/observable-subscribe-on-scheduler/">《RxJava 源码解析 —— Observable#subscribeOn(Scheduler)》</a> 详细解析。</li></ul><p>为什么是<strong>抽象类</strong>，而不是<strong>接口</strong>呢？官方说明如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Why is this an abstract class instead of an interface?</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *  : Java doesn't support extension methods and there are many overload methods needing default</span></div><div class="line"><span class="comment"> *    implementations.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *  : Virtual extension methods aren't available until Java8 which RxJava will not set as a minimum target for</span></div><div class="line"><span class="comment"> *    a long time.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *  : If only an interface were used Scheduler implementations would then need to extend from an</span></div><div class="line"><span class="comment"> *    AbstractScheduler pair that gives all of the functionality unless they intend on copy/pasting the</span></div><div class="line"><span class="comment"> *    functionality.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *  : Without virtual extension methods even additive changes are breaking and thus severely impede library</span></div><div class="line"><span class="comment"> *    maintenance.</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure></p><ul><li>【第一、二点】Java 在 8.0 版本之前，接口不支持默认实现方法，而 Scheduler 需要多个方法提供默认实现。RxJava 考虑到兼容性，将长期使用低版本的 Java 。</li><li>【第三、四点】如果将 Scheduler 定义为接口，那么需要添加一个 AbstractScheduler 抽象类，实现接口的默认方法实现。</li></ul><p>Scheduler 提供方法如下 ：</p><ul><li><a href="https://github.com/ReactiveX/RxJava/blob/5b2394c9ee91f298661fff5e043744c84b425808/src/main/java/rx/Scheduler.java#L54" rel="external nofollow noopener noreferrer" target="_blank"><code>#createWorker()</code></a> <strong>抽象</strong>方法 ：创建 Worker 。</li><li><a href="https://github.com/ReactiveX/RxJava/blob/5b2394c9ee91f298661fff5e043744c84b425808/src/main/java/rx/Scheduler.java#L129" rel="external nofollow noopener noreferrer" target="_blank"><code>#now()</code></a> <strong>默认</strong>方法 ：返回当前时间。</li><li><s><a href="https://github.com/ReactiveX/RxJava/blob/5b2394c9ee91f298661fff5e043744c84b425808/src/main/java/rx/Scheduler.java#L208" rel="external nofollow noopener noreferrer" target="_blank"><code>#when(...)</code></a> <strong>默认</strong>方法 ：跳过，Hystrix 暂未使用。</s></li></ul><h1>2. Worker</h1><p><code>rx.Scheduler.Worker</code> ，工作单元对象<strong>抽象类</strong>，执行 Scheduler 调度的操作( <code>rx.functions.Action0</code> )。</p><p>Worker 提供方法如下 ：</p><ul><li><a href="https://github.com/ReactiveX/RxJava/blob/5b2394c9ee91f298661fff5e043744c84b425808/src/main/java/rx/Scheduler.java#L70" rel="external nofollow noopener noreferrer" target="_blank"><code>#schedule(Action0)</code></a> <strong>抽象</strong>方法 ：<strong>立即</strong>调度操作。</li><li><a href="https://github.com/ReactiveX/RxJava/blob/5b2394c9ee91f298661fff5e043744c84b425808/src/main/java/rx/Scheduler.java#L87" rel="external nofollow noopener noreferrer" target="_blank"><code>#schedulePeriodically(Action0, long, long, TimeUnit)</code></a> <strong>抽象</strong>方法：<strong>延迟</strong>调度操作。</li><li><s><a href="https://github.com/ReactiveX/RxJava/blob/5b2394c9ee91f298661fff5e043744c84b425808/src/main/java/rx/Scheduler.java#L109" rel="external nofollow noopener noreferrer" target="_blank"><code>#schedulePeriodically(Action0, long, long, TimeUnit)</code></a> <strong>默认</strong>方法 ：<strong>周期性</strong>操作。跳过，Hystrix 暂未使用。</s></li><li><a href="https://github.com/ReactiveX/RxJava/blob/5b2394c9ee91f298661fff5e043744c84b425808/src/main/java/rx/Scheduler.java#L119" rel="external nofollow noopener noreferrer" target="_blank"><code>#now()</code></a> <strong>默认</strong>方法 ：返回当前时间。</li></ul><p>Worker 实现 <code>rx.Subscription</code> <strong>接口</strong>，但是并未实现对应的方法，需要子类实现，用于 ：</p><ul><li><code>#unsubscribe()</code> ：<strong>原意</strong>取消订阅，<strong>实意</strong>取消操作。</li><li><code>#isUnsubscribed()</code> ：<strong>原意</strong>订阅是否取消，<strong>实意</strong>操作是否取消。</li></ul><h1>3. 默认调度器实现</h1><p>在 <code>rx.internal.schedulers</code> 包下，提供了多种默认调度器的实现。</p><p><img src="http://www.iocoder.cn/images/RxJava/2019_01_15/01.png" alt=""></p><p><a href="https://github.com/ReactiveX/RxJava/blob/5b2394c9ee91f298661fff5e043744c84b425808/src/main/java/rx/schedulers/Schedulers.java" rel="external nofollow noopener noreferrer" target="_blank"><code>rx.schedulers.Schedulers</code></a> ，默认调度器单例工厂，创建上图调度器工厂并进行管理。</p><blockquote><p>参考 <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/Scheduler.html#%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E7%A7%8D%E7%B1%BB" rel="external nofollow noopener noreferrer" target="_blank">《ReactiveX文档中文翻译 —— Scheduler》「调度器的种类」</a></p></blockquote><table><thead><tr><th>单例</th><th>类</th><th>说明</th></tr></thead><tbody><tr><td><code>Schedulers#io()</code></td><td>CachedThreadScheduler</td><td>用于 IO 密集型任务，如异步阻塞 IO 操作，这个调度器的线程池会根据需要增长</td></tr><tr><td><code>Schedulers#computation()</code></td><td>EventLoopsScheduler</td><td>用于普通的计算任务，默认线程数等于处理器的数量</td></tr><tr><td><code>Schedulers#from(Executor)</code></td><td>ExecutorScheduler</td><td>使用指定的 Executor 作为调度器</td></tr><tr><td><code>Schedulers#immediate()</code></td><td>ImmediateScheduler</td><td>在当前线程立即开始执行任务</td></tr><tr><td><code>Schedulers#newThread()</code></td><td>NewThreadScheduler</td><td>为每个任务创建一个新线程</td></tr><tr><td><code>Schedulers#trampoline()</code></td><td>TrampolineScheduler</td><td>当其它排队的任务完成后，在当前线程排队开始执行</td></tr></tbody></table><p>在 Hystrix 里，继承 Scheduler <strong>抽象类</strong>，实现了<strong>自定义</strong>的 Scheduler 。</p><p>因此，跳过默认调度器的源码解析。</p><h1>4. 操作符与调度器</h1><p>点击 <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/Scheduler.html#%E9%BB%98%E8%AE%A4%E8%B0%83%E5%BA%A6%E5%99%A8" rel="external nofollow noopener noreferrer" target="_blank">《ReactiveX文档中文翻译 —— Scheduler》「默认调度器」</a> 查看。</p><h1>5. 使用示例</h1><p>点击 <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/Scheduler.html#%E4%BD%BF%E7%94%A8%E8%B0%83%E5%BA%A6%E5%99%A8" rel="external nofollow noopener noreferrer" target="_blank">《ReactiveX文档中文翻译 —— Scheduler》「使用调度器」</a> 查看。</p><p>可能你会觉得示例有丢丢“奇怪”，在 <a href="http://www.iocoder.cn/RxJava/observable-subscribe-on-scheduler/">《RxJava 源码解析 —— Observable#subscribeOn(Scheduler)》</a> 你将获得答案。</p><h1>666. 彩蛋</h1><p>本文偏介绍性，大量内容引用 <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/Scheduler.html" rel="external nofollow noopener noreferrer" target="_blank">《ReactiveX文档中文翻译 —— Scheduler》</a> 。</p><p>后续根据需要，可能解析默认调度器的源码实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/RxJava/scheduler/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 RxJava 1.2.X 版本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本系列写作目的，为了辅助 H
      
    
    </summary>
    
      <category term="RxJava" scheme="http://www.iocoder.cn/categories/RxJava/"/>
    
    
  </entry>
  
  <entry>
    <title>RxJava 源码解析 —— BlockingObservable</title>
    <link href="http://www.iocoder.cn/RxJava/blocking-observable/"/>
    <id>http://www.iocoder.cn/RxJava/blocking-observable/</id>
    <published>2019-01-07T16:00:00.000Z</published>
    <updated>2017-11-01T18:48:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/RxJava/blocking-observable/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 RxJava 1.2.X 版本</strong></p><p>本系列写作目的，为了辅助 Hystrix 的理解，因此会较为零散与琐碎，望见谅见谅。</p><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><blockquote><p><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Blocking-Observable-Operators.html" rel="external nofollow noopener noreferrer" target="_blank">《ReactiveX/RxJava文档中文版 —— 阻塞操作》</a><br>BlockingObservable 的方法不是将一个 Observable 变换为另一个，也不是过滤Observables，它们会打断 Observable 的调用链，会阻塞等待直到 Observable 发射了想要的数据，然后返回这个数据（而不是一个 Observable ）。</p></blockquote><h1>1. toBlocking</h1><p>调用 <code>Observable#toBlocking()</code> 或 <code>BlockingObservable#from(Observable)</code> 方法，将 Observable 转换成 BlockingObservable 。代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// BlockingObservable.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingObservable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Observable&lt;? extends T&gt; o;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BlockingObservable</span><span class="params">(Observable&lt;? extends T&gt; o)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.o = o;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">BlockingObservable&lt;T&gt; <span class="title">from</span><span class="params">(<span class="keyword">final</span> Observable&lt;? extends T&gt; o)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BlockingObservable&lt;T&gt;(o);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Observable.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> BlockingObservable&lt;T&gt; <span class="title">toBlocking</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> BlockingObservable.from(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>从代码上我们可以看到，BlockingObservable 并未将 Observable 转换成新的，而是简单的包了一层。</li></ul><h1>2. toFuture</h1><blockquote><p><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/To.html#tofuture" rel="external nofollow noopener noreferrer" target="_blank">《ReactiveX/RxJava文档中文版 —— TO》</a><br><img src="http://www.iocoder.cn/images/Hystrix/2018_10_08/04.png" alt=""><code>#toFuture()</code> 操作符也是只能用于 BlockingObservable 。这个操作符将Observable 转换为一个返回<strong>单个数据项</strong>的 Future 。</p><ul><li>如果原始 Observable 发射多个数据项，Future会收到一个IllegalArgumentException；</li><li>如果原始 Observable 没有发射任何数据，Future会收到一个NoSuchElementException。</li></ul><p>如果你想将发射多个数据项的 Observable 转换为 Future ，可以这样用：<code>myObservable.toList().toBlocking().toFuture()</code> 。</p></blockquote><p>点击<a href="https://github.com/ReactiveX/RxJava/blob/396b6104e419b80002c45faf76ac38f00d2ff64a/src/main/java/rx/internal/operators/BlockingOperatorToFuture.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 <code>#toFuture()</code> 的代码实现：</p><ul><li>通过向传入 Observable 订阅 Subscriber ，打断 Observable 的调用链，会阻塞等待直到 Observable 发射了想要的数据。<ul><li><code>#onNext()</code> 方法，设置执行的返回值( <code>value</code> )。</li><li><code>#onCompleted()</code> 方法，CountDownLatch (<code>finished</code>) 减一。</li><li><code>#onError()</code> 方法，设置执行时发生的异常( <code>error</code> )，并 CountDownLatch (<code>finished</code>) 减一。</li></ul></li><li>返回的 Future ，通过 CountDownLatch ( <code>error</code> ) 判断是否执行完成；通过 <code>value</code> ， <code>error</code> 获得执行的结果。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/RxJava/blocking-observable/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 RxJava 1.2.X 版本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本系列写
      
    
    </summary>
    
      <category term="RxJava" scheme="http://www.iocoder.cn/categories/RxJava/"/>
    
    
  </entry>
  
  <entry>
    <title>RxJava 源码解析 —— Observable#defer(...)</title>
    <link href="http://www.iocoder.cn/RxJava/observable-defer/"/>
    <id>http://www.iocoder.cn/RxJava/observable-defer/</id>
    <published>2018-12-31T16:00:00.000Z</published>
    <updated>2017-11-01T18:47:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/RxJava/observable-defer/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 RxJava 1.2.X 版本</strong></p><p>本系列写作目的，为了辅助 Hystrix 的理解，因此会较为零散与琐碎，望见谅见谅。</p><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><p>在一些业务场景下，我们需要 Observable 是<strong>动态</strong>的，例如说，<a href="http://www.iocoder.cn/Hystrix/command-execute-result-cache/?self">《Hystrix 源码解析 —— 执行结果缓存》</a> 分享的缓存 Observable ，无法在创建 Observable 阶段就知道是否有缓存，通过 <code>Observable#defer(...)</code> 方法，声明<strong>动态</strong>的 Observable 。示例代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">   Observable.defer(<span class="keyword">new</span> Func0&lt;Observable&lt;String&gt;&gt;() &#123; <span class="comment">// #defer(...)</span></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">           String name = Math.random() &gt; <span class="number">0.5</span> ? <span class="string">"小明"</span> : <span class="string">"小贾"</span>; <span class="comment">// 随机名字</span></div><div class="line">           <span class="keyword">return</span> Observable.just(name);</div><div class="line">       &#125;</div><div class="line">   &#125;).subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123; <span class="comment">// #subscribe(...)</span></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">           System.out.println(s);</div><div class="line">       &#125;</div><div class="line">   &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><hr><p><code>Observable#defer(...)</code> 方法，代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Observable.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">defer</span><span class="params">(Func0&lt;Observable&lt;T&gt;&gt; observableFactory)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> create(<span class="keyword">new</span> OnSubscribeDefer&lt;T&gt;(observableFactory));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(OnSubscribe&lt;T&gt; f)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Observable&lt;T&gt;(RxJavaHooks.onCreate(f));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>使用传入 <code>observableFactory</code> 参数，生成<strong>动态</strong>的 Observable 。</li></ul><hr><p>OnSubscribeDefer 类，代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OnSubscribeDefer</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">OnSubscribe</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">final</span> Func0&lt;? extends Observable&lt;? extends T&gt;&gt; observableFactory;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OnSubscribeDefer</span><span class="params">(Func0&lt;? extends Observable&lt;? extends T&gt;&gt; observableFactory)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.observableFactory = observableFactory;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; s)</span> </span>&#123;</div><div class="line">        Observable&lt;? extends T&gt; o;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            o = observableFactory.call();</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            Exceptions.throwOrReport(t, s);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        o.unsafeSubscribe(Subscribers.wrap(s));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>在 <code>Observable#subscribe(...)</code> 方法调用时，调用 <code>OnSubscribeDefer#call(...)</code> 方法 ：<ul><li>调用 <code>Func0#call()</code> 方法，创建<strong>动态</strong>的 Observable 。</li><li>调用 <code>Observable#unsafeSubscribe(...)</code> 方法，<strong>继续订阅逻辑</strong>。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/RxJava/observable-defer/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 RxJava 1.2.X 版本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本系列写作目的
      
    
    </summary>
    
      <category term="RxJava" scheme="http://www.iocoder.cn/categories/RxJava/"/>
    
    
  </entry>
  
  <entry>
    <title>Hystrix 源码解析 —— 命令合并执行</title>
    <link href="http://www.iocoder.cn/Hystrix/command-collapser-execute/"/>
    <id>http://www.iocoder.cn/Hystrix/command-collapser-execute/</id>
    <published>2018-11-03T16:00:00.000Z</published>
    <updated>2017-11-08T12:23:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/Hystrix/command-collapser-execute/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Hystrix 1.5.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Hystrix/command-collapser-execute/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-collapser-execute/">2. HystrixCollapser</a><ul><li><a href="http://www.iocoder.cn/Hystrix/command-collapser-execute/">2.1 构造方法</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-collapser-execute/">2.2 执行命令方式</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-collapser-execute/">2.3 核心方法</a></li></ul></li><li><a href="http://www.iocoder.cn/Hystrix/command-collapser-execute/">3. RequestCollapserFactory</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-collapser-execute/">4. RequestCollapser</a><ul><li><a href="http://www.iocoder.cn/Hystrix/command-collapser-execute/">4.1 构造方法</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-collapser-execute/">4.2 RequestBatch</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-collapser-execute/">4.3 #submitRequest(arg)</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-collapser-execute/">4.4 #createNewBatchAndExecutePreviousIfNeeded(previousBatch)</a></li></ul></li><li><a href="http://www.iocoder.cn/Hystrix/command-collapser-execute/">5. CollapserTimer</a><ul><li><a href="http://www.iocoder.cn/Hystrix/command-collapser-execute/">5.1 RealCollapserTimer</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-collapser-execute/">5.2 CollapsedTask</a></li></ul></li><li><a href="http://www.iocoder.cn/Hystrix/command-collapser-execute/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p>本文主要分享 <strong>Hystrix 命令合并执行</strong>。</p><p>在 <a href="http://youdang.github.io/2016/02/05/translate-hystrix-wiki-how-it-works/#%E8%AF%B7%E6%B1%82%E5%90%88%E5%B9%B6" rel="external nofollow noopener noreferrer" target="_blank">《【翻译】Hystrix文档-实现原理》「请求合并」</a> 中，对 Hystrix 命令合并执行的<strong>概念</strong>、<strong>原理</strong>、<strong>使用场景</strong>、<strong>优缺点</strong>已经做了非常详细透彻的分享，所以胖友可以先认真阅读学习下。</p><p>命令合并执行整体流程如下图 ：</p><blockquote><p>FROM <a href="http://youdang.github.io/2016/02/05/translate-hystrix-wiki-how-it-works/#%E8%AF%B7%E6%B1%82%E5%90%88%E5%B9%B6" rel="external nofollow noopener noreferrer" target="_blank">《【翻译】Hystrix文档-实现原理》「请求合并」</a><br><img src="http://www.iocoder.cn/images/Hystrix/2018_11_04/01.jpeg" alt=""></p></blockquote><ul><li>第一步，提交<strong>单个</strong>命令请求到请求队列( RequestQueue )</li><li>第二部，定时任务( TimerTask ) <strong>固定周期</strong>从请求队列获取<strong>多个</strong>命令执行，合并执行。</li></ul><p>在官方提供的示例中，我们通过 <a href="https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-examples/src/main/java/com/netflix/hystrix/examples/basic/CommandCollapserGetValueForKey.java" rel="external nofollow noopener noreferrer" target="_blank">CommandCollapserGetValueForKey</a> 熟悉命令合并执行的使用。</p><hr><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1>2. HystrixCollapser</h1><p><code>com.netflix.hystrix.HystrixCollapser</code> ，<strong>命令</strong>合并器<strong>抽象父类</strong>。</p><blockquote><p>NOTE ：<code>com.netflix.hystrix.HystrixObservableCollapser</code> ，<strong>另一种</strong>命令合并器<strong>抽象父类</strong>，本文暂不解析。</p></blockquote><h2>2.1 构造方法</h2><p>HystrixCollapser <strong>构造方法</strong>，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixCollapser</span>&lt;<span class="title">BatchReturnType</span>, <span class="title">ResponseType</span>, <span class="title">RequestArgumentType</span>&gt;</span></div><div class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">HystrixExecutable</span>&lt;<span class="title">ResponseType</span>&gt;, <span class="title">HystrixObservable</span>&lt;<span class="title">ResponseType</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RequestCollapserFactory&lt;BatchReturnType, ResponseType, RequestArgumentType&gt; collapserFactory;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HystrixRequestCache requestCache;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HystrixCollapserBridge&lt;BatchReturnType, ResponseType, RequestArgumentType&gt; collapserInstanceWrapper;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HystrixCollapserMetrics metrics;</div><div class="line">    </div><div class="line">    <span class="comment">/* package for tests */</span> HystrixCollapser(HystrixCollapserKey collapserKey, Scope scope, CollapserTimer timer, HystrixCollapserProperties.Setter propertiesBuilder, HystrixCollapserMetrics metrics) &#123;</div><div class="line">        <span class="keyword">if</span> (collapserKey == <span class="keyword">null</span> || collapserKey.name().trim().equals(<span class="string">""</span>)) &#123;</div><div class="line">            String defaultKeyName = getDefaultNameFromClass(getClass());</div><div class="line">            collapserKey = HystrixCollapserKey.Factory.asKey(defaultKeyName);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        HystrixCollapserProperties properties = HystrixPropertiesFactory.getCollapserProperties(collapserKey, propertiesBuilder);</div><div class="line">        <span class="keyword">this</span>.collapserFactory = <span class="keyword">new</span> RequestCollapserFactory&lt;BatchReturnType, ResponseType, RequestArgumentType&gt;(collapserKey, scope, timer, properties);</div><div class="line">        <span class="keyword">this</span>.requestCache = HystrixRequestCache.getInstance(collapserKey, HystrixPlugins.getInstance().getConcurrencyStrategy());</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (metrics == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">this</span>.metrics = HystrixCollapserMetrics.getInstance(collapserKey, properties);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">this</span>.metrics = metrics;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> HystrixCollapser&lt;BatchReturnType, ResponseType, RequestArgumentType&gt; self = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">         <span class="comment">/* strategy: HystrixMetricsPublisherCollapser */</span></div><div class="line">        HystrixMetricsPublisherFactory.createOrRetrievePublisherForCollapser(collapserKey, <span class="keyword">this</span>.metrics, properties);</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * Used to pass public method invocation to the underlying implementation in a separate package while leaving the methods 'protected' in this class.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        collapserInstanceWrapper = <span class="keyword">new</span> HystrixCollapserBridge&lt;BatchReturnType, ResponseType, RequestArgumentType&gt;() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="keyword">public</span> Collection&lt;Collection&lt;CollapsedRequest&lt;ResponseType, RequestArgumentType&gt;&gt;&gt; shardRequests(Collection&lt;CollapsedRequest&lt;ResponseType, RequestArgumentType&gt;&gt; requests) &#123;</div><div class="line">                Collection&lt;Collection&lt;CollapsedRequest&lt;ResponseType, RequestArgumentType&gt;&gt;&gt; shards = self.shardRequests(requests);</div><div class="line">                self.metrics.markShards(shards.size());</div><div class="line">                <span class="keyword">return</span> shards;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;BatchReturnType&gt; <span class="title">createObservableCommand</span><span class="params">(Collection&lt;CollapsedRequest&lt;ResponseType, RequestArgumentType&gt;&gt; requests)</span> </span>&#123;</div><div class="line">                <span class="keyword">final</span> HystrixCommand&lt;BatchReturnType&gt; command = self.createCommand(requests);</div><div class="line"></div><div class="line">                command.markAsCollapsedCommand(<span class="keyword">this</span>.getCollapserKey(), requests.size());</div><div class="line">                self.metrics.markBatch(requests.size());</div><div class="line"></div><div class="line">                <span class="keyword">return</span> command.toObservable();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;Void&gt; <span class="title">mapResponseToRequests</span><span class="params">(Observable&lt;BatchReturnType&gt; batchResponse, <span class="keyword">final</span> Collection&lt;CollapsedRequest&lt;ResponseType, RequestArgumentType&gt;&gt; requests)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> batchResponse.single().doOnNext(<span class="keyword">new</span> Action1&lt;BatchReturnType&gt;() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(BatchReturnType batchReturnType)</span> </span>&#123;</div><div class="line">                        <span class="comment">// this is a blocking call in HystrixCollapser</span></div><div class="line">                        self.mapResponseToRequests(batchReturnType, requests);</div><div class="line">                    &#125;</div><div class="line">                &#125;).ignoreElements().cast(Void.class);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> HystrixCollapserKey <span class="title">getCollapserKey</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> self.getCollapserKey();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>BatchReturnType <strong>泛型</strong>，<strong>多个</strong>命令合并执行返回结果类型。</li><li>ResponseType <strong>泛型</strong>，<strong>单个</strong>命令执行返回结果类型。</li><li>RequestArgumentType <strong>泛型</strong>，<strong>单个</strong>命令参数类型。</li><li><code>collapserFactory</code> 属性，RequestCollapser <strong>工厂</strong>，在 <a href="#">「3. RequestCollapserFactory」</a> 详细解析。</li><li><code>requestCache</code> 属性，TODO 【2012】【请求上下文】</li><li><code>collapserInstanceWrapper</code> 属性，<strong>命令</strong>合并器包装器。<ul><li><code>com.netflix.hystrix.collapser.HystrixCollapserBridge</code> <strong>接口</strong>，点击 <a href="https://github.com/YunaiV/Hystrix/blob/dc176978c2beb2465ba4edb37d0024e388f15d5d/hystrix-core/src/main/java/com/netflix/hystrix/collapser/HystrixCollapserBridge.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看代码。</li><li>HystrixCollapserBridge ，为 RequestBatch <strong>透明</strong>调用 HystrixCollapser 或 HystrixObservableCollapser 的方法不同的实现。参见 <a href="http://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/bridge.html" rel="external nofollow noopener noreferrer" target="_blank">《桥接模式》</a> 。</li></ul></li><li><code>metrics</code> 属性，TODO 【2002】【metrics】</li></ul><h2>2.2 执行命令方式</h2><p>在 <a href="http://www.iocoder.cn/Hystrix/command-execute-mode/?self">《Hystrix 源码解析 —— 执行命令方式》</a> 中，我们已经看了 HystrixCommand 提供的<strong>四种</strong>执行命令方式。</p><p>HystrixCollapser 类似于 HystrixCommand ，也提供<strong>四种</strong>相同的执行命令方式，其中如下三种方式代码基本<strong>类似</strong>，我们就给下<strong>传送门</strong>，就不重复啰嗦了 ：</p><ul><li><code>#observe()</code> 方法 ：<a href="https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java#L336" rel="external nofollow noopener noreferrer" target="_blank">传送门</a> 。</li><li><code>#queue()</code> 方法 ：<a href="https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java#L456" rel="external nofollow noopener noreferrer" target="_blank">传送门</a> 。</li><li><code>#execute()</code> 方法 ：<a href="https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java#L426" rel="external nofollow noopener noreferrer" target="_blank">传送门</a> 。</li></ul><p>下面一起来看看 <code>#toObservable()</code> 方法的实现，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> Observable&lt;ResponseType&gt; <span class="title">toObservable</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// when we callback with the data we want to do the work</span></div><div class="line"> <span class="number">3</span>:     <span class="comment">// on a separate thread than the one giving us the callback</span></div><div class="line"> <span class="number">4</span>:     <span class="keyword">return</span> toObservable(Schedulers.computation());</div><div class="line"> <span class="number">5</span>: &#125;</div><div class="line"> <span class="number">6</span>: </div><div class="line"> <span class="number">7</span>: <span class="function"><span class="keyword">public</span> Observable&lt;ResponseType&gt; <span class="title">toObservable</span><span class="params">(Scheduler observeOn)</span> </span>&#123;</div><div class="line"> <span class="number">8</span>:     <span class="keyword">return</span> Observable.defer(<span class="keyword">new</span> Func0&lt;Observable&lt;ResponseType&gt;&gt;() &#123;</div><div class="line"> <span class="number">9</span>:         <span class="meta">@Override</span></div><div class="line"><span class="number">10</span>:         <span class="function"><span class="keyword">public</span> Observable&lt;ResponseType&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">11</span>:             <span class="comment">// // 缓存开关、缓存KEY</span></div><div class="line"><span class="number">12</span>:             <span class="keyword">final</span> <span class="keyword">boolean</span> isRequestCacheEnabled = getProperties().requestCacheEnabled().get();</div><div class="line"><span class="number">13</span>:             <span class="keyword">final</span> String cacheKey = getCacheKey();</div><div class="line"><span class="number">14</span>: </div><div class="line"><span class="number">15</span>:             <span class="comment">// 优先从缓存中获取</span></div><div class="line"><span class="number">16</span>:             <span class="comment">/* try from cache first */</span></div><div class="line"><span class="number">17</span>:             <span class="keyword">if</span> (isRequestCacheEnabled) &#123;</div><div class="line"><span class="number">18</span>:                 HystrixCachedObservable&lt;ResponseType&gt; fromCache = requestCache.get(cacheKey);</div><div class="line"><span class="number">19</span>:                 <span class="keyword">if</span> (fromCache != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">20</span>:                     metrics.markResponseFromCache();</div><div class="line"><span class="number">21</span>:                     <span class="keyword">return</span> fromCache.toObservable();</div><div class="line"><span class="number">22</span>:                 &#125;</div><div class="line"><span class="number">23</span>:             &#125;</div><div class="line"><span class="number">24</span>: </div><div class="line"><span class="number">25</span>:             <span class="comment">// 获得 RequestCollapser</span></div><div class="line"><span class="number">26</span>:             RequestCollapser&lt;BatchReturnType, ResponseType, RequestArgumentType&gt; requestCollapser = collapserFactory.getRequestCollapser(collapserInstanceWrapper);</div><div class="line"><span class="number">27</span>: </div><div class="line"><span class="number">28</span>:             <span class="comment">// 提交 命令请求</span></div><div class="line"><span class="number">29</span>:             Observable&lt;ResponseType&gt; response = requestCollapser.submitRequest(getRequestArgument());</div><div class="line"><span class="number">30</span>: </div><div class="line"><span class="number">31</span>:             <span class="comment">// 获得 缓存Observable</span></div><div class="line"><span class="number">32</span>:             <span class="keyword">if</span> (isRequestCacheEnabled &amp;&amp; cacheKey != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">33</span>:                 HystrixCachedObservable&lt;ResponseType&gt; toCache = HystrixCachedObservable.from(response);</div><div class="line"><span class="number">34</span>:                 HystrixCachedObservable&lt;ResponseType&gt; fromCache = requestCache.putIfAbsent(cacheKey, toCache);</div><div class="line"><span class="number">35</span>:                 <span class="keyword">if</span> (fromCache == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">36</span>:                     <span class="keyword">return</span> toCache.toObservable();</div><div class="line"><span class="number">37</span>:                 &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">38</span>:                     toCache.unsubscribe(); <span class="comment">// 取消订阅</span></div><div class="line"><span class="number">39</span>:                     <span class="keyword">return</span> fromCache.toObservable();</div><div class="line"><span class="number">40</span>:                 &#125;</div><div class="line"><span class="number">41</span>:             &#125;</div><div class="line"><span class="number">42</span>: </div><div class="line"><span class="number">43</span>:             <span class="comment">// 获得 非缓存Observable</span></div><div class="line"><span class="number">44</span>:             <span class="keyword">return</span> response;</div><div class="line"><span class="number">45</span>:         &#125;</div><div class="line"><span class="number">46</span>:     &#125;);</div><div class="line"><span class="number">47</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><code>observeOn</code> 方法参数，实际方法暂未用到，跳过无视。</li><li>第 11 至 13 行 ：缓存存开关、KEY 。</li><li>【<em>反向</em>】第 32 至 41 行 ：获得【缓存 Observable】。这块代码和 <code>AbstractCommand#toObservavle(...)</code> 类似，在 <a href="http://www.iocoder.cn/Hystrix/command-execute-result-cache/?self">《Hystrix 源码解析 —— 执行结果缓存》「4. AbstractCommand#toObservavle(...)」</a> 有详细解析。</li><li>【<em>反向</em>】第 44 行 ：获得【非缓存 Observable】。</li><li>注意 ：返回的 Observable ，很可能命令实际并未执行，或者说并未执行完成，此时在 <code>#queue()</code> / <code>#execute()</code> 方法，通过 BlockingObservable <strong>阻塞</strong>等待执行完成。BlockingObservable 在 <a href="http://www.iocoder.cn/RxJava/blocking-observable/?self">《RxJava 源码解析 —— BlockingObservable》</a> 有详细解析。</li><li>第 26 行 ：调用 <code>RequestCollapserFactory#getRequestCollapser()</code> ，获得 RequestCollapser 。在 <a href="#">「3. RequestCollapserFactory」</a> 详细解析。</li><li>第 29 行 ：提交<strong>单个</strong>命令请求到请求队列( RequestQueue )，即<strong>命令合并执行整体流程第一步</strong>。在 <a href="#">「4. RequestCollapser」</a> 详细解析。</li></ul><h2>2.3 核心方法</h2><ul><li><p><code>#getRequestArgument(...)</code> <strong>抽象</strong>方法，获得<strong>单个</strong>命令参数。代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> RequestArgumentType <span class="title">getRequestArgument</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure></p></li></ul><hr><ul><li><p><code>#createCommand(...)</code> <strong>抽象</strong>方法，将<strong>多个</strong>命令请求<strong>合并</strong>，创建<strong>一个</strong> HystrixCommand 。代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> HystrixCommand&lt;BatchReturnType&gt; <span class="title">createCommand</span><span class="params">(Collection&lt;CollapsedRequest&lt;ResponseType, RequestArgumentType&gt;&gt; requests)</span></span>;</div></pre></td></tr></table></figure></p></li></ul><hr><ul><li><p><code>#mapResponseToRequests(...)</code> <strong>抽象</strong>方法，将<strong>一个</strong> HystrixCommand 的执行结果，<strong>映射</strong>回对应的命令请求们。</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">mapResponseToRequests</span><span class="params">(BatchReturnType batchResponse, Collection&lt;CollapsedRequest&lt;ResponseType, RequestArgumentType&gt;&gt; requests)</span></span>;</div></pre></td></tr></table></figure></p></li></ul><hr><ul><li><p><code>#shardRequests(...)</code> 方法，将<strong>多个</strong>命令请求<strong>分片</strong>成 <strong>N</strong> 个【<strong>多个</strong>命令请求】。默认实现下，不进行分片。代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">protected</span> Collection&lt;Collection&lt;CollapsedRequest&lt;ResponseType, RequestArgumentType&gt;&gt;&gt; shardRequests(Collection&lt;CollapsedRequest&lt;ResponseType, RequestArgumentType&gt;&gt; requests) &#123;</div><div class="line">    <span class="keyword">return</span> Collections.singletonList(requests);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li></ul><hr><ul><li><p>在<strong>未重写</strong> <code>#shardRequests(...)</code> 的情况下，整体方法流程如下 ：</p><p><img src="http://www.iocoder.cn/images/Hystrix/2018_11_04/02.png" alt=""></p></li><li><p>在<strong>重写</strong> <code>#shardRequests(...)</code> 的情况下，整体方法流程如下 ：</p><p><img src="http://www.iocoder.cn/images/Hystrix/2018_11_04/03.png" alt=""></p><ul><li>本图中命令请求分片仅仅是例子，实际根据重写的逻辑不同而不同。</li></ul></li></ul><h1>3. RequestCollapserFactory</h1><p><code>com.netflix.hystrix.collapser.RequestCollapserFactory</code> ，RequestCollapser <strong>工厂</strong>。</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestCollapserFactory</span>&lt;<span class="title">BatchReturnType</span>, <span class="title">ResponseType</span>, <span class="title">RequestArgumentType</span>&gt; </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CollapserTimer timer;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HystrixCollapserKey collapserKey;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HystrixCollapserProperties properties;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HystrixConcurrencyStrategy concurrencyStrategy;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Scope scope;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RequestCollapserFactory</span><span class="params">(HystrixCollapserKey collapserKey, Scope scope, CollapserTimer timer, HystrixCollapserProperties properties)</span> </span>&#123;</div><div class="line">         <span class="comment">/* strategy: ConcurrencyStrategy */</span></div><div class="line">        <span class="keyword">this</span>.concurrencyStrategy = HystrixPlugins.getInstance().getConcurrencyStrategy();</div><div class="line">        <span class="keyword">this</span>.timer = timer;</div><div class="line">        <span class="keyword">this</span>.scope = scope;</div><div class="line">        <span class="keyword">this</span>.collapserKey = collapserKey;</div><div class="line">        <span class="keyword">this</span>.properties = properties;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><ul><li><code>timer</code> 属性，命令合并器的定时器，在 <a href="#">「5. CollapserTimer」</a> 详细解析。</li><li><code>collapserKey</code> 属性，命令合并器标识，实现类似 HystrixThreadPoolKey 。<ul><li>HystrixCollapserKey ，点击 <a href="https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapserKey.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看代码。</li><li>HystrixThreadPoolKey ，在 <a href="http://www.iocoder.cn/Hystrix/command-execute-second-isolation-strategy/?self">《Hystrix 源码解析 —— 命令执行（二）之执行隔离策略》「3. HystrixThreadPoolKey」</a> 有详细解析。</li></ul></li><li><code>properties</code> 属性，命令合并器属性配置。</li><li><code>concurrencyStrategy</code> 属性，并发策略，在 <a href="http://www.iocoder.cn/Hystrix/command-execute-second-isolation-strategy/?self">《Hystrix 源码解析 —— 命令执行（二）之执行隔离策略》「4. HystrixConcurrencyStrategy」</a> 有详细解析。</li><li><code>scope</code> 属性，命令请求作用域。目前有两种作用域 ：<ul><li><p><code>REQUEST</code> ：请求上下文( HystrixRequestContext )。</p><blockquote><p>Typically this means that requests within a single user-request (ie. HTTP request) are collapsed.<br>No interaction with other user requests.<br>1 queue per user request.* <code>GLOBAL</code> ：全局。</p></blockquote><blockquote><p>Requests from any thread (ie. all HTTP requests) within the JVM will be collapsed.<br>1 queue for entire app.</p></blockquote></li></ul></li></ul><hr><p>调用 <code>#getRequestCollapser()</code> 方法，获得 RequestCollapser 。代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> RequestCollapser&lt;BatchReturnType, ResponseType, RequestArgumentType&gt; <span class="title">getRequestCollapser</span><span class="params">(HystrixCollapserBridge&lt;BatchReturnType, ResponseType, RequestArgumentType&gt; commandCollapser)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (Scopes.REQUEST == Scopes.valueOf(getScope().name())) &#123;</div><div class="line">       <span class="keyword">return</span> getCollapserForUserRequest(commandCollapser);</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Scopes.GLOBAL == Scopes.valueOf(getScope().name())) &#123;</div><div class="line">       <span class="keyword">return</span> getCollapserForGlobalScope(commandCollapser);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       logger.warn(<span class="string">"Invalid Scope: &#123;&#125;  Defaulting to REQUEST scope."</span>, getScope());</div><div class="line">       <span class="keyword">return</span> getCollapserForUserRequest(commandCollapser);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>根据 <code>scope</code> 不同，调用两个不同方法，获得 RequestCollapser 。这两个方法大体逻辑相同，优先从<strong>缓存</strong>中查找满足条件的 RequestCollapser 返回；若不存在，则创建满足条件的 RequestCollapser 添加到<strong>缓存</strong>并返回。<ul><li><code>REQUEST</code> ：调用 <code>#getCollapserForUserRequest()</code> 方法，TODO 【2012】【请求上下文】。</li><li><code>GLOBAL</code> ：调用 <code>#getCollapserForGlobalScope()</code> 方法，点击 <a href="https://github.com/YunaiV/Hystrix/blob/dc176978c2beb2465ba4edb37d0024e388f15d5d/hystrix-core/src/main/java/com/netflix/hystrix/collapser/RequestCollapserFactory.java#L97" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看<strong>中文注释</strong>的代码。</li></ul></li></ul><h1>4. RequestCollapser</h1><p><code>com.netflix.hystrix.collapser.RequestCollapser</code> ，<strong>命令请求</strong>合并器。主要用于 ：</p><ul><li>提交<strong>单个</strong>命令请求到请求队列( RequestQueue )。</li><li>接收<strong>来自定时任务</strong>提交的<strong>多个</strong>命令，合并执行。</li></ul><h2>4.1 构造方法</h2><p>RequestCollapser <strong>构造方法</strong>，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestCollapser</span>&lt;<span class="title">BatchReturnType</span>, <span class="title">ResponseType</span>, <span class="title">RequestArgumentType</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HystrixCollapserBridge&lt;BatchReturnType, ResponseType, RequestArgumentType&gt; commandCollapser;</div><div class="line">    <span class="comment">// batch can be null once shutdown</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;RequestBatch&lt;BatchReturnType, ResponseType, RequestArgumentType&gt;&gt; batch = <span class="keyword">new</span> AtomicReference&lt;RequestBatch&lt;BatchReturnType, ResponseType, RequestArgumentType&gt;&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;Reference&lt;TimerListener&gt;&gt; timerListenerReference = <span class="keyword">new</span> AtomicReference&lt;Reference&lt;TimerListener&gt;&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean timerListenerRegistered = <span class="keyword">new</span> AtomicBoolean();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CollapserTimer timer;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HystrixCollapserProperties properties;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HystrixConcurrencyStrategy concurrencyStrategy;</div><div class="line">    </div><div class="line">    RequestCollapser(HystrixCollapserBridge&lt;BatchReturnType, ResponseType, RequestArgumentType&gt; commandCollapser, HystrixCollapserProperties properties, CollapserTimer timer, HystrixConcurrencyStrategy concurrencyStrategy) &#123;</div><div class="line">        <span class="keyword">this</span>.commandCollapser = commandCollapser; <span class="comment">// the command with implementation of abstract methods we need </span></div><div class="line">        <span class="keyword">this</span>.concurrencyStrategy = concurrencyStrategy;</div><div class="line">        <span class="keyword">this</span>.properties = properties;</div><div class="line">        <span class="keyword">this</span>.timer = timer;</div><div class="line">        batch.set(<span class="keyword">new</span> RequestBatch&lt;BatchReturnType, ResponseType, RequestArgumentType&gt;(properties, commandCollapser, properties.maxRequestsInBatch().get()));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><code>commandCollapser</code> 属性，<strong>命令</strong>合并器包装器。</li><li><code>batch</code> 属性，RequestBatch，<strong>即是本文一直说的请求队列</strong>。在 <a href="#">「4.2 RequestBatch」</a> 也会详细解析。</li><li><code>timerListenerReference</code> 属性，<strong>注册</strong>在命令合并器的定时器的监听器。每个  RequestCollapser <strong>独有一个</strong>监听器。该监听器( 实际上会使用该监听器创建定时任务 )<strong>固定周期</strong>从请求队列获取<strong>多个</strong>命令执行，提交 RequestCollapser 合并执行。在 <a href="#">「5. CollapserTimer」</a> 也会详细解析。</li><li><code>timerListenerRegistered</code> 属性，<code>timerListenerReference</code> 是否已经注册。</li><li><code>timer</code> 属性，命令合并器的定时器。</li><li><code>properties</code> 属性，命令合并器属性配置。</li><li><code>concurrencyStrategy</code> 属性，并发策略。</li></ul><h2>4.2 RequestBatch</h2><p><code>com.netflix.hystrix.collapser.RequestBatch</code> ，命令请求队列。提供如下功能 ：</p><ul><li>命令请求的添加</li><li>命令请求的移除</li><li>命令请求的<strong>批量执行</strong>。笔者把 RequestBatch 解释成 &quot;命令请求队列&quot;，主要方便大家理解。<ul><li>那可能有胖友有疑问，为啥该功能不在 RequestCollapser 直接实现，这样 RequestBatch 成为纯粹的队列呢？在 <a href="#">「4.4 #createNewBatchAndExecutePreviousIfNeeded(previousBatch)」</a> 详细解析。</li></ul></li></ul><p>RequestBatch <strong>构造方法</strong>，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestBatch</span>&lt;<span class="title">BatchReturnType</span>, <span class="title">ResponseType</span>, <span class="title">RequestArgumentType</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HystrixCollapserBridge&lt;BatchReturnType, ResponseType, RequestArgumentType&gt; commandCollapser;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxBatchSize;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean batchStarted = <span class="keyword">new</span> AtomicBoolean();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;RequestArgumentType, CollapsedRequest&lt;ResponseType, RequestArgumentType&gt;&gt; argumentMap =</div><div class="line">            <span class="keyword">new</span> ConcurrentHashMap&lt;RequestArgumentType, CollapsedRequest&lt;ResponseType, RequestArgumentType&gt;&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HystrixCollapserProperties properties;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> ReentrantReadWriteLock batchLock = <span class="keyword">new</span> ReentrantReadWriteLock();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RequestBatch</span><span class="params">(HystrixCollapserProperties properties, HystrixCollapserBridge&lt;BatchReturnType, ResponseType, RequestArgumentType&gt; commandCollapser, <span class="keyword">int</span> maxBatchSize)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.properties = properties;</div><div class="line">        <span class="keyword">this</span>.commandCollapser = commandCollapser;</div><div class="line">        <span class="keyword">this</span>.maxBatchSize = maxBatchSize;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><code>commandCollapser</code> 属性，<strong>命令</strong>合并器包装器。</li><li><code>maxBatchSize</code> 属性，队列最大长度。</li><li><code>batchStarted</code> 属性，执行是否开始。</li><li><code>argumentMap</code> 属性，命令请求参数映射( <strong>队列</strong> )。</li><li><code>properties</code> 属性，命令合并器属性配置。</li><li><code>batchLock</code> 属性，<code>argumentMap</code> 操作的<strong>读写锁</strong>。</li></ul><p>RequestBatch 实现队列具体的操作方法，在 <a href="#">「4.3 #submitRequest(arg)」</a>/<a href="#">「4.4 #createNewBatchAndExecutePreviousIfNeeded(previousBatch)」</a> 一起解析。</p><h2>4.3 #submitRequest(arg)</h2><p>在 <code>#toObservable()</code> 方法里，调用 <code>#submitRequest(arg)</code> 方法，提交<strong>单个</strong>命令请求到 RequestBatch 。代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> Observable&lt;ResponseType&gt; <span class="title">submitRequest</span><span class="params">(<span class="keyword">final</span> RequestArgumentType arg)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">/*</span></div><div class="line"><span class="comment"> 3:      * We only want the timer ticking if there are actually things to do so we register it the first time something is added.</span></div><div class="line"><span class="comment"> 4:      */</span></div><div class="line"> <span class="number">5</span>:     <span class="keyword">if</span> (!timerListenerRegistered.get() &amp;&amp; timerListenerRegistered.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</div><div class="line"> <span class="number">6</span>:         <span class="comment">/* schedule the collapsing task to be executed every x milliseconds (x defined inside CollapsedTask) */</span></div><div class="line"> <span class="number">7</span>:         timerListenerReference.set(timer.addListener(<span class="keyword">new</span> CollapsedTask()));</div><div class="line"> <span class="number">8</span>:     &#125;</div><div class="line"> <span class="number">9</span>: </div><div class="line"><span class="number">10</span>:     <span class="comment">// loop until succeed (compare-and-set spin-loop)</span></div><div class="line"><span class="number">11</span>:     <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line"><span class="number">12</span>:         <span class="comment">// 获得 RequestBatch</span></div><div class="line"><span class="number">13</span>:         <span class="keyword">final</span> RequestBatch&lt;BatchReturnType, ResponseType, RequestArgumentType&gt; b = batch.get();</div><div class="line"><span class="number">14</span>:         <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">15</span>:             <span class="keyword">return</span> Observable.error(<span class="keyword">new</span> IllegalStateException(<span class="string">"Submitting requests after collapser is shutdown"</span>));</div><div class="line"><span class="number">16</span>:         &#125;</div><div class="line"><span class="number">17</span>: </div><div class="line"><span class="number">18</span>:         <span class="comment">// 添加到 RequestBatch</span></div><div class="line"><span class="number">19</span>:         <span class="keyword">final</span> Observable&lt;ResponseType&gt; response;</div><div class="line"><span class="number">20</span>:         <span class="keyword">if</span> (arg != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">21</span>:             response = b.offer(arg);</div><div class="line"><span class="number">22</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">23</span>:             response = b.offer( (RequestArgumentType) NULL_SENTINEL);</div><div class="line"><span class="number">24</span>:         &#125;</div><div class="line"><span class="number">25</span>: </div><div class="line"><span class="number">26</span>:         <span class="comment">// 添加成功，返回 Observable</span></div><div class="line"><span class="number">27</span>:         <span class="comment">// it will always get an Observable unless we hit the max batch size</span></div><div class="line"><span class="number">28</span>:         <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">29</span>:             <span class="keyword">return</span> response;</div><div class="line"><span class="number">30</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">31</span>:             <span class="comment">// 添加失败，执行 RequestBatch ，并创建新的 RequestBatch</span></div><div class="line"><span class="number">32</span>:             <span class="comment">// this batch can't accept requests so create a new one and set it if another thread doesn't beat us</span></div><div class="line"><span class="number">33</span>:             createNewBatchAndExecutePreviousIfNeeded(b);</div><div class="line"><span class="number">34</span>:         &#125;</div><div class="line"><span class="number">35</span>:     &#125;</div><div class="line"><span class="number">36</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 5 至 8 行 ：当 RequestCollapser 的监听任务( CollapsedTask )还未创建，进行初始化。</li><li>第 11 至 35 行 ：<strong>死循环</strong>，直到提交<strong>单个</strong>命令请求到 RequestBatch <strong>成功</strong>。<ul><li>第 13 至 16 行 ：获得 RequestBatch 。从目前代码看下来，除非 RequestCollapser 被 <code>#shutdown()</code> 后才会出现为 <code>null</code> 的情况。</li><li>第 19 至 24 行 ：调动 <code>RequestBatch#offer(...)</code> 方法，提交<strong>单个</strong>命令请求到 RequestBatch ，并获得 Observable 。这里对 <code>arg == null</code> 做了特殊处理，因为 <code>RequestBatch.argumentMap</code> 是 ConcurrentHashMap ，不允许值为 <code>null</code> 。另外，<code>RequestBatch#offer(...)</code> 方法的实现代码，在结束了当前方法，详细解析。</li><li>第 28 至 29 行 ：添加成功，返回 Observable 。</li><li>第 30 至 34 行 ：添加失败，执行当前 RequestBatch 的<strong>多个</strong>命令合并执行，并创建<strong>新的</strong> RequestBatch 。在 <a href="#">「4.4 #createNewBatchAndExecutePreviousIfNeeded(previousBatch)」</a>   详细解析。</li></ul></li></ul><hr><p><code>RequestBatch#offer(...)</code> 方法，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> Observable&lt;ResponseType&gt;  <span class="title">offer</span><span class="params">(RequestArgumentType arg)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// 执行已经开始，添加失败</span></div><div class="line"> <span class="number">3</span>:     <span class="comment">/* short-cut - if the batch is started we reject the offer */</span></div><div class="line"> <span class="number">4</span>:     <span class="keyword">if</span> (batchStarted.get()) &#123;</div><div class="line"> <span class="number">5</span>:         <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"> <span class="number">6</span>:     &#125;</div><div class="line"> <span class="number">7</span>: </div><div class="line"> <span class="number">8</span>:     <span class="comment">/*</span></div><div class="line"><span class="comment"> 9:      * The 'read' just means non-exclusive even though we are writing.</span></div><div class="line"><span class="comment">10:      */</span></div><div class="line"><span class="number">11</span>:     <span class="keyword">if</span> (batchLock.readLock().tryLock()) &#123;</div><div class="line"><span class="number">12</span>:         <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">13</span>:             <span class="comment">// 执行已经开始，添加失败</span></div><div class="line"><span class="number">14</span>:             <span class="comment">/* double-check now that we have the lock - if the batch is started we reject the offer */</span></div><div class="line"><span class="number">15</span>:             <span class="keyword">if</span> (batchStarted.get()) &#123;</div><div class="line"><span class="number">16</span>:                 <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"><span class="number">17</span>:             &#125;</div><div class="line"><span class="number">18</span>: </div><div class="line"><span class="number">19</span>:             <span class="comment">// 超过队列最大长度，添加失败</span></div><div class="line"><span class="number">20</span>:             <span class="keyword">if</span> (argumentMap.size() &gt;= maxBatchSize) &#123;</div><div class="line"><span class="number">21</span>:                 <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"><span class="number">22</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">23</span>:                 <span class="comment">// 创建 CollapsedRequestSubject ，并添加到队列</span></div><div class="line"><span class="number">24</span>:                 CollapsedRequestSubject&lt;ResponseType, RequestArgumentType&gt; collapsedRequest = <span class="keyword">new</span> CollapsedRequestSubject&lt;ResponseType, RequestArgumentType&gt;(arg, <span class="keyword">this</span>);</div><div class="line"><span class="number">25</span>:                 <span class="keyword">final</span> CollapsedRequestSubject&lt;ResponseType, RequestArgumentType&gt; existing = (CollapsedRequestSubject&lt;ResponseType, RequestArgumentType&gt;) argumentMap.putIfAbsent(arg, collapsedRequest);</div><div class="line"><span class="number">26</span>:                 <span class="comment">/**</span></div><div class="line"><span class="comment">27:                  * If the argument already exists in the batch, then there are 2 options:</span></div><div class="line"><span class="comment">28:                  * A) If request caching is ON (the default): only keep 1 argument in the batch and let all responses</span></div><div class="line"><span class="comment">29:                  * be hooked up to that argument</span></div><div class="line"><span class="comment">30:                  * B) If request caching is OFF: return an error to all duplicate argument requests</span></div><div class="line"><span class="comment">31:                  *</span></div><div class="line"><span class="comment">32:                  * This maintains the invariant that each batch has no duplicate arguments.  This prevents the impossible</span></div><div class="line"><span class="comment">33:                  * logic (in a user-provided mapResponseToRequests for HystrixCollapser and the internals of HystrixObservableCollapser)</span></div><div class="line"><span class="comment">34:                  * of trying to figure out which argument of a set of duplicates should get attached to a response.</span></div><div class="line"><span class="comment">35:                  *</span></div><div class="line"><span class="comment">36:                  * See https://github.com/Netflix/Hystrix/pull/1176 for further discussion.</span></div><div class="line"><span class="comment">37:                  */</span></div><div class="line"><span class="number">38</span>:                 <span class="keyword">if</span> (existing != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">39</span>:                     <span class="keyword">boolean</span> requestCachingEnabled = properties.requestCacheEnabled().get();</div><div class="line"><span class="number">40</span>:                     <span class="keyword">if</span> (requestCachingEnabled) &#123;</div><div class="line"><span class="number">41</span>:                         <span class="keyword">return</span> existing.toObservable();</div><div class="line"><span class="number">42</span>:                     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">43</span>:                         <span class="keyword">return</span> Observable.error(<span class="keyword">new</span> IllegalArgumentException(<span class="string">"Duplicate argument in collapser batch : ["</span> + arg + <span class="string">"]  This is not supported.  Please turn request-caching on for HystrixCollapser:"</span> + commandCollapser.getCollapserKey().name() + <span class="string">" or prevent duplicates from making it into the batch!"</span>));</div><div class="line"><span class="number">44</span>:                     &#125;</div><div class="line"><span class="number">45</span>:                 &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">46</span>:                     <span class="keyword">return</span> collapsedRequest.toObservable();</div><div class="line"><span class="number">47</span>:                 &#125;</div><div class="line"><span class="number">48</span>: </div><div class="line"><span class="number">49</span>:             &#125;</div><div class="line"><span class="number">50</span>:         &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">51</span>:             batchLock.readLock().unlock();</div><div class="line"><span class="number">52</span>:         &#125;</div><div class="line"><span class="number">53</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">54</span>:         <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"><span class="number">55</span>:     &#125;</div><div class="line"><span class="number">56</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 4 至 6 行 ：执行已经开始，添加失败。在 <code>RequestBatch#executeBatchIfNotAlreadyStarted(...)</code> 方法的开头，优先 <strong>CAS</strong> 使 <code>batchStarted = true</code> 。</p></li><li><p>第 11 行 ：获得<strong>读锁</strong>。<code>The 'read' just means non-exclusive even though we are writing.</code> ，即使该方法实际在做**&quot;写操作&quot;**，不排他，线程安全，所以可以使用读锁。</p></li><li><p>第 15 至 17 行 ：<code>double-check</code>，执行已经开始，添加失败。在 <code>RequestBatch#executeBatchIfNotAlreadyStarted(...)</code> 方法，优先 <strong>CAS</strong> 使 <code>batchStarted = true</code>，再获取<strong>写锁</strong>，所以会出现该情况。</p></li><li><p>第 20 至 21 行 ：超过队列最大长度，添加失败。</p></li><li><p>第 24 至 25 行 ：创建 <code>com.netflix.hystrix.collapser.CollapsedRequestSubject</code> ，并将<strong>它</strong>添加到队列( <code>argumentMap</code> ) 。</p><ul><li><p>CollapsedRequestSubject 实现 <code>com.netflix.hystrix.HystrixCollapser.CollapsedRequest</code> <strong>接口</strong>，定义了批量命令执行的<strong>请求</strong>，不仅限于获得请求参数( <code>#getArgument()</code> 方法 )，也包括对批量命令执行结束后，每个<strong>请求</strong>的结果设置( <code>#setResponse(...)</code>/<code>#emitResponse(...)</code>/<code>#setException(...)</code>/<code>#setComplete()</code> 方法 )，点击 <a href="https://github.com/YunaiV/Hystrix/blob/dc176978c2beb2465ba4edb37d0024e388f15d5d/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java#L512" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看该接口的代码。</p></li><li><p>CollapsedRequestSubject <strong>构造方法</strong>，代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/* package */</span><span class="class"><span class="keyword">class</span> <span class="title">CollapsedRequestSubject</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">CollapsedRequest</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 参数</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> R argument;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 结果( response ) 是否设置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> AtomicBoolean valueSet = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 可回放的 ReplaySubject</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReplaySubject&lt;T&gt; subject = ReplaySubject.create();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 带订阅数量的 ReplaySubject</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Observable&lt;T&gt; subjectWithAccounting;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 订阅数量</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> outstandingSubscriptions = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CollapsedRequestSubject</span><span class="params">(<span class="keyword">final</span> R arg, <span class="keyword">final</span> RequestBatch&lt;?, T, R&gt; containingBatch)</span> </span>&#123;</div><div class="line">        <span class="comment">// 设置 argument</span></div><div class="line">        <span class="keyword">if</span> (arg == RequestCollapser.NULL_SENTINEL) &#123;</div><div class="line">            <span class="keyword">this</span>.argument = <span class="keyword">null</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">this</span>.argument = arg;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 设置 带订阅数量的 ReplaySubject</span></div><div class="line">        <span class="keyword">this</span>.subjectWithAccounting = subject</div><div class="line">                .doOnSubscribe(<span class="keyword">new</span> Action0() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">                        outstandingSubscriptions++;</div><div class="line">                    &#125;</div><div class="line">                &#125;)</div><div class="line">                .doOnUnsubscribe(<span class="keyword">new</span> Action0() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">                        outstandingSubscriptions--;</div><div class="line">                        <span class="keyword">if</span> (outstandingSubscriptions == <span class="number">0</span>) &#123;</div><div class="line">                            containingBatch.remove(arg);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><code>argument</code> 属性，<strong>单个</strong>命令请求参数。</li><li><code>valueSet</code> 属性，结果( Response ) 是否设置，通过 <code>#setResponse()</code>/<code>#emitResponse()</code> 方法设置。</li><li><code>subject</code> 属性，<strong>可回放执行结果</strong>的 Subject 。此处使用 ReplaySubject 的主要目的，当 HystrixCollapser 开启<strong>缓存</strong>功能时，通过回放执行结果，在 <a href="http://www.iocoder.cn/Hystrix/command-execute-result-cache/?self">《Hystrix 源码解析 —— 执行结果缓存》「5. HystrixCachedObservable」</a> 也有相同的实现。另外，这里有一点要注意下，ReplaySubject 并<strong>没有</strong>向任何 Observable 订阅结果，<strong>而是通过 <code>#setResponse()</code>/<code>#emitResponse()</code> 方法设置结果</strong>。</li><li><code>outstandingSubscriptions</code> 属性，订阅数量。</li><li><code>subjectWithAccounting</code> 属性，带订阅数量的 ReplaySubject 。当取消订阅时，调用 <code>RequestBatch#remove(arg)</code> 方法，移除<strong>单个</strong>命令请求。</li></ul></li></ul></li><li><p>第 38 至 47 行 ：返回 Observable 。</p><ul><li>当 <code>argumentMap</code> 已经存在 <code>arg</code> 对应的 Observable 时，必须开启缓存 ( <code>HystrixCollapserProperties.requestCachingEnabled = true</code> ) 功能。原因是，如果在<strong>相同的</strong> <code>arg</code> ，并且未开启缓存，同时<strong>第 43 行</strong>实现的是 <code>collapsedRequest.toObservable()</code> ，那么<strong>相同的</strong> <code>arg</code> 将有<strong>多个</strong> Observable 执行命令，此时 <code>HystrixCollapserBridge#mapResponseToRequests(...)</code> 方法无法将执行( Response )赋值到 <code>arg</code> 对应的命令请求( CollapsedRequestSubject ) 。更多讨论，见 <a href="https://github.com/Netflix/Hystrix/pull/1176" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/Netflix/Hystrix/pull/1176</a> 。</li><li>回过头看 <code>HystrixCollapser#toObservable()</code> 方法的<strong>第 32 至 41 行的代码</strong>，这里也有对<strong>缓存</strong>功能，是不是<strong>重复</strong>了呢？<code>argumentMap</code> 针对的是 RequestBatch 级的缓存，HystrixCollapser : RequestCollapser : RequestBatch 是 <code>1 : 1 : N</code> 的关系，通过 <code>HystrixCollapser#toObservable()</code> 对缓存的处理逻辑，保证 RequestBatch 切换后，<strong>依然有缓存</strong>。</li></ul></li></ul><hr><p><code>RequestBatch#remove()</code> 方法，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/* package-private */</span> <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(RequestArgumentType arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (batchStarted.get()) &#123;</div><div class="line">        <span class="comment">//nothing we can do</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (batchLock.readLock().tryLock()) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">/* double-check now that we have the lock - if the batch is started, deleting is useless */</span></div><div class="line">            <span class="keyword">if</span> (batchStarted.get()) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            argumentMap.remove(arg);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            batchLock.readLock().unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>当 RequestBatch 开始执行，不允许移除<strong>单个</strong>命令请求。</li></ul><h2>4.4 #createNewBatchAndExecutePreviousIfNeeded(previousBatch)</h2><p>本小节建议在 <a href="#">「5. CollapserTimer」</a> 后，再回过头看。</p><p><code>#createNewBatchAndExecutePreviousIfNeeded(previousBatch)</code> 方法，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createNewBatchAndExecutePreviousIfNeeded</span><span class="params">(RequestBatch&lt;BatchReturnType, ResponseType, RequestArgumentType&gt; previousBatch)</span> </span>&#123;</div><div class="line"><span class="number">2</span>:     <span class="keyword">if</span> (previousBatch == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">3</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Trying to start null batch which means it was shutdown already."</span>);</div><div class="line"><span class="number">4</span>:     &#125;</div><div class="line"><span class="number">5</span>:     <span class="keyword">if</span> (batch.compareAndSet(previousBatch, <span class="keyword">new</span> RequestBatch&lt;BatchReturnType, ResponseType, RequestArgumentType&gt;(properties, commandCollapser, properties.maxRequestsInBatch().get()))) &#123;</div><div class="line"><span class="number">6</span>:         <span class="comment">// this thread won so trigger the previous batch</span></div><div class="line"><span class="number">7</span>:         previousBatch.executeBatchIfNotAlreadyStarted();</div><div class="line"><span class="number">8</span>:     &#125;</div><div class="line"><span class="number">9</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 5 行 ：通过 <strong>CAS</strong> 修改 <code>batch</code> ，保证并发情况下的线程安全。同时注意，此处也进行了<strong>新的</strong> RequestBatch ，切换掉<strong>老的</strong> RequestBatch 。</li><li>第 6 行 ：使用<strong>老的</strong> RequestBatch ，调用 <code>RequestBatch#executeBatchIfNotAlreadyStarted()</code> 方法，命令合并执行。</li></ul><hr><p><code>RequestBatch#executeBatchIfNotAlreadyStarted()</code> 方法，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeBatchIfNotAlreadyStarted</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="number">2</span>:     <span class="comment">/*</span></div><div class="line"><span class="comment">  3:      * - check that we only execute once since there's multiple paths to do so (timer, waiting thread or max batch size hit)</span></div><div class="line"><span class="comment">  4:      * - close the gate so 'offer' can no longer be invoked and we turn those threads away so they create a new batch</span></div><div class="line"><span class="comment">  5:      */</span></div><div class="line">  <span class="number">6</span>:     <span class="comment">// 设置 执行已经开始</span></div><div class="line">  <span class="number">7</span>:     <span class="keyword">if</span> (batchStarted.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</div><div class="line">  <span class="number">8</span>:         <span class="comment">// 获得 写锁</span></div><div class="line">  <span class="number">9</span>:         <span class="comment">/* wait for 'offer'/'remove' threads to finish before executing the batch so 'requests' is complete */</span></div><div class="line"> <span class="number">10</span>:         batchLock.writeLock().lock();</div><div class="line"> <span class="number">11</span>: </div><div class="line"> <span class="number">12</span>:         <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">13</span>:             <span class="comment">// 将多个命令请求分片成 N 个【多个命令请求】。</span></div><div class="line"> <span class="number">14</span>:             <span class="comment">// shard batches</span></div><div class="line"> <span class="number">15</span>:             Collection&lt;Collection&lt;CollapsedRequest&lt;ResponseType, RequestArgumentType&gt;&gt;&gt; shards = commandCollapser.shardRequests(argumentMap.values());</div><div class="line"> <span class="number">16</span>:             <span class="comment">// for each shard execute its requests </span></div><div class="line"> <span class="number">17</span>:             <span class="keyword">for</span> (<span class="keyword">final</span> Collection&lt;CollapsedRequest&lt;ResponseType, RequestArgumentType&gt;&gt; shardRequests : shards) &#123;</div><div class="line"> <span class="number">18</span>:                 <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">19</span>:                     <span class="comment">// 将多个命令请求合并，创建一个 HystrixCommand</span></div><div class="line"> <span class="number">20</span>:                     <span class="comment">// create a new command to handle this batch of requests</span></div><div class="line"> <span class="number">21</span>:                     Observable&lt;BatchReturnType&gt; o = commandCollapser.createObservableCommand(shardRequests);</div><div class="line"> <span class="number">22</span>: </div><div class="line"> <span class="number">23</span>:                     <span class="comment">// 将一个 HystrixCommand 的执行结果，映射回对应的命令请求们</span></div><div class="line"> <span class="number">24</span>:                     commandCollapser.mapResponseToRequests(o, shardRequests).doOnError(<span class="keyword">new</span> Action1&lt;Throwable&gt;() &#123;</div><div class="line"> <span class="number">25</span>: </div><div class="line"> <span class="number">26</span>:                         <span class="comment">/**</span></div><div class="line"><span class="comment"> 27:                          * This handles failed completions</span></div><div class="line"><span class="comment"> 28:                          */</span></div><div class="line"> <span class="number">29</span>:                         <span class="meta">@Override</span></div><div class="line"> <span class="number">30</span>:                         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line"> <span class="number">31</span>:                             <span class="comment">// handle Throwable in case anything is thrown so we don't block Observers waiting for onError/onCompleted</span></div><div class="line"> <span class="number">32</span>:                             Exception ee;</div><div class="line"> <span class="number">33</span>:                             <span class="keyword">if</span> (e <span class="keyword">instanceof</span> Exception) &#123;</div><div class="line"> <span class="number">34</span>:                                 ee = (Exception) e;</div><div class="line"> <span class="number">35</span>:                             &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">36</span>:                                 ee = <span class="keyword">new</span> RuntimeException(<span class="string">"Throwable caught while executing batch and mapping responses."</span>, e);</div><div class="line"> <span class="number">37</span>:                             &#125;</div><div class="line"> <span class="number">38</span>:                             logger.debug(<span class="string">"Exception mapping responses to requests."</span>, e);</div><div class="line"> <span class="number">39</span>:                             <span class="comment">// if a failure occurs we want to pass that exception to all of the Futures that we've returned</span></div><div class="line"> <span class="number">40</span>:                             <span class="keyword">for</span> (CollapsedRequest&lt;ResponseType, RequestArgumentType&gt; request : argumentMap.values()) &#123;</div><div class="line"> <span class="number">41</span>:                                 <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">42</span>:                                     ((CollapsedRequestSubject&lt;ResponseType, RequestArgumentType&gt;) request).setExceptionIfResponseNotReceived(ee);</div><div class="line"> <span class="number">43</span>:                                 &#125; <span class="keyword">catch</span> (IllegalStateException e2) &#123;</div><div class="line"> <span class="number">44</span>:                                     <span class="comment">// if we have partial responses set in mapResponseToRequests</span></div><div class="line"> <span class="number">45</span>:                                     <span class="comment">// then we may get IllegalStateException as we loop over them</span></div><div class="line"> <span class="number">46</span>:                                     <span class="comment">// so we'll log but continue to the rest</span></div><div class="line"> <span class="number">47</span>:                                     logger.error(<span class="string">"Partial success of 'mapResponseToRequests' resulted in IllegalStateException while setting Exception. Continuing ... "</span>, e2);</div><div class="line"> <span class="number">48</span>:                                 &#125;</div><div class="line"> <span class="number">49</span>:                             &#125;</div><div class="line"> <span class="number">50</span>:                         &#125;</div><div class="line"> <span class="number">51</span>: </div><div class="line"> <span class="number">52</span>:                     &#125;).doOnCompleted(<span class="keyword">new</span> Action0() &#123;</div><div class="line"> <span class="number">53</span>: </div><div class="line"> <span class="number">54</span>:                         <span class="comment">/**</span></div><div class="line"><span class="comment"> 55:                          * This handles successful completions</span></div><div class="line"><span class="comment"> 56:                          */</span></div><div class="line"> <span class="number">57</span>:                         <span class="meta">@Override</span></div><div class="line"> <span class="number">58</span>:                         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">59</span>:                             <span class="comment">// check that all requests had setResponse or setException invoked in case 'mapResponseToRequests' was implemented poorly</span></div><div class="line"> <span class="number">60</span>:                             Exception e = <span class="keyword">null</span>;</div><div class="line"> <span class="number">61</span>:                             <span class="keyword">for</span> (CollapsedRequest&lt;ResponseType, RequestArgumentType&gt; request : shardRequests) &#123;</div><div class="line"> <span class="number">62</span>:                                 <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">63</span>:                                    e = ((CollapsedRequestSubject&lt;ResponseType, RequestArgumentType&gt;) request).setExceptionIfResponseNotReceived(e,<span class="string">"No response set by "</span> + commandCollapser.getCollapserKey().name() + <span class="string">" 'mapResponseToRequests' implementation."</span>);</div><div class="line"> <span class="number">64</span>:                                 &#125; <span class="keyword">catch</span> (IllegalStateException e2) &#123;</div><div class="line"> <span class="number">65</span>:                                     logger.debug(<span class="string">"Partial success of 'mapResponseToRequests' resulted in IllegalStateException while setting 'No response set' Exception. Continuing ... "</span>, e2);</div><div class="line"> <span class="number">66</span>:                                 &#125;</div><div class="line"> <span class="number">67</span>:                             &#125;</div><div class="line"> <span class="number">68</span>:                         &#125;</div><div class="line"> <span class="number">69</span>: </div><div class="line"> <span class="number">70</span>:                     &#125;).subscribe();</div><div class="line"> <span class="number">71</span>:                     </div><div class="line"> <span class="number">72</span>:                 &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"> <span class="number">73</span>:                     <span class="comment">// 异常</span></div><div class="line"> <span class="number">74</span>:                     logger.error(<span class="string">"Exception while creating and queueing command with batch."</span>, e);</div><div class="line"> <span class="number">75</span>:                     <span class="comment">// if a failure occurs we want to pass that exception to all of the Futures that we've returned</span></div><div class="line"> <span class="number">76</span>:                     <span class="keyword">for</span> (CollapsedRequest&lt;ResponseType, RequestArgumentType&gt; request : shardRequests) &#123;</div><div class="line"> <span class="number">77</span>:                         <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">78</span>:                             request.setException(e);</div><div class="line"> <span class="number">79</span>:                         &#125; <span class="keyword">catch</span> (IllegalStateException e2) &#123;</div><div class="line"> <span class="number">80</span>:                             logger.debug(<span class="string">"Failed trying to setException on CollapsedRequest"</span>, e2);</div><div class="line"> <span class="number">81</span>:                         &#125;</div><div class="line"> <span class="number">82</span>:                     &#125;</div><div class="line"> <span class="number">83</span>:                 &#125;</div><div class="line"> <span class="number">84</span>:             &#125;</div><div class="line"> <span class="number">85</span>: </div><div class="line"> <span class="number">86</span>:         &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"> <span class="number">87</span>:             <span class="comment">// 异常</span></div><div class="line"> <span class="number">88</span>:             logger.error(<span class="string">"Exception while sharding requests."</span>, e);</div><div class="line"> <span class="number">89</span>:             <span class="comment">// same error handling as we do around the shards, but this is a wider net in case the shardRequest method fails</span></div><div class="line"> <span class="number">90</span>:             <span class="keyword">for</span> (CollapsedRequest&lt;ResponseType, RequestArgumentType&gt; request : argumentMap.values()) &#123;</div><div class="line"> <span class="number">91</span>:                 <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">92</span>:                     request.setException(e);</div><div class="line"> <span class="number">93</span>:                 &#125; <span class="keyword">catch</span> (IllegalStateException e2) &#123;</div><div class="line"> <span class="number">94</span>:                     logger.debug(<span class="string">"Failed trying to setException on CollapsedRequest"</span>, e2);</div><div class="line"> <span class="number">95</span>:                 &#125;</div><div class="line"> <span class="number">96</span>:             &#125;</div><div class="line"> <span class="number">97</span>:         &#125; <span class="keyword">finally</span> &#123;</div><div class="line"> <span class="number">98</span>:             batchLock.writeLock().unlock();</div><div class="line"> <span class="number">99</span>:         &#125;</div><div class="line"><span class="number">100</span>:     &#125;</div><div class="line"><span class="number">101</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>代码看起来是有点长哈，请对照着官方示例 <a href="https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-examples/src/main/java/com/netflix/hystrix/examples/basic/CommandCollapserGetValueForKey.java" rel="external nofollow noopener noreferrer" target="_blank">CommandCollapserGetValueForKey</a> 一起看，临门一脚了，胖友！</li><li>第 7 行 ：通过 <strong>CAS</strong> 修改 <code>batchStarted</code> ，保证并发情况下的线程安全。</li><li>第 10 行 ：获得<strong>写锁</strong>。等待调用 <code>#offer(...)</code>/<code>#remove(...)</code> 方法的线程执行完成，以保证命令合并执行时，不再有新的请求添加或移除。</li><li>第 15 行 ：调用 <code>HystrixCollapserBridge#shardRequests(...)</code> 方法，将<strong>多个</strong>命令请求<strong>分片</strong>成 <strong>N</strong> 个【<strong>多个</strong>命令请求】。默认实现下，不进行分片。点击 <a href="https://github.com/YunaiV/Hystrix/blob/dc176978c2beb2465ba4edb37d0024e388f15d5d/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java#L146" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看代码。</li><li>第 17 行 ：循环 <strong>N</strong> 个【<strong>多个</strong>命令请求】。</li><li>第 21 行 ：调用 <code>HystrixCollapserBridge#createObservableCommand(...)</code> 方法，将<strong>多个</strong>命令请求<strong>合并</strong>，创建<strong>一个</strong> HystrixCommand 。点击 <a href="https://github.com/YunaiV/Hystrix/blob/dc176978c2beb2465ba4edb37d0024e388f15d5d/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java#L156" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看代码。</li><li>第 24 行 ：调用 <code>HystrixCollapserBridge#mapResponseToRequests(...)</code> 方法，将<strong>一个</strong> HystrixCommand 的执行结果，<strong>映射</strong>回对应的命令请求们。点击 <a href="https://github.com/YunaiV/Hystrix/blob/dc176978c2beb2465ba4edb37d0024e388f15d5d/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java#L166" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看代码。<ul><li><code>Observable#single()</code> 方法，如果 Observable 终止时只发射了一个值，返回那个值，否则抛出异常。在 <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/First.html#single" rel="external nofollow noopener noreferrer" target="_blank">《ReactiveX文档中文翻译》「single」</a> 有相关分享。</li><li><code>Observable#ignoreElements()</code> 方法，抑制原始 Observable 发射的所有数据，只允许它的终止通知（<code>#onError()</code> 或 <code>#onCompleted()</code>）通过。在 <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/IgnoreElements.html" rel="external nofollow noopener noreferrer" target="_blank">《ReactiveX文档中文翻译》「IgnoreElements」</a> 有相关分享。也推荐点击 <a href="https://github.com/ReactiveX/RxJava/blob/6db98f8750f580995657f83b5620b579c97e6a06/src/main/java/rx/internal/operators/OperatorIgnoreElements.java" rel="external nofollow noopener noreferrer" target="_blank"><code>rx.internal.operators.OperatorIgnoreElements</code></a> 看下源码，可能更加易懂。</li><li><code>Observable#cast()</code> 方法，将原始 Observable 发射的每一项数据都强制转换为一个指定的类型，然后再发射数据，它是 <code>map</code> 的一个特殊版本。在 <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Map.html#cast" rel="external nofollow noopener noreferrer" target="_blank">《ReactiveX文档中文翻译》「cast」</a> 有相关分享。也推荐点击 <a href="https://github.com/ReactiveX/RxJava/blob/6db98f8750f580995657f83b5620b579c97e6a06/src/main/java/rx/internal/operators/OperatorCast.java" rel="external nofollow noopener noreferrer" target="_blank"><code>rx.internal.operators.OperatorCast</code></a> 看下源码，可能更加易懂。</li><li>使用 <code>Observable#ignoreElements()</code>/<code>Observable#cast()</code> 方法，用于将 Observable 变成不再继续向下发射数据项，只给现有方法里 <code>Observable#doNext()</code> 处理数据项，调用 <code>HystrixCollapser#mapResponseToRequests(...)</code> 方法。</li><li>点击 <a href="https://github.com/YunaiV/Hystrix/blob/dc176978c2beb2465ba4edb37d0024e388f15d5d/hystrix-core/src/main/java/com/netflix/hystrix/collapser/CollapsedRequestSubject.java#L101" rel="external nofollow noopener noreferrer" target="_blank">链接</a> ，查看 <code>CollapsedRequestSubject#setResponse(response)</code> 方法的代码。</li></ul></li><li>第 24 至 50 行 ：调用 <code>Observable#doError(Action1)</code> 方法，当命令合并执行发生异常时，设置<strong>每个</strong> CollapsedRequestSubject 的执行结果为异常。<ul><li>点击 <a href="https://github.com/YunaiV/Hystrix/blob/dc176978c2beb2465ba4edb37d0024e388f15d5d/hystrix-core/src/main/java/com/netflix/hystrix/collapser/CollapsedRequestSubject.java#L137" rel="external nofollow noopener noreferrer" target="_blank">链接</a>，查看 <code>CollapsedRequestSubject#setResponse(response)</code> 方法的代码。</li></ul></li><li>第 52 至 68 行 ：调用 <code>Observable#doOnCompleted(Action0)</code> 方法，当命令合并执行完成时，检查<strong>每个</strong> CollapsedRequestSubject 是否都有返回结果。设置没有返回结果的 CollapsedRequestSubject 的执行结果为异常。一般情况下，是用户实现 <code>HystrixCollapser#mapResponseToRequests(...)</code> 方法存在 BUG 。另外，如果不设置，将导致无结果的<strong>单个</strong>命令请求<strong>无限阻塞</strong>。</li><li>第 70 行 ：调用 <code>Observable#subscribe()</code> 方法，<strong>触发</strong> HystrixCommand 执行。</li><li>第 72 至 96 行 ：发生异常，设置<strong>每个</strong> CollapsedRequestSubject 的执行结果为异常。<ul><li>点击 <a href="https://github.com/YunaiV/Hystrix/blob/dc176978c2beb2465ba4edb37d0024e388f15d5d/hystrix-core/src/main/java/com/netflix/hystrix/collapser/CollapsedRequestSubject.java#L170" rel="external nofollow noopener noreferrer" target="_blank">链接</a>，查看 <code>CollapsedRequestSubject#setException(response)</code> 方法的代码。</li></ul></li><li>第 97 至 99 行 ：释放<strong>写锁</strong>。</li></ul><h1>5. CollapserTimer</h1><p><code>com.netflix.hystrix.collapser.CollapserTimer</code> ，命令合并器的定时器<strong>接口</strong>，定义了<strong>提交定时监听器，生成定时任务</strong>的接口方法，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CollapserTimer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function">Reference&lt;TimerListener&gt; <span class="title">addListener</span><span class="params">(TimerListener collapseTask)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2>5.1 RealCollapserTimer</h2><p><code>com.netflix.hystrix.collapser.RealCollapserTimer</code> ，命令合并器的定时器<strong>实现类</strong>，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealCollapserTimer</span> <span class="keyword">implements</span> <span class="title">CollapserTimer</span> </span>&#123;</div><div class="line">    <span class="comment">/* single global timer that all collapsers will schedule their tasks on */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HystrixTimer timer = HystrixTimer.getInstance();</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Reference&lt;TimerListener&gt; <span class="title">addListener</span><span class="params">(TimerListener collapseTask)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> timer.addTimerListener(collapseTask);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>实际上，使用的是 HystrixTimer 提供的单例。在 <a href="http://www.iocoder.cn/Hystrix/command-execute-third-timeout/?self">《Hystrix 源码解析 —— 执行结果缓存》「3. HystrixTimer」</a> 有详细解析。</li></ul><h2>5.2 CollapsedTask</h2><p><code>com.netflix.hystrix.collapser.RequestCollapser.CollapsedTask</code> ，定时任务，固定周期( 可配，默认 <code>HystrixCollapserProperties.timerDelayInMilliseconds = 10ms</code> ) 轮询其对应的<strong>一个</strong> RequestCollapser <strong>当前</strong> RequestBatch 。若有命令需要执行，则提交 RequestCollapser 合并执行。</p><p>代码比较简单，点击 <a href="https://github.com/YunaiV/Hystrix/blob/dc176978c2beb2465ba4edb37d0024e388f15d5d/hystrix-core/src/main/java/com/netflix/hystrix/collapser/RequestCollapser.java#L138" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 直接看代码。</p><h1>666. 彩蛋</h1><p>T T 一开始把命令合并执行，理解成类似线程池批量执行任务，怎么看官方示例，怎么奇怪。有一样的同学，一起泪目 + 握爪下。</p><p>本文有点点长，实在不想拆分成多篇。</p><p>恩，另外部分地方写的不够清晰，欢迎一起讨论和优化。</p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/Hystrix/command-collapser-execute/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 Hystrix 1.5.X 版本&lt;/strong&gt;&lt;/p&gt;
      
    
    </summary>
    
      <category term="Hystrix" scheme="http://www.iocoder.cn/categories/Hystrix/"/>
    
    
  </entry>
  
  <entry>
    <title>Hystrix 源码解析 —— 请求执行（四）之失败回退逻辑</title>
    <link href="http://www.iocoder.cn/Hystrix/command-execute-fourth-fallback/"/>
    <id>http://www.iocoder.cn/Hystrix/command-execute-fourth-fallback/</id>
    <published>2018-10-30T16:00:00.000Z</published>
    <updated>2017-11-06T10:48:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/Hystrix/command-execute-fourth-fallback/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Hystrix 1.5.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Hystrix/command-execute-fourth-fallback/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-fourth-fallback/">2. handleFallback</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-fourth-fallback/">3. #handleShortCircuitViaFallback()</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-fourth-fallback/">4. #handleSemaphoreRejectionViaFallback()</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-fourth-fallback/">5. #handleThreadPoolRejectionViaFallback()</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-fourth-fallback/">6. #handleTimeoutViaFallback()</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-fourth-fallback/">7. #handleFailureViaFallback()</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-fourth-fallback/">8. #getFallbackOrThrowException(...)</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-fourth-fallback/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p>本文主要分享 <strong>Hystrix 命令执行（四）之失败回退逻辑</strong>。</p><p>建议 ：对 RxJava 已经有一定的了解的基础上阅读本文。</p><p>Hystrix 执行命令整体流程如下图：</p><blockquote><p>FROM <a href="http://youdang.github.io/2016/02/05/translate-hystrix-wiki-how-it-works/#%E6%B5%81%E7%A8%8B%E5%9B%BE" rel="external nofollow noopener noreferrer" target="_blank">《【翻译】Hystrix文档-实现原理》「流程图」</a><br><img src="http://www.iocoder.cn/images/Hystrix/2018_10_31/01.jpeg" alt=""></p></blockquote><ul><li><strong>红</strong>圈 ：Hystrix 命令执行失败，执行回退逻辑。<strong>也就是大家经常在文章中看到的“服务降级”</strong>。</li><li><strong>绿</strong>圈 ：四种情况会触发失败回退逻辑( fallback )。<ul><li>第一种 ：<code>short-circuit</code> ，处理<strong>链路处于熔断</strong>的回退逻辑，在 <a href="#">「3. #handleShortCircuitViaFallback()」</a> 详细解析。</li><li>第二种 ：<code>semaphore-rejection</code> ，处理<strong>信号量获得失败</strong>的回退逻辑，在 <a href="#">「4. #handleShortCircuitViaFallback()」</a> 详细解析。</li><li>第三种 ：<code>thread-pool-rejection</code> ，处理<strong>线程池提交任务拒绝</strong>的回退逻辑，在 <a href="#">「5. #handleThreadPoolRejectionViaFallback()」</a> 详细解析。</li><li>第四种 ：<code>execution-timeout</code> ，处理<strong>命令执行超时</strong>的回退逻辑，在 <a href="#">「6. #handleTimeoutViaFallback()」</a> 详细解析。</li><li>第五种 ：<code>execution-failure</code> ，处理<strong>命令执行异常</strong>的回退逻辑，在 <a href="#">「7. #handleFailureViaFallback()」</a> 详细解析。</li><li>第六种 ：<code>bad-request</code> ，TODO 【2014】【HystrixBadRequestException】，和 <code>hystrix-javanica</code> 子项目相关。</li></ul></li></ul><p>另外，<code>#handleXXXX()</code> 方法，整体代码比较类似，最终都是调用 <code>#getFallbackOrThrowException()</code> 方法，获得【回退逻辑 Observable】或者【异常 Observable】，在 <a href="#">「8. #getFallbackOrThrowException(...)」</a> 详细解析。</p><hr><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1>2. handleFallback</h1><p>在 <a href="http://www.iocoder.cn/Hystrix/command-execute-first-run/?self">《Hystrix 源码解析 —— 命令执行（一）之正常执行逻辑》「4. #executeCommandAndObserve(...)」</a> 中，<code>#executeCommandAndObserve(...)</code> 的<strong>第 82 行</strong> <code>onErrorResumeNext(handleFallback)</code> 代码，通过调用 <code>Observable#onErrorResumeNext(...)</code> 方法，实现【执行命令 Observable】执行异常时，返回【回退逻辑 Observable】，执行失败回退逻辑。</p><blockquote><p>FROM <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Catch.html#onerrorreturn" rel="external nofollow noopener noreferrer" target="_blank">《ReactiveX文档中文翻译》「onErrorResumeNext」</a><br>onErrorResumeNext 方法返回一个镜像原有 Observable 行为的新 Observable ，后者会忽略前者的 onError 调用，不会将错误传递给观察者，作为替代，它会开始镜像另一个，备用的 Observable 。</p><ul><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#onErrorResumeNext-rx.functions.Func1-" rel="external nofollow noopener noreferrer" target="_blank">onErrorResumeNext(Func1))</a></li><li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#onErrorResumeNext-rx.Observable-" rel="external nofollow noopener noreferrer" target="_blank">onErrorResumeNext(Observable))</a></li></ul></blockquote><p><a href="https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java#L602" rel="external nofollow noopener noreferrer" target="_blank"><code>handleFallback</code></a> 变量，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">final</span> Func1&lt;Throwable, Observable&lt;R&gt;&gt; handleFallback = <span class="keyword">new</span> Func1&lt;Throwable, Observable&lt;R&gt;&gt;() &#123;</div><div class="line"> <span class="number">2</span>:     <span class="meta">@Override</span></div><div class="line"> <span class="number">3</span>:     <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">(Throwable t)</span> </span>&#123;</div><div class="line"> <span class="number">4</span>:         <span class="comment">// TODO 【2015】【链路熔断】</span></div><div class="line"> <span class="number">5</span>:         circuitBreaker.markNonSuccess();</div><div class="line"> <span class="number">6</span>:         <span class="comment">// 标记 executionResult 执行异常</span></div><div class="line"> <span class="number">7</span>:         Exception e = getExceptionFromThrowable(t);</div><div class="line"> <span class="number">8</span>:         executionResult = executionResult.setExecutionException(e);</div><div class="line"> <span class="number">9</span>:         <span class="comment">// 返回 【回退逻辑 Observable】</span></div><div class="line"><span class="number">10</span>:         <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RejectedExecutionException) &#123; <span class="comment">// 线程池提交任务拒绝异常</span></div><div class="line"><span class="number">11</span>:             <span class="keyword">return</span> handleThreadPoolRejectionViaFallback(e);</div><div class="line"><span class="number">12</span>:         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> HystrixTimeoutException) &#123; <span class="comment">// 执行命令超时异常</span></div><div class="line"><span class="number">13</span>:             <span class="keyword">return</span> handleTimeoutViaFallback();</div><div class="line"><span class="number">14</span>:         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> HystrixBadRequestException) &#123; <span class="comment">// TODO 【2014】【HystrixBadRequestException】</span></div><div class="line"><span class="number">15</span>:             <span class="keyword">return</span> handleBadRequestByEmittingError(e);</div><div class="line"><span class="number">16</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">17</span>:             <span class="comment">/*</span></div><div class="line"><span class="comment">18:              * Treat HystrixBadRequestException from ExecutionHook like a plain HystrixBadRequestException.</span></div><div class="line"><span class="comment">19:              */</span></div><div class="line"><span class="number">20</span>:             <span class="keyword">if</span> (e <span class="keyword">instanceof</span> HystrixBadRequestException) &#123; <span class="comment">// TODO 【2014】【HystrixBadRequestException】</span></div><div class="line"><span class="number">21</span>:                 eventNotifier.markEvent(HystrixEventType.BAD_REQUEST, commandKey);</div><div class="line"><span class="number">22</span>:                 <span class="keyword">return</span> Observable.error(e);</div><div class="line"><span class="number">23</span>:             &#125;</div><div class="line"><span class="number">24</span>: </div><div class="line"><span class="number">25</span>:             <span class="keyword">return</span> handleFailureViaFallback(e);</div><div class="line"><span class="number">26</span>:         &#125;</div><div class="line"><span class="number">27</span>:     &#125;</div><div class="line"><span class="number">28</span>: &#125;;</div></pre></td></tr></table></figure></p><ul><li>第 5 行 ：TODO 【2015】【链路熔断】</li><li>第 7 至 8 行 ：标记 <code>executionResult</code> <strong>执行异常</strong>。</li><li>第 10 至 11 行 ：<code>thread-pool-rejection</code> ，处理<strong>线程池提交任务拒绝</strong>的回退逻辑，在 <a href="#">「5. #handleThreadPoolRejectionViaFallback()」</a> 详细解析。</li><li>第 12 至 13 行 ：<code>execution-timeout</code> ，处理<strong>命令执行超时</strong>的回退逻辑，在 <a href="">「6. #handleTimeoutViaFallback()」</a> 详细解析。</li><li>第 14 至 23 行 ：，<code>bad-request</code> ，TODO 【2014】【HystrixBadRequestException】，和 <code>hystrix-javanica</code> 子项目相关。</li><li>第 25 行 ：<code>execution-failure</code> 处理<strong>命令执行异常</strong>的回退逻辑，在 <a href="#">「7. #handleFailureViaFallback()」</a> 详细解析。</li></ul><h1>3. #handleShortCircuitViaFallback()</h1><p><code>#handleShortCircuitViaFallback()</code> 方法，<code>short-circuit</code> ，处理<strong>链路处于熔断</strong>的回退逻辑，在 <a href="https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java#L558" rel="external nofollow noopener noreferrer" target="_blank">此处</a> 被调用，代码如下 ：</p><p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"> 1: private Observable&lt;R&gt; handleShortCircuitViaFallback() &#123;</div><div class="line"> 2:     // TODO 【2011】【Hystrix 事件机制】</div><div class="line"> 3:     // record that we are returning a short-circuited fallback</div><div class="line"> 4:     eventNotifier.markEvent(HystrixEventType.SHORT_CIRCUITED, commandKey);</div><div class="line"> 5:     // 标记 executionResult 执行异常</div><div class="line"> 6:     // short-circuit and go directly to fallback (or throw an exception if no fallback implemented)</div><div class="line"> 7:     Exception shortCircuitException = new RuntimeException(&quot;Hystrix circuit short-circuited and is OPEN&quot;);</div><div class="line"> 8:     executionResult = executionResult.setExecutionException(shortCircuitException);</div><div class="line"> 9:     try &#123;</div><div class="line">10:         // 获得 【回退逻辑 Observable】 或者 【异常 Observable】</div><div class="line">11:         return getFallbackOrThrowException(this, HystrixEventType.SHORT_CIRCUITED, FailureType.SHORTCIRCUIT,</div><div class="line">12:                 &quot;short-circuited&quot;, shortCircuitException);</div><div class="line">13:     &#125; catch (Exception e) &#123;</div><div class="line">14:         return Observable.error(e);</div><div class="line">15:     &#125;</div><div class="line">16: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 4 行 ：TODO 【2011】【Hystrix 事件机制】</li><li>第 7 至 8 行 ：标记 <code>executionResult</code> <strong>执行异常</strong>。</li><li>第 11 至 12 行 ：调用 <code>#getFallbackOrThrowException()</code> 方法，获得【回退逻辑 Observable】或者【异常 Observable】，在 <a href="#">「8. #getFallbackOrThrowException(...)」</a> 详细解析。</li><li>第 14 行 ：返回【异常 Observable】。</li></ul><h1>4. #handleSemaphoreRejectionViaFallback()</h1><p><code>#handleSemaphoreRejectionViaFallback()</code> 方法，<code>semaphore-rejection</code> ，处理<strong>信号量获得失败</strong>的回退逻辑，在 <a href="https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java#L555" rel="external nofollow noopener noreferrer" target="_blank">此处</a> 被调用，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> Observable&lt;R&gt; <span class="title">handleSemaphoreRejectionViaFallback</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// 标记 executionResult 执行异常</span></div><div class="line"> <span class="number">3</span>:     Exception semaphoreRejectionException = <span class="keyword">new</span> RuntimeException(<span class="string">"could not acquire a semaphore for execution"</span>);</div><div class="line"> <span class="number">4</span>:     executionResult = executionResult.setExecutionException(semaphoreRejectionException);</div><div class="line"> <span class="number">5</span>:     <span class="comment">// TODO 【2011】【Hystrix 事件机制】</span></div><div class="line"> <span class="number">6</span>:     eventNotifier.markEvent(HystrixEventType.SEMAPHORE_REJECTED, commandKey);</div><div class="line"> <span class="number">7</span>:     logger.debug(<span class="string">"HystrixCommand Execution Rejection by Semaphore."</span>); <span class="comment">// debug only since we're throwing the exception and someone higher will do something with it</span></div><div class="line"> <span class="number">8</span>:     <span class="comment">// retrieve a fallback or throw an exception if no fallback available</span></div><div class="line"> <span class="number">9</span>:     <span class="comment">// 获得 【回退逻辑 Observable】 或者 【异常 Observable】</span></div><div class="line"><span class="number">10</span>:     <span class="keyword">return</span> getFallbackOrThrowException(<span class="keyword">this</span>, HystrixEventType.SEMAPHORE_REJECTED, FailureType.REJECTED_SEMAPHORE_EXECUTION,</div><div class="line"><span class="number">11</span>:             <span class="string">"could not acquire a semaphore for execution"</span>, semaphoreRejectionException);</div><div class="line"><span class="number">12</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 3 至 4 行 ：标记 <code>executionResult</code> <strong>执行异常</strong>。</li><li>第 6 至 7 行 ：TODO 【2011】【Hystrix 事件机制】</li><li>第 10 至 11 行 ：调用 <code>#getFallbackOrThrowException()</code> 方法，获得【回退逻辑 Observable】或者【异常 Observable】，在 <a href="#">「8. #getFallbackOrThrowException(...)」</a> 详细解析。</li></ul><h1>5. #handleThreadPoolRejectionViaFallback()</h1><p><code>#handleThreadPoolRejectionViaFallback()</code> 方法，<code>thread-pool-rejection</code> ，处理<strong>线程池提交任务拒绝</strong>的回退逻辑，在 <a href="https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java#L990" rel="external nofollow noopener noreferrer" target="_blank">此处</a> 被调用，代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> Observable&lt;R&gt; <span class="title">handleThreadPoolRejectionViaFallback</span><span class="params">(Exception underlying)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// TODO 【2011】【Hystrix 事件机制】</span></div><div class="line"> <span class="number">3</span>:     eventNotifier.markEvent(HystrixEventType.THREAD_POOL_REJECTED, commandKey);</div><div class="line"> <span class="number">4</span>:     <span class="comment">// TODO 【2002】【metrics】</span></div><div class="line"> <span class="number">5</span>:     threadPool.markThreadRejection();</div><div class="line"> <span class="number">6</span>:     <span class="comment">// 获得 【回退逻辑 Observable】 或者 【异常 Observable】</span></div><div class="line"> <span class="number">7</span>:     <span class="comment">// use a fallback instead (or throw exception if not implemented)</span></div><div class="line"> <span class="number">8</span>:     <span class="keyword">return</span> getFallbackOrThrowException(<span class="keyword">this</span>, HystrixEventType.THREAD_POOL_REJECTED, FailureType.REJECTED_THREAD_EXECUTION,</div><div class="line"> <span class="number">9</span>:             <span class="string">"could not be queued for execution"</span>, underlying);</div><div class="line"><span class="number">10</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 3 行 ：TODO 【2011】【Hystrix 事件机制】</li><li>第 5 行 ：TODO 【2002】【metrics】</li><li>第 8 至 9 行 ：调用 <code>#getFallbackOrThrowException()</code> 方法，获得【回退逻辑 Observable】或者【异常 Observable】，在 <a href="#">「8. #getFallbackOrThrowException(...)」</a> 详细解析。</li></ul><h1>6. #handleTimeoutViaFallback()</h1><p><code>#handleTimeoutViaFallback()</code> 方法，<code>execution-timeout</code> ，处理<strong>命令执行超时</strong>的回退逻辑，在 <a href="https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java#L611" rel="external nofollow noopener noreferrer" target="_blank">此处</a> 被调用，代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="number">1</span>: <span class="function"><span class="keyword">private</span> Observable&lt;R&gt; <span class="title">handleTimeoutViaFallback</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">2</span>:     <span class="comment">// 获得 【回退逻辑 Observable】 或者 【异常 Observable】</span></div><div class="line"><span class="number">3</span>:     <span class="keyword">return</span> getFallbackOrThrowException(<span class="keyword">this</span>, HystrixEventType.TIMEOUT, FailureType.TIMEOUT,</div><div class="line"><span class="number">4</span>:             <span class="string">"timed-out"</span>, <span class="keyword">new</span> TimeoutException());</div><div class="line"><span class="number">5</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 3 至 4 行 ：调用 <code>#getFallbackOrThrowException()</code> 方法，获得【回退逻辑 Observable】或者【异常 Observable】，在 <a href="#">「8. #getFallbackOrThrowException(...)」</a> 详细解析。</li></ul><h1>7. #handleFailureViaFallback()</h1><p><code>#handleFailureViaFallback()</code> 方法，<code>execution-failure</code> ，处理<strong>命令执行异常</strong>的回退逻辑，在 <a href="https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java#L623" rel="external nofollow noopener noreferrer" target="_blank">此处</a> 被调用，代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> Observable&lt;R&gt; <span class="title">handleFailureViaFallback</span><span class="params">(Exception underlying)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// TODO 【2011】【Hystrix 事件机制】</span></div><div class="line"> <span class="number">3</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment"> 4:      * All other error handling</span></div><div class="line"><span class="comment"> 5:      */</span></div><div class="line"> <span class="number">6</span>:     logger.debug(<span class="string">"Error executing HystrixCommand.run(). Proceeding to fallback logic ..."</span>, underlying);</div><div class="line"> <span class="number">7</span>: </div><div class="line"> <span class="number">8</span>:     <span class="comment">// report failure</span></div><div class="line"> <span class="number">9</span>:     eventNotifier.markEvent(HystrixEventType.FAILURE, commandKey);</div><div class="line"><span class="number">10</span>: </div><div class="line"><span class="number">11</span>:     <span class="comment">// 标记 executionResult 异常 TODO 【2007】【executionResult】用途 为啥不是执行异常</span></div><div class="line"><span class="number">12</span>:     <span class="comment">// record the exception</span></div><div class="line"><span class="number">13</span>:     executionResult = executionResult.setException(underlying);</div><div class="line"><span class="number">14</span>:     <span class="comment">// 获得 【回退逻辑 Observable】 或者 【异常 Observable】</span></div><div class="line"><span class="number">15</span>:     <span class="keyword">return</span> getFallbackOrThrowException(<span class="keyword">this</span>, HystrixEventType.FAILURE, FailureType.COMMAND_EXCEPTION, <span class="string">"failed"</span>, underlying);</div><div class="line"><span class="number">16</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 2 至 9 行 ：TODO 【2011】【Hystrix 事件机制】</li><li>第 13 行 ：标记 <code>executionResult</code> <strong>异常</strong>。</li><li>第 15 行 ：调用 <code>#getFallbackOrThrowException()</code> 方法，获得【回退逻辑 Observable】或者【异常 Observable】，在 <a href="#">「8. #getFallbackOrThrowException(...)」</a> 详细解析。</li></ul><h1>8. #getFallbackOrThrowException(...)</h1><p><code>#getFallbackOrThrowException()</code> 方法，获得【回退逻辑 Observable】或者【异常 Observable】，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">private</span> Observable&lt;R&gt; <span class="title">getFallbackOrThrowException</span><span class="params">(<span class="keyword">final</span> AbstractCommand&lt;R&gt; _cmd, <span class="keyword">final</span> HystrixEventType eventType, <span class="keyword">final</span> FailureType failureType, <span class="keyword">final</span> String message, <span class="keyword">final</span> Exception originalException)</span> </span>&#123;</div><div class="line">  <span class="number">2</span>:     <span class="comment">// 记录 HystrixRequestContext</span></div><div class="line">  <span class="number">3</span>:     <span class="keyword">final</span> HystrixRequestContext requestContext = HystrixRequestContext.getContextForCurrentThread();</div><div class="line">  <span class="number">4</span>:     <span class="comment">// 标记 executionResult 添加( 记录 )事件</span></div><div class="line">  <span class="number">5</span>:     <span class="keyword">long</span> latency = System.currentTimeMillis() - executionResult.getStartTimestamp();</div><div class="line">  <span class="number">6</span>:     <span class="comment">// record the executionResult</span></div><div class="line">  <span class="number">7</span>:     <span class="comment">// do this before executing fallback so it can be queried from within getFallback (see See https://github.com/Netflix/Hystrix/pull/144)</span></div><div class="line">  <span class="number">8</span>:     executionResult = executionResult.addEvent((<span class="keyword">int</span>) latency, eventType);</div><div class="line">  <span class="number">9</span>: </div><div class="line"> <span class="number">10</span>:     <span class="keyword">if</span> (isUnrecoverable(originalException)) &#123; <span class="comment">// 无法恢复的异常</span></div><div class="line"> <span class="number">11</span>:         logger.error(<span class="string">"Unrecoverable Error for HystrixCommand so will throw HystrixRuntimeException and not apply fallback. "</span>, originalException);</div><div class="line"> <span class="number">12</span>: </div><div class="line"> <span class="number">13</span>:         <span class="comment">// TODO 【2003】【HOOK】</span></div><div class="line"> <span class="number">14</span>:         <span class="comment">/* executionHook for all errors */</span></div><div class="line"> <span class="number">15</span>:         Exception e = wrapWithOnErrorHook(failureType, originalException);</div><div class="line"> <span class="number">16</span>:         <span class="comment">// 返回 【异常 Observable】</span></div><div class="line"> <span class="number">17</span>:         <span class="keyword">return</span> Observable.error(<span class="keyword">new</span> HystrixRuntimeException(failureType, <span class="keyword">this</span>.getClass(), getLogMessagePrefix() + <span class="string">" "</span> + message + <span class="string">" and encountered unrecoverable error."</span>, e, <span class="keyword">null</span>));</div><div class="line"> <span class="number">18</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">19</span>:         <span class="keyword">if</span> (isRecoverableError(originalException)) &#123; <span class="comment">// 可恢复的异常</span></div><div class="line"> <span class="number">20</span>:             logger.warn(<span class="string">"Recovered from java.lang.Error by serving Hystrix fallback"</span>, originalException);</div><div class="line"> <span class="number">21</span>:         &#125;</div><div class="line"> <span class="number">22</span>: </div><div class="line"> <span class="number">23</span>:         <span class="keyword">if</span> (properties.fallbackEnabled().get()) &#123;</div><div class="line"> <span class="number">24</span>:             <span class="comment">/* fallback behavior is permitted so attempt */</span></div><div class="line"> <span class="number">25</span>: </div><div class="line"> <span class="number">26</span>:             <span class="comment">// 设置 HystrixRequestContext 的 Action</span></div><div class="line"> <span class="number">27</span>:             <span class="keyword">final</span> Action1&lt;Notification&lt;? <span class="keyword">super</span> R&gt;&gt; setRequestContext = <span class="keyword">new</span> Action1&lt;Notification&lt;? <span class="keyword">super</span> R&gt;&gt;() &#123;</div><div class="line"> <span class="number">28</span>:                 <span class="meta">@Override</span></div><div class="line"> <span class="number">29</span>:                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Notification&lt;? <span class="keyword">super</span> R&gt; rNotification)</span> </span>&#123;</div><div class="line"> <span class="number">30</span>:                     setRequestContextIfNeeded(requestContext);</div><div class="line"> <span class="number">31</span>:                 &#125;</div><div class="line"> <span class="number">32</span>:             &#125;;</div><div class="line"> <span class="number">33</span>: </div><div class="line"> <span class="number">34</span>:             <span class="comment">// TODO 【2007】【executionResult】用途</span></div><div class="line"> <span class="number">35</span>:             <span class="keyword">final</span> Action1&lt;R&gt; markFallbackEmit = <span class="keyword">new</span> Action1&lt;R&gt;() &#123;</div><div class="line"> <span class="number">36</span>:                 <span class="meta">@Override</span></div><div class="line"> <span class="number">37</span>:                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(R r)</span> </span>&#123;</div><div class="line"> <span class="number">38</span>:                     <span class="keyword">if</span> (shouldOutputOnNextEvents()) &#123;</div><div class="line"> <span class="number">39</span>:                         executionResult = executionResult.addEvent(HystrixEventType.FALLBACK_EMIT);</div><div class="line"> <span class="number">40</span>:                         eventNotifier.markEvent(HystrixEventType.FALLBACK_EMIT, commandKey);</div><div class="line"> <span class="number">41</span>:                     &#125;</div><div class="line"> <span class="number">42</span>:                 &#125;</div><div class="line"> <span class="number">43</span>:             &#125;;</div><div class="line"> <span class="number">44</span>: </div><div class="line"> <span class="number">45</span>:             <span class="comment">// TODO 【2007】【executionResult】用途</span></div><div class="line"> <span class="number">46</span>:             <span class="keyword">final</span> Action0 markFallbackCompleted = <span class="keyword">new</span> Action0() &#123;</div><div class="line"> <span class="number">47</span>:                 <span class="meta">@Override</span></div><div class="line"> <span class="number">48</span>:                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">49</span>:                     <span class="keyword">long</span> latency = System.currentTimeMillis() - executionResult.getStartTimestamp();</div><div class="line"> <span class="number">50</span>:                     eventNotifier.markEvent(HystrixEventType.FALLBACK_SUCCESS, commandKey);</div><div class="line"> <span class="number">51</span>:                     executionResult = executionResult.addEvent((<span class="keyword">int</span>) latency, HystrixEventType.FALLBACK_SUCCESS);</div><div class="line"> <span class="number">52</span>:                 &#125;</div><div class="line"> <span class="number">53</span>:             &#125;;</div><div class="line"> <span class="number">54</span>: </div><div class="line"> <span class="number">55</span>:             <span class="comment">// 处理异常 的 Func</span></div><div class="line"> <span class="number">56</span>:             <span class="keyword">final</span> Func1&lt;Throwable, Observable&lt;R&gt;&gt; handleFallbackError = <span class="keyword">new</span> Func1&lt;Throwable, Observable&lt;R&gt;&gt;() &#123;</div><div class="line"> <span class="number">57</span>:                 <span class="meta">@Override</span></div><div class="line"> <span class="number">58</span>:                 <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">(Throwable t)</span> </span>&#123;</div><div class="line"> <span class="number">59</span>:                     <span class="comment">// TODO 【2003】【HOOK】</span></div><div class="line"> <span class="number">60</span>:                     <span class="comment">/* executionHook for all errors */</span></div><div class="line"> <span class="number">61</span>:                     Exception e = wrapWithOnErrorHook(failureType, originalException);</div><div class="line"> <span class="number">62</span>:                     <span class="comment">// 获得 Exception</span></div><div class="line"> <span class="number">63</span>:                     Exception fe = getExceptionFromThrowable(t);</div><div class="line"> <span class="number">64</span>: </div><div class="line"> <span class="number">65</span>:                     <span class="keyword">long</span> latency = System.currentTimeMillis() - executionResult.getStartTimestamp();</div><div class="line"> <span class="number">66</span>:                     Exception toEmit;</div><div class="line"> <span class="number">67</span>: </div><div class="line"> <span class="number">68</span>:                     <span class="keyword">if</span> (fe <span class="keyword">instanceof</span> UnsupportedOperationException) &#123;</div><div class="line"> <span class="number">69</span>:                         <span class="comment">// TODO 【2011】【Hystrix 事件机制】</span></div><div class="line"> <span class="number">70</span>:                         logger.debug(<span class="string">"No fallback for HystrixCommand. "</span>, fe); <span class="comment">// debug only since we're throwing the exception and someone higher will do something with it</span></div><div class="line"> <span class="number">71</span>:                         eventNotifier.markEvent(HystrixEventType.FALLBACK_MISSING, commandKey);</div><div class="line"> <span class="number">72</span>:                         <span class="comment">// 标记 executionResult 添加( 记录 )事件 HystrixEventType.FALLBACK_MISSING</span></div><div class="line"> <span class="number">73</span>:                         executionResult = executionResult.addEvent((<span class="keyword">int</span>) latency, HystrixEventType.FALLBACK_MISSING);</div><div class="line"> <span class="number">74</span>: </div><div class="line"> <span class="number">75</span>:                         <span class="comment">// 创建 HystrixRuntimeException</span></div><div class="line"> <span class="number">76</span>:                         toEmit = <span class="keyword">new</span> HystrixRuntimeException(failureType, _cmd.getClass(), getLogMessagePrefix() + <span class="string">" "</span> + message + <span class="string">" and no fallback available."</span>, e, fe);</div><div class="line"> <span class="number">77</span>:                     &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">78</span>:                         <span class="comment">// TODO 【2011】【Hystrix 事件机制】</span></div><div class="line"> <span class="number">79</span>:                         logger.debug(<span class="string">"HystrixCommand execution "</span> + failureType.name() + <span class="string">" and fallback failed."</span>, fe);</div><div class="line"> <span class="number">80</span>:                         eventNotifier.markEvent(HystrixEventType.FALLBACK_FAILURE, commandKey);</div><div class="line"> <span class="number">81</span>:                         <span class="comment">// 标记 executionResult 添加( 记录 )事件 HystrixEventType.FALLBACK_FAILURE</span></div><div class="line"> <span class="number">82</span>:                         executionResult = executionResult.addEvent((<span class="keyword">int</span>) latency, HystrixEventType.FALLBACK_FAILURE);</div><div class="line"> <span class="number">83</span>: </div><div class="line"> <span class="number">84</span>:                         <span class="comment">// 创建 HystrixRuntimeException</span></div><div class="line"> <span class="number">85</span>:                         toEmit = <span class="keyword">new</span> HystrixRuntimeException(failureType, _cmd.getClass(), getLogMessagePrefix() + <span class="string">" "</span> + message + <span class="string">" and fallback failed."</span>, e, fe);</div><div class="line"> <span class="number">86</span>:                     &#125;</div><div class="line"> <span class="number">87</span>: </div><div class="line"> <span class="number">88</span>:                     <span class="comment">// <span class="doctag">NOTE:</span> we're suppressing fallback exception here</span></div><div class="line"> <span class="number">89</span>:                     <span class="keyword">if</span> (shouldNotBeWrapped(originalException)) &#123;</div><div class="line"> <span class="number">90</span>:                         <span class="keyword">return</span> Observable.error(e);</div><div class="line"> <span class="number">91</span>:                     &#125;</div><div class="line"> <span class="number">92</span>: </div><div class="line"> <span class="number">93</span>:                     <span class="keyword">return</span> Observable.error(toEmit);</div><div class="line"> <span class="number">94</span>:                 &#125;</div><div class="line"> <span class="number">95</span>:             &#125;;</div><div class="line"> <span class="number">96</span>: </div><div class="line"> <span class="number">97</span>:             <span class="comment">// 获得 TryableSemaphore</span></div><div class="line"> <span class="number">98</span>:             <span class="keyword">final</span> TryableSemaphore fallbackSemaphore = getFallbackSemaphore();</div><div class="line"> <span class="number">99</span>: </div><div class="line"><span class="number">100</span>:             <span class="comment">// 信号量释放Action</span></div><div class="line"><span class="number">101</span>:             <span class="keyword">final</span> AtomicBoolean semaphoreHasBeenReleased = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</div><div class="line"><span class="number">102</span>:             <span class="keyword">final</span> Action0 singleSemaphoreRelease = <span class="keyword">new</span> Action0() &#123;</div><div class="line"><span class="number">103</span>:                 <span class="meta">@Override</span></div><div class="line"><span class="number">104</span>:                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">105</span>:                     <span class="keyword">if</span> (semaphoreHasBeenReleased.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</div><div class="line"><span class="number">106</span>:                         fallbackSemaphore.release();</div><div class="line"><span class="number">107</span>:                     &#125;</div><div class="line"><span class="number">108</span>:                 &#125;</div><div class="line"><span class="number">109</span>:             &#125;;</div><div class="line"><span class="number">110</span>: </div><div class="line"><span class="number">111</span>:             Observable&lt;R&gt; fallbackExecutionChain;</div><div class="line"><span class="number">112</span>: </div><div class="line"><span class="number">113</span>:             <span class="comment">// acquire a permit</span></div><div class="line"><span class="number">114</span>:             <span class="keyword">if</span> (fallbackSemaphore.tryAcquire()) &#123;</div><div class="line"><span class="number">115</span>:                 <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">116</span>:                     <span class="keyword">if</span> (isFallbackUserDefined()) &#123;</div><div class="line"><span class="number">117</span>:                         executionHook.onFallbackStart(<span class="keyword">this</span>);</div><div class="line"><span class="number">118</span>:                         fallbackExecutionChain = getFallbackObservable();</div><div class="line"><span class="number">119</span>:                     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">120</span>:                         <span class="comment">//same logic as above without the hook invocation</span></div><div class="line"><span class="number">121</span>:                         fallbackExecutionChain = getFallbackObservable();</div><div class="line"><span class="number">122</span>:                     &#125;</div><div class="line"><span class="number">123</span>:                 &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line"><span class="number">124</span>:                     <span class="comment">//If hook or user-fallback throws, then use that as the result of the fallback lookup</span></div><div class="line"><span class="number">125</span>:                     fallbackExecutionChain = Observable.error(ex);</div><div class="line"><span class="number">126</span>:                 &#125;</div><div class="line"><span class="number">127</span>: </div><div class="line"><span class="number">128</span>:                 <span class="comment">// 获得 【回退逻辑 Observable】</span></div><div class="line"><span class="number">129</span>:                 <span class="keyword">return</span> fallbackExecutionChain</div><div class="line"><span class="number">130</span>:                         .doOnEach(setRequestContext)</div><div class="line"><span class="number">131</span>:                         .lift(<span class="keyword">new</span> FallbackHookApplication(_cmd)) <span class="comment">// TODO 【2003】【HOOK】</span></div><div class="line"><span class="number">132</span>:                         .lift(<span class="keyword">new</span> DeprecatedOnFallbackHookApplication(_cmd))</div><div class="line"><span class="number">133</span>:                         .doOnNext(markFallbackEmit)</div><div class="line"><span class="number">134</span>:                         .doOnCompleted(markFallbackCompleted)</div><div class="line"><span class="number">135</span>:                         .onErrorResumeNext(handleFallbackError) <span class="comment">//</span></div><div class="line"><span class="number">136</span>:                         .doOnTerminate(singleSemaphoreRelease)</div><div class="line"><span class="number">137</span>:                         .doOnUnsubscribe(singleSemaphoreRelease);</div><div class="line"><span class="number">138</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">139</span>:                <span class="keyword">return</span> handleFallbackRejectionByEmittingError();</div><div class="line"><span class="number">140</span>:             &#125;</div><div class="line"><span class="number">141</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">142</span>:             <span class="keyword">return</span> handleFallbackDisabledByEmittingError(originalException, failureType, message);</div><div class="line"><span class="number">143</span>:         &#125;</div><div class="line"><span class="number">144</span>:     &#125;</div><div class="line"><span class="number">145</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>耐心，这个方法看起来灰常长，也仅限于长，理解成难度很小。</p></li><li><p>第 3 行 ：记录 HystrixRequestContext 。</p></li><li><p>第 5 至 8 行 ：标记 <code>executionResult</code> 添加( 记录 )事件。</p></li><li><p>第 10 至 17 行 ：调用 <code>#isUnrecoverable(Exception)</code> 方法，若异常<strong>不可恢复</strong>，直接返回【异常 Observable】。点击 <a href="https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java#L1077" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看该方法。</p></li><li><p>第 19 至 21 行 ：调用 <code>#isRecoverableError(Exception)</code> 方法，若异常<strong>可恢复</strong>，打印 <code>WARN</code> 日志。点击 <a href="https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java#L1093" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看该方法。主要针对 <code>java.lang.Error</code> 情况，打印 <code>#isUnrecoverable(Exception)</code> 排除掉的 Error。</p></li><li><p>【<em>反向</em>】第 141 至 143 行 ：当配置 <code>HystrixCommandProperties.fallbackEnabled = false</code> ( 默认值 ：<code>true</code> ) ，即失败回退功能<strong>关闭</strong>，调用 <code>#handleFallbackDisabledByEmittingError()</code> ，返回【异常 Observable】。点击 <a href="https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java#L1047" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看该方法。</p></li><li><p>【<em>反向</em>】第 138 至 140 行 ：<strong>失败回退</strong>信号量( TryableSemaphore )【注意，不是<strong>正常执行</strong>信号量】使用失败，调用 <code>#handleFallbackRejectionByEmittingError()</code> ，返回【异常 Observable】。点击 <a href="https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java#L1038" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看该方法。</p></li><li><p>第 23 行 ：当配置 <code>HystrixCommandProperties.fallbackEnabled = true</code> ( 默认值 ：<code>true</code> ) ，即失败回退功能<strong>开启</strong>。</p></li><li><p>第 27 至 32 行 ：设置 HystrixRequestContext 的 Action ，使用<strong>第 3 行</strong>记录的 HystrixRequestContext 。</p></li><li><p>第 35 至 43 行 ：TODO 【2007】【executionResult】用途</p></li><li><p>第 46 至 53 行 ：TODO 【2007】【executionResult】用途</p></li><li><p>第 56 至 95 行 ：处理回退逻辑执行发生异常的 Func1 ，返回【异常 Observable】。</p><ul><li>第 61 行 ：TODO 【2003】【HOOK】</li><li>第 63 行 ：调用 <code>#getExceptionFromThrowable(Throwable)</code> 方法，获得 Exception 。若 <code>t</code> 的<strong>类型</strong>为 Throwable 时，包装成 Exception 。点击 <a href="https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java#L1978" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看该方法代码。</li><li>第 68 至 76 行 ：当 <code>fe</code> 的<strong>类型</strong>为 UnsupportedOperationException 时，使用 <code>e</code> + <code>fe</code> 创建 HystrixRuntimeException 。该异常发生于 <code>HystrixCommand#getFallback()</code> <strong>抽象方法</strong>未被覆写。</li><li>第 77 至 86 行 ：当 <code>fe</code> 的<strong>类型</strong>为其他异常时，使用 <code>e</code> + <code>fe</code> 创建 HystrixRuntimeException 。该异常发生于 <code>HystrixCommand#getFallback()</code> 执行发生异常。</li><li>第 89 至 91 行 ：调用 <code>#shouldNotBeWrapped()</code> 方法，判断 <code>originalException</code> 是 ExceptionNotWrappedByHystrix 的<strong>实现</strong>时，即<strong>要求</strong>返回的【异常 Observable】不使用 HystrixRuntimeException 包装。点击 <a href="https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java#L1057" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看该方法代码。</li><li>第 93 行 ：返回【异常 Observable】，使用 <code>toEmit</code> ( HystrixRuntimeException ) 为异常。</li></ul></li><li><p>第 98 行 ：调用 <code>#getFallbackSemaphore()</code> 方法，获得<strong>失败回退</strong>信号量( TryableSemaphore )对象，点击 <a href="https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java#L1241" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看该方法代码。TryableSemaphore 在 <a href="http://www.iocoder.cn/Hystrix/command-execute-first-run/?self">《Hystrix 源码解析 —— 命令执行（一）之正常执行逻辑》「3. TryableSemaphore」</a> 有详细解析。</p></li><li><p>第 100 至 109 行 ：信号量<strong>释放</strong>的 Action。</p></li><li><p>第 114 至 137 行 ：<strong>失败回退</strong>信号量( TryableSemaphore )使用成功，返回【回退逻辑 Observable】。</p><ul><li>【重要】第 116 至 122 行 ：调用 <code>#getFallbackObservable()</code> 方法，创建【回退逻辑 Observable】。将子类对 <code>HystrixCommand#getFallback()</code> <strong>抽象方法</strong>的执行结果，使用 <code>Observable#just(...)</code> 包装返回。点击 <a href="https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommand.java#L314" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看该方法的代码。<ul><li>第 116 行 ：调用 <code>#isFallbackUserDefined()</code> 方法，返回<strong>命令子类</strong>是否实现 <code>HystrixCommand#getFallback()</code> <strong>抽象方法</strong>。只有已实现( <code>true</code> ) 的情况下，调用 HOOK TODO 【2003】【HOOK】。</li></ul></li><li>第 129 至 137 行 ：获得 【回退逻辑 Observable】。<ul><li>第 131 行 ：// TODO 【2003】【HOOK】</li><li>第 135 行 ：调用 <code>Observable#onErrorResumeNext(...)</code> 方法，实现【失败回退 Observable】执行异常时，返回【异常 Observable】。</li></ul></li></ul></li></ul><hr><p>有两个注意点：</p><ul><li>当命令执行<strong>超时</strong>时，失败回退逻辑使用的是 <strong>HystrixTimer 的线程池</strong>。</li><li>失败回退逻辑，无超时时间，使用要小心。</li></ul><h1>666. 彩蛋</h1><p>比想象中“臭长”的逻辑。</p><p>总的来说，逻辑和 <a href="http://www.iocoder.cn/Hystrix/command-execute-first-run/?self">《Hystrix 源码解析 —— 命令执行（一）之正常执行逻辑》</a> 是很类似的。</p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/Hystrix/command-execute-fourth-fallback/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 Hystrix 1.5.X 版本&lt;/stron
      
    
    </summary>
    
      <category term="Hystrix" scheme="http://www.iocoder.cn/categories/Hystrix/"/>
    
    
  </entry>
  
  <entry>
    <title>Hystrix 源码解析 —— 命令执行（三）之执行超时</title>
    <link href="http://www.iocoder.cn/Hystrix/command-execute-third-timeout/"/>
    <id>http://www.iocoder.cn/Hystrix/command-execute-third-timeout/</id>
    <published>2018-10-27T16:00:00.000Z</published>
    <updated>2017-11-08T09:55:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/Hystrix/command-execute-third-timeout/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Hystrix 1.5.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Hystrix/command-execute-third-timeout/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-third-timeout/">2. HystrixObservableTimeoutOperator</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-third-timeout/">3. HystrixTimer</a><ul><li><a href="http://www.iocoder.cn/Hystrix/command-execute-third-timeout/">3.1 ScheduledExecutor</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-third-timeout/">3.2 TimerListener</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-third-timeout/">3.3 TimerReference</a></li></ul></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-third-timeout/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p>本文主要分享 <strong>Hystrix 命令执行（三）之执行超时</strong>。</p><p>建议 ：对 RxJava 已经有一定的了解的基础上阅读本文。</p><p>开启<strong>执行超时</strong>功能，需要配置 ：</p><ul><li><code>HystrixCommandProperties.executionTimeoutEnabled</code> ：执行命令超时功能开关。<ul><li>值 ：Boolean</li><li>默认值 ：<code>true</code></li></ul></li><li><code>HystrixCommandProperties.executionTimeoutInMilliseconds</code> ：执行命令超时时长。<ul><li>值 ：Integer</li><li>单位 ：毫秒</li><li>默认值 ：1000 毫秒</li></ul></li></ul><p>在 <a href="http://www.iocoder.cn/Hystrix/command-execute-first-run/?self">《Hystrix 源码解析 —— 命令执行（一）之正常执行逻辑》「4. #executeCommandAndObserve(…)」</a> 中，<code>#executeCommandAndObserve(...)</code> 方法的<strong>第 75 行</strong> <code>lift(new HystrixObservableTimeoutOperator&lt;R&gt;(_cmd))</code> ，实现了对执行命令超时的监控。</p><ul><li>对 <code>Observable#lift(Operator)</code> 方法不熟悉的同学，在 <a href="http://www.iocoder.cn/RxJava/observable-lift-operator/?self">《RxJava 源码解析 —— Observable#lift(Operator)》</a> 有详细解析。</li></ul><hr><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1>2. HystrixObservableTimeoutOperator</h1><p>HystrixObservableTimeoutOperator 类，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">  <span class="number">1</span>: <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixObservableTimeoutOperator</span>&lt;<span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">Operator</span>&lt;<span class="title">R</span>, <span class="title">R</span>&gt; </span>&#123;</div><div class="line">  <span class="number">2</span>: </div><div class="line">  <span class="number">3</span>:     <span class="keyword">final</span> AbstractCommand&lt;R&gt; originalCommand;</div><div class="line">  <span class="number">4</span>: </div><div class="line">  <span class="number">5</span>:     <span class="function"><span class="keyword">public</span> <span class="title">HystrixObservableTimeoutOperator</span><span class="params">(<span class="keyword">final</span> AbstractCommand&lt;R&gt; originalCommand)</span> </span>&#123;</div><div class="line">  <span class="number">6</span>:         <span class="keyword">this</span>.originalCommand = originalCommand;</div><div class="line">  <span class="number">7</span>:     &#125;</div><div class="line">  <span class="number">8</span>: </div><div class="line">  <span class="number">9</span>:     <span class="meta">@Override</span></div><div class="line"> <span class="number">10</span>:     <span class="keyword">public</span> Subscriber&lt;? <span class="keyword">super</span> R&gt; call(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> R&gt; child) &#123;</div><div class="line"> <span class="number">11</span>:         <span class="comment">// 创建 订阅</span></div><div class="line"> <span class="number">12</span>:         <span class="keyword">final</span> CompositeSubscription s = <span class="keyword">new</span> CompositeSubscription();</div><div class="line"> <span class="number">13</span>:         <span class="comment">// 添加 订阅</span></div><div class="line"> <span class="number">14</span>:         <span class="comment">// if the child unsubscribes we unsubscribe our parent as well</span></div><div class="line"> <span class="number">15</span>:         child.add(s);</div><div class="line"> <span class="number">16</span>: </div><div class="line"> <span class="number">17</span>:         <span class="comment">//capture the HystrixRequestContext upfront so that we can use it in the timeout thread later</span></div><div class="line"> <span class="number">18</span>:         <span class="keyword">final</span> HystrixRequestContext hystrixRequestContext = HystrixRequestContext.getContextForCurrentThread();</div><div class="line"> <span class="number">19</span>: </div><div class="line"> <span class="number">20</span>:         TimerListener listener = <span class="keyword">new</span> TimerListener() &#123;</div><div class="line"> <span class="number">21</span>: </div><div class="line"> <span class="number">22</span>:             <span class="meta">@Override</span></div><div class="line"> <span class="number">23</span>:             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tick</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">24</span>:                 <span class="comment">// if we can go from NOT_EXECUTED to TIMED_OUT then we do the timeout codepath</span></div><div class="line"> <span class="number">25</span>:                 <span class="comment">// otherwise it means we lost a race and the run() execution completed or did not start</span></div><div class="line"> <span class="number">26</span>:                 <span class="keyword">if</span> (originalCommand.isCommandTimedOut.compareAndSet(TimedOutStatus.NOT_EXECUTED, TimedOutStatus.TIMED_OUT)) &#123;</div><div class="line"> <span class="number">27</span>:                     <span class="comment">// report timeout failure</span></div><div class="line"> <span class="number">28</span>:                     originalCommand.eventNotifier.markEvent(HystrixEventType.TIMEOUT, originalCommand.commandKey);</div><div class="line"> <span class="number">29</span>: </div><div class="line"> <span class="number">30</span>:                     <span class="comment">// shut down the original request</span></div><div class="line"> <span class="number">31</span>:                     s.unsubscribe();</div><div class="line"> <span class="number">32</span>: </div><div class="line"> <span class="number">33</span>:                     <span class="keyword">final</span> HystrixContextRunnable timeoutRunnable = <span class="keyword">new</span> HystrixContextRunnable(originalCommand.concurrencyStrategy, hystrixRequestContext, <span class="keyword">new</span> Runnable() &#123;</div><div class="line"> <span class="number">34</span>: </div><div class="line"> <span class="number">35</span>:                         <span class="meta">@Override</span></div><div class="line"> <span class="number">36</span>:                         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">37</span>:                             child.onError(<span class="keyword">new</span> HystrixTimeoutException());</div><div class="line"> <span class="number">38</span>:                         &#125;</div><div class="line"> <span class="number">39</span>:                     &#125;);</div><div class="line"> <span class="number">40</span>: </div><div class="line"> <span class="number">41</span>:                     timeoutRunnable.run();</div><div class="line"> <span class="number">42</span>:                     <span class="comment">//if it did not start, then we need to mark a command start for concurrency metrics, and then issue the timeout</span></div><div class="line"> <span class="number">43</span>:                 &#125;</div><div class="line"> <span class="number">44</span>:             &#125;</div><div class="line"> <span class="number">45</span>: </div><div class="line"> <span class="number">46</span>:             <span class="meta">@Override</span></div><div class="line"> <span class="number">47</span>:             <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIntervalTimeInMilliseconds</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">48</span>:                 <span class="keyword">return</span> originalCommand.properties.executionTimeoutInMilliseconds().get();</div><div class="line"> <span class="number">49</span>:             &#125;</div><div class="line"> <span class="number">50</span>:         &#125;;</div><div class="line"> <span class="number">51</span>: </div><div class="line"> <span class="number">52</span>:         <span class="keyword">final</span> Reference&lt;TimerListener&gt; tl = HystrixTimer.getInstance().addTimerListener(listener);</div><div class="line"> <span class="number">53</span>: </div><div class="line"> <span class="number">54</span>:         <span class="comment">// set externally so execute/queue can see this</span></div><div class="line"> <span class="number">55</span>:         originalCommand.timeoutTimer.set(tl);</div><div class="line"> <span class="number">56</span>: </div><div class="line"> <span class="number">57</span>:         <span class="comment">/**</span></div><div class="line"><span class="comment"> 58:          * If this subscriber receives values it means the parent succeeded/completed</span></div><div class="line"><span class="comment"> 59:          */</span></div><div class="line"> <span class="number">60</span>:         Subscriber&lt;R&gt; parent = <span class="keyword">new</span> Subscriber&lt;R&gt;() &#123;</div><div class="line"> <span class="number">61</span>: </div><div class="line"> <span class="number">62</span>:             <span class="meta">@Override</span></div><div class="line"> <span class="number">63</span>:             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">64</span>:                 <span class="keyword">if</span> (isNotTimedOut()) &#123;</div><div class="line"> <span class="number">65</span>:                     <span class="comment">// stop timer and pass notification through</span></div><div class="line"> <span class="number">66</span>:                     tl.clear();</div><div class="line"> <span class="number">67</span>:                     <span class="comment">// 完成</span></div><div class="line"> <span class="number">68</span>:                     child.onCompleted();</div><div class="line"> <span class="number">69</span>:                 &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">70</span>:                     System.out.println(<span class="string">"timeout: "</span> + <span class="string">"onCompleted"</span>); <span class="comment">// 笔者调试用</span></div><div class="line"> <span class="number">71</span>:                 &#125; </div><div class="line"> <span class="number">72</span>:             &#125;</div><div class="line"> <span class="number">73</span>: </div><div class="line"> <span class="number">74</span>:             <span class="meta">@Override</span></div><div class="line"> <span class="number">75</span>:             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line"> <span class="number">76</span>:                 <span class="keyword">if</span> (isNotTimedOut()) &#123;</div><div class="line"> <span class="number">77</span>:                     <span class="comment">// stop timer and pass notification through</span></div><div class="line"> <span class="number">78</span>:                     tl.clear();</div><div class="line"> <span class="number">79</span>:                     <span class="comment">// 异常</span></div><div class="line"> <span class="number">80</span>:                     child.onError(e);</div><div class="line"> <span class="number">81</span>:                 &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">82</span>:                     System.out.println(<span class="string">"timeout: "</span> + <span class="string">"onError"</span>); <span class="comment">// 笔者调试用</span></div><div class="line"> <span class="number">83</span>:                 &#125; </div><div class="line"> <span class="number">84</span>:             &#125;</div><div class="line"> <span class="number">85</span>: </div><div class="line"> <span class="number">86</span>:             <span class="meta">@Override</span></div><div class="line"> <span class="number">87</span>:             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(R v)</span> </span>&#123;</div><div class="line"> <span class="number">88</span>:                 <span class="keyword">if</span> (isNotTimedOut()) &#123;</div><div class="line"> <span class="number">89</span>:                     <span class="comment">// 继续执行</span></div><div class="line"> <span class="number">90</span>:                     child.onNext(v);</div><div class="line"> <span class="number">91</span>:                 &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">92</span>:                     System.out.println(<span class="string">"timeout: "</span> + <span class="string">"onNext"</span>); <span class="comment">// 笔者调试用</span></div><div class="line"> <span class="number">93</span>:                 &#125;</div><div class="line"> <span class="number">94</span>:             &#125;</div><div class="line"> <span class="number">95</span>: </div><div class="line"> <span class="number">96</span>:             <span class="comment">/**</span></div><div class="line"><span class="comment"> 97:              * 通过 CAS 判断是否超时</span></div><div class="line"><span class="comment"> 98:              *</span></div><div class="line"><span class="comment"> 99:              * <span class="doctag">@return</span> 是否超时</span></div><div class="line"><span class="comment">100:              */</span></div><div class="line"><span class="number">101</span>:             <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isNotTimedOut</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">102</span>:                 <span class="comment">// if already marked COMPLETED (by onNext) or succeeds in setting to COMPLETED</span></div><div class="line"><span class="number">103</span>:                 <span class="keyword">return</span> originalCommand.isCommandTimedOut.get() == TimedOutStatus.COMPLETED ||</div><div class="line"><span class="number">104</span>:                         originalCommand.isCommandTimedOut.compareAndSet(TimedOutStatus.NOT_EXECUTED, TimedOutStatus.COMPLETED);</div><div class="line"><span class="number">105</span>:             &#125;</div><div class="line"><span class="number">106</span>: </div><div class="line"><span class="number">107</span>:         &#125;;</div><div class="line"><span class="number">108</span>: </div><div class="line"><span class="number">109</span>:         <span class="comment">// 添加 订阅</span></div><div class="line"><span class="number">110</span>:         <span class="comment">// if s is unsubscribed we want to unsubscribe the parent</span></div><div class="line"><span class="number">111</span>:         s.add(parent);</div><div class="line"><span class="number">112</span>: </div><div class="line"><span class="number">113</span>:         <span class="keyword">return</span> parent;</div><div class="line"><span class="number">114</span>:     &#125;</div><div class="line"><span class="number">115</span>: </div><div class="line"><span class="number">116</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 12 行 ：创建订阅 <code>s</code> 。</p></li><li><p>第 15 行 ：添加订阅 <code>s</code> 到 <code>child</code> 的订阅。</p></li><li><p>第 18 行 ：获得 HystrixRequestContext 。因为下面 <code>listener</code> 的执行不在当前线程，HystrixRequestContext 基于 ThreadLocal 实现。</p></li><li><p>第 20 至 50 行 ：创建执行命令超时<strong>监听器</strong> <code>listener</code> ( TimerListener ) 。当超过执行命令的时长( <code>TimerListener#getIntervalTimeInMilliseconds()</code> )时，<code>TimerListener#tick()</code> 方法<strong>触发</strong>调用。</p><ul><li>第 26 行 ：通过 <code>AbstractCommand.isCommandTimedOut</code> 变量 CAS 操作，保证和下面<strong>第 60 行</strong>的 <code>parent</code> 有且只有一方操作成功。TimedOutStatus 状态变迁如下图 ：<img src="http://www.iocoder.cn/images/Hystrix/2018_10_28/01.png" alt=""></li><li>第 28 行 ：TODO 【2011】【Hystrix 事件机制】</li><li>第 31 行 ：取消订阅 <code>s</code> 。<strong>注意 ：不同执行隔离策略此处的表现不同</strong>。<ul><li><code>ExecutionIsolationStrategy.THREAD</code> ：该策略下提供取消订阅( <code>#unsubscribe()</code> )，并且命令执行超时，<strong>强制</strong>取消命令的执行。在 <a href="http://www.iocoder.cn/Hystrix/command-execute-second-isolation-strategy/?self">《Hystrix 源码解析 —— 命令执行（二）之执行隔离策略》「6.5 FutureCompleterWithConfigurableInterrupt」</a> 有详细解析。</li><li><code>ExecutionIsolationStrategy.SEMAPHORE</code> ：该策略下<strong>未</strong>提供取消订阅( <code>#unsubscribe()</code> )时，对超时执行命令的取消。<strong>所以，在选择执行隔离策略，要注意这块</strong>。</li></ul></li><li>第 34 至 41 行 ：执行 <code>child#onError(e) 【Subscriber#onError(Throwable)】</code> 方法，处理 HystrixTimeoutException 异常。该异常会被 <code>handleFallback</code> 处理，点击 <a href="https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java#L602" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看，在 <a href="http://www.iocoder.cn/Hystrix/command-execute-fourth-fallback/?self">《Hystrix 源码解析 —— 请求执行（四）之失败回退逻辑》</a> 详细解析。<ul><li>HystrixContextRunnable ，设置<strong>第 18 行</strong>获得的 HystrixRequestContext 到 <code>Callable#run()</code> 所在线程的 HystrixRequestContext ，并继续执行。点击 <a href="https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixContextRunnable.java#L27" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看。另外，HystrixContextRunnable 只有此处使用，独立成类的原因是测试用例使用到。</li></ul></li></ul></li><li><p>第 52 行 ：使用 TimerListener 到定时器，监听命令的超时执行。</p></li><li><p>第 55 行 ：设置 TimerListener 到 <code>AbstractCommand.timeoutTimer</code> 属性。用于执行超时等等场景下的 TimerListener 的清理( <code>tl#clear()</code> )。如下方法有通过该属性对 TimerListener 的清理 ：</p><ul><li><a href="https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java#L947" rel="external nofollow noopener noreferrer" target="_blank"><code>AbstractCommand#handleCommandEnd()</code></a></li><li><a href="https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java#L930" rel="external nofollow noopener noreferrer" target="_blank"><code>AbstractCommand#cleanUpAfterResponseFromCache()</code></a></li></ul></li><li><p>第 60 至 107 行 ：创建<strong>新</strong>的 Subscriber ( <code>parent</code> )。在传参的 <code>child</code> 的基础上，增加了对是否执行超时的判断( <code>#isNotTimedOut()</code> )和TimerListener的清理。</p></li><li><p>第 111 行 ：添加添加订阅 <code>parent</code> 到 <code>s</code> 的订阅。整体订阅关系如下 ：<img src="http://www.iocoder.cn/images/Hystrix/2018_10_28/02.png" alt=""></p><ul><li>这里看起来 <code>s</code> 有些“多余” ？因为 <code>parent</code> 和 <code>listener</code> 存在互相引用的情况，通过 <code>s</code> 解决。</li></ul></li><li><p>第 113 行 ：返回 <code>parent</code> 。<strong>注意</strong>。如果不能理解，建议阅读下 <a href="http://www.iocoder.cn/RxJava/observable-lift-operator/?self">《RxJava 源码解析 —— Observable#lift(Operator)》</a> 。</p></li></ul><h1>3. HystrixTimer</h1><p><code>com.netflix.hystrix.util.HystrixTimer</code> ，Hystrix 定时器。</p><p>目前有如下场景使用 ：</p><ul><li>执行命令超时任务，本文详细解析。</li><li>命令批量执行，在 <a href="http://www.iocoder.cn/Hystrix/command-collapser-execute?self">《Hystrix 源码解析 —— 命令合并执行》「5. CollapsedTask」</a> 详细解析。</li></ul><p>HystrixTimer <strong>构造方法</strong>，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixTimer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 单例</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HystrixTimer INSTANCE = <span class="keyword">new</span> HystrixTimer();</div><div class="line"></div><div class="line">    <span class="comment">/* package */</span> AtomicReference&lt;ScheduledExecutor&gt; executor = <span class="keyword">new</span> AtomicReference&lt;ScheduledExecutor&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HystrixTimer</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// private to prevent public instantiation</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HystrixTimer <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> INSTANCE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><code>INSTANCE</code> <strong>静态</strong>属性，单例。</li><li><code>executor</code> 属性，定时任务<strong>执行器</strong>( ScheduledExecutor )。</li></ul><hr><p>调用 <code>HystrixTimer#addTimerListener(TimerListener)</code> 方法，提交定时<strong>监听器</strong>，生成定时<strong>任务</strong>，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> Reference&lt;TimerListener&gt; <span class="title">addTimerListener</span><span class="params">(<span class="keyword">final</span> TimerListener listener)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     startThreadIfNeeded();</div><div class="line"> <span class="number">3</span>:     <span class="comment">// add the listener</span></div><div class="line"> <span class="number">4</span>: </div><div class="line"> <span class="number">5</span>:     Runnable r = <span class="keyword">new</span> Runnable() &#123;</div><div class="line"> <span class="number">6</span>: </div><div class="line"> <span class="number">7</span>:         <span class="meta">@Override</span></div><div class="line"> <span class="number">8</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">9</span>:             <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">10</span>:                 listener.tick();</div><div class="line"><span class="number">11</span>:             &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"><span class="number">12</span>:                 logger.error(<span class="string">"Failed while ticking TimerListener"</span>, e);</div><div class="line"><span class="number">13</span>:             &#125;</div><div class="line"><span class="number">14</span>:         &#125;</div><div class="line"><span class="number">15</span>:     &#125;;</div><div class="line"><span class="number">16</span>: </div><div class="line"><span class="number">17</span>:     ScheduledFuture&lt;?&gt; f = executor.get().getThreadPool().scheduleAtFixedRate(r, listener.getIntervalTimeInMilliseconds(), listener.getIntervalTimeInMilliseconds(), TimeUnit.MILLISECONDS);</div><div class="line"><span class="number">18</span>:     <span class="keyword">return</span> <span class="keyword">new</span> TimerReference(listener, f);</div><div class="line"><span class="number">19</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 2 行 ：调用 <code>#startThreadIfNeeded()</code> 方法，保证 <code>executor</code> <strong>延迟</strong>初始化已完成。<ul><li><code>#startThreadIfNeeded()</code> 方法 ，比较简单，点击 <a href="https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/util/HystrixTimer.java#L133" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看。</li><li>ScheduledExecutor 在 <a href="#">「3.1 ScheduledExecutor」</a> 详细解析。</li></ul></li><li>第 5 至 15 行 ：创建定时任务 Runnable 。在 <code>Runnable#run()</code> 方法里，调用 <code>TimerListener#tick()</code> 方法。在 <a href="#">「3.2 TimerListener」</a> 详细解析。</li><li>第 17 行 ：提交定时<strong>监听器</strong>，生成定时<strong>任务</strong> <code>f</code> ( ScheduledFuture )。</li><li>第 18 行 ：使用 <code>listener</code> + <code>f</code> 创建 TimerReference 返回。在 <a href="#">「3.3 TimerReference」</a> 详细解析。</li></ul><h2>3.1 ScheduledExecutor</h2><p><code>com.netflix.hystrix.util.HystrixTimer.ScheduledExecutor</code> ，Hystrix 定时任务<strong>执行器</strong>。代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/* package */</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledExecutor</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">    * 定时任务线程池执行器</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    <span class="comment">/* package */</span> <span class="keyword">volatile</span> ScheduledThreadPoolExecutor executor;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 是否初始化</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> initialized;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * We want this only done once when created in compareAndSet so use an initialize method</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// coreSize</span></div><div class="line">        HystrixPropertiesStrategy propertiesStrategy = HystrixPlugins.getInstance().getPropertiesStrategy();</div><div class="line">        <span class="keyword">int</span> coreSize = propertiesStrategy.getTimerThreadPoolProperties().getCorePoolSize().get();</div><div class="line"></div><div class="line">        <span class="comment">// 创建 ThreadFactory</span></div><div class="line">        ThreadFactory threadFactory = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (!PlatformSpecific.isAppEngineStandardEnvironment()) &#123;</div><div class="line">            threadFactory = <span class="keyword">new</span> ThreadFactory() &#123;</div><div class="line">                <span class="keyword">final</span> AtomicInteger counter = <span class="keyword">new</span> AtomicInteger();</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">                    Thread thread = <span class="keyword">new</span> Thread(r, <span class="string">"HystrixTimer-"</span> + counter.incrementAndGet());</div><div class="line">                    thread.setDaemon(<span class="keyword">true</span>);</div><div class="line">                    <span class="keyword">return</span> thread;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            threadFactory = PlatformSpecific.getAppEngineThreadFactory();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 创建 ScheduledThreadPoolExecutor</span></div><div class="line">        executor = <span class="keyword">new</span> ScheduledThreadPoolExecutor(coreSize, threadFactory);</div><div class="line"></div><div class="line">        <span class="comment">// 已初始化</span></div><div class="line">        initialized = <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> ScheduledThreadPoolExecutor <span class="title">getThreadPool</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> executor;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInitialized</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> initialized;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>线程池大小( <code>coreSize</code> )，通过 <code>HystrixTimerThreadPoolProperties.corePoolSize</code> 配置。</li></ul><h2>3.2 TimerListener</h2><p><code>com.netflix.hystrix.util.HystrixTimer.TimerListener</code> ，Hystrix 定时任务<strong>监听器</strong><strong>接口</strong>。代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">TimerListener</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * The 'tick' is called each time the interval occurs.</span></div><div class="line"><span class="comment">    * &lt;p&gt;</span></div><div class="line"><span class="comment">    * This method should NOT block or do any work but instead fire its work asynchronously to perform on another thread otherwise it will prevent the Timer from functioning.</span></div><div class="line"><span class="comment">    * &lt;p&gt;</span></div><div class="line"><span class="comment">    * This contract is used to keep this implementation single-threaded and simplistic.</span></div><div class="line"><span class="comment">    * &lt;p&gt;</span></div><div class="line"><span class="comment">    * If you need a ThreadLocal set, you can store the state in the TimerListener, then when tick() is called, set the ThreadLocal to your desired value.</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">tick</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * How often this TimerListener should 'tick' defined in milliseconds.</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="function"><span class="keyword">int</span> <span class="title">getIntervalTimeInMilliseconds</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><code>#tick()</code> 方法 ：时间到达( <strong>超时</strong> )执行的逻辑。</li><li><code>#getIntervalTimeInMilliseconds()</code> 方法 ：返回到达( <strong>超时</strong> )时间时长。</li></ul><h2>3.3 TimerReference</h2><p><code>com.netflix.hystrix.util.HystrixTimer.TimerReference</code> ，Hystrix 定时任务<strong>引用</strong>。代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerReference</span> <span class="keyword">extends</span> <span class="title">SoftReference</span>&lt;<span class="title">TimerListener</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledFuture&lt;?&gt; f;</div><div class="line"></div><div class="line">    TimerReference(TimerListener referent, ScheduledFuture&lt;?&gt; f) &#123;</div><div class="line">        <span class="keyword">super</span>(referent);</div><div class="line">        <span class="keyword">this</span>.f = f;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.clear();</div><div class="line">        <span class="comment">// stop this ScheduledFuture from any further executions</span></div><div class="line">        f.cancel(<span class="keyword">false</span>); <span class="comment">// 非强制</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>通过 <code>#clear()</code> 方法，可以取消定时任务的执行。</li></ul><h1>666. 彩蛋</h1><p>顺畅~刚开始看 Hystrix 执行命令超时逻辑，一直想不通。现在整理干净了。</p><p>喵了个咪~</p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/Hystrix/command-execute-third-timeout/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 Hystrix 1.5.X 版本&lt;/strong&gt;
      
    
    </summary>
    
      <category term="Hystrix" scheme="http://www.iocoder.cn/categories/Hystrix/"/>
    
    
  </entry>
  
  <entry>
    <title>Hystrix 源码解析 —— 命令执行（二）之执行隔离策略</title>
    <link href="http://www.iocoder.cn/Hystrix/command-execute-second-isolation-strategy/"/>
    <id>http://www.iocoder.cn/Hystrix/command-execute-second-isolation-strategy/</id>
    <published>2018-10-24T16:00:00.000Z</published>
    <updated>2017-11-06T10:40:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/Hystrix/command-execute-second-isolation-strategy/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Hystrix 1.5.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Hystrix/command-execute-second-isolation-strategy/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-second-isolation-strategy/">2. HystrixThreadPoolProperties</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-second-isolation-strategy/">3. HystrixThreadPoolKey</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-second-isolation-strategy/">4. HystrixConcurrencyStrategy</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-second-isolation-strategy/">5. HystrixThreadPool</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-second-isolation-strategy/">6. HystrixScheduler</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-second-isolation-strategy/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p>本文主要分享 <strong>Hystrix 命令执行（二）之执行隔离策略</strong>。</p><p>建议 ：对 RxJava 已经有一定的了解的基础上阅读本文。</p><p>Hystrix 提供两种执行隔离策略( ExecutionIsolationStrategy ) ：</p><ul><li><code>SEMAPHORE</code> ：信号量，命令在<strong>调用线程</strong>执行。在<a href="http://www.iocoder.cn/Hystrix/command-execute-first-run/?self">《Hystrix 源码解析 —— 命令执行（一）之正常执行逻辑》「3. TryableSemaphore」</a> 已经详细解析。</li><li><code>THREAD</code> ：线程池，命令在<strong>线程池</strong>执行。在<a href="http://www.iocoder.cn/Hystrix/command-execute-first-run/?self">《Hystrix 源码解析 —— 命令执行（一）之正常执行逻辑》「5. #executeCommandWithSpecifiedIsolation(...)」</a> 的 <code>#executeCommandWithSpecifiedIsolation(...)</code> 方法中，调用 <code>Observable#subscribeOn(Scheduler)</code> 方法，指定在 RxJava Scheduler 执行。<ul><li>如果你暂时不了解 Scheduler ，可以阅读 <a href="http://www.iocoder.cn/RxJava/scheduler/?self">《RxJava 源码解析 —— Scheduler》</a> 。</li><li>如果你暂时不了解 <code>Observable#subscribeOn(Scheduler)</code> ，可以阅读 <a href="http://www.iocoder.cn/RxJava/observable-subscribe-on-scheduler/?self">《RxJava 源码解析 —— Observable#subscribeOn(Scheduler)》</a> 。</li></ul></li></ul><p>两种方式的<strong>优缺点比较</strong>，推荐阅读 <a href="http://youdang.github.io/2016/02/05/translate-hystrix-wiki-how-it-works/#%E4%BE%9D%E8%B5%96%E9%9A%94%E7%A6%BB" rel="external nofollow noopener noreferrer" target="_blank">《【翻译】Hystrix文档-实现原理》「依赖隔离」</a>。</p><hr><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1>2. HystrixThreadPoolProperties</h1><p><code>com.netflix.hystrix.HystrixThreadPoolProperties</code> ，Hystrix 线程池属性配置<strong>抽象类</strong>，点击 <a href="https://github.com/YunaiV/Hystrix/blob/ba86690747b365482c306ec3a0725e0be4bab739/hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPoolProperties.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看，已添加中文注释说明。</p><p><code>com.netflix.hystrix.strategy.properties.HystrixPropertiesThreadPoolDefault</code> ，Hystrix 线程池配置<strong>实现类</strong>，点击 <a href="https://github.com/YunaiV/Hystrix/blob/ba86690747b365482c306ec3a0725e0be4bab739/hystrix-core/src/main/java/com/netflix/hystrix/strategy/properties/HystrixPropertiesThreadPoolDefault.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看。实际上没什么内容，官方如是说 ：</p><blockquote><p>Default implementation of {@link HystrixThreadPoolProperties} using Archaius (https://github.com/Netflix/archaius)</p></blockquote><h1>3. HystrixThreadPoolKey</h1><p><code>com.netflix.hystrix.HystrixThreadPoolKey</code> ，Hystrix 线程池标识<strong>接口</strong>。</p><blockquote><p>FROM HystrixThreadPoolKey 接口注释<br>A key to represent a {@link HystrixThreadPool} for monitoring, metrics publishing, caching and other such uses.<br>This interface is intended to work natively with Enums so that implementing code can be an enum that implements this interface.</p></blockquote><ul><li>直白的说 ，希望通过相同的 <code>name</code> ( 标识 ) 获得同 HystrixThreadPoolKey 对象。通过在内部维持一个 <code>name</code> 与 HystrixThreadPoolKey 对象的映射，以达到<strong>枚举</strong>的效果。</li></ul><p>HystrixThreadPoolKey 代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HystrixThreadPoolKey</span> <span class="keyword">extends</span> <span class="title">HystrixKey</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:         <span class="function"><span class="keyword">private</span> <span class="title">Factory</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">4</span>:         &#125;</div><div class="line"> <span class="number">5</span>: </div><div class="line"> <span class="number">6</span>:         <span class="comment">// used to intern instances so we don't keep re-creating them millions of times for the same key</span></div><div class="line"> <span class="number">7</span>:         <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InternMap&lt;String, HystrixThreadPoolKey&gt; intern</div><div class="line"> <span class="number">8</span>:                 = <span class="keyword">new</span> InternMap&lt;String, HystrixThreadPoolKey&gt;(</div><div class="line"> <span class="number">9</span>:                 <span class="keyword">new</span> InternMap.ValueConstructor&lt;String, HystrixThreadPoolKey&gt;() &#123;</div><div class="line"><span class="number">10</span>:                     <span class="meta">@Override</span></div><div class="line"><span class="number">11</span>:                     <span class="function"><span class="keyword">public</span> HystrixThreadPoolKey <span class="title">create</span><span class="params">(String key)</span> </span>&#123;</div><div class="line"><span class="number">12</span>:                         <span class="keyword">return</span> <span class="keyword">new</span> HystrixThreadPoolKeyDefault(key);</div><div class="line"><span class="number">13</span>:                     &#125;</div><div class="line"><span class="number">14</span>:                 &#125;);</div><div class="line"><span class="number">15</span>: </div><div class="line"><span class="number">16</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HystrixThreadPoolKey <span class="title">asKey</span><span class="params">(String name)</span> </span>&#123;</div><div class="line"><span class="number">17</span>:            <span class="keyword">return</span> intern.interned(name);</div><div class="line"><span class="number">18</span>:         &#125;</div><div class="line"><span class="number">19</span>: </div><div class="line"><span class="number">20</span>:         <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixThreadPoolKeyDefault</span> <span class="keyword">extends</span> <span class="title">HystrixKeyDefault</span> <span class="keyword">implements</span> <span class="title">HystrixThreadPoolKey</span> </span>&#123;</div><div class="line"><span class="number">21</span>:             <span class="function"><span class="keyword">public</span> <span class="title">HystrixThreadPoolKeyDefault</span><span class="params">(String name)</span> </span>&#123;</div><div class="line"><span class="number">22</span>:                 <span class="keyword">super</span>(name);</div><div class="line"><span class="number">23</span>:             &#125;</div><div class="line"><span class="number">24</span>:         &#125;</div><div class="line"><span class="number">25</span>: </div><div class="line"><span class="number">26</span>:         <span class="comment">/* package-private */</span> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getThreadPoolCount</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">27</span>:             <span class="keyword">return</span> intern.size();</div><div class="line"><span class="number">28</span>:         &#125;</div><div class="line"><span class="number">29</span>:     &#125;</div><div class="line"><span class="number">30</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>HystrixThreadPoolKey 实现 <code>com.netflix.hystrix.HystrixKey</code> <strong>接口</strong>，点击 <a href="https://github.com/Netflix/Hystrix/blob/d838f4d1ba65ce55755ab1c73f74c980f04572bf/hystrix-core/src/main/java/com/netflix/hystrix/HystrixKey.java#L6" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看。该接口定义的 <code>#name()</code> 方法，即是上文我们所说的标识( Key )。</li><li><code>intern</code> 属性，<code>name</code> 与 HystrixThreadPoolKey 对象的映射，以达到<strong>枚举</strong>的效果。<ul><li><code>com.netflix.hystrix.util.InternMap</code> ，点击 <a href="https://github.com/YunaiV/Hystrix/blob/853258ce3f499e1f525130064f0d6cb055088b29/hystrix-core/src/main/java/com/netflix/hystrix/util/InternMap.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看带中文注释的代码。</li></ul></li><li><code>#asKey(name)</code> 方法，从 <code>intern</code> 获得 HystrixThreadPoolKey 对象。</li><li><code>#getThreadPoolCount()</code> 方法，获得 HystrixThreadPoolKey 数量。</li></ul><hr><p>在 AbstractCommand <strong>构造方法</strong>里，初始化命令的 <code>threadPoolKey</code> 属性，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> HystrixThreadPoolKey threadPoolKey;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractCommand</span><span class="params">(HystrixCommandGroupKey group, HystrixCommandKey key, HystrixThreadPoolKey threadPoolKey, HystrixCircuitBreaker circuitBreaker, HystrixThreadPool threadPool,</span></span></div><div class="line"><span class="function"><span class="params">       HystrixCommandProperties.Setter commandPropertiesDefaults, HystrixThreadPoolProperties.Setter threadPoolPropertiesDefaults,</span></span></div><div class="line"><span class="function"><span class="params">       HystrixCommandMetrics metrics, TryableSemaphore fallbackSemaphore, TryableSemaphore executionSemaphore,</span></span></div><div class="line"><span class="function"><span class="params">       HystrixPropertiesStrategy propertiesStrategy, HystrixCommandExecutionHook executionHook)</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="comment">// ... 省略无关代码</span></div><div class="line"></div><div class="line">   <span class="keyword">this</span>.commandGroup = initGroupKey(group);</div><div class="line">   <span class="keyword">this</span>.commandKey = initCommandKey(key, getClass());</div><div class="line">   <span class="keyword">this</span>.properties = initCommandProperties(<span class="keyword">this</span>.commandKey, propertiesStrategy, commandPropertiesDefaults);</div><div class="line">   <span class="comment">// 初始化 threadPoolKey</span></div><div class="line">   <span class="keyword">this</span>.threadPoolKey = initThreadPoolKey(threadPoolKey, <span class="keyword">this</span>.commandGroup, <span class="keyword">this</span>.properties.executionIsolationThreadPoolKeyOverride().get());</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p>调用 <code>#initThreadPoolKey(...)</code> 方法，创建最终的 <code>threadPoolKey</code> 属性。代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HystrixThreadPoolKey <span class="title">initThreadPoolKey</span><span class="params">(HystrixThreadPoolKey threadPoolKey, HystrixCommandGroupKey groupKey, String threadPoolKeyOverride)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (threadPoolKeyOverride == <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="comment">// we don't have a property overriding the value so use either HystrixThreadPoolKey or HystrixCommandGroup</span></div><div class="line">       <span class="keyword">if</span> (threadPoolKey == <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="comment">/* use HystrixCommandGroup if HystrixThreadPoolKey is null */</span></div><div class="line">           <span class="keyword">return</span> HystrixThreadPoolKey.Factory.asKey(groupKey.name());</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">return</span> threadPoolKey;</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">// threadPoolKeyOverride 可覆盖属性</span></div><div class="line">       <span class="comment">// we have a property defining the thread-pool so use it instead</span></div><div class="line">       <span class="keyword">return</span> HystrixThreadPoolKey.Factory.asKey(threadPoolKeyOverride);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>优先级 ：<code>threadPoolKeyOverride</code> &gt; <code>threadPoolKey</code> &gt; <code>groupKey</code></li></ul></li></ul><h1>4. HystrixConcurrencyStrategy</h1><p><code>com.netflix.hystrix.strategy.concurrency.HystrixConcurrencyStrategy</code> ，Hystrix 并发策略<strong>抽象类</strong>。</p><p><code>HystrixConcurrencyStrategy#getThreadPool(...)</code> 方法，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> ThreadPoolExecutor <span class="title">getThreadPool</span><span class="params">(<span class="keyword">final</span> HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolProperties threadPoolProperties)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="keyword">final</span> ThreadFactory threadFactory = getThreadFactory(threadPoolKey);</div><div class="line"> <span class="number">3</span>: </div><div class="line"> <span class="number">4</span>:     <span class="keyword">final</span> <span class="keyword">boolean</span> allowMaximumSizeToDivergeFromCoreSize = threadPoolProperties.getAllowMaximumSizeToDivergeFromCoreSize().get();</div><div class="line"> <span class="number">5</span>:     <span class="keyword">final</span> <span class="keyword">int</span> dynamicCoreSize = threadPoolProperties.coreSize().get();</div><div class="line"> <span class="number">6</span>:     <span class="keyword">final</span> <span class="keyword">int</span> keepAliveTime = threadPoolProperties.keepAliveTimeMinutes().get();</div><div class="line"> <span class="number">7</span>:     <span class="keyword">final</span> <span class="keyword">int</span> maxQueueSize = threadPoolProperties.maxQueueSize().get();</div><div class="line"> <span class="number">8</span>: </div><div class="line"> <span class="number">9</span>:     <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue = getBlockingQueue(maxQueueSize);</div><div class="line"><span class="number">10</span>: </div><div class="line"><span class="number">11</span>:     <span class="keyword">if</span> (allowMaximumSizeToDivergeFromCoreSize) &#123;</div><div class="line"><span class="number">12</span>:         <span class="keyword">final</span> <span class="keyword">int</span> dynamicMaximumSize = threadPoolProperties.maximumSize().get();</div><div class="line"><span class="number">13</span>:         <span class="keyword">if</span> (dynamicCoreSize &gt; dynamicMaximumSize) &#123;</div><div class="line"><span class="number">14</span>:             logger.error(<span class="string">"Hystrix ThreadPool configuration at startup for : "</span> + threadPoolKey.name() + <span class="string">" is trying to set coreSize = "</span> +</div><div class="line"><span class="number">15</span>:                     dynamicCoreSize + <span class="string">" and maximumSize = "</span> + dynamicMaximumSize + <span class="string">".  Maximum size will be set to "</span> +</div><div class="line"><span class="number">16</span>:                     dynamicCoreSize + <span class="string">", the coreSize value, since it must be equal to or greater than the coreSize value"</span>);</div><div class="line"><span class="number">17</span>:             <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(dynamicCoreSize, dynamicCoreSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);</div><div class="line"><span class="number">18</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">19</span>:             <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(dynamicCoreSize, dynamicMaximumSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);</div><div class="line"><span class="number">20</span>:         &#125;</div><div class="line"><span class="number">21</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">22</span>:         <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(dynamicCoreSize, dynamicCoreSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);</div><div class="line"><span class="number">23</span>:     &#125;</div><div class="line"><span class="number">24</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 2 行 ：调用 <code>#getThreadFactory(...)</code> 方法，获得 ThreadFactory 。点击 <a href="https://github.com/Netflix/Hystrix/blob/1f64fced24289ea435f1e2d5a47a068bf7b79729/hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixConcurrencyStrategy.java#L118" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看方法代码。<ul><li><code>PlatformSpecific#getAppEngineThreadFactory()</code> 方法，无需细看，适用于 Google App Engine 场景。</li></ul></li><li>第 4 至 7 行 ：<a href="#">「2. HystrixThreadPoolProperties」</a> 有详细解析。</li><li>第 9 行 ：调用 <code>#getBlockingQueue()</code> 方法，获得线程池的阻塞队列。点击 <a href="https://github.com/Netflix/Hystrix/blob/1f64fced24289ea435f1e2d5a47a068bf7b79729/hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixConcurrencyStrategy.java#L150" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看方法代码。<ul><li>当 <code>maxQueueSize &lt;= 0</code> 时( 默认值 ：<code>-1</code> ) 时，使用 SynchronousQueue 。超过线程池的 <code>maximumPoolSize</code> 时，提交任务<strong>被拒绝</strong>。<ul><li><a href="http://ifeve.com/java-synchronousqueue/" rel="external nofollow noopener noreferrer" target="_blank">《Java并发包中的同步队列SynchronousQueue实现原理》</a></li></ul></li><li>当 <code>SynchronousQueue &gt; 0</code> 时，使用 LinkedBlockingQueue 。超过线程池的 <code>maximumPoolSize</code> 时，任务被拒绝。超过线程池的 <code>maximumPoolSize</code> + 线程池队列的 <code>maxQueueSize</code> 时，提交任务<strong>被阻塞等待</strong>。<ul><li><a href="https://fangjian0423.github.io/2016/05/10/java-arrayblockingqueue-linkedblockingqueue-analysis/" rel="external nofollow noopener noreferrer" target="_blank">《Java阻塞队列ArrayBlockingQueue和LinkedBlockingQueue实现原理分析》</a></li></ul></li><li>推荐 ：<a href="http://www.infoq.com/cn/articles/java-threadPool" rel="external nofollow noopener noreferrer" target="_blank">《聊聊并发（三）——JAVA线程池的分析和使用》</a></li><li>推荐 ：<a href="http://www.infoq.com/cn/articles/java-blocking-queue" rel="external nofollow noopener noreferrer" target="_blank">《聊聊并发（七）——Java中的阻塞队列》</a></li></ul></li><li>第 11 至 23 行 ：创建 ThreadPoolExecutor 。看起来代码比较多，根据 <code>allowMaximumSizeToDivergeFromCoreSize</code> 的情况，计算线程池的 <code>maximumPoolSize</code> 属性。计算的方式和 <a href="https://github.com/Netflix/Hystrix/blob/1f64fced24289ea435f1e2d5a47a068bf7b79729/hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPoolProperties.java#L138" rel="external nofollow noopener noreferrer" target="_blank"><code>HystrixThreadPoolProperties#actualMaximumSize()</code></a> 方法是一致的。</li></ul><hr><p><code>com.netflix.hystrix.strategy.concurrency.HystrixConcurrencyStrategyDefault</code> ，Hystrix 并发策略<strong>实现类</strong>。代码如下( 基本没做啥 ) ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixConcurrencyStrategyDefault</span> <span class="keyword">extends</span> <span class="title">HystrixConcurrencyStrategy</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 单例</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HystrixConcurrencyStrategyDefault INSTANCE = <span class="keyword">new</span> HystrixConcurrencyStrategyDefault();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HystrixConcurrencyStrategy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> INSTANCE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HystrixConcurrencyStrategyDefault</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><hr><p>在 AbstractCommand <strong>构造方法</strong>里，初始化命令的 <code>threadPoolKey</code> 属性，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> HystrixConcurrencyStrategy concurrencyStrategy;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractCommand</span><span class="params">(HystrixCommandGroupKey group, HystrixCommandKey key, HystrixThreadPoolKey threadPoolKey, HystrixCircuitBreaker circuitBreaker, HystrixThreadPool threadPool,</span></span></div><div class="line"><span class="function"><span class="params">       HystrixCommandProperties.Setter commandPropertiesDefaults, HystrixThreadPoolProperties.Setter threadPoolPropertiesDefaults,</span></span></div><div class="line"><span class="function"><span class="params">       HystrixCommandMetrics metrics, TryableSemaphore fallbackSemaphore, TryableSemaphore executionSemaphore,</span></span></div><div class="line"><span class="function"><span class="params">       HystrixPropertiesStrategy propertiesStrategy, HystrixCommandExecutionHook executionHook)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line">   </div><div class="line">    <span class="comment">// 初始化 并发策略</span></div><div class="line">    <span class="keyword">this</span>.concurrencyStrategy = HystrixPlugins.getInstance().getConcurrencyStrategy();</div><div class="line">   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>HystrixPlugins ，Hystrix <strong>插件</strong>体系，<a href="https://github.com/Netflix/Hystrix/wiki/Plugins" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/Netflix/Hystrix/wiki/Plugins</a> 有详细解析。</li><li>调用 <code>HystrixPlugins#getConcurrencyStrategy()</code> 获得 HystrixConcurrencyStrategy 对象。默认情况下，使用 HystrixConcurrencyStrategyDefault 。当然你也可以参考 Hystrix 插件体系，实现<strong>自定义</strong>的 HystrixConcurrencyStrategy 实现，以达到<strong>覆写</strong> <code>#getThreadPool()</code>，<code>#getBlockingQueue()</code> 等方法。点击 <a href="https://github.com/YunaiV/Hystrix/blob/853258ce3f499e1f525130064f0d6cb055088b29/hystrix-core/src/main/java/com/netflix/hystrix/strategy/HystrixPlugins.java#L164" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看该方法代码。</li></ul><h1>5. HystrixThreadPool</h1><p><code>com.netflix.hystrix.HystrixThreadPool</code> ，Hystrix 线程池<strong>接口</strong>。当 Hystrix 命令使用 <code>THREAD</code> 执行隔离策略时，<code>HystrixCommand#run()</code> 方法在<strong>线程池执行</strong>。点击 <a href="https://github.com/YunaiV/Hystrix/blob/853258ce3f499e1f525130064f0d6cb055088b29/hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPool.java#L47" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看。HystrixThreadPool 定义接口如下 ：</p><ul><li><code>#getExecutor()</code> ：获得 ExecutorService 。</li><li><code>#getScheduler()</code> / <code>#getScheduler(Func0&lt;Boolean&gt;)</code> ：获得 RxJava Scheduler 。</li><li><code>#isQueueSpaceAvailable()</code> ：线程池队列是否有<strong>空余</strong>。</li><li><code>#markThreadExecution()</code> / <code>#markThreadCompletion()</code> / <code>#markThreadRejection()</code> ：TODO 【2002】【metrics】</li></ul><h2>5.1 HystrixThreadPoolDefault</h2><p><code>com.netflix.hystrix.HystrixThreadPool.HystrixThreadPoolDefault</code> ，Hystrix 线程池<strong>实现类</strong>。</p><p><strong>构造方法</strong>，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">private</span> <span class="keyword">final</span> HystrixThreadPoolProperties properties;</div><div class="line"> <span class="number">2</span>: <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; queue;</div><div class="line"> <span class="number">3</span>: <span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor threadPool;</div><div class="line"> <span class="number">4</span>: <span class="keyword">private</span> <span class="keyword">final</span> HystrixThreadPoolMetrics metrics;</div><div class="line"> <span class="number">5</span>: <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> queueSize;</div><div class="line"> <span class="number">6</span>: </div><div class="line"> <span class="number">7</span>: <span class="function"><span class="keyword">public</span> <span class="title">HystrixThreadPoolDefault</span><span class="params">(HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolProperties.Setter propertiesDefaults)</span> </span>&#123;</div><div class="line"> <span class="number">8</span>:     <span class="comment">// 初始化 HystrixThreadPoolProperties</span></div><div class="line"> <span class="number">9</span>:     <span class="keyword">this</span>.properties = HystrixPropertiesFactory.getThreadPoolProperties(threadPoolKey, propertiesDefaults);</div><div class="line"><span class="number">10</span>:     <span class="comment">// 获得 HystrixConcurrencyStrategy</span></div><div class="line"><span class="number">11</span>:     HystrixConcurrencyStrategy concurrencyStrategy = HystrixPlugins.getInstance().getConcurrencyStrategy();</div><div class="line"><span class="number">12</span>:     <span class="comment">// 队列大小</span></div><div class="line"><span class="number">13</span>:     <span class="keyword">this</span>.queueSize = properties.maxQueueSize().get();</div><div class="line"><span class="number">14</span>: </div><div class="line"><span class="number">15</span>:     <span class="comment">// TODO 【2002】【metrics】</span></div><div class="line"><span class="number">16</span>:     <span class="keyword">this</span>.metrics = HystrixThreadPoolMetrics.getInstance(threadPoolKey,</div><div class="line"><span class="number">17</span>:             concurrencyStrategy.getThreadPool(threadPoolKey, properties), <span class="comment">// 初始化 ThreadPoolExecutor</span></div><div class="line"><span class="number">18</span>:             properties);</div><div class="line"><span class="number">19</span>: </div><div class="line"><span class="number">20</span>:     <span class="comment">// 获得 ThreadPoolExecutor</span></div><div class="line"><span class="number">21</span>:     <span class="keyword">this</span>.threadPool = <span class="keyword">this</span>.metrics.getThreadPool();</div><div class="line"><span class="number">22</span>:     <span class="keyword">this</span>.queue = <span class="keyword">this</span>.threadPool.getQueue(); <span class="comment">// 队列</span></div><div class="line"><span class="number">23</span>: </div><div class="line"><span class="number">24</span>:     <span class="comment">// TODO 【2002】【metrics】</span></div><div class="line"><span class="number">25</span>:     <span class="comment">/* strategy: HystrixMetricsPublisherThreadPool */</span></div><div class="line"><span class="number">26</span>:     HystrixMetricsPublisherFactory.createOrRetrievePublisherForThreadPool(threadPoolKey, <span class="keyword">this</span>.metrics, <span class="keyword">this</span>.properties);</div><div class="line"><span class="number">27</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 9 行 ：初始化 HystrixThreadPoolProperties 。</li><li>第 11 行 ：初始化 HystrixConcurrencyStrategy 。</li><li>第 13 行 ：初始化 <code>queueSize</code> 。</li><li>第 16 至 18 行 ：TODO 【2002】【metrics】<ul><li>第 17 行 ：调用 <code>HystrixConcurrencyStrategy#getThreadPool(...)</code> 方法，初始化 ThreadPoolExecutor 。</li></ul></li><li>第 21 行 ：<strong>获得</strong> ThreadPoolExecutor 。</li><li>第 22 行 ：<strong>获得</strong> ThreadPoolExecutor 的队列。</li><li>第 26 行 ：TODO 【2002】【metrics】</li></ul><hr><p><code>#getExecutor()</code> 方法，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ThreadPoolExecutor <span class="title">getExecutor</span><span class="params">()</span> </span>&#123;</div><div class="line">    touchConfig();</div><div class="line">    <span class="keyword">return</span> threadPool;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>调用 <code>#touchConfig()</code> 方法，<strong>动态</strong>调整 <code>threadPool</code> 的 <code>coreSize</code> / <code>maximumSize</code> / <code>keepAliveTime</code> 参数。点击 <a href="https://github.com/YunaiV/Hystrix/blob/853258ce3f499e1f525130064f0d6cb055088b29/hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPool.java#L188" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看该方法。</li></ul><hr><p><code>#getScheduler()</code> / <code>#getScheduler(Func0&lt;Boolean&gt;)</code> 方法，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Scheduler <span class="title">getScheduler</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//by default, interrupt underlying threads on timeout</span></div><div class="line">    <span class="keyword">return</span> getScheduler(<span class="keyword">new</span> Func0&lt;Boolean&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Scheduler <span class="title">getScheduler</span><span class="params">(Func0&lt;Boolean&gt; shouldInterruptThread)</span> </span>&#123;</div><div class="line">    touchConfig();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HystrixContextScheduler(HystrixPlugins.getInstance().getConcurrencyStrategy(), <span class="keyword">this</span>, shouldInterruptThread);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>HystrixContextScheduler 和 <code>shouldInterruptThread</code> 都在 <a href="#">「6. HystrixContextScheduler」</a> 详细解析。</li></ul><hr><p><code>#isQueueSpaceAvailable()</code> 方法，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isQueueSpaceAvailable</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (queueSize &lt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// we don't have a queue so we won't look for space but instead</span></div><div class="line">        <span class="comment">// let the thread-pool reject or not</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> threadPool.getQueue().size() &lt; properties.queueSizeRejectionThreshold().get();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>由于线程池的队列大小不能<strong>动态</strong>调整，该方法的<strong>实现</strong>通过 <a href="https://github.com/YunaiV/Hystrix/blob/853258ce3f499e1f525130064f0d6cb055088b29/hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPoolProperties.java#L85" rel="external nofollow noopener noreferrer" target="_blank"><code>HystrixThreadPoolProperties.queueSizeRejectionThreshold</code></a> 属性控制。</li><li>注意 <code>queueSize</code> 属性，决定了线程池的队列类型。<ul><li><code>queueSize &lt;= 0</code> 时，<code>#isQueueSpaceAvailable()</code> 都返回 <code>true</code> 的原因是，线程池使用 SynchronousQueue 作为队列，不支持<strong>新</strong>任务排队，任务超过线程池的 <code>maximumPoolSize</code> 时，新任务被拒绝。</li><li><code>queueSize &gt; 0</code> 时，<code>#isQueueSpaceAvailable()</code> 根据情况<code>true</code>/<code>false</code> 的原因是，线程池使用 LinkedBlockingQueue 作为队列，支持<strong>一定数量</strong>的<strong>阻塞</strong>排队，但是这个数量无法调整。通过 <code>#isQueueSpaceAvailable()</code> 方法的判断，<strong>动态</strong>调整。另外，初始<strong>配置</strong>的 <code>queueSize</code> 要<strong>相对大</strong>，否则即使 <code>queueSizeRejectionThreshold</code> 配置的大于 <code>queueSize</code> ，实际提交任务到线程池，也会被<strong>拒绝</strong>。</li></ul></li></ul><h2>5.2 Factory</h2><p><code>com.netflix.hystrix.HystrixThreadPool.Factory</code> ，HystrixThreadPool 工厂类，不仅限于 HystrixThreadPool 的创建，也提供了 HystrixThreadPool 的管理( HystrixThreadPool 的容器 )。</p><p><code>threadPools</code> 属性，维护创建的 HystrixThreadPool 对应的映射，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, HystrixThreadPool&gt; threadPools = <span class="keyword">new</span> ConcurrentHashMap&lt;String, HystrixThreadPool&gt;();</div></pre></td></tr></table></figure></p><ul><li>Key 为 <code>HystrixThreadPoolKey#name()</code> ，每个 HystrixThreadPoolKey 对应一个 HystrixThreadPool 对象。</li></ul><hr><p><code>#getInstance(...)</code> 方法，获得 HystrixThreadPool 对象，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/* package */</span><span class="function"><span class="keyword">static</span> HystrixThreadPool <span class="title">getInstance</span><span class="params">(HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolProperties.Setter propertiesBuilder)</span> </span>&#123;</div><div class="line">    <span class="comment">// get the key to use instead of using the object itself so that if people forget to implement equals/hashcode things will still work</span></div><div class="line">    String key = threadPoolKey.name();</div><div class="line"></div><div class="line">    <span class="comment">// this should find it for all but the first time</span></div><div class="line">    HystrixThreadPool previouslyCached = threadPools.get(key);</div><div class="line">    <span class="keyword">if</span> (previouslyCached != <span class="keyword">null</span>) &#123;</div><div class="line">         <span class="keyword">return</span> previouslyCached;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">// if we get here this is the first time so we need to initialize</span></div><div class="line">     <span class="keyword">synchronized</span> (HystrixThreadPool.class) &#123;</div><div class="line">        <span class="keyword">if</span> (!threadPools.containsKey(key)) &#123;</div><div class="line">            threadPools.put(key, <span class="keyword">new</span> HystrixThreadPoolDefault(threadPoolKey, propertiesBuilder));</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> threadPools.get(key);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>根据 <code>threadPoolKey</code> 先从 <code>threadPool</code> 获取已创建的 HystrixThreadPool ；获取不到，创建对应的 HystrixThreadPool 返回，并添加到 <code>threadPool</code> 。</li></ul><hr><p><code>#shutdown()</code> / <code>#shutdown(timeout, unit)</code> 方法，比较易懂，点击 <a href="https://github.com/YunaiV/Hystrix/blob/853258ce3f499e1f525130064f0d6cb055088b29/hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPool.java#L128" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看。</p><h2>5.3 初始化</h2><p>在 AbstractCommand <strong>构造方法</strong>里，初始化命令的 <code>threadPool</code> 属性，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> HystrixThreadPool threadPool;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractCommand</span><span class="params">(HystrixCommandGroupKey group, HystrixCommandKey key, HystrixThreadPoolKey threadPoolKey, HystrixCircuitBreaker circuitBreaker, HystrixThreadPool threadPool,</span></span></div><div class="line"><span class="function"><span class="params">       HystrixCommandProperties.Setter commandPropertiesDefaults, HystrixThreadPoolProperties.Setter threadPoolPropertiesDefaults,</span></span></div><div class="line"><span class="function"><span class="params">       HystrixCommandMetrics metrics, TryableSemaphore fallbackSemaphore, TryableSemaphore executionSemaphore,</span></span></div><div class="line"><span class="function"><span class="params">       HystrixPropertiesStrategy propertiesStrategy, HystrixCommandExecutionHook executionHook)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ... 省略其他代码</span></div><div class="line"></div><div class="line">    <span class="comment">// 初始化 threadPoolKey</span></div><div class="line">    <span class="keyword">this</span>.threadPoolKey = initThreadPoolKey(threadPoolKey, <span class="keyword">this</span>.commandGroup, <span class="keyword">this</span>.properties.executionIsolationThreadPoolKeyOverride().get());</div><div class="line">    <span class="comment">// 初始化 threadPool</span></div><div class="line">    <span class="keyword">this</span>.threadPool = initThreadPool(threadPool, <span class="keyword">this</span>.threadPoolKey, threadPoolPropertiesDefaults);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>调用 <code>#initThreadPool(...)</code> 方法，获得 HystrixThreadPool ，点击 <a href="https://github.com/YunaiV/Hystrix/blob/853258ce3f499e1f525130064f0d6cb055088b29/hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java#L286" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看。</li></ul><h1>6. HystrixScheduler</h1><p>Hystrix 实现了<strong>自定义的</strong> RxJava Scheduler ，整体类图如下 ：</p><p><img src="http://www.iocoder.cn/images/Hystrix/2018_10_25/01.png" alt=""></p><ul><li>HystrixContextScheduler ( 实现 RxJava Scheduler <strong>抽象类</strong> )，内嵌类型为 ThreadPoolScheduler ( 实现 RxJava Scheduler <strong>抽象类</strong> )的 <code>actualScheduler</code> 属性。</li><li>HystrixContextWorker ( 实现 RxJava Worker <strong>抽象类</strong> )，内嵌类型为 ThreadPoolWorker ( 实现 RxJava Worker <strong>抽象类</strong> )的 <code>worker</code> 属性。</li></ul><h2>6.1 HystrixContextScheduler</h2><p><strong>构造方法</strong>，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixContextScheduler</span> <span class="keyword">extends</span> <span class="title">Scheduler</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HystrixConcurrencyStrategy concurrencyStrategy;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Scheduler actualScheduler;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HystrixThreadPool threadPool;</div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HystrixContextScheduler</span><span class="params">(HystrixConcurrencyStrategy concurrencyStrategy, HystrixThreadPool threadPool, Func0&lt;Boolean&gt; shouldInterruptThread)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.concurrencyStrategy = concurrencyStrategy;</div><div class="line">        <span class="keyword">this</span>.threadPool = threadPool;</div><div class="line">        <span class="keyword">this</span>.actualScheduler = <span class="keyword">new</span> ThreadPoolScheduler(threadPool, shouldInterruptThread);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><code>actualScheduler</code> 属性，类型为 ThreadPoolScheduler 。</li></ul><hr><p><code>#createWorker()</code> 方法，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Worker <span class="title">createWorker</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HystrixContextSchedulerWorker(actualScheduler.createWorker());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>使用 <code>actualScheduler</code> 创建 ThreadPoolWorker ，传参给 HystrixContextSchedulerWorker 。</li></ul><h2>6.2 HystrixContextSchedulerWorker</h2><p><strong>构造方法</strong>，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixContextSchedulerWorker</span> <span class="keyword">extends</span> <span class="title">Worker</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Worker worker;</div><div class="line"></div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HystrixContextSchedulerWorker</span><span class="params">(Worker actualWorker)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.worker = actualWorker;</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><code>worker</code> 属性，类型为 ThreadPoolWorker 。</li></ul><hr><p><code>#schedule(Action0)</code> 方法，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Subscription <span class="title">schedule</span><span class="params">(Action0 action)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (threadPool != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (!threadPool.isQueueSpaceAvailable()) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Rejected command because thread-pool queueSize is at rejection threshold."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> worker.schedule(<span class="keyword">new</span> HystrixContexSchedulerAction(concurrencyStrategy, action));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>调用 <code>ThreadPool#isQueueSpaceAvailable()</code> 方法，判断线程池队列是否有<strong>空余</strong>。这个就是 HystrixContextScheduler 的<strong>实际</strong>用途。</li></ul><hr><p><code>#unsubscribe()</code> / <code>#isUnsubscribed()</code> 方法，使用 <code>worker</code> 判断，点击 <a href="https://github.com/YunaiV/Hystrix/blob/853258ce3f499e1f525130064f0d6cb055088b29/hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixContextScheduler.java#L80" rel="external nofollow noopener noreferrer" target="_blank">链接</a>查看。</p><h2>6.3 ThreadPoolScheduler</h2><p>ThreadPoolScheduler 比较简单，点击 <a href="https://github.com/YunaiV/Hystrix/blob/853258ce3f499e1f525130064f0d6cb055088b29/hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixContextScheduler.java#L111" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看。</p><h2>6.4 ThreadPoolWorker</h2><p><strong>构造方法</strong>，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolWorker</span> <span class="keyword">extends</span> <span class="title">Worker</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HystrixThreadPool threadPool;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CompositeSubscription subscription = <span class="keyword">new</span> CompositeSubscription();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Func0&lt;Boolean&gt; shouldInterruptThread;</div><div class="line"></div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolWorker</span><span class="params">(HystrixThreadPool threadPool, Func0&lt;Boolean&gt; shouldInterruptThread)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.threadPool = threadPool;</div><div class="line">        <span class="keyword">this</span>.shouldInterruptThread = shouldInterruptThread;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><code>subscription</code> 属性，订阅信息。</li></ul><hr><p><code>#schedule(Action0)</code> 方法，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> Subscription <span class="title">schedule</span><span class="params">(<span class="keyword">final</span> Action0 action)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="comment">// 未订阅，返回</span></div><div class="line"> <span class="number">4</span>:     <span class="keyword">if</span> (subscription.isUnsubscribed()) &#123;</div><div class="line"> <span class="number">5</span>:         <span class="comment">// don't schedule, we are unsubscribed</span></div><div class="line"> <span class="number">6</span>:         <span class="keyword">return</span> Subscriptions.unsubscribed();</div><div class="line"> <span class="number">7</span>:     &#125;</div><div class="line"> <span class="number">8</span>: </div><div class="line"> <span class="number">9</span>:     <span class="comment">// 创建 ScheduledAction</span></div><div class="line"><span class="number">10</span>:     <span class="comment">// This is internal RxJava API but it is too useful.</span></div><div class="line"><span class="number">11</span>:     ScheduledAction sa = <span class="keyword">new</span> ScheduledAction(action);</div><div class="line"><span class="number">12</span>: </div><div class="line"><span class="number">13</span>:     <span class="comment">// 添加到 订阅</span></div><div class="line"><span class="number">14</span>:     subscription.add(sa);</div><div class="line"><span class="number">15</span>:     sa.addParent(subscription);</div><div class="line"><span class="number">16</span>: </div><div class="line"><span class="number">17</span>:     <span class="comment">// 提交 任务</span></div><div class="line"><span class="number">18</span>:     ThreadPoolExecutor executor = (ThreadPoolExecutor) threadPool.getExecutor();</div><div class="line"><span class="number">19</span>:     FutureTask&lt;?&gt; f = (FutureTask&lt;?&gt;) executor.submit(sa);</div><div class="line"><span class="number">20</span>:     sa.add(<span class="keyword">new</span> FutureCompleterWithConfigurableInterrupt(f, shouldInterruptThread, executor));</div><div class="line"><span class="number">21</span>: </div><div class="line"><span class="number">22</span>:     <span class="keyword">return</span> sa;</div><div class="line"><span class="number">23</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 4 至 7 行 ：未订阅，返回。</li><li>第 11 行 ： 创建 ScheduledAction 。在 <a href="">TODO 【2013】【ScheduledAction】</a> 详细解析。</li><li>第 14 至 15 行 ：添加到订阅( <code>subscription</code> )。</li><li>第 18 至 20 行 ：使用 <code>threadPool</code> ，提交任务，并创建 FutureCompleterWithConfigurableInterrupt 添加到订阅( <code>sa</code> )。</li><li>第 22 行 ：返回订阅( <code>sa</code> )。整体订阅关系如下 ：<img src="http://www.iocoder.cn/images/Hystrix/2018_10_25/02.png" alt=""></li></ul><hr><p><code>#unsubscribe()</code> / <code>#isUnsubscribed()</code> 方法，使用 <code>subscription</code> 判断，点击 <a href="https://github.com/YunaiV/Hystrix/blob/853258ce3f499e1f525130064f0d6cb055088b29/hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixContextScheduler.java#L149" rel="external nofollow noopener noreferrer" target="_blank">链接</a>查看。</p><h2>6.5 FutureCompleterWithConfigurableInterrupt</h2><p><code>com.netflix.hystrix.strategy.concurrency.HystrixContextScheduler.FutureCompleterWithConfigurableInterrupt</code> ，实现类似 <code>rx.internal.schedulers.ScheduledAction.FutureCompleter</code> ，在它的基础上，支持配置 <code>FutureTask#cancel(Boolean)</code> 是否可<strong>打断</strong>运行( <code>mayInterruptIfRunning</code> )。</p><p><strong>构造方法</strong>，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureCompleterWithConfigurableInterrupt</span> <span class="keyword">implements</span> <span class="title">Subscription</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FutureTask&lt;?&gt; f;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Func0&lt;Boolean&gt; shouldInterruptThread;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor executor;</div><div class="line"></div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FutureCompleterWithConfigurableInterrupt</span><span class="params">(FutureTask&lt;?&gt; f, Func0&lt;Boolean&gt; shouldInterruptThread, ThreadPoolExecutor executor)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.f = f;</div><div class="line">        <span class="keyword">this</span>.shouldInterruptThread = shouldInterruptThread;</div><div class="line">        <span class="keyword">this</span>.executor = executor;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><hr><p><strong>当命令执行超时，或是主动取消命令执行时，调用 <code>#unsubscribe()</code> 方法，取消执行</strong>。<br><strong>当命令执行超时，或是主动取消命令执行时，调用 <code>#unsubscribe()</code> 方法，取消执行</strong>。<br><strong>当命令执行超时，或是主动取消命令执行时，调用 <code>#unsubscribe()</code> 方法，取消执行</strong>。</p><p><code>#unsubscribe()</code> 方法，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 从 线程池 移除 任务</span></div><div class="line">    executor.remove(f);</div><div class="line">    <span class="comment">// 根据 shouldInterruptThread 配置，是否强制取消</span></div><div class="line">    <span class="keyword">if</span> (shouldInterruptThread.call()) &#123;</div><div class="line">        f.cancel(<span class="keyword">true</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        f.cancel(<span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>根据 <code>shouldInterruptThread</code> 方法，判断是否<strong>强制</strong>取消。</li><li><code>shouldInterruptThread</code> 对应的方法，实现代码如下 ：</li></ul><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">subscribeOn(threadPool.getScheduler(<span class="keyword">new</span> Func0&lt;Boolean&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> properties.executionIsolationThreadInterruptOnTimeout().get() &amp;&amp; _cmd.isCommandTimedOut.get() == TimedOutStatus.TIMED_OUT;</div><div class="line">    &#125;</div><div class="line">&#125;));</div></pre></td></tr></table></figure></p><ul><li>当 <code>executionIsolationThreadInterruptOnTimeout = true</code> 时，命令可执行<strong>超时</strong>。当命令可执行<strong>超时</strong>时，<strong>强制</strong>取消。</li><li>当使用 <code>HystrixCommand.queue()</code> 返回的 Future ，可以使用 <code>Future#cancel(Boolean)</code> 取消命令执行。从 <code>shouldInterruptThread</code> 对应的方法可以看到，如果此时不满足命令执行<strong>超时</strong>的条件，命令执行取消的方式是<strong>非强制</strong>的。此时当 <code>executionIsolationThreadInterruptOnFutureCancel = true</code> 时，并且调用 <code>Future#cancel(Boolean)</code> 传递 <code>mayInterruptIfRunning = true</code> ，强制取消命令执行。<ul><li>模拟测试用例 ：<a href="https://github.com/YunaiV/Hystrix/blob/HEAD/hystrix-examples/src/main/java/com/netflix/hystrix/examples/basic/CommandHelloWorld.java#L118" rel="external nofollow noopener noreferrer" target="_blank"><code>CommandHelloWorld#testAsynchronous3()</code></a></li><li><code>HystrixCommand#queue()</code> ：点击 <a href="https://github.com/YunaiV/Hystrix/blob/ba86690747b365482c306ec3a0725e0be4bab739/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommand.java#L378" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 <code>Future#cancel(Boolean)</code> 方法。</li></ul></li></ul><h1>666. 彩蛋</h1><p>一边写一边想明白了 RxJava 的一些东西，挺舒服的赶脚。</p><p>继续 Go On ~ 周末嗨不停。</p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/Hystrix/command-execute-second-isolation-strategy/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 Hystrix 1.5.X
      
    
    </summary>
    
      <category term="Hystrix" scheme="http://www.iocoder.cn/categories/Hystrix/"/>
    
    
  </entry>
  
  <entry>
    <title>Hystrix 源码解析 —— 命令执行（一）之正常执行逻辑</title>
    <link href="http://www.iocoder.cn/Hystrix/command-execute-first-run/"/>
    <id>http://www.iocoder.cn/Hystrix/command-execute-first-run/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2017-11-08T10:02:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/Hystrix/command-execute-first-run/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Hystrix 1.5.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Hystrix/command-execute-first-run/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-first-run/">2. #applyHystrixSemantics(...)</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-first-run/">3. TryableSemaphore</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-first-run/">4. #executeCommandAndObserve(...)</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-first-run/">5. #executeCommandWithSpecifiedIsolation(...)</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-first-run/">6. #getUserExecutionObservable(...)</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-first-run/">7. #getExecutionObservable()</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-first-run/">8. CommandState</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-first-run/">9. ThreadState</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-first-run/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p>本文主要分享 <strong>Hystrix 命令执行（一）之正常执行逻辑</strong>。</p><p>建议 ：对 RxJava 已经有一定的了解的基础上阅读本文。</p><p>Hystrix 执行命令整体流程如下图：</p><blockquote><p>FROM <a href="http://youdang.github.io/2016/02/05/translate-hystrix-wiki-how-it-works/#%E6%B5%81%E7%A8%8B%E5%9B%BE" rel="external nofollow noopener noreferrer" target="_blank">《【翻译】Hystrix文档-实现原理》「流程图」</a><br><img src="http://www.iocoder.cn/images/Hystrix/2018_10_22/01.jpeg" alt=""></p></blockquote><ul><li><strong>红</strong>框 ：Hystrix 命令执行的过程。</li><li><strong>蓝</strong>圈 ：本文分享的部分 —— 正常执行逻辑。</li></ul><hr><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1>2. #applyHystrixSemantics(...)</h1><p>在 <a href="http://www.iocoder.cn/Hystrix/command-execute-result-cache/?self">《Hystrix 源码解析 —— 执行结果缓存》</a> 里，我们看到 <code>#toObservable()</code> 方法里的<strong>第 11 至 19 行</strong>，当缓存特性<strong>未开启</strong>，或者缓存<strong>未命中</strong>时，使用 <code>applyHystrixSemantics</code> 传入 <code>Observable#defer(...)</code> 方法，声明<strong>执行命令</strong>的 Observable。</p><p>创建 <code>applyHystrixSemantics</code> 变量，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// `AbstractCommand#toObservable()` 方法</span></div><div class="line">  <span class="number">1</span>: <span class="keyword">final</span> Func0&lt;Observable&lt;R&gt;&gt; applyHystrixSemantics = <span class="keyword">new</span> Func0&lt;Observable&lt;R&gt;&gt;() &#123;</div><div class="line">  <span class="number">2</span>:     <span class="meta">@Override</span></div><div class="line">  <span class="number">3</span>:     <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="number">4</span>:         <span class="comment">// commandState 处于 UNSUBSCRIBED 时，不执行命令</span></div><div class="line">  <span class="number">5</span>:         <span class="keyword">if</span> (commandState.get().equals(CommandState.UNSUBSCRIBED)) &#123;</div><div class="line">  <span class="number">6</span>:             <span class="keyword">return</span> Observable.never();</div><div class="line">  <span class="number">7</span>:         &#125;</div><div class="line">  <span class="number">8</span>:         <span class="comment">// 获得 执行Observable</span></div><div class="line">  <span class="number">9</span>:         <span class="keyword">return</span> applyHystrixSemantics(_cmd);</div><div class="line"> <span class="number">10</span>:     &#125;</div><div class="line"> <span class="number">11</span>: &#125;;</div></pre></td></tr></table></figure></p><ul><li>第 5 至 7 行 ：当 <code>commandState</code> 处于 <code>UNSUBSCRIBED</code> 时，不执行命令。</li><li>第 9 行 ：调用 <code>#applyHystrixSemantics(...)</code> 方法，获得执行 Observable 。</li></ul><hr><p><code>#applyHystrixSemantics(...)</code> 方法，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> Observable&lt;R&gt; <span class="title">applyHystrixSemantics</span><span class="params">(<span class="keyword">final</span> AbstractCommand&lt;R&gt; _cmd)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// TODO 【2003】【HOOK】</span></div><div class="line"> <span class="number">3</span>:     <span class="comment">// mark that we're starting execution on the ExecutionHook</span></div><div class="line"> <span class="number">4</span>:     <span class="comment">// if this hook throws an exception, then a fast-fail occurs with no fallback.  No state is left inconsistent</span></div><div class="line"> <span class="number">5</span>:     executionHook.onStart(_cmd);</div><div class="line"> <span class="number">6</span>: </div><div class="line"> <span class="number">7</span>:     <span class="comment">/* determine if we're allowed to execute */</span></div><div class="line"> <span class="number">8</span>:     <span class="keyword">if</span> (circuitBreaker.attemptExecution()) &#123;</div><div class="line"> <span class="number">9</span>:         <span class="comment">// 获得 信号量</span></div><div class="line"><span class="number">10</span>:         <span class="keyword">final</span> TryableSemaphore executionSemaphore = getExecutionSemaphore();</div><div class="line"><span class="number">11</span>: </div><div class="line"><span class="number">12</span>:         <span class="comment">// 信号量释放Action</span></div><div class="line"><span class="number">13</span>:         <span class="keyword">final</span> AtomicBoolean semaphoreHasBeenReleased = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</div><div class="line"><span class="number">14</span>:         <span class="keyword">final</span> Action0 singleSemaphoreRelease = <span class="keyword">new</span> Action0() &#123;</div><div class="line"><span class="number">15</span>:             <span class="meta">@Override</span></div><div class="line"><span class="number">16</span>:             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">17</span>:                 <span class="keyword">if</span> (semaphoreHasBeenReleased.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</div><div class="line"><span class="number">18</span>:                     executionSemaphore.release();</div><div class="line"><span class="number">19</span>:                 &#125;</div><div class="line"><span class="number">20</span>:             &#125;</div><div class="line"><span class="number">21</span>:         &#125;;</div><div class="line"><span class="number">22</span>: </div><div class="line"><span class="number">23</span>:         <span class="comment">// TODO 【2011】【Hystrix 事件机制】</span></div><div class="line"><span class="number">24</span>:         <span class="keyword">final</span> Action1&lt;Throwable&gt; markExceptionThrown = <span class="keyword">new</span> Action1&lt;Throwable&gt;() &#123;</div><div class="line"><span class="number">25</span>:             <span class="meta">@Override</span></div><div class="line"><span class="number">26</span>:             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Throwable t)</span> </span>&#123;</div><div class="line"><span class="number">27</span>:                 eventNotifier.markEvent(HystrixEventType.EXCEPTION_THROWN, commandKey);</div><div class="line"><span class="number">28</span>:             &#125;</div><div class="line"><span class="number">29</span>:         &#125;;</div><div class="line"><span class="number">30</span>: </div><div class="line"><span class="number">31</span>:         <span class="comment">// 信号量 获得</span></div><div class="line"><span class="number">32</span>:         <span class="keyword">if</span> (executionSemaphore.tryAcquire()) &#123;</div><div class="line"><span class="number">33</span>:             <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">34</span>:                 <span class="comment">// 标记 executionResult 调用开始时间</span></div><div class="line"><span class="number">35</span>:                 <span class="comment">/* used to track userThreadExecutionTime */</span></div><div class="line"><span class="number">36</span>:                 executionResult = executionResult.setInvocationStartTime(System.currentTimeMillis());</div><div class="line"><span class="number">37</span>: </div><div class="line"><span class="number">38</span>:                 <span class="comment">// 获得 执行Observable</span></div><div class="line"><span class="number">39</span>:                 <span class="keyword">return</span> executeCommandAndObserve(_cmd)</div><div class="line"><span class="number">40</span>:                         .doOnError(markExceptionThrown)</div><div class="line"><span class="number">41</span>:                         .doOnTerminate(singleSemaphoreRelease)</div><div class="line"><span class="number">42</span>:                         .doOnUnsubscribe(singleSemaphoreRelease);</div><div class="line"><span class="number">43</span>:             &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</div><div class="line"><span class="number">44</span>:                 <span class="keyword">return</span> Observable.error(e);</div><div class="line"><span class="number">45</span>:             &#125;</div><div class="line"><span class="number">46</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">47</span>:             <span class="keyword">return</span> handleSemaphoreRejectionViaFallback();</div><div class="line"><span class="number">48</span>:         &#125;</div><div class="line"><span class="number">49</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">50</span>:         <span class="keyword">return</span> handleShortCircuitViaFallback();</div><div class="line"><span class="number">51</span>:     &#125;</div><div class="line"><span class="number">52</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 5 行 ：TODO 【2003】【HOOK】</li><li>第 8 行 ：TODO 【2012】【链路健康度】</li><li>第 10 行 ：调用 <code>#getExecutionSemaphore()</code> 方法，获得<strong>信号量</strong>( TryableSemaphore )对象，在 <a href="#">「3. TryableSemaphore」</a> 详细解析。</li><li>第 13 至 21 行 ：信号量释放 Action ，用于下面【执行命令 Observable】的 <code>#doOnTerminate(Action)</code> 和 <code>#doOnUnsubscribe(Action)</code> 方法( 见第 41 至 42 行 )。</li><li>第 24 至 29 行 ：TODO 【2011】【Hystrix 事件机制】</li><li>第 32 行 ：调用 <code>TryableSemaphore#tryAcquire()</code> 方法，<strong>信号量</strong>( TryableSemaphore )使用成功，在 <a href="#">「3. TryableSemaphore」</a> 详细解析。</li><li>第 36 行 ：标记 <code>executionResult</code> 的<strong>调用</strong>开始时间。</li><li>第 39 行 ：调用 <code>#executeCommandAndObserve()</code> 方法，获得【执行命令 Observable】。在 <a href="#">「4. #executeCommandAndObserve(...)」</a> 详细解析。</li><li>第 43 至 45 行 ：若发生异常，调用 <code>Observable#error(Exception)</code> 方法返回 Observable 。</li><li>第 46 至 48 行 ：<strong>信号量</strong>( TryableSemaphore )使用失败，调用 <code>#handleSemaphoreRejectionViaFallback()</code> 方法，处理信号量拒绝的失败回退逻辑，在 <a href="http://www.iocoder.cn/Hystrix/command-execute-fourth-fallback/?self">《Hystrix 源码解析 —— 命令执行（四）之失败回退逻辑》</a> 详细解析。</li><li>第 49 至 51 行 ：链路处于<strong>熔断</strong>状态，调用 <code>#handleShortCircuitViaFallback()</code> 方法，处理链路熔断的失败回退逻辑，在 <a href="http://www.iocoder.cn/Hystrix/command-execute-fourth-fallback/?self">《Hystrix 源码解析 —— 命令执行（四）之失败回退逻辑》</a> 详细解析。</li></ul><h1>3. TryableSemaphore</h1><p><code>com.netflix.hystrix.AbstractCommand.TryableSemaphore</code> ，Hystrix 定义的信号量<strong>接口</strong>。代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TryableSemaphore</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumberOfPermitsUsed</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>从 API 上，Java 自带的 <code>java.util.concurrent.Semaphore</code> 都能满足，为什么不使用它呢？继续一起往下看。</li></ul><p>TryableSemaphore 共有两个子类实现 ：</p><ul><li>TryableSemaphoreNoOp</li><li>TryableSemaphoreActual</li></ul><h2>3.1 TryableSemaphoreNoOp</h2><p><code>com.netflix.hystrix.AbstractCommand.TryableSemaphoreNoOp</code> ，<strong>无操作</strong>的信号量。代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/* package */</span><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TryableSemaphoreNoOp</span> <span class="keyword">implements</span> <span class="title">TryableSemaphore</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> TryableSemaphore DEFAULT = <span class="keyword">new</span> TryableSemaphoreNoOp();</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</div><div class="line"> </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberOfPermitsUsed</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>从实现上看，<code>#tryAcquire()</code> 方法，每次都返回的是 <code>true</code> ；<code>#release()</code> 方法，无任何操作。这个是<strong>为什么</strong>？在 Hystrix 里提供了两种<strong>执行隔离策略</strong>  ：<ul><li><code>Thread</code> ，该方式不使用信号量，因此使用 TryableSemaphoreNoOp ，这样每次调用 <code>#tryAcquire()</code> 都能返回 <code>true</code> 。在 <a href="http://www.iocoder.cn/Hystrix/command-execute-second-isolation-strategy/?self">《Hystrix 源码解析 —— 命令执行（二）之执行隔离策略》</a> 详细解析该方式。</li><li><code>Semaphore</code> ，该方式使用信号量，因此使用 TryableSemaphoreActual ，这样每次调用 <code>#tryAcquire()</code> 根据情况返回 <code>true / false</code> 。在 <a href="#">「3.2 TryableSemaphoreActual」</a> 详细解析。</li></ul></li></ul><h2>3.2 TryableSemaphoreActual</h2><p><code>com.netflix.hystrix.AbstractCommand.TryableSemaphoreActual</code> ，<strong>真正的</strong>的信号量实现。不过实际上，TryableSemaphoreActual 更加像一个<strong>计数器</strong>。代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/* package */</span><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TryableSemaphoreActual</span> <span class="keyword">implements</span> <span class="title">TryableSemaphore</span> </span>&#123;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> HystrixProperty&lt;Integer&gt; numberOfPermits;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TryableSemaphoreActual</span><span class="params">(HystrixProperty&lt;Integer&gt; numberOfPermits)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.numberOfPermits = numberOfPermits;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> currentCount = count.incrementAndGet();</div><div class="line">        <span class="keyword">if</span> (currentCount &gt; numberOfPermits.get()) &#123;</div><div class="line">            count.decrementAndGet();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</div><div class="line">        count.decrementAndGet();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberOfPermitsUsed</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> count.get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><code>numberOfPermits</code> 属性，信号量<strong>上限</strong>。<code>com.netflix.hystrix.strategy.properties.HystrixProperty</code> 是一个接口，当其使用类似 <code>com.netflix.hystrix.strategy.properties.archaius.IntegerDynamicProperty</code> <strong>动态</strong>属性的实现时，可以实现动态调整信号量的<strong>上限</strong>，这就是上文提到的为什么不使用 <code>java.util.concurrent.Semaphore</code> 的原因之一。</li><li><code>count</code> 属性，信号量使用数量。🙂，这是为什么说 TryableSemaphoreActual 更加像一个<strong>计数器</strong> 的原因。</li><li>另一个不使用 <code>java.util.concurrent.Semaphore</code> 的原因，TryableSemaphoreActual 无<strong>阻塞</strong>获取信号量的需求，使用 AtomicInteger 可以达到更轻量级的实现。</li></ul><h2>3.3 #getExecutionSemaphore()</h2><p>调用 <code>#getExecutionSemaphore()</code> 方法，获得信号量对象，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 执行命令（正常执行）信号量映射</span></div><div class="line"><span class="comment">* KEY ：命令名 &#123;<span class="doctag">@link</span> #commandKey&#125;</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="comment">/* each circuit has a semaphore to restrict concurrent fallback execution */</span></div><div class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, TryableSemaphore&gt; executionSemaphorePerCircuit = <span class="keyword">new</span> ConcurrentHashMap&lt;String, TryableSemaphore&gt;();</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">protected</span> TryableSemaphore <span class="title">getExecutionSemaphore</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (properties.executionIsolationStrategy().get() == ExecutionIsolationStrategy.SEMAPHORE) &#123;</div><div class="line">        <span class="keyword">if</span> (executionSemaphoreOverride == <span class="keyword">null</span>) &#123;</div><div class="line">            TryableSemaphore _s = executionSemaphorePerCircuit.get(commandKey.name());</div><div class="line">            <span class="keyword">if</span> (_s == <span class="keyword">null</span>) &#123; <span class="comment">// 不存在时，创建 TryableSemaphoreActual</span></div><div class="line">                <span class="comment">// we didn't find one cache so setup</span></div><div class="line">               executionSemaphorePerCircuit.putIfAbsent(commandKey.name(), <span class="keyword">new</span> TryableSemaphoreActual(properties.executionIsolationSemaphoreMaxConcurrentRequests()));</div><div class="line">                <span class="comment">// assign whatever got set (this or another thread)</span></div><div class="line">                <span class="keyword">return</span> executionSemaphorePerCircuit.get(commandKey.name());</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> _s;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> executionSemaphoreOverride;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// return NoOp implementation since we're not using SEMAPHORE isolation</span></div><div class="line">        <span class="keyword">return</span> TryableSemaphoreNoOp.DEFAULT;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>根据<strong>执行隔离策略</strong>不同获取不同的信号量实现 ：<ul><li><code>Thread</code> ，该方式不使用信号量，因此使用 TryableSemaphoreNoOp 。</li><li><code>Semaphore</code> ，该方式使用信号量，因此使用 TryableSemaphoreActual 。<ul><li>相同的 <code>commandKey</code> ，使用相同的 TryableSemaphoreActual 。</li></ul></li></ul></li></ul><h1>4. #executeCommandAndObserve(...)</h1><p>调用 <code>#executeCommandAndObserve(...)</code> 方法，获得【执行命令 Observable】。代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> Observable&lt;R&gt; <span class="title">executeCommandAndObserve</span><span class="params">(<span class="keyword">final</span> AbstractCommand&lt;R&gt; _cmd)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// TODO 【】</span></div><div class="line"> <span class="number">3</span>:     <span class="keyword">final</span> HystrixRequestContext currentRequestContext = HystrixRequestContext.getContextForCurrentThread();</div><div class="line"> <span class="number">4</span>: </div><div class="line"> <span class="number">5</span>:     <span class="comment">// TODO 【2007】【executionResult】用途</span></div><div class="line"> <span class="number">6</span>:     <span class="keyword">final</span> Action1&lt;R&gt; markEmits = <span class="keyword">new</span> Action1&lt;R&gt;() &#123;</div><div class="line"> <span class="number">7</span>:         <span class="meta">@Override</span></div><div class="line"> <span class="number">8</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(R r)</span> </span>&#123;</div><div class="line"> <span class="number">9</span>:             <span class="keyword">if</span> (shouldOutputOnNextEvents()) &#123;</div><div class="line"><span class="number">10</span>:                 executionResult = executionResult.addEvent(HystrixEventType.EMIT);</div><div class="line"><span class="number">11</span>:                 eventNotifier.markEvent(HystrixEventType.EMIT, commandKey);</div><div class="line"><span class="number">12</span>:             &#125;</div><div class="line"><span class="number">13</span>:             <span class="keyword">if</span> (commandIsScalar()) &#123;</div><div class="line"><span class="number">14</span>:                 <span class="keyword">long</span> latency = System.currentTimeMillis() - executionResult.getStartTimestamp();</div><div class="line"><span class="number">15</span>:                 eventNotifier.markEvent(HystrixEventType.SUCCESS, commandKey);</div><div class="line"><span class="number">16</span>:                 executionResult = executionResult.addEvent((<span class="keyword">int</span>) latency, HystrixEventType.SUCCESS);</div><div class="line"><span class="number">17</span>:                 eventNotifier.markCommandExecution(getCommandKey(), properties.executionIsolationStrategy().get(), (<span class="keyword">int</span>) latency, executionResult.getOrderedList());</div><div class="line"><span class="number">18</span>:                 circuitBreaker.markSuccess();</div><div class="line"><span class="number">19</span>:             &#125;</div><div class="line"><span class="number">20</span>:         &#125;</div><div class="line"><span class="number">21</span>:     &#125;;</div><div class="line"><span class="number">22</span>: </div><div class="line"><span class="number">23</span>:     <span class="comment">// TODO 【2007】【executionResult】用途</span></div><div class="line"><span class="number">24</span>:     <span class="keyword">final</span> Action0 markOnCompleted = <span class="keyword">new</span> Action0() &#123;</div><div class="line"><span class="number">25</span>:         <span class="meta">@Override</span></div><div class="line"><span class="number">26</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">27</span>:             <span class="keyword">if</span> (!commandIsScalar()) &#123;</div><div class="line"><span class="number">28</span>:                 <span class="keyword">long</span> latency = System.currentTimeMillis() - executionResult.getStartTimestamp();</div><div class="line"><span class="number">29</span>:                 eventNotifier.markEvent(HystrixEventType.SUCCESS, commandKey);</div><div class="line"><span class="number">30</span>:                 executionResult = executionResult.addEvent((<span class="keyword">int</span>) latency, HystrixEventType.SUCCESS);</div><div class="line"><span class="number">31</span>:                 eventNotifier.markCommandExecution(getCommandKey(), properties.executionIsolationStrategy().get(), (<span class="keyword">int</span>) latency, executionResult.getOrderedList());</div><div class="line"><span class="number">32</span>:                 circuitBreaker.markSuccess();</div><div class="line"><span class="number">33</span>:             &#125;</div><div class="line"><span class="number">34</span>:         &#125;</div><div class="line"><span class="number">35</span>:     &#125;;</div><div class="line"><span class="number">36</span>: </div><div class="line"><span class="number">37</span>:     <span class="comment">// 失败回退逻辑 Func1</span></div><div class="line"><span class="number">38</span>:     <span class="keyword">final</span> Func1&lt;Throwable, Observable&lt;R&gt;&gt; handleFallback = <span class="keyword">new</span> Func1&lt;Throwable, Observable&lt;R&gt;&gt;() &#123;</div><div class="line"><span class="number">39</span>:         <span class="meta">@Override</span></div><div class="line"><span class="number">40</span>:         <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">(Throwable t)</span> </span>&#123;</div><div class="line"><span class="number">41</span>:             circuitBreaker.markNonSuccess();</div><div class="line"><span class="number">42</span>:             Exception e = getExceptionFromThrowable(t);</div><div class="line"><span class="number">43</span>:             executionResult = executionResult.setExecutionException(e);</div><div class="line"><span class="number">44</span>:             <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RejectedExecutionException) &#123;</div><div class="line"><span class="number">45</span>:                 <span class="keyword">return</span> handleThreadPoolRejectionViaFallback(e);</div><div class="line"><span class="number">46</span>:             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> HystrixTimeoutException) &#123;</div><div class="line"><span class="number">47</span>:                 <span class="keyword">return</span> handleTimeoutViaFallback();</div><div class="line"><span class="number">48</span>:             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> HystrixBadRequestException) &#123;</div><div class="line"><span class="number">49</span>:                 <span class="keyword">return</span> handleBadRequestByEmittingError(e);</div><div class="line"><span class="number">50</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">51</span>:                 <span class="comment">/*</span></div><div class="line"><span class="comment">52:                  * Treat HystrixBadRequestException from ExecutionHook like a plain HystrixBadRequestException.</span></div><div class="line"><span class="comment">53:                  */</span></div><div class="line"><span class="number">54</span>:                 <span class="keyword">if</span> (e <span class="keyword">instanceof</span> HystrixBadRequestException) &#123;</div><div class="line"><span class="number">55</span>:                     eventNotifier.markEvent(HystrixEventType.BAD_REQUEST, commandKey);</div><div class="line"><span class="number">56</span>:                     <span class="keyword">return</span> Observable.error(e);</div><div class="line"><span class="number">57</span>:                 &#125;</div><div class="line"><span class="number">58</span>: </div><div class="line"><span class="number">59</span>:                 <span class="keyword">return</span> handleFailureViaFallback(e);</div><div class="line"><span class="number">60</span>:             &#125;</div><div class="line"><span class="number">61</span>:         &#125;</div><div class="line"><span class="number">62</span>:     &#125;;</div><div class="line"><span class="number">63</span>: </div><div class="line"><span class="number">64</span>:     <span class="comment">// TODO 【2008】【请求缓存】</span></div><div class="line"><span class="number">65</span>:     <span class="keyword">final</span> Action1&lt;Notification&lt;? <span class="keyword">super</span> R&gt;&gt; setRequestContext = <span class="keyword">new</span> Action1&lt;Notification&lt;? <span class="keyword">super</span> R&gt;&gt;() &#123;</div><div class="line"><span class="number">66</span>:         <span class="meta">@Override</span></div><div class="line"><span class="number">67</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Notification&lt;? <span class="keyword">super</span> R&gt; rNotification)</span> </span>&#123;</div><div class="line"><span class="number">68</span>:             setRequestContextIfNeeded(currentRequestContext);</div><div class="line"><span class="number">69</span>:         &#125;</div><div class="line"><span class="number">70</span>:     &#125;;</div><div class="line"><span class="number">71</span>: </div><div class="line"><span class="number">72</span>:     Observable&lt;R&gt; execution;</div><div class="line"><span class="number">73</span>:     <span class="keyword">if</span> (properties.executionTimeoutEnabled().get()) &#123;</div><div class="line"><span class="number">74</span>:         execution = executeCommandWithSpecifiedIsolation(_cmd)</div><div class="line"><span class="number">75</span>:                 .lift(<span class="keyword">new</span> HystrixObservableTimeoutOperator&lt;R&gt;(_cmd)); <span class="comment">// 超时</span></div><div class="line"><span class="number">76</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">77</span>:         execution = executeCommandWithSpecifiedIsolation(_cmd);</div><div class="line"><span class="number">78</span>:     &#125;</div><div class="line"><span class="number">79</span>: </div><div class="line"><span class="number">80</span>:     <span class="keyword">return</span> execution.doOnNext(markEmits)</div><div class="line"><span class="number">81</span>:             .doOnCompleted(markOnCompleted)</div><div class="line"><span class="number">82</span>:             .onErrorResumeNext(handleFallback)</div><div class="line"><span class="number">83</span>:             .doOnEach(setRequestContext);</div><div class="line"><span class="number">84</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 3 行 ：TODO 【2012】【请求上下文】</li><li>第 6 至 21 行 ：TODO 【2007】【executionResult】用途</li><li>第 24 至 35 行 ：TODO 【2007】【executionResult】用途</li><li>第 38 至 62 行 ：失败回退逻辑 Func1 ，在 <a href="http://www.iocoder.cn/categories/Hystrix/?self">《Hystrix 源码解析 —— 请求执行（四）之失败回退逻辑》</a> 详细解析。</li><li>第 65 至 70 行 ：TODO 【2012】【请求上下文】</li><li>第 72 至 78 行 ：调用 <code>#executeCommandWithSpecifiedIsolation(...)</code> 方法，获得【执行命令 Observable】，在 <a href="#">「5. #executeCommandWithSpecifiedIsolation(...)」</a> 详细解析。<ul><li>若执行命令超时特性<strong>开启</strong>，调用 <code>Observable#lift(HystrixObservableTimeoutOperator)</code> 方法，实现执行命令超时功能。在 <a href="http://www.iocoder.cn/Hystrix/command-execute-third-timeout/?self">《Hystrix 源码解析 —— 命令执行（三）之执行超时》</a> 详细解析。</li></ul></li><li>第 80 至 83 行 ：返回【执行命令 Observable】。</li></ul><h1>5. #executeCommandWithSpecifiedIsolation(...)</h1><p>调用 <code>#executeCommandWithSpecifiedIsolation(...)</code> 方法，获得【执行命令 Observable】。代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">private</span> Observable&lt;R&gt; <span class="title">executeCommandWithSpecifiedIsolation</span><span class="params">(<span class="keyword">final</span> AbstractCommand&lt;R&gt; _cmd)</span> </span>&#123;</div><div class="line">  <span class="number">2</span>:     <span class="keyword">if</span> (properties.executionIsolationStrategy().get() == ExecutionIsolationStrategy.THREAD) &#123;</div><div class="line">  <span class="number">3</span>:         <span class="comment">// mark that we are executing in a thread (even if we end up being rejected we still were a THREAD execution and not SEMAPHORE)</span></div><div class="line">  <span class="number">4</span>:         <span class="keyword">return</span> Observable.defer(<span class="keyword">new</span> Func0&lt;Observable&lt;R&gt;&gt;() &#123;</div><div class="line">  <span class="number">5</span>:             <span class="meta">@Override</span></div><div class="line">  <span class="number">6</span>:             <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="number">7</span>: </div><div class="line">  <span class="number">8</span>:                 <span class="comment">// 标记 executionResult 执行已发生</span></div><div class="line">  <span class="number">9</span>:                 executionResult = executionResult.setExecutionOccurred();</div><div class="line"> <span class="number">10</span>: </div><div class="line"> <span class="number">11</span>:                 <span class="comment">// 设置 commandState 为 USER_CODE_EXECUTED</span></div><div class="line"> <span class="number">12</span>:                 <span class="keyword">if</span> (!commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.USER_CODE_EXECUTED)) &#123;</div><div class="line"> <span class="number">13</span>:                     <span class="keyword">return</span> Observable.error(<span class="keyword">new</span> IllegalStateException(<span class="string">"execution attempted while in state : "</span> + commandState.get().name()));</div><div class="line"> <span class="number">14</span>:                 &#125;</div><div class="line"> <span class="number">15</span>: </div><div class="line"> <span class="number">16</span>:                 <span class="comment">// TODO 【2002】【metrics】</span></div><div class="line"> <span class="number">17</span>:                 metrics.markCommandStart(commandKey, threadPoolKey, ExecutionIsolationStrategy.THREAD);</div><div class="line"> <span class="number">18</span>: </div><div class="line"> <span class="number">19</span>:                 <span class="comment">// TODO 【2009】【执行超时】</span></div><div class="line"> <span class="number">20</span>:                 <span class="keyword">if</span> (isCommandTimedOut.get() == TimedOutStatus.TIMED_OUT) &#123;</div><div class="line"> <span class="number">21</span>:                     <span class="comment">// the command timed out in the wrapping thread so we will return immediately</span></div><div class="line"> <span class="number">22</span>:                     <span class="comment">// and not increment any of the counters below or other such logic</span></div><div class="line"> <span class="number">23</span>:                     <span class="keyword">return</span> Observable.error(<span class="keyword">new</span> RuntimeException(<span class="string">"timed out before executing run()"</span>));</div><div class="line"> <span class="number">24</span>:                 &#125;</div><div class="line"> <span class="number">25</span>: </div><div class="line"> <span class="number">26</span>:                 <span class="comment">// 设置 线程状态 为 ThreadState.STARTED</span></div><div class="line"> <span class="number">27</span>:                 <span class="keyword">if</span> (threadState.compareAndSet(ThreadState.NOT_USING_THREAD, ThreadState.STARTED)) &#123;</div><div class="line"> <span class="number">28</span>:                     <span class="comment">// TODO 【2002】【metrics】</span></div><div class="line"> <span class="number">29</span>:                     <span class="comment">//we have not been unsubscribed, so should proceed</span></div><div class="line"> <span class="number">30</span>:                     HystrixCounters.incrementGlobalConcurrentThreads();</div><div class="line"> <span class="number">31</span>:                     threadPool.markThreadExecution();</div><div class="line"> <span class="number">32</span>: </div><div class="line"> <span class="number">33</span>:                     <span class="comment">// TODO 【2010】【endCurrentThreadExecutingCommand】</span></div><div class="line"> <span class="number">34</span>:                     <span class="comment">// store the command that is being run</span></div><div class="line"> <span class="number">35</span>:                     endCurrentThreadExecutingCommand = Hystrix.startCurrentThreadExecutingCommand(getCommandKey());</div><div class="line"> <span class="number">36</span>: </div><div class="line"> <span class="number">37</span>:                     <span class="comment">// 标记 executionResult 使用线程执行</span></div><div class="line"> <span class="number">38</span>:                     executionResult = executionResult.setExecutedInThread();</div><div class="line"> <span class="number">39</span>:                     <span class="comment">/**</span></div><div class="line"><span class="comment"> 40:                      * If any of these hooks throw an exception, then it appears as if the actual execution threw an error</span></div><div class="line"><span class="comment"> 41:                      */</span></div><div class="line"> <span class="number">42</span>:                     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">43</span>:                         <span class="comment">// TODO 【2003】【HOOK】</span></div><div class="line"> <span class="number">44</span>:                         executionHook.onThreadStart(_cmd);</div><div class="line"> <span class="number">45</span>:                         executionHook.onRunStart(_cmd);</div><div class="line"> <span class="number">46</span>:                         executionHook.onExecutionStart(_cmd);</div><div class="line"> <span class="number">47</span>: </div><div class="line"> <span class="number">48</span>:                         <span class="comment">// 获得 执行Observable</span></div><div class="line"> <span class="number">49</span>:                         <span class="keyword">return</span> getUserExecutionObservable(_cmd);</div><div class="line"> <span class="number">50</span>:                     &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line"> <span class="number">51</span>:                         <span class="keyword">return</span> Observable.error(ex);</div><div class="line"> <span class="number">52</span>:                     &#125;</div><div class="line"> <span class="number">53</span>:                 &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">54</span>:                     <span class="comment">//command has already been unsubscribed, so return immediately</span></div><div class="line"> <span class="number">55</span>:                     <span class="keyword">return</span> Observable.empty();</div><div class="line"> <span class="number">56</span>:                 &#125;</div><div class="line"> <span class="number">57</span>:             &#125;</div><div class="line"> <span class="number">58</span>:         &#125;).doOnTerminate(<span class="keyword">new</span> Action0() &#123;</div><div class="line"> <span class="number">59</span>:             <span class="meta">@Override</span></div><div class="line"> <span class="number">60</span>:             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">61</span>:                 <span class="keyword">if</span> (threadState.compareAndSet(ThreadState.STARTED, ThreadState.TERMINAL)) &#123;</div><div class="line"> <span class="number">62</span>:                     handleThreadEnd(_cmd);</div><div class="line"> <span class="number">63</span>:                 &#125;</div><div class="line"> <span class="number">64</span>:                 <span class="keyword">if</span> (threadState.compareAndSet(ThreadState.NOT_USING_THREAD, ThreadState.TERMINAL)) &#123;</div><div class="line"> <span class="number">65</span>:                     <span class="comment">//if it was never started and received terminal, then no need to clean up (I don't think this is possible)</span></div><div class="line"> <span class="number">66</span>:                 &#125;</div><div class="line"> <span class="number">67</span>:                 <span class="comment">//if it was unsubscribed, then other cleanup handled it</span></div><div class="line"> <span class="number">68</span>:             &#125;</div><div class="line"> <span class="number">69</span>:         &#125;).doOnUnsubscribe(<span class="keyword">new</span> Action0() &#123;</div><div class="line"> <span class="number">70</span>:             <span class="meta">@Override</span></div><div class="line"> <span class="number">71</span>:             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">72</span>:                 <span class="keyword">if</span> (threadState.compareAndSet(ThreadState.STARTED, ThreadState.UNSUBSCRIBED)) &#123;</div><div class="line"> <span class="number">73</span>:                     handleThreadEnd(_cmd);</div><div class="line"> <span class="number">74</span>:                 &#125;</div><div class="line"> <span class="number">75</span>:                 <span class="keyword">if</span> (threadState.compareAndSet(ThreadState.NOT_USING_THREAD, ThreadState.UNSUBSCRIBED)) &#123;</div><div class="line"> <span class="number">76</span>:                     <span class="comment">//if it was never started and was cancelled, then no need to clean up</span></div><div class="line"> <span class="number">77</span>:                 &#125;</div><div class="line"> <span class="number">78</span>:                 <span class="comment">//if it was terminal, then other cleanup handled it</span></div><div class="line"> <span class="number">79</span>:             &#125;</div><div class="line"> <span class="number">80</span>:         &#125;).subscribeOn(threadPool.getScheduler(<span class="keyword">new</span> Func0&lt;Boolean&gt;() &#123; <span class="comment">// TODO 芋艿：Scheduler</span></div><div class="line"> <span class="number">81</span>:             <span class="meta">@Override</span></div><div class="line"> <span class="number">82</span>:             <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">83</span>:                 <span class="keyword">return</span> properties.executionIsolationThreadInterruptOnTimeout().get() &amp;&amp; _cmd.isCommandTimedOut.get() == TimedOutStatus.TIMED_OUT;</div><div class="line"> <span class="number">84</span>:             &#125;</div><div class="line"> <span class="number">85</span>:         &#125;));</div><div class="line"> <span class="number">86</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">87</span>:         <span class="keyword">return</span> Observable.defer(<span class="keyword">new</span> Func0&lt;Observable&lt;R&gt;&gt;() &#123;</div><div class="line"> <span class="number">88</span>:             <span class="meta">@Override</span></div><div class="line"> <span class="number">89</span>:             <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">90</span>:                 <span class="comment">// 标记 executionResult 执行已发生</span></div><div class="line"> <span class="number">91</span>:                 executionResult = executionResult.setExecutionOccurred();</div><div class="line"> <span class="number">92</span>: </div><div class="line"> <span class="number">93</span>:                 <span class="comment">// 设置 commandState 为 USER_CODE_EXECUTED</span></div><div class="line"> <span class="number">94</span>:                 <span class="keyword">if</span> (!commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.USER_CODE_EXECUTED)) &#123;</div><div class="line"> <span class="number">95</span>:                     <span class="keyword">return</span> Observable.error(<span class="keyword">new</span> IllegalStateException(<span class="string">"execution attempted while in state : "</span> + commandState.get().name()));</div><div class="line"> <span class="number">96</span>:                 &#125;</div><div class="line"> <span class="number">97</span>: </div><div class="line"> <span class="number">98</span>:                 <span class="comment">// TODO 【2002】【metrics】</span></div><div class="line"> <span class="number">99</span>:                 metrics.markCommandStart(commandKey, threadPoolKey, ExecutionIsolationStrategy.SEMAPHORE);</div><div class="line"><span class="number">100</span>: </div><div class="line"><span class="number">101</span>:                 <span class="comment">// TODO 【2010】【endCurrentThreadExecutingCommand】</span></div><div class="line"><span class="number">102</span>:                 <span class="comment">// semaphore isolated</span></div><div class="line"><span class="number">103</span>:                 <span class="comment">// store the command that is being run</span></div><div class="line"><span class="number">104</span>:                 endCurrentThreadExecutingCommand = Hystrix.startCurrentThreadExecutingCommand(getCommandKey());</div><div class="line"><span class="number">105</span>:                 <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">106</span>:                     <span class="comment">// TODO 【2003】【HOOK】</span></div><div class="line"><span class="number">107</span>:                     executionHook.onRunStart(_cmd);</div><div class="line"><span class="number">108</span>:                     executionHook.onExecutionStart(_cmd);</div><div class="line"><span class="number">109</span>: </div><div class="line"><span class="number">110</span>:                     <span class="comment">// 获得 执行Observable</span></div><div class="line"><span class="number">111</span>:                     <span class="keyword">return</span> getUserExecutionObservable(_cmd);  <span class="comment">//the getUserExecutionObservable method already wraps sync exceptions, so this shouldn't throw</span></div><div class="line"><span class="number">112</span>:                 &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line"><span class="number">113</span>:                     <span class="comment">//If the above hooks throw, then use that as the result of the run method</span></div><div class="line"><span class="number">114</span>:                     <span class="keyword">return</span> Observable.error(ex);</div><div class="line"><span class="number">115</span>:                 &#125;</div><div class="line"><span class="number">116</span>:             &#125;</div><div class="line"><span class="number">117</span>:         &#125;);</div><div class="line"><span class="number">118</span>:     &#125;</div><div class="line"><span class="number">119</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>根据<strong>执行隔离策略</strong>不同，创建<strong>不同</strong>的【执行命令 Observable】。仔细对比下，大体逻辑都是相同的，差别在于<strong>执行隔离策略</strong>为 <code>Thread</code> 时，使用 RxJava Scheduler 以及对<strong>线程</strong>的处理。</p></li><li><p>第 2 至 85 行 ：<strong>执行隔离策略</strong>为 <code>Thread</code> ：</p><ul><li>第 9 行 ：标记 <code>executionResult</code> 执行已发生。</li><li>第 12 至 14 行 ：设置 <code>commandState</code> 为 <code>USER_CODE_EXECUTED</code> 。若设置失败，调用 <code>Observable#error(Exception)</code> 方法返回 Observable 。</li><li>第 17 行 ：TODO 【2002】【metrics】</li><li>第 20 至 24 行 ：TODO 【2009】【执行超时】</li><li>第 27 行 ：设置 <code>threadState</code> 为 <code>ThreadState.STARTED</code> 成功。<ul><li>第 30 至 31 行 ：TODO 【2002】【metrics】</li><li>第 35 行 ：TODO 【2010】【endCurrentThreadExecutingCommand】</li><li>第 38 行 ：标记 <code>executionResult</code> 使用<strong>线程</strong>执行。</li><li>第 44 至 46 行 ：TODO 【2003】【HOOK】</li><li>第 49 行 ：调用 <code>#getUserExecutionObservable(...)</code> 方法，<strong>创建</strong>【执行命令 Observable】。</li><li>第 50 至 52 行 ：若发生异常，调用 <code>Observable#error(Exception)</code> 方法返回 Observable 。</li></ul></li><li>第 53 至 56 行 ：设置 <code>threadState</code> 为 <code>ThreadState.STARTED</code> 失败，执行命令此时已经被<strong>取消</strong>，调用 <code>Observable#empty()</code> 方法返回 Observable 。</li><li>第 58 至 68 行 ：调用 <code>Observable#doOnTerminate(...)</code> 方法，添加 Action0 。<code>#handleThreadEnd(...)</code> 方法，点击 <a href="https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java#L1103" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看。</li><li>第 69 至 79 行 ：调用 <code>Observable#doOnUnsubscribe(...)</code> 方法，添加 Action0 。</li><li>第 80 至 85 行 ：调用 <code>Observable#subscribeOn(Scheduler)</code> 方法，指定 Observable <strong>自身</strong>在哪个调度器上执行。<ul><li>RxJava Scheduler ，在 <a href="http://www.iocoder.cn/RxJava/observable-subscribe-on-scheduler/?self">《RxJava 源码解析 —— Scheduler》</a> 有详细解析。</li><li><code>Observable#subscribeOn(Scheduler)</code> ，在 <a href="http://www.iocoder.cn/RxJava/observable-subscribe-on-scheduler/?self">《RxJava 源码解析 —— Observable#subscribeOn(Scheduler)》</a> 有详细解析。</li><li>调用 <code>ThreadPool#getScheduler(Func0&lt;Boolean&gt;)</code> 方法，获得 Hystrix 自定义实现的 RxJava Scheduler ，在 <a href="http://www.iocoder.cn/Hystrix/command-execute-second-isolation-strategy/?self">《Hystrix 源码解析 —— 命令执行（二）之执行隔离策略》</a> 详细解析。</li></ul></li></ul></li><li><p>第 86 至 118 行 ：<strong>执行隔离策略</strong>为 <code>SEMAPHORE</code> ：</p><ul><li>第 91 行 ：[ 与第 9 行<strong>相同</strong> ]。</li><li>第 94 至 96 行 ：[ 与第 12 至 14行<strong>相同</strong> ]。</li><li>第 99 行 ：[ 与第 17 行<strong>类似</strong> ]。</li><li>第 104 行 ：[ 与第 35 行<strong>相同</strong> ]。</li><li>第 107 至 108 行 ：[ 与第 45 至 46 行<strong>相同</strong> ]。</li><li>第 111 行 ：[ 与第 49 行<strong>相同</strong> ]。</li><li>第 112 至 115 行 ：[ 与第 50 至 52 行<strong>相同</strong> ]。</li></ul></li></ul><h1>6. #getUserExecutionObservable(...)</h1><p>调用 <code>#getUserExecutionObservable(...)</code> 方法，创建【执行命令 Observable】。代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> Observable&lt;R&gt; <span class="title">getUserExecutionObservable</span><span class="params">(<span class="keyword">final</span> AbstractCommand&lt;R&gt; _cmd)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     Observable&lt;R&gt; userObservable;</div><div class="line"> <span class="number">3</span>: </div><div class="line"> <span class="number">4</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">5</span>:         userObservable = getExecutionObservable();</div><div class="line"> <span class="number">6</span>:     &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line"> <span class="number">7</span>:         <span class="comment">// the run() method is a user provided implementation so can throw instead of using Observable.onError</span></div><div class="line"> <span class="number">8</span>:         <span class="comment">// so we catch it here and turn it into Observable.error</span></div><div class="line"> <span class="number">9</span>:         userObservable = Observable.error(ex);</div><div class="line"><span class="number">10</span>:     &#125;</div><div class="line"><span class="number">11</span>: </div><div class="line"><span class="number">12</span>:     <span class="keyword">return</span> userObservable</div><div class="line"><span class="number">13</span>:             .lift(<span class="keyword">new</span> ExecutionHookApplication(_cmd)) <span class="comment">// TODO 【2003】【HOOK】</span></div><div class="line"><span class="number">14</span>:             .lift(<span class="keyword">new</span> DeprecatedOnRunHookApplication(_cmd)); <span class="comment">// 已废弃</span></div><div class="line"><span class="number">15</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 5 行 ：调用 <code>#getExecutionObservable()</code> 方法，创建【执行命令 Observable】。<code>#getExecutionObservable()</code> 是个<strong>抽象</strong>方法，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Observable&lt;R&gt; <span class="title">getExecutionObservable</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure></p><ul><li>HystrixCommand 实现了该方法，在 <a href="#">「7. #getExecutionObservable」</a> 详细解析。</li></ul></li><li><p>第 6 至 10 行 ：若发生异常，调用 <code>Observable#error(Exception)</code> 方法返回 Observable 。</p></li><li><p>第 12 至 14 行 ：返回【执行命令 Observable】。</p><ul><li>第 13 行 ：TODO 【2003】【HOOK】</li></ul></li></ul><h1>7. #getExecutionObservable()</h1><p>调用 <code>HystrixCommand#getExecutionObservable()</code> 方法，创建【执行命令 Observable】。代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">final</span> <span class="keyword">protected</span> Observable&lt;R&gt; <span class="title">getExecutionObservable</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="keyword">return</span> Observable.defer(<span class="keyword">new</span> Func0&lt;Observable&lt;R&gt;&gt;() &#123;</div><div class="line"> <span class="number">4</span>:         <span class="meta">@Override</span></div><div class="line"> <span class="number">5</span>:         <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">6</span>:             <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">7</span>:                 <span class="keyword">return</span> Observable.just(run());</div><div class="line"> <span class="number">8</span>:             &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line"> <span class="number">9</span>:                 <span class="keyword">return</span> Observable.error(ex);</div><div class="line"><span class="number">10</span>:             &#125;</div><div class="line"><span class="number">11</span>:         &#125;</div><div class="line"><span class="number">12</span>:     &#125;).doOnSubscribe(<span class="keyword">new</span> Action0() &#123;</div><div class="line"><span class="number">13</span>:         <span class="meta">@Override</span></div><div class="line"><span class="number">14</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">15</span>:             <span class="comment">// 记录 执行线程</span></div><div class="line"><span class="number">16</span>:             <span class="comment">// Save thread on which we get subscribed so that we can interrupt it later if needed</span></div><div class="line"><span class="number">17</span>:             executionThread.set(Thread.currentThread());</div><div class="line"><span class="number">18</span>:         &#125;</div><div class="line"><span class="number">19</span>:     &#125;);</div><div class="line"><span class="number">20</span>: &#125;</div><div class="line"><span class="number">21</span>: </div><div class="line"><span class="number">22</span>: <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> R <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div></pre></td></tr></table></figure></p><ul><li>第 3 至 11 行 ：调用 <code>Observable#defer(Func0&lt;Observable&lt;R&gt;)</code> 方法，创建【执行命令 Observable】。<ul><li>第 7 行 ：调用 <code>#run()</code> 方法，<strong>运行正常执逻辑</strong>。通过 <code>Observable#just(...)</code> 方法，返回创建【执行命令 Observable】。</li></ul></li><li>第 12 至 19 行 ：调用 <code>#doOnSubscribe(...)</code> 方法，添加 Action 。该操作记录执行线程( <code>executionThread</code> ) 。<code>executionThread</code> 用于 <code>HystrixCommand#queue()</code> 方法，返回的 Future 结果，可以调用 <code>Future#cancel(Boolean)</code> 方法，点击 <a href="https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommand.java#L380" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看该方法。</li><li>第 22 行 ：<code>#run()</code> <strong>抽象</strong>方法，实现该方法，<strong>运行正常执逻辑</strong>。</li></ul><h1>8. CommandState</h1><p><code>com.netflix.hystrix.AbstractCommand.CommandState</code> ，命令状态，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">enum</span> CommandState &#123;</div><div class="line">    NOT_STARTED, OBSERVABLE_CHAIN_CREATED, USER_CODE_EXECUTED, UNSUBSCRIBED, TERMINAL</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>状态变迁如下图 ：</p><p><img src="http://www.iocoder.cn/images/Hystrix/2018_10_22/02.png" alt=""></p><h1>9. ThreadState</h1><p><code>com.netflix.hystrix.AbstractCommand.ThreadState</code> ，线程状态，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">enum</span> ThreadState &#123;</div><div class="line">   NOT_USING_THREAD, STARTED, UNSUBSCRIBED, TERMINAL</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>状态变迁如下图 ：</p><p><img src="http://www.iocoder.cn/images/Hystrix/2018_10_22/03.png" alt=""></p><h1>666. 彩蛋</h1><p>对 Hystrix 和 RxJava 慢慢更有感觉了。</p><p>柳暗花明又一村。</p><p>继续加油！</p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/Hystrix/command-execute-first-run/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 Hystrix 1.5.X 版本&lt;/strong&gt;&lt;/p&gt;
      
    
    </summary>
    
      <category term="Hystrix" scheme="http://www.iocoder.cn/categories/Hystrix/"/>
    
    
  </entry>
  
  <entry>
    <title>Hystrix 源码解析 —— 执行结果缓存</title>
    <link href="http://www.iocoder.cn/Hystrix/command-execute-result-cache/"/>
    <id>http://www.iocoder.cn/Hystrix/command-execute-result-cache/</id>
    <published>2018-10-14T16:00:00.000Z</published>
    <updated>2017-11-08T09:51:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/Hystrix/command-execute-result-cache/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Hystrix 1.5.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Hystrix/command-execute-result-cache/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-result-cache/">2. 好处</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-result-cache/">3. Observable#defer(...)</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-result-cache/">4. AbstractCommand#toObservavle(...)</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-result-cache/">5. HystrixCachedObservable</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-result-cache/">6. HystrixCommandResponseFromCache</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-result-cache/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p>本文主要分享 <strong>Hystrix 执行命令的结果缓存</strong>。</p><p>建议 ：对 RxJava 已经有一定的了解的基础上阅读本文。</p><p>Hystrix 执行命令整体流程如下图：</p><blockquote><p>FROM <a href="http://youdang.github.io/2016/02/05/translate-hystrix-wiki-how-it-works/#%E6%B5%81%E7%A8%8B%E5%9B%BE" rel="external nofollow noopener noreferrer" target="_blank">《【翻译】Hystrix文档-实现原理》「流程图」</a><br><img src="http://www.iocoder.cn/images/Hystrix/2018_10_15/01.jpeg" alt=""></p></blockquote><ul><li>红圈 ：在 <a href="http://www.iocoder.cn/Hystrix/command-execute-mode/?self">《Hystrix 源码解析 —— 执行命令方式》</a> 有详细解析。</li><li>紫圈 ：在 <code>#toObservable()</code> 方法里，如果请求结果缓存这个特性被<strong>启用</strong>，并且<strong>缓存命中</strong>，则缓存的回应会立即通过一个 Observable 对象的形式返回；如果<strong>缓存未命中</strong>，则返回【<strong>订阅了执行命令的 Observable</strong>】的 ReplySubject 对象缓存执行结果。<ul><li>ReplySubject 能够<strong>重放</strong>执行结果，从而实现缓存的功效。本文不对 ReplySubject 做太多拓展，感兴趣的同学可以阅读 <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/Subject.html" rel="external nofollow noopener noreferrer" target="_blank">《ReactiveX/RxJava文档中文版 —— Subject》</a> 。</li></ul></li></ul><p>在官方提供的示例中，我们使用 <a href="https://github.com/Netflix/Hystrix/blob/1f64fced24289ea435f1e2d5a47a068bf7b79729/hystrix-examples/src/main/java/com/netflix/hystrix/examples/basic/CommandUsingRequestCache.java" rel="external nofollow noopener noreferrer" target="_blank">CommandUsingRequestCache</a> 进行调试 。</p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1>2. 好处</h1><p>点击 <a href="http://youdang.github.io/2016/02/05/translate-hystrix-wiki-how-it-works/#%E8%AF%B7%E6%B1%82%E7%BC%93%E5%AD%98" rel="external nofollow noopener noreferrer" target="_blank">《【翻译】Hystrix文档-实现原理》「请求缓存」</a> ，查看对<strong>请求缓存</strong>的好处分享，写的真的很赞。</p><h1>3. Observable#defer(...)</h1><p>本小节为<strong>拓展内容</strong>，源码解析 RxJava ( 非 Hystrix ) 的 <code>Observable#defer(...)</code> 的方法实现。考虑到 Hystrix 大量使用，为了更好的理解，解析下源码。</p><p><a href="http://www.iocoder.cn/RxJava/observable-defer/">《RxJava 源码解析 —— Observable#defer(...)》</a></p><h1>4. AbstractCommand#toObservavle(...)</h1><p><code>AbstractCommand#toObservavle(...)</code> 方法，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">toObservable</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="keyword">final</span> AbstractCommand&lt;R&gt; _cmd = <span class="keyword">this</span>;</div><div class="line"> <span class="number">3</span>: </div><div class="line"> <span class="number">4</span>:     <span class="comment">//doOnCompleted handler already did all of the SUCCESS work</span></div><div class="line"> <span class="number">5</span>:     <span class="comment">//doOnError handler already did all of the FAILURE/TIMEOUT/REJECTION/BAD_REQUEST work</span></div><div class="line"> <span class="number">6</span>:     <span class="keyword">final</span> Action0 terminateCommandCleanup = <span class="keyword">new</span> Action0() &#123;&#125; <span class="comment">// ... 省略</span></div><div class="line"> <span class="number">7</span>: </div><div class="line"> <span class="number">8</span>:     <span class="comment">//mark the command as CANCELLED and store the latency (in addition to standard cleanup)</span></div><div class="line"> <span class="number">9</span>:     <span class="keyword">final</span> Action0 unsubscribeCommandCleanup = <span class="keyword">new</span> Action0() &#123;&#125; <span class="comment">// ... 省略</span></div><div class="line"><span class="number">10</span>: </div><div class="line"><span class="number">11</span>:     <span class="keyword">final</span> Func0&lt;Observable&lt;R&gt;&gt; applyHystrixSemantics = <span class="keyword">new</span> Func0&lt;Observable&lt;R&gt;&gt;() &#123;</div><div class="line"><span class="number">12</span>:         <span class="meta">@Override</span></div><div class="line"><span class="number">13</span>:         <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">14</span>:             <span class="keyword">if</span> (commandState.get().equals(CommandState.UNSUBSCRIBED)) &#123;</div><div class="line"><span class="number">15</span>:                 <span class="keyword">return</span> Observable.never();</div><div class="line"><span class="number">16</span>:             &#125;</div><div class="line"><span class="number">17</span>:             <span class="keyword">return</span> applyHystrixSemantics(_cmd);</div><div class="line"><span class="number">18</span>:         &#125;</div><div class="line"><span class="number">19</span>:     &#125;;</div><div class="line"><span class="number">20</span>: </div><div class="line"><span class="number">21</span>:     <span class="keyword">final</span> Func1&lt;R, R&gt; wrapWithAllOnNextHooks = <span class="keyword">new</span> Func1&lt;R, R&gt;() &#123;&#125; <span class="comment">// ... 省略 </span></div><div class="line"><span class="number">22</span>: </div><div class="line"><span class="number">23</span>:     <span class="keyword">final</span> Action0 fireOnCompletedHook = <span class="keyword">new</span> Action0() &#123;&#125; <span class="comment">// ... 省略 </span></div><div class="line"><span class="number">24</span>: </div><div class="line"><span class="number">25</span>:     <span class="keyword">return</span> Observable.defer(<span class="keyword">new</span> Func0&lt;Observable&lt;R&gt;&gt;() &#123;</div><div class="line"><span class="number">26</span>:         <span class="meta">@Override</span></div><div class="line"><span class="number">27</span>:         <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">28</span>:             <span class="comment">/* this is a stateful object so can only be used once */</span></div><div class="line"><span class="number">29</span>:             <span class="keyword">if</span> (!commandState.compareAndSet(CommandState.NOT_STARTED, CommandState.OBSERVABLE_CHAIN_CREATED)) &#123;</div><div class="line"><span class="number">30</span>:                 IllegalStateException ex = <span class="keyword">new</span> IllegalStateException(<span class="string">"This instance can only be executed once. Please instantiate a new instance."</span>);</div><div class="line"><span class="number">31</span>:                 <span class="comment">//TODO make a new error type for this</span></div><div class="line"><span class="number">32</span>:                 <span class="keyword">throw</span> <span class="keyword">new</span> HystrixRuntimeException(FailureType.BAD_REQUEST_EXCEPTION, _cmd.getClass(), getLogMessagePrefix() + <span class="string">" command executed multiple times - this is not permitted."</span>, ex, <span class="keyword">null</span>);</div><div class="line"><span class="number">33</span>:             &#125;</div><div class="line"><span class="number">34</span>: </div><div class="line"><span class="number">35</span>:             <span class="comment">// 命令开始时间戳</span></div><div class="line"><span class="number">36</span>:             commandStartTimestamp = System.currentTimeMillis();</div><div class="line"><span class="number">37</span>: </div><div class="line"><span class="number">38</span>:             <span class="comment">// TODO【2001】【打印日志】</span></div><div class="line"><span class="number">39</span>:             <span class="keyword">if</span> (properties.requestLogEnabled().get()) &#123;</div><div class="line"><span class="number">40</span>:                 <span class="comment">// log this command execution regardless of what happened</span></div><div class="line"><span class="number">41</span>:                 <span class="keyword">if</span> (currentRequestLog != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">42</span>:                     currentRequestLog.addExecutedCommand(_cmd);</div><div class="line"><span class="number">43</span>:                 &#125;</div><div class="line"><span class="number">44</span>:             &#125;</div><div class="line"><span class="number">45</span>: </div><div class="line"><span class="number">46</span>:             <span class="comment">// 缓存开关、缓存KEY</span></div><div class="line"><span class="number">47</span>:             <span class="keyword">final</span> <span class="keyword">boolean</span> requestCacheEnabled = isRequestCachingEnabled();</div><div class="line"><span class="number">48</span>:             <span class="keyword">final</span> String cacheKey = getCacheKey();</div><div class="line"><span class="number">49</span>: </div><div class="line"><span class="number">50</span>:             <span class="comment">// 优先从缓存中获取</span></div><div class="line"><span class="number">51</span>:             <span class="comment">/* try from cache first */</span></div><div class="line"><span class="number">52</span>:             <span class="keyword">if</span> (requestCacheEnabled) &#123;</div><div class="line"><span class="number">53</span>:                 HystrixCommandResponseFromCache&lt;R&gt; fromCache = (HystrixCommandResponseFromCache&lt;R&gt;) requestCache.get(cacheKey);</div><div class="line"><span class="number">54</span>:                 <span class="keyword">if</span> (fromCache != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">55</span>:                     isResponseFromCache = <span class="keyword">true</span>; <span class="comment">// 标记 从缓存中结果</span></div><div class="line"><span class="number">56</span>:                     <span class="keyword">return</span> handleRequestCacheHitAndEmitValues(fromCache, _cmd);</div><div class="line"><span class="number">57</span>:                 &#125;</div><div class="line"><span class="number">58</span>:             &#125;</div><div class="line"><span class="number">59</span>: </div><div class="line"><span class="number">60</span>:             <span class="comment">// 获得 执行命令Observable</span></div><div class="line"><span class="number">61</span>:             Observable&lt;R&gt; hystrixObservable =</div><div class="line"><span class="number">62</span>:                     Observable.defer(applyHystrixSemantics)</div><div class="line"><span class="number">63</span>:                             .map(wrapWithAllOnNextHooks);</div><div class="line"><span class="number">64</span>: </div><div class="line"><span class="number">65</span>:             <span class="comment">// 获得 缓存Observable</span></div><div class="line"><span class="number">66</span>:             Observable&lt;R&gt; afterCache;</div><div class="line"><span class="number">67</span>:             <span class="comment">// put in cache</span></div><div class="line"><span class="number">68</span>:             <span class="keyword">if</span> (requestCacheEnabled &amp;&amp; cacheKey != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">69</span>:                 <span class="comment">// wrap it for caching</span></div><div class="line"><span class="number">70</span>:                 HystrixCachedObservable&lt;R&gt; toCache = HystrixCachedObservable.from(hystrixObservable, _cmd);</div><div class="line"><span class="number">71</span>:                 <span class="comment">// 并发若不存在</span></div><div class="line"><span class="number">72</span>:                 HystrixCommandResponseFromCache&lt;R&gt; fromCache = (HystrixCommandResponseFromCache&lt;R&gt;) requestCache.putIfAbsent(cacheKey, toCache);</div><div class="line"><span class="number">73</span>:                 <span class="keyword">if</span> (fromCache != <span class="keyword">null</span>) &#123; <span class="comment">// 添加失败</span></div><div class="line"><span class="number">74</span>:                     <span class="comment">// another thread beat us so we'll use the cached value instead</span></div><div class="line"><span class="number">75</span>:                     toCache.unsubscribe();</div><div class="line"><span class="number">76</span>:                     isResponseFromCache = <span class="keyword">true</span>; <span class="comment">// 标记 从缓存中结果</span></div><div class="line"><span class="number">77</span>:                     <span class="keyword">return</span> handleRequestCacheHitAndEmitValues(fromCache, _cmd);</div><div class="line"><span class="number">78</span>:                 &#125; <span class="keyword">else</span> &#123; <span class="comment">// 添加成功</span></div><div class="line"><span class="number">79</span>:                     <span class="comment">// we just created an ObservableCommand so we cast and return it</span></div><div class="line"><span class="number">80</span>:                     afterCache = toCache.toObservable();</div><div class="line"><span class="number">81</span>:                 &#125;</div><div class="line"><span class="number">82</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">83</span>:                 afterCache = hystrixObservable;</div><div class="line"><span class="number">84</span>:             &#125;</div><div class="line"><span class="number">85</span>: </div><div class="line"><span class="number">86</span>:             <span class="comment">//</span></div><div class="line"><span class="number">87</span>:             <span class="keyword">return</span> afterCache</div><div class="line"><span class="number">88</span>:                     .doOnTerminate(terminateCommandCleanup)     <span class="comment">// perform cleanup once (either on normal terminal state (this line), or unsubscribe (next line))</span></div><div class="line"><span class="number">89</span>:                     .doOnUnsubscribe(unsubscribeCommandCleanup) <span class="comment">// perform cleanup once</span></div><div class="line"><span class="number">90</span>:                     .doOnCompleted(fireOnCompletedHook);</div><div class="line"><span class="number">91</span>:         &#125;</div><div class="line"><span class="number">92</span>:     &#125;);</div><div class="line"><span class="number">93</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 2 行 ：<code>_cmd</code> 指向当前命令对象，用于下面实现 FuncX ，ActionX 内部类使用。</p></li><li><p>第 11 至 19 行 ：当缓存特性<strong>未开启</strong>，或者缓存<strong>未命中</strong>时，使用 <code>applyHystrixSemantics</code> 传入 <code>Observable#defer(...)</code> 方法，声明<strong>执行命令</strong>的 Observable。</p></li><li><p>第 25 行 ：声明缓存 Observable 。Hystrix 执行命令的 Observable 声明关系如下：</p><p><img src="http://www.iocoder.cn/images/Hystrix/2018_10_15/02.png" alt=""></p></li><li><p>第 29 至 33 行 ：<strong>一条命令只能执行一次</strong>。</p></li><li><p>第 36 行 ：记录命令<strong>开始</strong>时间戳。</p></li><li><p>第 38 至 44 行 ：TODO【2001】【打印日志】</p></li><li><p>第 47 至 48 行 ：缓存存开关、KEY 。</p></li><li><p>第 52 至 58 行 ：如果请求结果缓存这个特性被<strong>启用</strong>，并且<strong>缓存命中</strong>，则缓存的回应会立即通过一个 Observable 对象的形式返回。</p><ul><li>第 53 行 ：<code>requestCache</code> 缓存，在 <a href="#">TODO 【2008】【请求缓存】</a> 详细解析。</li><li>第 53 行 ：<a href="#">「6. HystrixCommandResponseFromCache」</a> 详细解析。</li><li>第 56 行 ：<code>#handleRequestCacheHitAndEmitValues(...)</code> 方法，在<strong>第 78 行</strong>详细解析。</li></ul></li><li><p>第 61 至 63 行 ：获取<strong>执行命令</strong>的 Observable 。在 <a href="http://www.iocoder.cn/Hystrix/command-execute-first-run/?self">《Hystrix 源码解析 —— 命令执行（一）之正常执行逻辑》</a> 详细解析。</p></li><li><p>第 68 至 81 行 ：当缓存特性<strong>开启</strong>，并且缓存<strong>未命中</strong>时，创建【<strong>订阅了执行命令的 Observable</strong>】的 HystrixCommandResponseFromCache 。</p><ul><li>第 69 至 72 行 ：创建 HystrixCommandResponseFromCache ，并添加到 <code>requestCache</code> 。哟，<code>HystrixRequestCache#putIfAbsent(...)</code> 方法，<strong>多个线程</strong>添加时，只有一个线程添加成功。</li><li>第 73 至 77 行 ：添加<strong>失败</strong>的线程( <strong>们</strong> )：<ul><li>第 75 行 ：调用 <code>HystrixCommandResponseFromCache#unsubscribe()</code> 方法，取消 HystrixCommandResponseFromCache 的订阅。这一步很关键，因为我们<strong>不希望缓存不存在时，多个线程去执行命令，最好有且只有一个线程执行命令</strong>。在 <a href="#">「5. HystrixCachedObservable」</a> 详细解析。</li><li>第 77 行 ：<a href="#">「6. HystrixCommandResponseFromCache」</a> 详细解析。</li></ul></li><li>第 80 行 ：调用 <code>HystrixCommandResponseFromCachetoObservable()</code> 方法，获得缓存 Observable 。</li></ul></li><li><p>第 82 至 84 行 ：当缓存特性<strong>未开启</strong>，使用执行命令 Observable 。</p></li><li><p>第 87 至 91 行 ：在返回的 Observable 上，订阅一些清理的处理逻辑。对这几个方法有疑惑的同学，可以阅读 <a href="http://gank.io/post/560e15be2dca930e00da1083#toc_10" rel="external nofollow noopener noreferrer" target="_blank">《给 Android 开发者的 RxJava 详解》「 3) Subscribe (订阅) 」</a> 。</p></li></ul><h1>5. HystrixCachedObservable</h1><p><code>com.netflix.hystrix.HystrixCachedObservable</code> ，缓存 Observable 。</p><p>HystrixCachedObservable <strong>构造方法</strong>，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixCachedObservable</span>&lt;<span class="title">R</span>&gt; </span>&#123;</div><div class="line"> <span class="number">2</span>: <span class="comment">/**</span></div><div class="line"><span class="comment"> 3:  * 订阅</span></div><div class="line"><span class="comment"> 4:  */</span></div><div class="line"> <span class="number">5</span>: <span class="keyword">protected</span> <span class="keyword">final</span> Subscription originalSubscription;</div><div class="line"> <span class="number">6</span>: <span class="comment">/**</span></div><div class="line"><span class="comment"> 7:  * 缓存 cachedObservable</span></div><div class="line"><span class="comment"> 8:  */</span></div><div class="line"> <span class="number">9</span>: <span class="keyword">protected</span> <span class="keyword">final</span> Observable&lt;R&gt; cachedObservable;</div><div class="line"><span class="number">10</span>: <span class="comment">/**</span></div><div class="line"><span class="comment">11:  * TODO 【2006】【outstandingSubscriptions】</span></div><div class="line"><span class="comment">12:  */</span></div><div class="line"><span class="number">13</span>: <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> outstandingSubscriptions = <span class="number">0</span>;</div><div class="line"><span class="number">14</span>: <span class="comment">//private AtomicInteger outstandingSubscriptions2 = new AtomicInteger(0);</span></div><div class="line"><span class="number">15</span>: </div><div class="line"><span class="number">16</span>: <span class="function"><span class="keyword">protected</span> <span class="title">HystrixCachedObservable</span><span class="params">(<span class="keyword">final</span> Observable&lt;R&gt; originalObservable)</span> </span>&#123;</div><div class="line"><span class="number">17</span>:     ReplaySubject&lt;R&gt; replaySubject = ReplaySubject.create();</div><div class="line"><span class="number">18</span>:     <span class="keyword">this</span>.originalSubscription = originalObservable</div><div class="line"><span class="number">19</span>:             .subscribe(replaySubject);</div><div class="line"><span class="number">20</span>: </div><div class="line"><span class="number">21</span>:     <span class="keyword">this</span>.cachedObservable = replaySubject</div><div class="line"><span class="number">22</span>:             .doOnUnsubscribe(<span class="keyword">new</span> Action0() &#123;</div><div class="line"><span class="number">23</span>:                 <span class="meta">@Override</span></div><div class="line"><span class="number">24</span>:                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">25</span>:                     outstandingSubscriptions--;</div><div class="line"><span class="number">26</span>:                     <span class="keyword">if</span> (outstandingSubscriptions == <span class="number">0</span>) &#123;</div><div class="line"><span class="number">27</span>:                         originalSubscription.unsubscribe();</div><div class="line"><span class="number">28</span>:                     &#125;</div><div class="line"><span class="number">29</span>:                 &#125;</div><div class="line"><span class="number">30</span>:             &#125;)</div><div class="line"><span class="number">31</span>:             .doOnSubscribe(<span class="keyword">new</span> Action0() &#123;</div><div class="line"><span class="number">32</span>:                 <span class="meta">@Override</span></div><div class="line"><span class="number">33</span>:                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">34</span>:                     outstandingSubscriptions++;</div><div class="line"><span class="number">35</span>:                 &#125;</div><div class="line"><span class="number">36</span>:             &#125;);</div><div class="line"><span class="number">37</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 17 至 19 行 ：实际上，<strong>HystrixCachedObservable 不是一个 Observable 的子类</strong>，而是对传入的 Observable <strong>封装</strong> ：使用 ReplaySubject 向传入的 Observable 发起订阅，通过 ReplaySubject 能够<strong>重放</strong>执行结果，从而实现缓存的功效。这里有几个卡到笔者的并且很有趣的点，我们一一道来 ：从上文中，我们可以看到，传入的 <code>originalObservable</code> 为 <code>hystrixObservable</code> 执行命令 Observable 。在 Hystrix 里，提供了两种执行命令的隔离方式 ：线程池( <code>THREAD</code> ) 和信号量( <code>SEMAPHORE</code> )。</p><ul><li><p>当使用 <code>THREAD</code> 隔离时，<code>#subscribe(replaySubject)</code> 调用完成时，<strong>实际命令并未开始执行</strong>，或者说，这是一个<strong>异步</strong>的执行命令的过程。那么，<strong>会不会影响返回执行结果呢</strong>？答案当然是不会，BlockingObservable 在得到执行完成才会<strong>结束阻塞</strong>，此时已经有执行结果。</p></li><li><p>当使用 <code>SEMAPHORE</code> 隔离时，<code>#subscribe(replaySubject)</code> 调用完成时，<strong>实际命令已经执行完成</strong>，所以即使 <code>AbstractCommand#toObservavle(...)</code> 的第 75 行 ：调用 <code>HystrixCommandResponseFromCache#unsubscribe()</code> 方法，也会浪费，<strong>重复</strong>执行命令。而对于 <code>THREAD</code> 隔离的情况，通过取消订阅的方式，只会执行<strong>一次</strong>命令。当然，如果“恶搞” <code>THREAD</code> 隔离的情况，增加 <code>sleep</code> 的调用如下，就能达到<strong>重复</strong>执行命令的效果。</p><p><img src="http://www.iocoder.cn/images/Hystrix/2018_10_15/03.png" alt=""></p></li></ul></li><li><p>第 21 至 36 行 ：TODO 【2006】【outstandingSubscriptions】原子性没问题么？历史版本使用的是 AtomicInteger 。</p></li></ul><hr><p>HystrixCachedObservable 的其他方法，点击 <a href="https://github.com/Netflix/Hystrix/blob/1f64fced24289ea435f1e2d5a47a068bf7b79729/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCachedObservable.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看。</p><h1>6. HystrixCommandResponseFromCache</h1><p><code>com.netflix.hystrix.HystrixCommandResponseFromCache</code> ，是 HystrixCachedObservable 的子类。在父类的基础上，增加了对 <code>AbstractCommand.executionResult</code> 的关注。</p><p><code>HystrixCachedObservable#from(Observable, AbstractCommand)</code> 方法，创建 HystrixCommandResponseFromCache 对象，点击 <a href="https://github.com/Netflix/Hystrix/blob/1f64fced24289ea435f1e2d5a47a068bf7b79729/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCachedObservable.java#L36" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看。</p><hr><p><code>HystrixCommandResponseFromCache#toObservableWithStateCopiedInto(...)</code> 方法，点击 <a href="https://github.com/Netflix/Hystrix/blob/1f64fced24289ea435f1e2d5a47a068bf7b79729/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommandResponseFromCache.java#L17" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看。</p><ul><li>通过 <code>completionLogicRun</code> 属性，保证 <code>#doOnError()</code> ，<code>#doOnCompleted()</code> ，<code>#doOnUnsubscribe()</code> 方法有且只有一个方法执行具体逻辑。<ul><li><code>#doOnError()</code> ，<code>#doOnCompleted()</code> 执行时，调用 <code>#commandCompleted()</code> 方法，从缓存命令( <code>HystrixCommandResponseFromCache.originalCommand</code> ) 复制 <code>executionResult</code> 属性给当前命令( <code>commandToCopyStateInto</code> ) 。</li><li><code>#doOnUnsubscribe()</code> 执行时，调用 <code>#commandUnsubscribed()</code> 方法，使用当前命令( <code>commandToCopyStateInto</code> )<strong>自己</strong>的 <code>executionResult</code> ，不进行复制。</li></ul></li><li>TODO 【2007】【executionResult】用途</li></ul><h1>666. 彩蛋</h1><p>如鲠在喉的感觉，从周六开始磨了四天多，一直没写到一个比较舒服的状态。</p><p>先发现发，如果有不清晰的地方，烦请指出，谢谢。</p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/Hystrix/command-execute-result-cache/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 Hystrix 1.5.X 版本&lt;/strong&gt;&lt;
      
    
    </summary>
    
      <category term="Hystrix" scheme="http://www.iocoder.cn/categories/Hystrix/"/>
    
    
  </entry>
  
  <entry>
    <title>Hystrix 源码解析 —— 执行命令方式</title>
    <link href="http://www.iocoder.cn/Hystrix/command-execute-mode/"/>
    <id>http://www.iocoder.cn/Hystrix/command-execute-mode/</id>
    <published>2018-10-09T16:00:00.000Z</published>
    <updated>2017-11-06T10:40:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/Hystrix/command-execute-mode/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Hystrix 1.5.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Hystrix/command-execute-mode/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-mode/">2. 实现</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-mode/">3. BlockingObservable</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-mode/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p>本文主要分享 <strong>Hystrix 执行命令方法</strong>。</p><p>建议 ：对 RxJava 已经有一定的了解的基础上阅读本文。</p><p>在官方提供的示例中，我们看到 <a href="https://github.com/Netflix/Hystrix/blob/d838f4d1ba65ce55755ab1c73f74c980f04572bf/hystrix-examples/src/main/java/com/netflix/hystrix/examples/basic/CommandHelloWorld.java" rel="external nofollow noopener noreferrer" target="_blank">CommandHelloWorld</a> 通过继承 <a href="https://github.com/Netflix/Hystrix/blob/d838f4d1ba65ce55755ab1c73f74c980f04572bf/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommand.java" rel="external nofollow noopener noreferrer" target="_blank">HystrixCommand</a> 抽象类，有四种调用方式：</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left"><code>#execute()</code></td><td style="text-align:left"><strong>同步</strong>调用，返回<strong>直接</strong>结果</td></tr><tr><td style="text-align:left"><code>#queue()</code></td><td style="text-align:left"><strong>异步</strong>调用，返回 <code>java.util.concurrent.Future</code></td></tr><tr><td style="text-align:left"><code>#observe()</code></td><td style="text-align:left"><strong>异步</strong>调用，返回 <code>rx.Observable</code> 。向 Observable 注册 <code>rx.Subscriber</code> 处理结果</td></tr><tr><td style="text-align:left"><code>#toObservable()</code></td><td style="text-align:left"><strong>未调用</strong>，返回 <code>rx.Observable</code> 。向 Observable 注册 <code>rx.Subscriber</code> 处理结果</td></tr></tbody></table><ul><li>第四种方式，点击 <a href="https://github.com/YunaiV/Hystrix/blob/master/hystrix-examples/src/main/java/com/netflix/hystrix/examples/basic/CommandHelloWorld.java#L165" rel="external nofollow noopener noreferrer" target="_blank"><code>#testToObservable()</code></a> 查看笔者补充的示例。</li></ul><p><img src="http://www.iocoder.cn/images/Hystrix/2018_10_08/01.jpeg" alt=""></p><hr><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1>2. 实现</h1><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractCommand.java</span></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCommand</span>&lt;<span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">HystrixInvokableInfo</span>&lt;<span class="title">R</span>&gt;, <span class="title">HystrixObservable</span>&lt;<span class="title">R</span>&gt; </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略无关属性与方法</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">toObservable</span><span class="params">()</span> </span>&#123;</div><div class="line">    </div><div class="line">        <span class="keyword">return</span> Observable.defer(<span class="keyword">new</span> Func0&lt;Observable&lt;R&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="comment">// ....</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">observe</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// us a ReplaySubject to buffer the eagerly subscribed-to Observable</span></div><div class="line">        ReplaySubject&lt;R&gt; subject = ReplaySubject.create();</div><div class="line">        <span class="comment">// eagerly kick off subscription</span></div><div class="line">        <span class="keyword">final</span> Subscription sourceSubscription = toObservable().subscribe(subject);</div><div class="line">        <span class="comment">// return the subject that can be subscribed to later while the execution has already started</span></div><div class="line">        <span class="keyword">return</span> subject.doOnUnsubscribe(<span class="keyword">new</span> Action0() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">                sourceSubscription.unsubscribe();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// HystrixCommand.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixCommand</span>&lt;<span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCommand</span>&lt;<span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">HystrixExecutable</span>&lt;<span class="title">R</span>&gt;, <span class="title">HystrixInvokableInfo</span>&lt;<span class="title">R</span>&gt;, <span class="title">HystrixObservable</span>&lt;<span class="title">R</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ... 省略无关属性与方法</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> Future&lt;R&gt; <span class="title">queue</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Future&lt;R&gt; delegate = toObservable().toBlocking().toFuture();</div><div class="line">        <span class="keyword">final</span> Future&lt;R&gt; f = <span class="keyword">new</span> Future&lt;R&gt;() &#123;</div><div class="line">            <span class="comment">// ... 包装 delegate</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">        <span class="keyword">return</span> f;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> queue().get();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            <span class="keyword">throw</span> Exceptions.sneakyThrow(decomposeException(e));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> R <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p><code>#toObservable()</code> 方法 ：<strong>未</strong>做订阅，返回干净的 Observable 。<strong>这就是为什么上文说“未调用”</strong> 。</p></li><li><p><code>#observe()</code> 方法 ：调用 <code>#toObservable()</code> 方法的基础上，向 Observable 注册 <code>rx.subjects.ReplaySubject</code> <strong>发起订阅</strong> 。</p><ul><li>ReplaySubject 会发射所有来自原始 Observable 的数据给观察者，无论它们是何时订阅的。感兴趣的同学可以阅读 <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/Subject.html" rel="external nofollow noopener noreferrer" target="_blank">《ReactiveX/RxJava文档中文版 —— Subject》</a> 。</li></ul></li><li><p><code>#queue()</code> 方法 ：调用 <code>#toObservable()</code> 方法的基础上，调用：</p><ul><li><code>Observable#toBlocking()</code> 方法 ：将 Observable 转换成<strong>阻塞</strong>的 <code>rx.observables.BlockingObservable</code> 。</li><li><code>BlockingObservable#toFuture()</code> 方法 ：返回可获得 <code>#run()</code> <strong>抽象方法</strong>执行结果的 Future 。<ul><li><code>#run()</code> 方法 ：子类实现该方法，执行<strong>正常的业务逻辑</strong>。</li></ul></li><li>BlockingObservable 在 <a href="#">「3. BlockingObservable」</a> 详细解析。</li></ul></li><li><p><code>#execute()</code> 方法 ：调用 <code>#queue()</code> 方法的基础上，调用 <code>Future#get()</code> 方法，<strong>同步</strong>返回 <code>#run()</code> 的执行结果。</p></li><li><p>整理四种调用方式如下：</p><p><img src="http://www.iocoder.cn/images/Hystrix/2018_10_08/02.png" alt=""></p><blockquote><p>FROM <a href="http://youdang.github.io/2016/02/05/translate-hystrix-wiki-how-it-works/#problem9" rel="external nofollow noopener noreferrer" target="_blank">《【翻译】Hystrix文档-实现原理》</a><img src="http://www.iocoder.cn/images/Hystrix/2018_10_08/03.png" alt=""></p></blockquote></li></ul><h1>3. BlockingObservable</h1><p>本小节为<strong>拓展内容</strong>，源码解析 RxJava ( 非 Hystrix ) 的 <code>rx.observables.BlockingObservable</code> 的实现，所以你可以选择：</p><ul><li>1 ) 跳过本小节，不影响对本文的理解。</li><li>2 ) 选择阅读 <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Blocking-Observable-Operators.html" rel="external nofollow noopener noreferrer" target="_blank">《ReactiveX/RxJava文档中文版 —— 阻塞操作》</a> ，理解 BlockingObservable 的原理。</li><li>3 ) 选择阅读本小节，理解 BlockingObservable 的原理以及实现。</li></ul><p><a href="http://www.iocoder.cn/RxJava/blocking-observable/">《RxJava 源码解析 —— BlockingObservable》</a></p><h1>666. 彩蛋</h1><p>第一篇 Hystrix 正式的源码解析。</p><p>梳理 Hystrix 的源码还是蛮痛苦的，主要是因为对 RxJava 不够熟悉。</p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/Hystrix/command-execute-mode/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 Hystrix 1.5.X 版本&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
      
    
    </summary>
    
      <category term="Hystrix" scheme="http://www.iocoder.cn/categories/Hystrix/"/>
    
    
  </entry>
  
  <entry>
    <title>Hystrix 源码解析 —— 调试环境搭建</title>
    <link href="http://www.iocoder.cn/Hystrix/build-debugging-environment/"/>
    <id>http://www.iocoder.cn/Hystrix/build-debugging-environment/</id>
    <published>2018-09-30T16:00:00.000Z</published>
    <updated>2017-11-06T10:40:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/Hystrix/build-debugging-environment/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Hystrix 1.5.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Hystrix/build-debugging-environment/">1. 依赖工具</a></li><li><a href="http://www.iocoder.cn/Hystrix/build-debugging-environment/">2. 源码拉取</a></li><li><a href="http://www.iocoder.cn/Hystrix/build-debugging-environment/">3. 运行示例</a></li><li><a href="http://www.iocoder.cn/Hystrix/build-debugging-environment/">4. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 依赖工具</h1><ul><li>Gradle</li><li>JDK</li><li>IntelliJ IDEA</li></ul><hr><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1>2. 源码拉取</h1><p>从官方仓库 <a href="https://github.com/Netflix/Hystrix.git" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/Netflix/Hystrix.git</a> <code>Fork</code> 出属于自己的仓库。为什么要 <code>Fork</code> ？既然开始阅读、调试源码，我们可能会写一些注释，有了自己的仓库，可以进行自由的提交。😈</p><p>使用 <code>IntelliJ IDEA</code> 从 <code>Fork</code> 出来的仓库拉取代码。在项目路径下，在<strong>命令行</strong>执行 <code>./gradlew</code> 命令，<code>Gradle</code> 会下载依赖包，可能会花费一些时间，耐心等待下。其间可能会出现因为网络原因( 我相信你懂的 )，可能会出现失败的情况，淡定，重新执行上述命令直到成功。此刻，你就是一个 <code>while(true)</code> 的小强。</p><p>本文基于 <code>master</code> 分支。</p><h1>3. 运行示例</h1><p>在 <code>hystrix-examples</code> 子项目下，提供了<strong>大量</strong>的示例，如下图：</p><p><img src="http://www.iocoder.cn/images/Hystrix/2018_10_01/01.png" alt=""></p><ul><li><code>basic</code> 包 ：针对 Hystrix 每个特性提供小的单元测试示例。你可以从 CommandHelloWorld 开始尝试。</li><li><code>demo</code> 包 ：结合实际场景的实战小例子。运行入口为 HystrixCommandDemo 或者 HystrixCommandAsyncDemo 。恩，聪慧如你，从名字能看出它们的区别点。</li></ul><p>可能有部分同学对 Hystrix 的特性了解的不是很清晰，笔者推荐如下文章：</p><ul><li><a href="http://youdang.github.io/2016/02/05/translate-hystrix-wiki-how-it-works/" rel="external nofollow noopener noreferrer" target="_blank">《【翻译】Hystrix 文档 - 实现原理》</a></li><li><a href="http://tech.lede.com/2017/06/15/rd/server/hystrix/" rel="external nofollow noopener noreferrer" target="_blank">《hystrix 在 spring mvc 的使用》</a></li></ul><p>另外，笔者也整理了下 Hystrix 的特性如下( 可能不是很严谨，主要辅助理解 ) ：</p><ul><li>断路器机制<ul><li>计算线路健康度</li></ul></li><li>Fallback ( 失败回退 )</li><li>资源隔离<ul><li>方式<ul><li>线程池</li><li>信号量</li></ul></li><li>依赖隔离</li></ul></li><li>执行模型<ul><li>同步执行</li><li>异步执行</li><li>Reactive模式执行<ul><li>observe</li><li>toObservable</li></ul></li></ul></li><li>运维平台<ul><li>基础 Dashboard</li><li>整合 Turbine</li></ul></li><li>缓存</li><li>请求合并( HystrixCollapser )</li></ul><h1>4. 彩蛋</h1><p>为了显得本文的诚意( 真的不是水更 )，友情提示如下：</p><p>Hystrix 基于 RxJava 实现，所以笔者推荐阅读如下文章 ：</p><ul><li><a href="http://gank.io/post/560e15be2dca930e00da1083" rel="external nofollow noopener noreferrer" target="_blank">《给 Android 开发者的 RxJava 详解》</a></li><li><a href="http://www.jianshu.com/p/856297523728" rel="external nofollow noopener noreferrer" target="_blank">《大话 RxJava》系列</a></li><li><a href="https://www.gitbook.com/book/mcxiaoke/rxdocs/details" rel="external nofollow noopener noreferrer" target="_blank">《ReactiveX/RxJava文档中文版》</a></li></ul><p>可能一开始理解会比较困难，保持耐心，你即将打开一个新的世界。对了，<strong>变换</strong>( <code>#lift(Operator)</code> ) 会是一个难点，我相信你可以理解。</p><hr><p>胖友，分享一波朋友圈可好！</p><p>对了，这是一个系列文，所以，千万不要错过。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/Hystrix/build-debugging-environment/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 Hystrix 1.5.X 版本&lt;/strong&gt;&lt;/
      
    
    </summary>
    
      <category term="Hystrix" scheme="http://www.iocoder.cn/categories/Hystrix/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— StringCache</title>
    <link href="http://www.iocoder.cn/Eureka/string-cache/"/>
    <id>http://www.iocoder.cn/Eureka/string-cache/</id>
    <published>2018-08-20T16:00:00.000Z</published>
    <updated>2017-10-19T15:47:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/Eureka/string-cache/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/Eureka/string-cache/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/string-cache/">2. StringCache</a></li><li><a href="http://www.iocoder.cn/Eureka/string-cache/">3. 使用场景</a></li><li><a href="http://www.iocoder.cn/Eureka/string-cache/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p>本文主要分享 <strong>Eureka 自己实现的 StringCache</strong>。</p><p>先一起来看下美团点评技术团队对 <code>String#intern(...)</code> 的分享：</p><blockquote><p>FROM <a href="https://tech.meituan.com/in_depth_understanding_string_intern.html" rel="external nofollow noopener noreferrer" target="_blank">《深入解析String#intern》「 引言 」</a><br>在 JAVA 语言中有8中基本类型和一种比较特殊的类型 <code>String</code>。这些类型为了使他们在运行过程中速度更快，更节省内存，都提供了一种常量池的概念。常量池就类似一个 JAVA 系统级别提供的缓存。<br>8 种基本类型的常量池都是系统协调的，<code>String</code> 类型的常量池比较特殊。它的主要使用方法有两种：</p><ul><li>直接使用双引号声明出来的 <code>String</code> 对象会直接存储在常量池中</li><li>如果不是用双引号声明的 <code>String</code> 对象，可以使用String提供的 <code>intern</code> 方法。<code>intern</code> 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中</li></ul></blockquote><ul><li>字符串常量池能带来速度更快，更节省内存的好处</li><li><strong>非双引号声明</strong>的 String 对象，需要使用 <code>String#intern()</code> 方法，将字符串存储到字符串常量池。</li></ul><p>看起来一切都非常非常非常美好，那为什么 Eureka 自己实现了 StringCache ？</p><p>继续参见美团点评技术团队对 <code>String#intern(...)</code> 的分享：</p><blockquote><p>FROM <a href="https://tech.meituan.com/in_depth_understanding_string_intern.html" rel="external nofollow noopener noreferrer" target="_blank">《深入解析String#intern》「 native 代码 」</a><br>JAVA 使用 JNI 调用 c++ 实现的 StringTable 的 <code>intern</code> 方法, StringTable的 <code>intern</code> 方法跟 Java 中的 HashMap 的实现是差不多的, 只是不能自动扩容。<strong>默认大小是1009</strong>。</p></blockquote><blockquote><p>要注意的是，String 的 String Pool 是一个<strong>固定大小</strong>的 Hashtable，默认值大小长度是 1009，如果放进 String Pool 的 String 非常多，就会造成<strong>Hash冲突严重</strong>，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降（因为要一个一个找）。</p></blockquote><blockquote><p>在 JDK6 中 StringTable 是固定的，就是 1009 的长度，所以如果常量池中的字符串过多就会导致效率下降很快。在jdk7中，StringTable的长度可以通过一个参数指定：</p></blockquote><blockquote><ul><li>-XX:StringTableSize=99991</li></ul></blockquote><ul><li>JDK 自带的 String Pool 固定大小( 即使可配 )，不支持自动扩容，大量使用 <code>String#intern(...)</code> 后，会导致性能大幅度下降。</li><li>Eureka 的应用实例( InstanceInfo ) 的 <code>appName</code>、<code>appGroupName</code>、<code>vipAddress</code>、<code>secureVipAddress</code>、<code>metadata</code> 和应用( Application )的 <code>name</code> 等属性需要使用到 String Pool ，为了在大量的网络通信序列化反序列的过程中，速度更快，更节省内容。</li></ul><p>另外，FastJSON 在 1.124 版本<strong>之前</strong>也使用 <code>String#intern(...)</code> 方法，优化 JSON Key 的速度和空间，但是在大量动态 JSON Key 的场景下，反而会导致性能下降。所以 FastJSON 1.124 修复了该问题。参见如下：</p><blockquote><p>FROM <a href="https://tech.meituan.com/in_depth_understanding_string_intern.html" rel="external nofollow noopener noreferrer" target="_blank">《深入解析String#intern》「 fastjson 不当使用 」</a><br><img src="http://www.iocoder.cn/images/Eureka/2018_08_21/01.png" alt=""></p></blockquote><ul><li>But ，FastJSON 1.124 版本<strong>之前</strong>恰好适合 Eureka ，因为 <code>appName</code>、<code>appGroupName</code> <strong>相对不那么动态</strong>。考虑到可能还是有大量的字符串存在，因而实现自定义的 StringCache 类，以解决 StringPool 的 HashTable 不支持动态扩容的情况。</li></ul><p>OK，下面我们来看看 Eureka 是如何实现自定义的 StringCache 类。</p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1>2. StringCache</h1><p><code>com.netflix.discovery.util.StringCache</code> ，字符串缓存。代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringCache</span> </span>&#123;</div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>:     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LENGTH_LIMIT = <span class="number">38</span>;</div><div class="line"> <span class="number">4</span>: </div><div class="line"> <span class="number">5</span>:     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StringCache INSTANCE = <span class="keyword">new</span> StringCache();</div><div class="line"> <span class="number">6</span>: </div><div class="line"> <span class="number">7</span>:     <span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</div><div class="line"> <span class="number">8</span>:     <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, WeakReference&lt;String&gt;&gt; cache = <span class="keyword">new</span> WeakHashMap&lt;String, WeakReference&lt;String&gt;&gt;();</div><div class="line"> <span class="number">9</span>:     <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> lengthLimit;</div><div class="line"><span class="number">10</span>: </div><div class="line"><span class="number">11</span>:     <span class="function"><span class="keyword">public</span> <span class="title">StringCache</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">12</span>:         <span class="keyword">this</span>(LENGTH_LIMIT);</div><div class="line"><span class="number">13</span>:     &#125;</div><div class="line"><span class="number">14</span>: </div><div class="line"><span class="number">15</span>:     <span class="function"><span class="keyword">public</span> <span class="title">StringCache</span><span class="params">(<span class="keyword">int</span> lengthLimit)</span> </span>&#123;</div><div class="line"><span class="number">16</span>:         <span class="keyword">this</span>.lengthLimit = lengthLimit;</div><div class="line"><span class="number">17</span>:     &#125;</div><div class="line"><span class="number">18</span>: </div><div class="line"><span class="number">19</span>:     <span class="function"><span class="keyword">public</span> String <span class="title">cachedValueOf</span><span class="params">(<span class="keyword">final</span> String str)</span> </span>&#123;</div><div class="line"><span class="number">20</span>:         <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; (lengthLimit &lt; <span class="number">0</span> || str.length() &lt;= lengthLimit)) &#123;</div><div class="line"><span class="number">21</span>:             <span class="comment">// Return value from cache if available</span></div><div class="line"><span class="number">22</span>:             <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">23</span>:                 lock.readLock().lock();</div><div class="line"><span class="number">24</span>:                 WeakReference&lt;String&gt; ref = cache.get(str);</div><div class="line"><span class="number">25</span>:                 <span class="keyword">if</span> (ref != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">26</span>:                     <span class="keyword">return</span> ref.get();</div><div class="line"><span class="number">27</span>:                 &#125;</div><div class="line"><span class="number">28</span>:             &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">29</span>:                 lock.readLock().unlock();</div><div class="line"><span class="number">30</span>:             &#125;</div><div class="line"><span class="number">31</span>: </div><div class="line"><span class="number">32</span>:             <span class="comment">// Update cache with new content</span></div><div class="line"><span class="number">33</span>:             <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">34</span>:                 lock.writeLock().lock();</div><div class="line"><span class="number">35</span>:                 WeakReference&lt;String&gt; ref = cache.get(str);</div><div class="line"><span class="number">36</span>:                 <span class="keyword">if</span> (ref != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">37</span>:                     <span class="keyword">return</span> ref.get();</div><div class="line"><span class="number">38</span>:                 &#125;</div><div class="line"><span class="number">39</span>:                 cache.put(str, <span class="keyword">new</span> WeakReference&lt;&gt;(str));</div><div class="line"><span class="number">40</span>:             &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">41</span>:                 lock.writeLock().unlock();</div><div class="line"><span class="number">42</span>:             &#125;</div><div class="line"><span class="number">43</span>:             <span class="keyword">return</span> str;</div><div class="line"><span class="number">44</span>:         &#125;</div><div class="line"><span class="number">45</span>:         <span class="keyword">return</span> str;</div><div class="line"><span class="number">46</span>:     &#125;</div><div class="line"><span class="number">47</span>: </div><div class="line"><span class="number">48</span>:     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">49</span>:         <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">50</span>:             lock.readLock().lock();</div><div class="line"><span class="number">51</span>:             <span class="keyword">return</span> cache.size();</div><div class="line"><span class="number">52</span>:         &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">53</span>:             lock.readLock().unlock();</div><div class="line"><span class="number">54</span>:         &#125;</div><div class="line"><span class="number">55</span>:     &#125;</div><div class="line"><span class="number">56</span>: </div><div class="line"><span class="number">57</span>:     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">intern</span><span class="params">(String original)</span> </span>&#123;</div><div class="line"><span class="number">58</span>:         <span class="keyword">return</span> INSTANCE.cachedValueOf(original);</div><div class="line"><span class="number">59</span>:     &#125;</div><div class="line"><span class="number">60</span>: </div><div class="line"><span class="number">61</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><code>INSTANCE</code> 属性，字符串缓存<strong>单例</strong>。</li><li><code>lock</code> 属性，<strong>读写锁</strong>，保证读写互斥。</li><li><code>cache</code> 属性，缓存哈希表。<ul><li>使用 WeakHashMap，当 StringCache 被回收时，其对应的值一起被移除。</li><li><a href="http://blog.csdn.net/yangzl2008/article/details/6980709" rel="external nofollow noopener noreferrer" target="_blank">《WeakHashMap和HashMap的区别》</a></li><li><a href="http://www.cnblogs.com/skywang12345/p/3311092.html" rel="external nofollow noopener noreferrer" target="_blank">《Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例》</a></li></ul></li><li><code>lengthLimit</code> 属性，缓存字符串最大长度。默认值：38 。</li><li><code>#cachedValueOf(...)</code> 方法，获得字符串缓存。若缓存不存在，则进行缓存。和 <code>String#intern()</code> 的逻辑相同，区别在于 <code>cache</code> 支持自动扩容。<ul><li>第 22 至 30 行 ：读锁，读取缓存。</li><li>第 32 至 42 行 ：缓存不存在，写锁，写入缓存。</li></ul></li><li><code>#size()</code> 方法，缓存大小。</li><li><code>#intern()</code> <strong>静态</strong>方法，使用 <code>INSTANCE</code> 获取缓存字符串。</li></ul><h1>3. 使用场景</h1><p>在 InstanceInfo 下的使用，点击 <a href="https://github.com/YunaiV/eureka/blob/7f868f9ca715a8862c0c10cac04e238bbf371db0/eureka-client/src/main/java/com/netflix/appinfo/InstanceInfo.java#L233" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看。</p><p>在 Application 下的使用，点击 <a href="https://github.com/YunaiV/eureka/blob/7f868f9ca715a8862c0c10cac04e238bbf371db0/eureka-client/src/main/java/com/netflix/discovery/shared/Application.java#L95" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看。</p><h1>666. 彩蛋</h1><p>又 Get 新姿势了，好开森。</p><p>胖友，分享个朋友圈，可好？！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/Eureka/string-cache/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.iocoder.cn/Eureka/string-cache/&quot;
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 基于令牌桶算法的 RateLimiter</title>
    <link href="http://www.iocoder.cn/Eureka/rate-limiter/"/>
    <id>http://www.iocoder.cn/Eureka/rate-limiter/</id>
    <published>2018-08-13T16:00:00.000Z</published>
    <updated>2017-10-19T05:48:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/Eureka/rate-limiter/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Eureka/rate-limiter/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/rate-limiter/">2. RateLimiter</a><ul><li><a href="http://www.iocoder.cn/Eureka/rate-limiter/">2.1 refillToken</a></li><li><a href="http://www.iocoder.cn/Eureka/rate-limiter/">2.2 consumeToken</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/rate-limiter/">3. RateLimitingFilter</a></li><li><a href="http://www.iocoder.cn/Eureka/rate-limiter/">4. InstanceInfoReplicator</a></li><li><a href="http://www.iocoder.cn/Eureka/rate-limiter/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p>本文主要分享 <strong>RateLimiter 的代码实现和 RateLimiter 在 Eureka 中的应用</strong>。</p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1>2. RateLimiter</h1><p><code>com.netflix.discovery.util.RateLimiter</code> ，基于**Token Bucket Algorithm ( 令牌桶算法 )**的速率限制器。</p><blockquote><p>FROM <a href="http://www.cnblogs.com/LBSer/p/4083131.html" rel="external nofollow noopener noreferrer" target="_blank">《接口限流实践》</a><br>令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。<br><img src="http://www.iocoder.cn/images/Eureka/2018_08_14/01.png" alt=""></p></blockquote><p>RateLimiter 目前支持<strong>分钟级</strong>和<strong>秒级</strong>两种速率限制。构造方法如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 速率单位转换成毫秒</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> rateToMsConversion;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RateLimiter</span><span class="params">(TimeUnit averageRateUnit)</span> </span>&#123;</div><div class="line">        <span class="keyword">switch</span> (averageRateUnit) &#123;</div><div class="line">            <span class="keyword">case</span> SECONDS: <span class="comment">// 秒级</span></div><div class="line">                rateToMsConversion = <span class="number">1000</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MINUTES: <span class="comment">// 分钟级</span></div><div class="line">                rateToMsConversion = <span class="number">60</span> * <span class="number">1000</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"TimeUnit of "</span> + averageRateUnit + <span class="string">" is not supported"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><code>averageRateUnit</code> 参数，速率<strong>单位</strong>。构造方法里将 <code>averageRateUnit</code> 转换成 <code>rateToMsConversion</code> 。</li></ul><p>调用 <code>#acquire(...)</code> 方法，获取令牌，并返回<strong>是否获取成功</strong></p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// RateLimiter.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获取令牌( Token )</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> burstSize 令牌桶上限</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> averageRate 令牌再装平均速率</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 是否获取成功</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> burstSize, <span class="keyword">long</span> averageRate)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> acquire(burstSize, averageRate, System.currentTimeMillis());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> burstSize, <span class="keyword">long</span> averageRate, <span class="keyword">long</span> currentTimeMillis)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (burstSize &lt;= <span class="number">0</span> || averageRate &lt;= <span class="number">0</span>) &#123; <span class="comment">// Instead of throwing exception, we just let all the traffic go</span></div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// 填充 令牌</span></div><div class="line">   refillToken(burstSize, averageRate, currentTimeMillis);</div><div class="line">   <span class="comment">// 消费 令牌</span></div><div class="line">   <span class="keyword">return</span> consumeToken(burstSize);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p><code>burstSize</code> 参数 ：令牌桶上限。</p></li><li><p><code>averageRate</code> 参数 ：令牌填充<strong>平均</strong>速率。</p></li><li><p>我们举个 🌰 来理解这两个参数 + 构造方法里的一个参数：</p><ul><li><code>averageRateUnit = SECONDS</code></li><li><code>averageRate = 2000</code></li><li><code>burstSize = 10</code></li><li>每<strong>秒</strong>可获取 <code>2000</code> 个令牌。例如，每秒允许请求 <code>2000</code> 次。</li><li>每<strong>毫秒</strong>可填充 <code>2000 / 1000 = 2</code> 个<strong>消耗</strong>的令牌。</li><li>每<strong>毫秒</strong>可获取 <code>10</code> 个令牌。例如，每毫秒允许请求上限为 <code>10</code> 次，并且请求<strong>消耗</strong>掉的令牌，需要逐步填充。这里要注意下，虽然每毫秒允许请求上限为 <code>10</code> 次，这是在没有任何令牌被<strong>消耗</strong>的情况下，实际每秒允许请求依然是 <code>2000</code> 次。</li><li><strong>这就是基于令牌桶算法的限流的特点：让流量平稳，而不是瞬间流量。1000 QPS 相对平均的分摊在这一秒内，而不是第 1 ms 999 请求，后面 999 ms 0 请求</strong>。</li></ul></li><li><p>从代码上看，<code>#acquire(...)</code> 分成两部分，我们分别解析，整体如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_08_14/02.png" alt=""></p></li></ul><h2>2.1 refillToken</h2><p>调用 <code>#refillToken(...)</code> 方法，填充<strong>已消耗</strong>的令牌。可能很多同学开始和我想的一样，一个后台每毫秒执行填充。<strong>为什么不适合这样呢？<strong>一方面，实际项目里每个接口都会有相应的 RateLimiter ，导致</strong>太多</strong>执行频率<strong>极高</strong>的后台任务；另一方面，获取令牌时才计算，多次令牌填充可以合并成一次，减少冗余和无效的计算。</p><p>代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="comment">/**</span></div><div class="line"><span class="comment"> 2:  * 速率单位转换成毫秒</span></div><div class="line"><span class="comment"> 3:  */</span></div><div class="line"> <span class="number">4</span>: <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> rateToMsConversion;</div><div class="line"> <span class="number">5</span>: </div><div class="line"> <span class="number">6</span>: <span class="comment">/**</span></div><div class="line"><span class="comment"> 7:  * 消耗令牌数</span></div><div class="line"><span class="comment"> 8:  */</span></div><div class="line"> <span class="number">9</span>: <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger consumedTokens = <span class="keyword">new</span> AtomicInteger();</div><div class="line"><span class="number">10</span>: <span class="comment">/**</span></div><div class="line"><span class="comment">11:  * 最后填充令牌的时间</span></div><div class="line"><span class="comment">12:  */</span></div><div class="line"><span class="number">13</span>: <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong lastRefillTime = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</div><div class="line"><span class="number">14</span>: </div><div class="line"><span class="number">15</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refillToken</span><span class="params">(<span class="keyword">int</span> burstSize, <span class="keyword">long</span> averageRate, <span class="keyword">long</span> currentTimeMillis)</span> </span>&#123;</div><div class="line"><span class="number">16</span>:     <span class="comment">// 获得 最后填充令牌的时间</span></div><div class="line"><span class="number">17</span>:     <span class="keyword">long</span> refillTime = lastRefillTime.get();</div><div class="line"><span class="number">18</span>:     <span class="comment">// 获得 过去多少毫秒</span></div><div class="line"><span class="number">19</span>:     <span class="keyword">long</span> timeDelta = currentTimeMillis - refillTime;</div><div class="line"><span class="number">20</span>: </div><div class="line"><span class="number">21</span>:     <span class="comment">// 计算 可填充最大令牌数量</span></div><div class="line"><span class="number">22</span>:     <span class="keyword">long</span> newTokens = timeDelta * averageRate / rateToMsConversion;</div><div class="line"><span class="number">23</span>:     <span class="keyword">if</span> (newTokens &gt; <span class="number">0</span>) &#123;</div><div class="line"><span class="number">24</span>:         <span class="comment">// 计算 新的填充令牌的时间</span></div><div class="line"><span class="number">25</span>:         <span class="keyword">long</span> newRefillTime = refillTime == <span class="number">0</span></div><div class="line"><span class="number">26</span>:                 ? currentTimeMillis</div><div class="line"><span class="number">27</span>:                 : refillTime + newTokens * rateToMsConversion / averageRate;</div><div class="line"><span class="number">28</span>:         <span class="comment">// CAS 保证有且仅有一个线程进入填充</span></div><div class="line"><span class="number">29</span>:         <span class="keyword">if</span> (lastRefillTime.compareAndSet(refillTime, newRefillTime)) &#123;</div><div class="line"><span class="number">30</span>:             <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">// 死循环，直到成功</span></div><div class="line"><span class="number">31</span>:                 <span class="comment">// 计算 填充令牌后的已消耗令牌数量</span></div><div class="line"><span class="number">32</span>:                 <span class="keyword">int</span> currentLevel = consumedTokens.get();</div><div class="line"><span class="number">33</span>:                 <span class="keyword">int</span> adjustedLevel = Math.min(currentLevel, burstSize); <span class="comment">// In case burstSize decreased</span></div><div class="line"><span class="number">34</span>:                 <span class="keyword">int</span> newLevel = (<span class="keyword">int</span>) Math.max(<span class="number">0</span>, adjustedLevel - newTokens);</div><div class="line"><span class="number">35</span>:                 <span class="comment">// CAS 避免和正在消费令牌的线程冲突</span></div><div class="line"><span class="number">36</span>:                 <span class="keyword">if</span> (consumedTokens.compareAndSet(currentLevel, newLevel)) &#123;</div><div class="line"><span class="number">37</span>:                     <span class="keyword">return</span>;</div><div class="line"><span class="number">38</span>:                 &#125;</div><div class="line"><span class="number">39</span>:             &#125;</div><div class="line"><span class="number">40</span>:         &#125;</div><div class="line"><span class="number">41</span>:     &#125;</div><div class="line"><span class="number">42</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 17 行 ：获取最后填充令牌的时间( <code>refillTime</code> ) 。每次填充令牌，会设置 <code>currentTimeMillis</code> 到 <code>refillTime</code> 。</li><li>第 19 行 ：获得距离最后填充令牌的时间差( <code>timeDelta</code> )，用于计算需要填充的令牌数。</li><li>第 22 行 ：计算<strong>可填充的</strong>最大令牌数量( <code>newTokens</code> )。<code>newTokens</code> 可能超过 <code>burstSize</code> ，所以下面会有逻辑调整 <code>newTokens</code> 。</li><li>第 25 至 27 行 ：计算<strong>新的</strong>填充令牌的时间。<strong>为什么不能用 <code>currentTimeMillis</code> 呢</strong>？例如，<code>averageRate = 500 &amp;&amp; averageRateUnit = SECONDS</code> 时， 每 2 毫秒才填充一个令牌，如果设置 <code>currentTimeMillis</code> ，<strong>会导致不足以填充一个令牌的时长被吞了</strong>。</li><li>第 29 行 ：通过 <strong>CAS</strong> 保证有且<strong>仅有一个</strong>线程进入填充逻辑。</li><li>第 30 行 ：<strong>死循环直到成功</strong>。</li><li>第 32 至 34 行 ：计算<strong>新的</strong>填充令牌后的<strong>已消耗</strong>的令牌数量。<ul><li>第 33 行 ：<code>burstSize</code> 可能调小，例如，系统接入分布式配置中心，可以远程调整该数值。如果此时 <code>burstSize</code> 更小，以它作为<strong>已消耗</strong>的令牌数量。</li></ul></li><li>第 36 行 ：通过 <strong>CAS</strong> 保证避免覆盖设置正在消费令牌的线程。</li></ul><h2>2.2 consumeToken</h2><p>用 <code>#refillToken(...)</code> 方法，填充**消耗( 获取 )**的令牌。</p><p>代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">consumeToken</span><span class="params">(<span class="keyword">int</span> burstSize)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">// 死循环，直到没有令牌，或者获取令牌成功</span></div><div class="line"> <span class="number">3</span>:         <span class="comment">// 没有令牌</span></div><div class="line"> <span class="number">4</span>:         <span class="keyword">int</span> currentLevel = consumedTokens.get();</div><div class="line"> <span class="number">5</span>:         <span class="keyword">if</span> (currentLevel &gt;= burstSize) &#123;</div><div class="line"> <span class="number">6</span>:             <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"> <span class="number">7</span>:         &#125;</div><div class="line"> <span class="number">8</span>:         <span class="comment">// CAS 避免和正在消费令牌或者填充令牌的线程冲突</span></div><div class="line"> <span class="number">9</span>:         <span class="keyword">if</span> (consumedTokens.compareAndSet(currentLevel, currentLevel + <span class="number">1</span>)) &#123;</div><div class="line"><span class="number">10</span>:             <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"><span class="number">11</span>:         &#125;</div><div class="line"><span class="number">12</span>:     &#125;</div><div class="line"><span class="number">13</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 2 行 ：<strong>死循环直到没有令牌或者竞争获取令牌成功</strong>。</li><li>第 4 至 7 行 ：没有令牌。</li><li>第 9 至 11 行 ：通过 <strong>CAS</strong> 避免和正在消费令牌或者填充令牌的线程冲突。</li></ul><h1>3. RateLimitingFilter</h1><p><code>com.netflix.eureka.RateLimitingFilter</code> ，Eureka-Server 限流过滤器。使用 RateLimiting ，保证 Eureka-Server 稳定性。</p><p><code>#doFilter(...)</code> 方法，代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="comment">// 获得 Target</span></div><div class="line"> <span class="number">4</span>:     Target target = getTarget(request);</div><div class="line"> <span class="number">5</span>: </div><div class="line"> <span class="number">6</span>:     <span class="comment">// Other Target ，不做限流</span></div><div class="line"> <span class="number">7</span>:     <span class="keyword">if</span> (target == Target.Other) &#123;</div><div class="line"> <span class="number">8</span>:         chain.doFilter(request, response);</div><div class="line"> <span class="number">9</span>:         <span class="keyword">return</span>;</div><div class="line"><span class="number">10</span>:     &#125;</div><div class="line"><span class="number">11</span>: </div><div class="line"><span class="number">12</span>:     HttpServletRequest httpRequest = (HttpServletRequest) request;</div><div class="line"><span class="number">13</span>:     <span class="comment">// 判断是否被限流</span></div><div class="line"><span class="number">14</span>:     <span class="keyword">if</span> (isRateLimited(httpRequest, target)) &#123;</div><div class="line"><span class="number">15</span>:         <span class="comment">// TODO[0012]：监控相关，跳过</span></div><div class="line"><span class="number">16</span>:         incrementStats(target);</div><div class="line"><span class="number">17</span>:         <span class="comment">// 如果开启限流，返回 503 状态码</span></div><div class="line"><span class="number">18</span>:         <span class="keyword">if</span> (serverConfig.isRateLimiterEnabled()) &#123;</div><div class="line"><span class="number">19</span>:             ((HttpServletResponse) response).setStatus(HttpServletResponse.SC_SERVICE_UNAVAILABLE);</div><div class="line"><span class="number">20</span>:             <span class="keyword">return</span>;</div><div class="line"><span class="number">21</span>:         &#125;</div><div class="line"><span class="number">22</span>:     &#125;</div><div class="line"><span class="number">23</span>:     chain.doFilter(request, response);</div><div class="line"><span class="number">24</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 4 行 ：调用 <code>#getTarget()</code> 方法，获取 Target。RateLimitingFilter 只对符合正在表达式 <code>^.*/apps(/[^/]*)?$</code> 的接口做限流，其中不包含 Eureka-Server 集群批量同步接口。</p><ul><li>点击 <a href="https://github.com/YunaiV/eureka/blob/7f868f9ca715a8862c0c10cac04e238bbf371db0/eureka-core/src/main/java/com/netflix/eureka/RateLimitingFilter.java#L98" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 Target 枚举类代码。</li><li>点击 <a href="https://github.com/YunaiV/eureka/blob/7f868f9ca715a8862c0c10cac04e238bbf371db0/eureka-core/src/main/java/com/netflix/eureka/RateLimitingFilter.java#L150" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 <code>#getTarget(...)</code> 方法代码。</li></ul></li><li><p>第 14 行 ：调用 <code>#isRateLimited(...)</code> 方法，判断是否被限流。代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRateLimited</span><span class="params">(HttpServletRequest request, Target target)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// 判断是否特权应用</span></div><div class="line"> <span class="number">3</span>:     <span class="keyword">if</span> (isPrivileged(request)) &#123;</div><div class="line"> <span class="number">4</span>:         logger.debug(<span class="string">"Privileged &#123;&#125; request"</span>, target);</div><div class="line"> <span class="number">5</span>:         <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"> <span class="number">6</span>:     &#125;</div><div class="line"> <span class="number">7</span>:     <span class="comment">// 判断是否被超载( 限流 )</span></div><div class="line"> <span class="number">8</span>:     <span class="keyword">if</span> (isOverloaded(target)) &#123;</div><div class="line"> <span class="number">9</span>:         logger.debug(<span class="string">"Overloaded &#123;&#125; request; discarding it"</span>, target);</div><div class="line"><span class="number">10</span>:         <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"><span class="number">11</span>:     &#125;</div><div class="line"><span class="number">12</span>:     logger.debug(<span class="string">"&#123;&#125; request admitted"</span>, target);</div><div class="line"><span class="number">13</span>:     <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"><span class="number">14</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 3 至 6 行 ：调用 <code>#isPrivileged()</code> 方法，判断是否为特权应用，对特权应用不开启限流逻辑。代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPrivileged</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</div><div class="line">    <span class="comment">// 是否对标准客户端开启限流</span></div><div class="line">    <span class="keyword">if</span> (serverConfig.isRateLimiterThrottleStandardClients()) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 以请求头( "DiscoveryIdentity-Name" ) 判断是否在标准客户端名集合内</span></div><div class="line">    Set&lt;String&gt; privilegedClients = serverConfig.getRateLimiterPrivilegedClients();</div><div class="line">    String clientName = request.getHeader(AbstractEurekaIdentity.AUTH_NAME_HEADER_KEY);</div><div class="line">    <span class="keyword">return</span> privilegedClients.contains(clientName) || DEFAULT_PRIVILEGED_CLIENTS.contains(clientName);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>x</li></ul></li><li><p>第 8 至 11 行 ：调用 <code>#isOverloaded(...)</code> 方法，判断是否超载( 限流 )。代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* Includes both full and delta fetches.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RateLimiter registryFetchRateLimiter = <span class="keyword">new</span> RateLimiter(TimeUnit.SECONDS);</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* Only full registry fetches.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RateLimiter registryFullFetchRateLimiter = <span class="keyword">new</span> RateLimiter(TimeUnit.SECONDS);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isOverloaded</span><span class="params">(Target target)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> maxInWindow = serverConfig.getRateLimiterBurstSize(); <span class="comment">// 10</span></div><div class="line">    <span class="keyword">int</span> fetchWindowSize = serverConfig.getRateLimiterRegistryFetchAverageRate(); <span class="comment">// 500</span></div><div class="line">    <span class="keyword">boolean</span> overloaded = !registryFetchRateLimiter.acquire(maxInWindow, fetchWindowSize);</div><div class="line">    <span class="keyword">if</span> (target == Target.FullFetch) &#123;</div><div class="line">        <span class="keyword">int</span> fullFetchWindowSize = serverConfig.getRateLimiterFullFetchAverageRate(); <span class="comment">// 100</span></div><div class="line">            overloaded |= !registryFullFetchRateLimiter.acquire(maxInWindow, fullFetchWindowSize);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> overloaded;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>x</li></ul></li></ul></li><li><p>第 18 至 21 行 ：若 <code>eureka.rateLimiter.enabled = true</code>( 默认值 ：<code>false</code> ，可配 )，返回 503 状态码。</p></li></ul><h1>4. InstanceInfoReplicator</h1><p><code>com.netflix.discovery.InstanceInfoReplicator</code> ，Eureka-Client 应用实例复制器。在 <a href="http://www.iocoder.cn/Eureka/instance-registry-register/?self">《Eureka 源码解析 —— 应用实例注册发现（一）之注册》「2.1 应用实例信息复制器」</a> 有详细解析。</p><p>应用实例状态发生变化时，调用 <code>#onDemandUpdate()</code> 方法，向 Eureka-Server 发起注册，同步应用实例信息。InstanceInfoReplicator 使用 RateLimiter ，避免状态<strong>频繁</strong>发生变化，向 Eureka-Server <strong>频繁</strong>同步。代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">InstanceInfoReplicator</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * RateLimiter</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RateLimiter rateLimiter;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 令牌桶上限，默认：2</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> burstSize;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 令牌再装平均速率，默认：60 * 2 / 30 = 4</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> allowedRatePerMinute;</div><div class="line">    </div><div class="line">    InstanceInfoReplicator(DiscoveryClient discoveryClient, InstanceInfo instanceInfo, <span class="keyword">int</span> replicationIntervalSeconds, <span class="keyword">int</span> burstSize) &#123;</div><div class="line">        <span class="comment">// ... 省略其他代码</span></div><div class="line">        </div><div class="line">        <span class="keyword">this</span>.rateLimiter = <span class="keyword">new</span> RateLimiter(TimeUnit.MINUTES);</div><div class="line">        <span class="keyword">this</span>.replicationIntervalSeconds = replicationIntervalSeconds;</div><div class="line">        <span class="keyword">this</span>.burstSize = burstSize;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.allowedRatePerMinute = <span class="number">60</span> * <span class="keyword">this</span>.burstSize / <span class="keyword">this</span>.replicationIntervalSeconds;</div><div class="line">        logger.info(<span class="string">"InstanceInfoReplicator onDemand update allowed rate per min is &#123;&#125;"</span>, allowedRatePerMinute);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDemandUpdate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (rateLimiter.acquire(burstSize, allowedRatePerMinute)) &#123; <span class="comment">// 限流</span></div><div class="line">            scheduler.submit(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    logger.debug(<span class="string">"Executing on-demand update of local InstanceInfo"</span>);</div><div class="line">                    <span class="comment">// 取消任务</span></div><div class="line">                    Future latestPeriodic = scheduledPeriodicRef.get();</div><div class="line">                    <span class="keyword">if</span> (latestPeriodic != <span class="keyword">null</span> &amp;&amp; !latestPeriodic.isDone()) &#123;</div><div class="line">                        logger.debug(<span class="string">"Canceling the latest scheduled update, it will be rescheduled at the end of on demand update"</span>);</div><div class="line">                        latestPeriodic.cancel(<span class="keyword">false</span>);</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 再次调用</span></div><div class="line">                    InstanceInfoReplicator.<span class="keyword">this</span>.run();</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            logger.warn(<span class="string">"Ignoring onDemand update due to rate limiter"</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>在 <code>#onDemandUpdate()</code> 方法，调用 <code>RateLimiter#acquire(...)</code> 方法，获取令牌。<ul><li>若获取成功，向 Eureka-Server 发起注册，同步应用实例信息。</li><li>若获取失败，<strong>不</strong>向 Eureka-Server 发起注册，同步应用实例信息。<strong>这样会不会有问题</strong>？答案是<strong>不会</strong>。<ul><li>InstanceInfoReplicator 会<strong>固定周期</strong>检查本地应用实例是否有没向 Eureka-Server ，若未同步，则发起同步。在 <a href="http://www.iocoder.cn/Eureka/instance-registry-register/?self">《Eureka 源码解析 —— 应用实例注册发现（一）之注册》「2.1 应用实例信息复制器」</a> 有详细解析。</li><li>Eureka-Client 向 Eureka-Server 心跳时，Eureka-Server 会对比应用实例的 <code>lastDirtyTimestamp</code> ，若 Eureka-Client 的更大，则 Eureka-Server 返回 404 状态码。Eureka-Client 接收到 404 状态码后，发起注册同步。在 <a href="http://www.iocoder.cn/Eureka/instance-registry-renew/?self">Eureka 源码解析 —— 应用实例注册发现（二）之续租》「2.2 HeartbeatThread」</a> 有详细解析。</li></ul></li></ul></li></ul><h1>666. 彩蛋</h1><p>后面找时间研究下 Google Guava RateLimiter 的源码实现，从功能上更加强大，感兴趣的胖友可以瞅瞅呀。</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/Eureka/rate-limiter/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 Eureka 1.8.X 版本&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a hr
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— Eureka-Server 集群同步</title>
    <link href="http://www.iocoder.cn/Eureka/server-cluster/"/>
    <id>http://www.iocoder.cn/Eureka/server-cluster/</id>
    <published>2018-08-06T16:00:00.000Z</published>
    <updated>2017-10-19T05:48:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/Eureka/server-cluster/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">2. 集群节点初始化与更新</a><ul><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">2.1 集群节点启动</a></li><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">2.2 更新集群节点信息</a></li><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">2.3 集群节点</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">3. 获取初始注册信息</a></li><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">4. 同步注册信息</a><ul><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">4.1 同步操作类型</a></li><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">4.2 发起 Eureka-Server 同步操作</a></li><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">4.3 接收 Eureka-Server 同步操作</a></li><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">4.4 处理 Eureka-Server 同步结果</a></li></ul></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p>本文主要分享 <strong>Eureka-Server 集群同步注册信息</strong>。</p><p>Eureka-Server 集群如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_08_07/01.png" alt=""></p><ul><li>Eureka-Server 集群不区分<strong>主从节点</strong>或者 <strong>Primary &amp; Secondary 节点</strong>，所有节点<strong>相同角色( 也就是没有角色 )，完全对等</strong>。</li><li>Eureka-Client 可以向<strong>任意</strong> Eureka-Client 发起任意<strong>读写</strong>操作，Eureka-Server 将操作复制到另外的 Eureka-Server 以达到<strong>最终一致性</strong>。注意，Eureka-Server 是选择了 AP 的组件。</li></ul><p>Eureka-Server 可以使用直接配置所有节点的服务地址，或者基于 DNS 配置。推荐阅读：<a href="http://blog.didispace.com/springcloud6/?from=http://www.iocoder.cn" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud构建微服务架构（六）高可用服务注册中心》</a> 。</p><p>本文主要类在 <code>com.netflix.eureka.cluster</code> 包下。</p><p>OK，让我们开始愉快的遨游在代码的海洋。</p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><p>ps ：<strong>注意</strong>，本文提到的<strong>同步</strong>，准确来说是<strong>复制( Replication )</strong>。</p><h1>2. 集群节点初始化与更新</h1><p><code>com.netflix.eureka.cluster.PeerEurekaNodes</code> ，Eureka-Server 集群节点集合 。构造方法如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeerEurekaNodes</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(PeerEurekaNodes.class);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用实例注册表</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> PeerAwareInstanceRegistry registry;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Eureka-Server 配置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> EurekaServerConfig serverConfig;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Eureka-Client 配置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> EurekaClientConfig clientConfig;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Eureka-Server 编解码</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> ServerCodecs serverCodecs;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用实例信息管理器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApplicationInfoManager applicationInfoManager;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Eureka-Server 集群节点数组</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;PeerEurekaNode&gt; peerEurekaNodes = Collections.emptyList();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Eureka-Server 服务地址数组</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Set&lt;String&gt; peerEurekaNodeUrls = Collections.emptySet();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 定时任务服务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> ScheduledExecutorService taskExecutor;</div><div class="line"></div><div class="line">    <span class="meta">@Inject</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PeerEurekaNodes</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">            PeerAwareInstanceRegistry registry,</span></span></div><div class="line"><span class="function"><span class="params">            EurekaServerConfig serverConfig,</span></span></div><div class="line"><span class="function"><span class="params">            EurekaClientConfig clientConfig,</span></span></div><div class="line"><span class="function"><span class="params">            ServerCodecs serverCodecs,</span></span></div><div class="line"><span class="function"><span class="params">            ApplicationInfoManager applicationInfoManager)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.registry = registry;</div><div class="line">        <span class="keyword">this</span>.serverConfig = serverConfig;</div><div class="line">        <span class="keyword">this</span>.clientConfig = clientConfig;</div><div class="line">        <span class="keyword">this</span>.serverCodecs = serverCodecs;</div><div class="line">        <span class="keyword">this</span>.applicationInfoManager = applicationInfoManager;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><code>peerEurekaNodes</code>, <code>peerEurekaNodeUrls</code>, <code>taskExecutor</code> 属性，在构造方法中<strong>未设置和初始化</strong>，而是在 <code>PeerEurekaNodes#start()</code> 方法，设置和初始化，下文我们会解析这个方法。</li><li>Eureka-Server 在初始化时，调用 <code>EurekaBootStrap#getPeerEurekaNodes(...)</code> 方法，创建 PeerEurekaNodes ，点击 <a href="https://github.com/YunaiV/eureka/blob/94a4a1ebd35a3350893369a05757c01b2534b702/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java#L245" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看该方法的实现。</li></ul><h2>2.1 集群节点启动</h2><p>调用 <code>PeerEurekaNodes#start()</code> 方法，集群节点启动，主要完成两个逻辑：</p><ul><li>初始化集群节点信息</li><li>初始化固定周期( 默认：10 分钟，可配置 )更新集群节点信息的任务</li></ul><p>代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// 创建 定时任务服务</span></div><div class="line"> <span class="number">3</span>:     taskExecutor = Executors.newSingleThreadScheduledExecutor(</div><div class="line"> <span class="number">4</span>:             <span class="keyword">new</span> ThreadFactory() &#123;</div><div class="line"> <span class="number">5</span>:                 <span class="meta">@Override</span></div><div class="line"> <span class="number">6</span>:                 <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line"> <span class="number">7</span>:                     Thread thread = <span class="keyword">new</span> Thread(r, <span class="string">"Eureka-PeerNodesUpdater"</span>);</div><div class="line"> <span class="number">8</span>:                     thread.setDaemon(<span class="keyword">true</span>);</div><div class="line"> <span class="number">9</span>:                     <span class="keyword">return</span> thread;</div><div class="line"><span class="number">10</span>:                 &#125;</div><div class="line"><span class="number">11</span>:             &#125;</div><div class="line"><span class="number">12</span>:     );</div><div class="line"><span class="number">13</span>:     <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">14</span>:         <span class="comment">// 初始化 集群节点信息</span></div><div class="line"><span class="number">15</span>:         updatePeerEurekaNodes(resolvePeerUrls());</div><div class="line"><span class="number">16</span>:         <span class="comment">// 初始化 初始化固定周期更新集群节点信息的任务</span></div><div class="line"><span class="number">17</span>:         Runnable peersUpdateTask = <span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="number">18</span>:             <span class="meta">@Override</span></div><div class="line"><span class="number">19</span>:             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">20</span>:                 <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">21</span>:                     updatePeerEurekaNodes(resolvePeerUrls());</div><div class="line"><span class="number">22</span>:                 &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"><span class="number">23</span>:                     logger.error(<span class="string">"Cannot update the replica Nodes"</span>, e);</div><div class="line"><span class="number">24</span>:                 &#125;</div><div class="line"><span class="number">25</span>: </div><div class="line"><span class="number">26</span>:             &#125;</div><div class="line"><span class="number">27</span>:         &#125;;</div><div class="line"><span class="number">28</span>:         taskExecutor.scheduleWithFixedDelay(</div><div class="line"><span class="number">29</span>:                 peersUpdateTask,</div><div class="line"><span class="number">30</span>:                 serverConfig.getPeerEurekaNodesUpdateIntervalMs(),</div><div class="line"><span class="number">31</span>:                 serverConfig.getPeerEurekaNodesUpdateIntervalMs(),</div><div class="line"><span class="number">32</span>:                 TimeUnit.MILLISECONDS</div><div class="line"><span class="number">33</span>:         );</div><div class="line"><span class="number">34</span>:     &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"><span class="number">35</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</div><div class="line"><span class="number">36</span>:     &#125;</div><div class="line"><span class="number">37</span>:     <span class="comment">// 打印 集群节点信息</span></div><div class="line"><span class="number">38</span>:     <span class="keyword">for</span> (PeerEurekaNode node : peerEurekaNodes) &#123;</div><div class="line"><span class="number">39</span>:         logger.info(<span class="string">"Replica node URL:  "</span> + node.getServiceUrl());</div><div class="line"><span class="number">40</span>:     &#125;</div><div class="line"><span class="number">41</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 15 行 &amp;&amp; 第 21 行 ：调用 <code>#updatePeerEurekaNodes()</code> 方法，更新集群节点信息。</li></ul><h2>2.2 更新集群节点信息</h2><p>调用 <code>#resolvePeerUrls()</code> 方法，获得 Eureka-Server 集群服务地址数组，代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">resolvePeerUrls</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// 获得 Eureka-Server 集群服务地址数组</span></div><div class="line"> <span class="number">3</span>:     InstanceInfo myInfo = applicationInfoManager.getInfo();</div><div class="line"> <span class="number">4</span>:     String zone = InstanceInfo.getZone(clientConfig.getAvailabilityZones(clientConfig.getRegion()), myInfo);</div><div class="line"> <span class="number">5</span>:     List&lt;String&gt; replicaUrls = EndpointUtils.getDiscoveryServiceUrls(clientConfig, zone, <span class="keyword">new</span> EndpointUtils.InstanceInfoBasedUrlRandomizer(myInfo));</div><div class="line"> <span class="number">6</span>: </div><div class="line"> <span class="number">7</span>:     <span class="comment">// 移除自己（避免向自己同步）</span></div><div class="line"> <span class="number">8</span>:     <span class="keyword">int</span> idx = <span class="number">0</span>;</div><div class="line"> <span class="number">9</span>:     <span class="keyword">while</span> (idx &lt; replicaUrls.size()) &#123;</div><div class="line"><span class="number">10</span>:         <span class="keyword">if</span> (isThisMyUrl(replicaUrls.get(idx))) &#123;</div><div class="line"><span class="number">11</span>:             replicaUrls.remove(idx);</div><div class="line"><span class="number">12</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">13</span>:             idx++;</div><div class="line"><span class="number">14</span>:         &#125;</div><div class="line"><span class="number">15</span>:     &#125;</div><div class="line"><span class="number">16</span>:     <span class="keyword">return</span> replicaUrls;</div><div class="line"><span class="number">17</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 2 至 5 行 ：获得 Eureka-Server 集群服务地址数组。<code>EndpointUtils#getDiscoveryServiceUrls(...)</code> 方法，逻辑与 <a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/?self">《Eureka 源码解析 —— EndPoint 与 解析器》「3.4 ConfigClusterResolver」</a> 基本类似。EndpointUtils 正在逐步，猜测未来这里会替换。</li><li>第 7 至 15 行 ：移除自身节点，避免向自己同步。</li></ul><hr><p>调用 <code>#updatePeerEurekaNodes()</code> 方法，更新集群节点信息，主要完成两部分逻辑：</p><ul><li>添加新增的集群节点</li><li>关闭删除的集群节点</li></ul><p>代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">updatePeerEurekaNodes</span><span class="params">(List&lt;String&gt; newPeerUrls)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="keyword">if</span> (newPeerUrls.isEmpty()) &#123;</div><div class="line"> <span class="number">3</span>:         logger.warn(<span class="string">"The replica size seems to be empty. Check the route 53 DNS Registry"</span>);</div><div class="line"> <span class="number">4</span>:         <span class="keyword">return</span>;</div><div class="line"> <span class="number">5</span>:     &#125;</div><div class="line"> <span class="number">6</span>: </div><div class="line"> <span class="number">7</span>:     <span class="comment">// 计算 新增的集群节点地址</span></div><div class="line"> <span class="number">8</span>:     Set&lt;String&gt; toShutdown = <span class="keyword">new</span> HashSet&lt;&gt;(peerEurekaNodeUrls);</div><div class="line"> <span class="number">9</span>:     toShutdown.removeAll(newPeerUrls);</div><div class="line"><span class="number">10</span>: </div><div class="line"><span class="number">11</span>:     <span class="comment">// 计算 删除的集群节点地址</span></div><div class="line"><span class="number">12</span>:     Set&lt;String&gt; toAdd = <span class="keyword">new</span> HashSet&lt;&gt;(newPeerUrls);</div><div class="line"><span class="number">13</span>:     toAdd.removeAll(peerEurekaNodeUrls);</div><div class="line"><span class="number">14</span>: </div><div class="line"><span class="number">15</span>:     <span class="keyword">if</span> (toShutdown.isEmpty() &amp;&amp; toAdd.isEmpty()) &#123; <span class="comment">// No change</span></div><div class="line"><span class="number">16</span>:         <span class="keyword">return</span>;</div><div class="line"><span class="number">17</span>:     &#125;</div><div class="line"><span class="number">18</span>: </div><div class="line"><span class="number">19</span>:     <span class="comment">// 关闭删除的集群节点</span></div><div class="line"><span class="number">20</span>:     <span class="comment">// Remove peers no long available</span></div><div class="line"><span class="number">21</span>:     List&lt;PeerEurekaNode&gt; newNodeList = <span class="keyword">new</span> ArrayList&lt;&gt;(peerEurekaNodes);</div><div class="line"><span class="number">22</span>:     <span class="keyword">if</span> (!toShutdown.isEmpty()) &#123;</div><div class="line"><span class="number">23</span>:         logger.info(<span class="string">"Removing no longer available peer nodes &#123;&#125;"</span>, toShutdown);</div><div class="line"><span class="number">24</span>:         <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"><span class="number">25</span>:         <span class="keyword">while</span> (i &lt; newNodeList.size()) &#123;</div><div class="line"><span class="number">26</span>:             PeerEurekaNode eurekaNode = newNodeList.get(i);</div><div class="line"><span class="number">27</span>:             <span class="keyword">if</span> (toShutdown.contains(eurekaNode.getServiceUrl())) &#123;</div><div class="line"><span class="number">28</span>:                 newNodeList.remove(i);</div><div class="line"><span class="number">29</span>:                 eurekaNode.shutDown(); <span class="comment">// 关闭</span></div><div class="line"><span class="number">30</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">31</span>:                 i++;</div><div class="line"><span class="number">32</span>:             &#125;</div><div class="line"><span class="number">33</span>:         &#125;</div><div class="line"><span class="number">34</span>:     &#125;</div><div class="line"><span class="number">35</span>: </div><div class="line"><span class="number">36</span>:     <span class="comment">// 添加新增的集群节点</span></div><div class="line"><span class="number">37</span>:     <span class="comment">// Add new peers</span></div><div class="line"><span class="number">38</span>:     <span class="keyword">if</span> (!toAdd.isEmpty()) &#123;</div><div class="line"><span class="number">39</span>:         logger.info(<span class="string">"Adding new peer nodes &#123;&#125;"</span>, toAdd);</div><div class="line"><span class="number">40</span>:         <span class="keyword">for</span> (String peerUrl : toAdd) &#123;</div><div class="line"><span class="number">41</span>:             newNodeList.add(createPeerEurekaNode(peerUrl));</div><div class="line"><span class="number">42</span>:         &#125;</div><div class="line"><span class="number">43</span>:     &#125;</div><div class="line"><span class="number">44</span>: </div><div class="line"><span class="number">45</span>:     <span class="comment">// 赋值</span></div><div class="line"><span class="number">46</span>:     <span class="keyword">this</span>.peerEurekaNodes = newNodeList;</div><div class="line"><span class="number">47</span>:     <span class="keyword">this</span>.peerEurekaNodeUrls = <span class="keyword">new</span> HashSet&lt;&gt;(newPeerUrls);</div><div class="line"><span class="number">48</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 7 至 9 行 ：<strong>计算</strong>新增的集群节点地址。</p></li><li><p>第 11 至 13 行 ：<strong>计算</strong>删除的集群节点地址。</p></li><li><p>第 19 至 34 行 ：<strong>关闭</strong>删除的集群节点。</p></li><li><p>第 36 至 43 行 ：<strong>添加</strong>新增的集群节点。调用 <code>#createPeerEurekaNode(peerUrl)</code> 方法，创建集群节点，代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="number">1</span>: <span class="function"><span class="keyword">protected</span> PeerEurekaNode <span class="title">createPeerEurekaNode</span><span class="params">(String peerEurekaNodeUrl)</span> </span>&#123;</div><div class="line"><span class="number">2</span>:     HttpReplicationClient replicationClient = JerseyReplicationClient.createReplicationClient(serverConfig, serverCodecs, peerEurekaNodeUrl);</div><div class="line"><span class="number">3</span>:     String targetHost = hostFromUrl(peerEurekaNodeUrl);</div><div class="line"><span class="number">4</span>:     <span class="keyword">if</span> (targetHost == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">5</span>:         targetHost = <span class="string">"host"</span>;</div><div class="line"><span class="number">6</span>:     &#125;</div><div class="line"><span class="number">7</span>:     <span class="keyword">return</span> <span class="keyword">new</span> PeerEurekaNode(registry, targetHost, peerEurekaNodeUrl, replicationClient, serverConfig);</div><div class="line"><span class="number">8</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 2 行 ：创建 Eureka-Server 集群通信客户端，在 <a href="http://www.iocoder.cn/Eureka/transport/?self">《Eureka 源码解析 —— 网络通信》「4.2 JerseyReplicationClient」</a> 有详细解析。</li><li>第 7 行 ：创建 PeerEurekaNode ，在 <a href="#">「2.3 PeerEurekaNode」</a> 有详细解析。</li></ul></li></ul><h2>2.3 集群节点</h2><p><code>com.netflix.eureka.cluster.PeerEurekaNode</code> ，单个集群节点。</p><p>点击 <a href="https://github.com/YunaiV/eureka/blob/fcc9027a197783a23e7cb72ad0f617b7dc63d221/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java#L111" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看<strong>构造方法</strong></p><ul><li>第 129 行 ：创建 ReplicationTaskProcessor 。在 <a href="#">「4.1.2 同步操作任务处理器」</a> 详细解析</li><li>第 131 至 140 行 ：创建<strong>批量任务</strong>分发器，在 <a href="http://www.iocoder.cn/Eureka/batch-tasks/?self">《Eureka 源码解析 —— 任务批处理》</a> 有详细解析。</li><li>第 142 至 151 行 ：创建<strong>单任务</strong>分发器，用于 Eureka-Server 向亚马逊 AWS 的 ASG ( <code>Autoscaling Group</code> ) 同步状态。暂时跳过。</li></ul><h1>3. 获取初始注册信息</h1><p>Eureka-Server 启动时，调用 <code>PeerAwareInstanceRegistryImpl#syncUp()</code> 方法，从集群的一个 Eureka-Server 节点获取<strong>初始</strong>注册信息，代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">syncUp</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="comment">// Copy entire entry from neighboring DS node</span></div><div class="line"> <span class="number">4</span>:     <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"> <span class="number">5</span>: </div><div class="line"> <span class="number">6</span>:     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ((i &lt; serverConfig.getRegistrySyncRetries()) &amp;&amp; (count == <span class="number">0</span>)); i++) &#123;</div><div class="line"> <span class="number">7</span>:         <span class="comment">// 未读取到注册信息，sleep 等待</span></div><div class="line"> <span class="number">8</span>:         <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</div><div class="line"> <span class="number">9</span>:             <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">10</span>:                 Thread.sleep(serverConfig.getRegistrySyncRetryWaitMs());</div><div class="line"><span class="number">11</span>:             &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line"><span class="number">12</span>:                 logger.warn(<span class="string">"Interrupted during registry transfer.."</span>);</div><div class="line"><span class="number">13</span>:                 <span class="keyword">break</span>;</div><div class="line"><span class="number">14</span>:             &#125;</div><div class="line"><span class="number">15</span>:         &#125;</div><div class="line"><span class="number">16</span>: </div><div class="line"><span class="number">17</span>:         <span class="comment">// 获取注册信息</span></div><div class="line"><span class="number">18</span>:         Applications apps = eurekaClient.getApplications();</div><div class="line"><span class="number">19</span>:         <span class="keyword">for</span> (Application app : apps.getRegisteredApplications()) &#123;</div><div class="line"><span class="number">20</span>:             <span class="keyword">for</span> (InstanceInfo instance : app.getInstances()) &#123;</div><div class="line"><span class="number">21</span>:                 <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">22</span>:                     <span class="keyword">if</span> (isRegisterable(instance)) &#123; <span class="comment">// 判断是否能够注册</span></div><div class="line"><span class="number">23</span>:                         register(instance, instance.getLeaseInfo().getDurationInSecs(), <span class="keyword">true</span>); <span class="comment">// 注册</span></div><div class="line"><span class="number">24</span>:                         count++;</div><div class="line"><span class="number">25</span>:                     &#125;</div><div class="line"><span class="number">26</span>:                 &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line"><span class="number">27</span>:                     logger.error(<span class="string">"During DS init copy"</span>, t);</div><div class="line"><span class="number">28</span>:                 &#125;</div><div class="line"><span class="number">29</span>:             &#125;</div><div class="line"><span class="number">30</span>:         &#125;</div><div class="line"><span class="number">31</span>:     &#125;</div><div class="line"><span class="number">32</span>:     <span class="keyword">return</span> count;</div><div class="line"><span class="number">33</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 7 至 15 行 ：未获取到注册信息，<code>sleep</code> 等待再次重试。</li><li>第 17 至 30 行 ：获取注册信息，若获取到，注册到自身节点。<ul><li>第 22 行 ：判断应用实例是否能够注册到自身节点。主要用于亚马逊 AWS 环境下的判断，若非部署在亚马逊里，都返回 <code>true</code> 。点击 <a href="https://github.com/YunaiV/eureka/blob/94a4a1ebd35a3350893369a05757c01b2534b702/eureka-core/src/main/java/com/netflix/eureka/registry/PeerAwareInstanceRegistryImpl.java#L593" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看实现。</li><li>第 23 行 ：调用 <code>#register()</code> 方法，注册应用实例到自身节点。在 <a href="http://www.iocoder.cn/Eureka/instance-registry-register/">《Eureka 源码解析 —— 应用实例注册发现（一）之注册》</a> 有详细解析。</li></ul></li></ul><hr><p>若调用 <code>#syncUp()</code> 方法，未获取到应用实例，则 Eureka-Server 会有一段时间( 默认：5 分钟，可配 )不允许被 Eureka-Client 获取注册信息，避免影响 Eureka-Client 。</p><ul><li><p>标记 Eureka-Server 启动时，未获取到应用实例，代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// PeerAwareInstanceRegistryImpl.java</span></div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> peerInstancesTransferEmptyOnStartup = <span class="keyword">true</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openForTraffic</span><span class="params">(ApplicationInfoManager applicationInfoManager, <span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">    <span class="comment">// ... 省略其他代码</span></div><div class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.peerInstancesTransferEmptyOnStartup = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// ... 省略其他代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li></ul><ul><li><p>判断 Eureka-Server 是否允许被 Eureka-Client 获取注册信息，代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// PeerAwareInstanceRegistryImpl.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldAllowAccess</span><span class="params">(<span class="keyword">boolean</span> remoteRegionRequired)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.peerInstancesTransferEmptyOnStartup) &#123;</div><div class="line">       <span class="comment">// 设置启动时间</span></div><div class="line">       <span class="keyword">this</span>.startupTime = System.currentTimeMillis();</div><div class="line">       <span class="keyword">if</span> (!(System.currentTimeMillis() &gt; <span class="keyword">this</span>.startupTime + serverConfig.getWaitTimeInMsWhenSyncEmpty())) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// ... 省略其他代码</span></div><div class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li></ul><h1>4. 同步注册信息</h1><p>Eureka-Server 集群同步注册信息如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_08_07/02.png" alt=""></p><ul><li>Eureka-Server 接收到 Eureka-Client 的 Register、Heartbeat、Cancel、StatusUpdate、DeleteStatusOverride 操作，固定间隔( 默认值 ：500 毫秒，可配 )向 Eureka-Server 集群内其他节点同步( <strong>准实时，非实时</strong> )。</li></ul><h2>4.1 同步操作类型</h2><p><code>com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl.Action</code> ，同步操作类型，代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Action &#123;</div><div class="line">   Heartbeat, Register, Cancel, StatusUpdate, DeleteStatusOverride;</div><div class="line"></div><div class="line">   <span class="comment">// ... 省略监控相关属性</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>Register ，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-register/?self">《Eureka 源码解析 —— 应用实例注册发现（一）之注册》</a> 有详细解析</li><li>Heartbeat ，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-renew/?self">《Eureka 源码解析 —— 应用实例注册发现（二）之续租》</a> 有详细解析</li><li>Cancel ，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-cancel/?self">《Eureka 源码解析 —— 应用实例注册发现（三）之下线》</a> 有详细解析</li><li>StatusUpdate ，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/?self">《Eureka 源码解析 —— 应用实例注册发现（八）之覆盖状态》</a> 有详细解析</li><li>DeleteStatusOverride ，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/?self">《Eureka 源码解析 —— 应用实例注册发现（八）之覆盖状态》</a> 有详细解析</li></ul><h2>4.2 发起 Eureka-Server 同步操作</h2><p>Eureka-Server 在完成 Eureka-Client 发起的上述操作在<strong>自身节点的执行后</strong>，向集群内其他 Eureka-Server 发起同步操作。以 Register 操作举例子，代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// PeerAwareInstanceRegistryImpl.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> InstanceInfo info, <span class="keyword">final</span> <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">   <span class="comment">// 租约过期时间</span></div><div class="line">   <span class="keyword">int</span> leaseDuration = Lease.DEFAULT_DURATION_IN_SECS;</div><div class="line">   <span class="keyword">if</span> (info.getLeaseInfo() != <span class="keyword">null</span> &amp;&amp; info.getLeaseInfo().getDurationInSecs() &gt; <span class="number">0</span>) &#123;</div><div class="line">       leaseDuration = info.getLeaseInfo().getDurationInSecs();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 注册应用实例信息</span></div><div class="line">   <span class="keyword">super</span>.register(info, leaseDuration, isReplication);</div><div class="line">   <span class="comment">// Eureka-Server 复制</span></div><div class="line">   replicateToPeers(Action.Register, info.getAppName(), info.getId(), info, <span class="keyword">null</span>, isReplication);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>最后一行，调用 <code>#replicateToPeers(...)</code> 方法，传递<strong>对应的同步操作类型</strong>，发起同步操作。</li></ul><hr><p><code>#replicateToPeers(...)</code> 方法，代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replicateToPeers</span><span class="params">(Action action, String appName, String id,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">2</span>:                               InstanceInfo info <span class="comment">/* optional */</span>,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">3</span>:                               InstanceStatus newStatus <span class="comment">/* optional */</span>, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line"> <span class="number">4</span>:     Stopwatch tracer = action.getTimer().start();</div><div class="line"> <span class="number">5</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">6</span>:         <span class="keyword">if</span> (isReplication) &#123;</div><div class="line"> <span class="number">7</span>:             numberOfReplicationsLastMin.increment();</div><div class="line"> <span class="number">8</span>:         &#125;</div><div class="line"> <span class="number">9</span>: </div><div class="line"><span class="number">10</span>:         <span class="comment">// Eureka-Server 发起的请求 或者 集群为空</span></div><div class="line"><span class="number">11</span>:         <span class="comment">// If it is a replication already, do not replicate again as this will create a poison replication</span></div><div class="line"><span class="number">12</span>:         <span class="keyword">if</span> (peerEurekaNodes == Collections.EMPTY_LIST || isReplication) &#123;</div><div class="line"><span class="number">13</span>:             <span class="keyword">return</span>;</div><div class="line"><span class="number">14</span>:         &#125;</div><div class="line"><span class="number">15</span>: </div><div class="line"><span class="number">16</span>:         <span class="keyword">for</span> (<span class="keyword">final</span> PeerEurekaNode node : peerEurekaNodes.getPeerEurekaNodes()) &#123;</div><div class="line"><span class="number">17</span>:             <span class="comment">// If the url represents this host, do not replicate to yourself.</span></div><div class="line"><span class="number">18</span>:             <span class="keyword">if</span> (peerEurekaNodes.isThisMyUrl(node.getServiceUrl())) &#123;</div><div class="line"><span class="number">19</span>:                 <span class="keyword">continue</span>;</div><div class="line"><span class="number">20</span>:             &#125;</div><div class="line"><span class="number">21</span>:             replicateInstanceActionsToPeers(action, appName, id, info, newStatus, node);</div><div class="line"><span class="number">22</span>:         &#125;</div><div class="line"><span class="number">23</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">24</span>:         tracer.stop();</div><div class="line"><span class="number">25</span>:     &#125;</div><div class="line"><span class="number">26</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 10 至 14 行 ：Eureka-Server 在处理上述操作( Action )，无论来自 Eureka-Client 发起请求，还是 Eureka-Server 发起同步，调用的内部方法相同，通过 <code>isReplication=true</code> 参数，避免死循环同步。</li><li>第 16 至 22 行 ：<strong>循环</strong>集群内<strong>每个</strong>节点，调用 <code>#replicateInstanceActionsToPeers(...)</code> 方法，发起同步操作。</li></ul><hr><p><code>#replicateInstanceActionsToPeers(...)</code> 方法，代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replicateInstanceActionsToPeers</span><span class="params">(Action action, String appName,</span></span></div><div class="line"><span class="function"><span class="params">                                            String id, InstanceInfo info, InstanceStatus newStatus,</span></span></div><div class="line"><span class="function"><span class="params">                                            PeerEurekaNode node)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       InstanceInfo infoFromRegistry;</div><div class="line">       CurrentRequestVersion.set(Version.V2);</div><div class="line">       <span class="keyword">switch</span> (action) &#123;</div><div class="line">           <span class="keyword">case</span> Cancel:</div><div class="line">               node.cancel(appName, id);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> Heartbeat:</div><div class="line">               InstanceStatus overriddenStatus = overriddenInstanceStatusMap.get(id);</div><div class="line">               infoFromRegistry = getInstanceByAppAndId(appName, id, <span class="keyword">false</span>);</div><div class="line">               node.heartbeat(appName, id, infoFromRegistry, overriddenStatus, <span class="keyword">false</span>);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> Register:</div><div class="line">               node.register(info);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> StatusUpdate:</div><div class="line">               infoFromRegistry = getInstanceByAppAndId(appName, id, <span class="keyword">false</span>);</div><div class="line">               node.statusUpdate(appName, id, newStatus, infoFromRegistry);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> DeleteStatusOverride:</div><div class="line">               infoFromRegistry = getInstanceByAppAndId(appName, id, <span class="keyword">false</span>);</div><div class="line">               node.deleteStatusOverride(appName, id, infoFromRegistry);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">       logger.error(<span class="string">"Cannot replicate information to &#123;&#125; for action &#123;&#125;"</span>, node.getServiceUrl(), action.name(), t);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p><strong>Cancel</strong> ：调用 <code>PeerEurekaNode#cancel(...)</code> 方法，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java#L157" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看实现。</p></li><li><p><strong>Heartbeat</strong> ：调用 <code>PeerEurekaNode#heartbeat(...)</code> 方法，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java#L194" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看实现。</p></li><li><p><strong>Register</strong> ：调用 <code>PeerEurekaNode#register(...)</code> 方法，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java#L134" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看实现。</p></li><li><p><strong>StatusUpdate</strong> ：调用 <code>PeerEurekaNode#statusUpdate(...)</code> 方法，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java#L243" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看实现。</p></li><li><p><strong>DeleteStatusOverride</strong> ：调用 <code>PeerEurekaNode#deleteStatusOverride(...)</code> 方法，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java#L294" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看实现。</p></li><li><p>上面的每个方法实现，我们<strong>都</strong>会看到类似这么一段代码 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">batchingDispatcher.process(</div><div class="line">    taskId(<span class="string">"$&#123;action&#125;"</span>, appName, id), <span class="comment">// id</span></div><div class="line">    <span class="keyword">new</span> InstanceReplicationTask(targetHost, Action.Cancel, appName, id) &#123;</div><div class="line">        </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> replicationClient.doString(...);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleFailure</span><span class="params">(<span class="keyword">int</span> statusCode, Object responseEntity)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">            <span class="comment">// do Something...</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;, <span class="comment">// ReplicationTask 子类</span></div><div class="line">    expiryTime</div><div class="line">)</div></pre></td></tr></table></figure></p><ul><li><p><code>#task(...)</code> 方法，生成同步操作任务<strong>编号</strong>。代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">taskId</span><span class="params">(String requestType, String appName, String id)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> requestType + <span class="string">'#'</span> + appName + <span class="string">'/'</span> + id;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><strong>相同应用实例的相同同步操作使用相同任务编号</strong>。在 <a href="http://www.iocoder.cn/Eureka/batch-tasks/?self">《Eureka 源码解析 —— 任务批处理》「2. 整体流程」</a> 中，我们看到&quot; 接收线程( Runner )合并任务，将相同任务编号的任务合并，只执行一次。 &quot;，因此，相同应用实例的相同同步操作就能被合并，减少操作量。例如，Eureka-Server 同步某个应用实例的 Heartbeat 操作，接收同步的 Eureak-Server 挂了，一方面这个应用的这次操作会<strong>重试</strong>，另一方面，这个应用实例会发起<strong>新的</strong> Heartbeat 操作，通过任务编号合并，接收同步的 Eureka-Server 恢复后，减少收到<strong>重复积压</strong>的任务。</li></ul></li><li><p>InstanceReplicationTask ，同步操作任务，在 <a href="#">「4.1.1 同步操作任务」</a> 详细解析。</p></li><li><p><code>expiryTime</code> ，任务过期时间。</p></li></ul></li></ul><h3>4.1.1 同步操作任务</h3><p><img src="http://www.iocoder.cn/images/Eureka/2018_08_07/03.png" alt=""></p><ul><li><code>com.netflix.eureka.cluster.ReplicationTask</code> ，同步任务<strong>抽象类</strong><ul><li>点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTask.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 ReplicationTask 代码。</li><li>定义了 <code>#getTaskName()</code> <strong>抽象</strong>方法。</li><li>定义了 <code>#execute()</code> <strong>抽象</strong>方法，执行同步任务。</li><li>实现了 <code>#handleSuccess()</code> 方法，处理成功执行同步结果。</li><li>实现了 <code>#handleFailure(...)</code> 方法，处理失败执行同步结果。</li></ul></li><li><code>com.netflix.eureka.cluster.InstanceReplicationTask</code> ，同步应用实例任务<strong>抽象类</strong><ul><li>点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/InstanceReplicationTask.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 InstanceReplicationTask 代码。</li><li>实现了父类 <code>#getTaskName()</code> <strong>抽象</strong>方法。</li></ul></li><li><code>com.netflix.eureka.cluster.AsgReplicationTask</code> ，亚马逊 AWS 使用，暂时跳过。</li></ul><p>从上面 <code>PeerEurekaNode#同步操作(...)</code> 方法，<strong>全部</strong>实现了 InstanceReplicationTask 类的 <code>#execute()</code> 方法，<strong>部分</strong>重写了 <code>#handleFailure(...)</code> 方法。</p><h3>4.1.2 同步操作任务处理器</h3><p><code>com.netflix.eureka.cluster.InstanceReplicationTask</code> ，实现 TaskProcessor <strong>接口</strong>，同步操作任务处理器。</p><ul><li>TaskProcessor ，在 <a href="http://www.iocoder.cn/Eureka/batch-tasks/?self">《Eureka 源码解析 —— 任务批处理》「10. 任务执行器【执行任务】」</a> 有详细解析。</li><li>点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 InstanceReplicationTask 代码。</li></ul><p><code>ReplicationTaskProcessor#process(task)</code> ，<strong>处理单任务</strong>，用于 Eureka-Server 向亚马逊 AWS 的 ASG ( <code>Autoscaling Group</code> ) 同步状态，暂时跳过，感兴趣的同学可以点击 <a href="https://github.com/YunaiV/eureka/blob/94a4a1ebd35a3350893369a05757c01b2534b702/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java#L38" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看方法代码。</p><p><code>ReplicationTaskProcessor#process(tasks)</code> ，<strong>处理批量任务</strong>，用于 Eureka-Server 集群注册信息的同步操作任务，通过调用被同步的 Eureka-Server 的 <code>peerreplication/batch/</code> 接口，一次性将批量( 多个 )的同步操作任务发起请求，代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> ProcessingResult <span class="title">process</span><span class="params">(List&lt;ReplicationTask&gt; tasks)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="comment">// 创建 批量提交同步操作任务的请求对象</span></div><div class="line"> <span class="number">4</span>:     ReplicationList list = createReplicationListOf(tasks);</div><div class="line"> <span class="number">5</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">6</span>:         <span class="comment">// 发起 批量提交同步操作任务的请求</span></div><div class="line"> <span class="number">7</span>:         EurekaHttpResponse&lt;ReplicationListResponse&gt; response = replicationClient.submitBatchUpdates(list);</div><div class="line"> <span class="number">8</span>:         <span class="comment">// 处理 批量提交同步操作任务的响应</span></div><div class="line"> <span class="number">9</span>:         <span class="keyword">int</span> statusCode = response.getStatusCode();</div><div class="line"><span class="number">10</span>:         <span class="keyword">if</span> (!isSuccess(statusCode)) &#123;</div><div class="line"><span class="number">11</span>:             <span class="keyword">if</span> (statusCode == <span class="number">503</span>) &#123;</div><div class="line"><span class="number">12</span>:                 logger.warn(<span class="string">"Server busy (503) HTTP status code received from the peer &#123;&#125;; rescheduling tasks after delay"</span>, peerId);</div><div class="line"><span class="number">13</span>:                 <span class="keyword">return</span> ProcessingResult.Congestion;</div><div class="line"><span class="number">14</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">15</span>:                 <span class="comment">// Unexpected error returned from the server. This should ideally never happen.</span></div><div class="line"><span class="number">16</span>:                 logger.error(<span class="string">"Batch update failure with HTTP status code &#123;&#125;; discarding &#123;&#125; replication tasks"</span>, statusCode, tasks.size());</div><div class="line"><span class="number">17</span>:                 <span class="keyword">return</span> ProcessingResult.PermanentError;</div><div class="line"><span class="number">18</span>:             &#125;</div><div class="line"><span class="number">19</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">20</span>:             handleBatchResponse(tasks, response.getEntity().getResponseList());</div><div class="line"><span class="number">21</span>:         &#125;</div><div class="line"><span class="number">22</span>:     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"><span class="number">23</span>:         <span class="keyword">if</span> (isNetworkConnectException(e)) &#123;</div><div class="line"><span class="number">24</span>:             logNetworkErrorSample(<span class="keyword">null</span>, e);</div><div class="line"><span class="number">25</span>:             <span class="keyword">return</span> ProcessingResult.TransientError;</div><div class="line"><span class="number">26</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">27</span>:             logger.error(<span class="string">"Not re-trying this exception because it does not seem to be a network exception"</span>, e);</div><div class="line"><span class="number">28</span>:             <span class="keyword">return</span> ProcessingResult.PermanentError;</div><div class="line"><span class="number">29</span>:         &#125;</div><div class="line"><span class="number">30</span>:     &#125;</div><div class="line"><span class="number">31</span>:     <span class="keyword">return</span> ProcessingResult.Success;</div><div class="line"><span class="number">32</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 4 行 ：创建批量提交同步操作任务的请求对象( ReplicationList ) 。比较易懂，咱就不啰嗦贴代码了。<ul><li>ReplicationList ，点击 <a href="https://github.com/YunaiV/eureka/blob/94a4a1ebd35a3350893369a05757c01b2534b702/eureka-core/src/main/java/com/netflix/eureka/cluster/protocol/ReplicationList.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看类。</li><li>ReplicationInstance ，点击 <a href="https://github.com/YunaiV/eureka/blob/94a4a1ebd35a3350893369a05757c01b2534b702/eureka-core/src/main/java/com/netflix/eureka/cluster/protocol/ReplicationInstance.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看类。</li><li><code>#createReplicationListOf(...)</code> ，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java#L142" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看方法。</li><li><code>#createReplicationInstanceOf(...)</code> ，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java#L173" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看方法。</li></ul></li><li>第 7 行 ：调用 <code>JerseyReplicationClient#submitBatchUpdates(...)</code> 方法，请求 <code>peerreplication/batch/</code> 接口，一次性将批量( 多个 )的同步操作任务发起请求。<ul><li><code>JerseyReplicationClient#submitBatchUpdates(...)</code> 方法，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/transport/JerseyReplicationClient.java#L109" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看方法。</li><li>ReplicationListResponse ，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/protocol/ReplicationListResponse.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看类。</li><li>ReplicationInstanceResponse ，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/protocol/ReplicationInstanceResponse.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看类。</li></ul></li><li>第 9 至 31 行 ：处理批量提交同步操作任务的响应，在 <a href="#">「4.4 处理 Eureka-Server 同步结果」</a> 详细解析。</li></ul><h2>4.3 接收 Eureka-Server 同步操作</h2><p><code>com.netflix.eureka.resources.PeerReplicationResource</code> ，同步操作任务 Resource ( Controller )。</p><p><code>peerreplication/batch/</code> 接口，映射 <code>PeerReplicationResource#batchReplication(...)</code> 方法，代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Path</span>(<span class="string">"batch"</span>)</div><div class="line"> <span class="number">2</span>: <span class="meta">@POST</span></div><div class="line"> <span class="number">3</span>: <span class="function"><span class="keyword">public</span> Response <span class="title">batchReplication</span><span class="params">(ReplicationList replicationList)</span> </span>&#123;</div><div class="line"> <span class="number">4</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">5</span>:         ReplicationListResponse batchResponse = <span class="keyword">new</span> ReplicationListResponse();</div><div class="line"> <span class="number">6</span>:         <span class="comment">// 逐个同步操作任务处理，并将处理结果( ReplicationInstanceResponse ) 合并到 ReplicationListResponse 。</span></div><div class="line"> <span class="number">7</span>:         <span class="keyword">for</span> (ReplicationInstance instanceInfo : replicationList.getReplicationList()) &#123;</div><div class="line"> <span class="number">8</span>:             <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">9</span>:                 batchResponse.addResponse(dispatch(instanceInfo));</div><div class="line"><span class="number">10</span>:             &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"><span class="number">11</span>:                 batchResponse.addResponse(<span class="keyword">new</span> ReplicationInstanceResponse(Status.INTERNAL_SERVER_ERROR.getStatusCode(), <span class="keyword">null</span>));</div><div class="line"><span class="number">12</span>:                 logger.error(instanceInfo.getAction() + <span class="string">" request processing failed for batch item "</span></div><div class="line"><span class="number">13</span>:                         + instanceInfo.getAppName() + <span class="string">'/'</span> + instanceInfo.getId(), e);</div><div class="line"><span class="number">14</span>:             &#125;</div><div class="line"><span class="number">15</span>:         &#125;</div><div class="line"><span class="number">16</span>:         <span class="keyword">return</span> Response.ok(batchResponse).build();</div><div class="line"><span class="number">17</span>:     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"><span class="number">18</span>:         logger.error(<span class="string">"Cannot execute batch Request"</span>, e);</div><div class="line"><span class="number">19</span>:         <span class="keyword">return</span> Response.status(Status.INTERNAL_SERVER_ERROR).build();</div><div class="line"><span class="number">20</span>:     &#125;</div><div class="line"><span class="number">21</span>: &#125;</div><div class="line"><span class="number">22</span>: </div><div class="line"><span class="number">23</span>: <span class="function"><span class="keyword">private</span> ReplicationInstanceResponse <span class="title">dispatch</span><span class="params">(ReplicationInstance instanceInfo)</span> </span>&#123;</div><div class="line"><span class="number">24</span>:     ApplicationResource applicationResource = createApplicationResource(instanceInfo);</div><div class="line"><span class="number">25</span>:     InstanceResource resource = createInstanceResource(instanceInfo, applicationResource);</div><div class="line"><span class="number">26</span>: </div><div class="line"><span class="number">27</span>:     String lastDirtyTimestamp = toString(instanceInfo.getLastDirtyTimestamp());</div><div class="line"><span class="number">28</span>:     String overriddenStatus = toString(instanceInfo.getOverriddenStatus());</div><div class="line"><span class="number">29</span>:     String instanceStatus = toString(instanceInfo.getStatus());</div><div class="line"><span class="number">30</span>: </div><div class="line"><span class="number">31</span>:     Builder singleResponseBuilder = <span class="keyword">new</span> Builder();</div><div class="line"><span class="number">32</span>:     <span class="keyword">switch</span> (instanceInfo.getAction()) &#123;</div><div class="line"><span class="number">33</span>:         <span class="keyword">case</span> Register:</div><div class="line"><span class="number">34</span>:             singleResponseBuilder = handleRegister(instanceInfo, applicationResource);</div><div class="line"><span class="number">35</span>:             <span class="keyword">break</span>;</div><div class="line"><span class="number">36</span>:         <span class="keyword">case</span> Heartbeat:</div><div class="line"><span class="number">37</span>:             singleResponseBuilder = handleHeartbeat(serverConfig, resource, lastDirtyTimestamp, overriddenStatus, instanceStatus);</div><div class="line"><span class="number">38</span>:             <span class="keyword">break</span>;</div><div class="line"><span class="number">39</span>:         <span class="keyword">case</span> Cancel:</div><div class="line"><span class="number">40</span>:             singleResponseBuilder = handleCancel(resource);</div><div class="line"><span class="number">41</span>:             <span class="keyword">break</span>;</div><div class="line"><span class="number">42</span>:         <span class="keyword">case</span> StatusUpdate:</div><div class="line"><span class="number">43</span>:             singleResponseBuilder = handleStatusUpdate(instanceInfo, resource);</div><div class="line"><span class="number">44</span>:             <span class="keyword">break</span>;</div><div class="line"><span class="number">45</span>:         <span class="keyword">case</span> DeleteStatusOverride:</div><div class="line"><span class="number">46</span>:             singleResponseBuilder = handleDeleteStatusOverride(instanceInfo, resource);</div><div class="line"><span class="number">47</span>:             <span class="keyword">break</span>;</div><div class="line"><span class="number">48</span>:     &#125;</div><div class="line"><span class="number">49</span>:     <span class="keyword">return</span> singleResponseBuilder.build();</div><div class="line"><span class="number">50</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 7 至 15 行 ：逐个处理<strong>单个</strong>同步操作任务，并将处理结果( ReplicationInstanceResponse ) 添加到 ReplicationListResponse 。</li><li>第 23 至 50 行 ：处理<strong>单个</strong>同步操作任务，返回处理结果( ReplicationInstanceResponse )。<ul><li>第 24 至 25 行 ：创建 ApplicationResource , InstanceResource 。我们看到，实际该方法是把<strong>单个</strong>同步操作任务提交到其他 Resource ( Controller ) 处理，Eureka-Server 收到 Eureka-Client 请求响应的 Resource ( Controller ) 是<strong>相同的逻辑</strong>。</li><li>Register ：点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java#L137" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 <code>#handleRegister(...)</code> 方法。</li><li>Heartbeat ：点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java#L147" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 <code>#handleHeartbeat(...)</code> 方法。</li><li>Cancel ：点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java#L142" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 <code>#handleCancel(...)</code> 方法。</li><li>StatusUpdate ：点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java#L165" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 <code>#handleStatusUpdate(...)</code> 方法。</li><li>DeleteStatusOverride ：点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java#L170" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 <code>#handleDeleteStatusOverride(...)</code> 方法。</li></ul></li></ul><h2>4.4 处理 Eureka-Server 同步结果</h2><p>😈 想想就有小激动，终于写到这里了。</p><p>接 <code>ReplicationTaskProcessor#process(tasks)</code> 方法，处理批量提交同步操作任务的响应，代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> ProcessingResult <span class="title">process</span><span class="params">(List&lt;ReplicationTask&gt; tasks)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="comment">// 创建 批量提交同步操作任务的请求对象</span></div><div class="line"> <span class="number">4</span>:     ReplicationList list = createReplicationListOf(tasks);</div><div class="line"> <span class="number">5</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">6</span>:         <span class="comment">// 发起 批量提交同步操作任务的请求</span></div><div class="line"> <span class="number">7</span>:         EurekaHttpResponse&lt;ReplicationListResponse&gt; response = replicationClient.submitBatchUpdates(list);</div><div class="line"> <span class="number">8</span>:         <span class="comment">// 处理 批量提交同步操作任务的响应</span></div><div class="line"> <span class="number">9</span>:         <span class="keyword">int</span> statusCode = response.getStatusCode();</div><div class="line"><span class="number">10</span>:         <span class="keyword">if</span> (!isSuccess(statusCode)) &#123;</div><div class="line"><span class="number">11</span>:             <span class="keyword">if</span> (statusCode == <span class="number">503</span>) &#123;</div><div class="line"><span class="number">12</span>:                 logger.warn(<span class="string">"Server busy (503) HTTP status code received from the peer &#123;&#125;; rescheduling tasks after delay"</span>, peerId);</div><div class="line"><span class="number">13</span>:                 <span class="keyword">return</span> ProcessingResult.Congestion;</div><div class="line"><span class="number">14</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">15</span>:                 <span class="comment">// Unexpected error returned from the server. This should ideally never happen.</span></div><div class="line"><span class="number">16</span>:                 logger.error(<span class="string">"Batch update failure with HTTP status code &#123;&#125;; discarding &#123;&#125; replication tasks"</span>, statusCode, tasks.size());</div><div class="line"><span class="number">17</span>:                 <span class="keyword">return</span> ProcessingResult.PermanentError;</div><div class="line"><span class="number">18</span>:             &#125;</div><div class="line"><span class="number">19</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">20</span>:             handleBatchResponse(tasks, response.getEntity().getResponseList());</div><div class="line"><span class="number">21</span>:         &#125;</div><div class="line"><span class="number">22</span>:     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"><span class="number">23</span>:         <span class="keyword">if</span> (isNetworkConnectException(e)) &#123;</div><div class="line"><span class="number">24</span>:             logNetworkErrorSample(<span class="keyword">null</span>, e);</div><div class="line"><span class="number">25</span>:             <span class="keyword">return</span> ProcessingResult.TransientError;</div><div class="line"><span class="number">26</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">27</span>:             logger.error(<span class="string">"Not re-trying this exception because it does not seem to be a network exception"</span>, e);</div><div class="line"><span class="number">28</span>:             <span class="keyword">return</span> ProcessingResult.PermanentError;</div><div class="line"><span class="number">29</span>:         &#125;</div><div class="line"><span class="number">30</span>:     &#125;</div><div class="line"><span class="number">31</span>:     <span class="keyword">return</span> ProcessingResult.Success;</div><div class="line"><span class="number">32</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 10 行 ，调用 <code>#isSuccess(...)</code> 方法，判断请求是否成功，响应状态码是否在  [200, 300) 范围内。</p></li><li><p>第 11 至 13 行 ：状态码 503 ，目前 Eureka-Server 返回 503 的原因是被限流。在 <a href="http://www.iocoder.cn/Eureka/rate-limiter/?self">《Eureka 源码解析 —— 基于令牌桶算法的 RateLimiter》</a> 详细解析。<strong>该情况为瞬时错误，会重试该同步操作任务</strong>，在 <a href="http://www.iocoder.cn/Eureka/batch-tasks/?self">《Eureka 源码解析 —— 任务批处理》「3. 任务处理器」</a> 有详细解析。</p></li><li><p>第 14 至 18 行 ：非<strong>预期</strong>状态码，目前 Eureka-Server 在代码上看下来，不会返回这样的状态码。<strong>该情况为永久错误，会重试该同步操作任务</strong>，在 <a href="http://www.iocoder.cn/Eureka/batch-tasks/?self">《Eureka 源码解析 —— 任务批处理》「3. 任务处理器」</a> 有详细解析。</p></li><li><p>第 20 行 ：请求成功，调用 <code>#handleBatchResponse(...)</code> 方法，逐个处理<strong>每个</strong> ReplicationTask 和 ReplicationInstanceResponse 。<strong>这里有一点要注意下，请求成功指的是整个请求成功，实际每个 ReplicationInstanceResponse 可能返回的状态码不在 [200, 300) 范围内</strong>。该方法下文详细解析。</p></li><li><p>第 23 至 25 行 ：请求发生网络异常，例如网络超时，打印网络异常日志。目前日志的打印为部分采样，条件为网络发生异常每间隔 10 秒打印一条，避免网络发生异常打印超级大量的日志。<strong>该情况为永久错误，会重试该同步操作任务</strong>，在 <a href="http://www.iocoder.cn/Eureka/batch-tasks/?self">《Eureka 源码解析 —— 任务批处理》「3. 任务处理器」</a> 有详细解析。</p><ul><li><code>#isNetworkConnectException(...)</code> ，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java#L163" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看方法。</li><li><code>#logNetworkErrorSample(...)</code> ，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java#L103" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看方法。</li></ul></li><li><p>第 26 至 29 行 ：非<strong>预期</strong>异常，目前 Eureka-Server 在代码上看下来，不会抛出这样的异常。<strong>该情况为永久错误，会重试该同步操作任务</strong>，在 <a href="http://www.iocoder.cn/Eureka/batch-tasks/?self">《Eureka 源码解析 —— 任务批处理》「3. 任务处理器」</a> 有详细解析。</p></li></ul><hr><p><code>#handleBatchResponse(...)</code> 方法，代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBatchResponse</span><span class="params">(List&lt;ReplicationTask&gt; tasks, List&lt;ReplicationInstanceResponse&gt; responseList)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (tasks.size() != responseList.size()) &#123;</div><div class="line">       <span class="comment">// This should ideally never happen unless there is a bug in the software.</span></div><div class="line">       logger.error(<span class="string">"Batch response size different from submitted task list (&#123;&#125; != &#123;&#125;); skipping response analysis"</span>, responseList.size(), tasks.size());</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks.size(); i++) &#123;</div><div class="line">       handleBatchResponse(tasks.get(i), responseList.get(i));</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBatchResponse</span><span class="params">(ReplicationTask task, ReplicationInstanceResponse response)</span> </span>&#123;</div><div class="line">   <span class="comment">// 执行成功</span></div><div class="line">   <span class="keyword">int</span> statusCode = response.getStatusCode();</div><div class="line">   <span class="keyword">if</span> (isSuccess(statusCode)) &#123;</div><div class="line">       task.handleSuccess();</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// 执行失败</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       task.handleFailure(response.getStatusCode(), response.getResponseEntity());</div><div class="line">   &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">       logger.error(<span class="string">"Replication task "</span> + task.getTaskName() + <span class="string">" error handler failure"</span>, e);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p><code>ReplicationTask#handleSuccess()</code> 方法，无任务同步操作任务重写，是个<strong>空方法</strong>，代码如下：</p><p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// ReplicationTask.java</div><div class="line">public void handleSuccess() &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li><li><p><code>ReplicationTask#handleFailure()</code> 方法，有<strong>两个</strong>同步操作任务重写：</p><ul><li><p>Cancel ：当 Eureka-Server 不存在下线的应用实例时，返回 404 状态码，此时打印错误日志，代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// PeerEurekaNode#cancel(...)</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleFailure</span><span class="params">(<span class="keyword">int</span> statusCode, Object responseEntity)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">    <span class="keyword">super</span>.handleFailure(statusCode, responseEntity);</div><div class="line">    <span class="keyword">if</span> (statusCode == <span class="number">404</span>) &#123;</div><div class="line">        logger.warn(<span class="string">"&#123;&#125;: missing entry."</span>, getTaskName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>x</li></ul></li><li><p>Heartbeat ：情况较为复杂，我们换一行继续说，避免排版有问题，影响阅读。</p></li></ul></li></ul><p>噔噔噔恰，本文的重要头戏来啦！Last But Very Importment ！！！</p><p>Eureka-Server 是允许<strong>同一时刻</strong>允许在任意节点被 Eureka-Client 发起<strong>写入</strong>相关的操作，网络是不可靠的资源，Eureka-Client 可能向一个 Eureka-Server 注册成功，但是网络波动，导致 Eureka-Client 误以为失败，此时恰好 Eureka-Client 变更了应用实例的状态，重试向另一个 Eureka-Server 注册，那么两个 Eureka-Server 对该应用实例的状态产生冲突。</p><p>再例如...... 我们不要继续举例子，网络波动真的很复杂。我们来看看 Eureka 是怎么处理的。</p><p>应用实例( InstanceInfo ) 的 <code>lastDirtyTimestamp</code> 属性，使用<strong>时间戳</strong>，表示应用实例的<strong>版本号</strong>，当请求方( 不仅仅是 Eureka-Client ，也可能是同步注册操作的 Eureka-Server ) 向 Eureka-Server 发起注册时，若 Eureka-Server 已存在拥有更大 <code>lastDirtyTimestamp</code> 该实例( <strong>相同应用并且相同应用实例编号被认为是相同实例</strong> )，则请求方注册的应用实例( InstanceInfo ) 无法覆盖注册此 Eureka-Server 的该实例( 见 <code>AbstractInstanceRegistry#register(...)</code> 方法 )。例如我们上面举的例子，第一个 Eureka-Server 向 第二个 Eureka-Server 同步注册应用实例时，不会注册覆盖，反倒是第二个 Eureka-Server 同步注册应用到第一个 Eureka-Server ，注册覆盖成功，因为 <code>lastDirtyTimestamp</code> ( 应用实例状态变更时，可以设置 <code>lastDirtyTimestamp</code> 为当前时间，见 <code>ApplicationInfoManager#setInstanceStatus(status)</code> 方法 )。</p><p>但是光靠<strong>注册</strong>请求判断 <code>lastDirtyTimestamp</code> 显然是不够的，因为网络异常情况下时，同步操作任务多次执行失败到达过期时间后，此时在 Eureka-Server 集群同步起到最终一致性<strong>最最最</strong>关键性出现了：Heartbeat 。因为 Heartbeat 会周期性的执行，通过它一方面可以判断 Eureka-Server 是否存在心跳对应的应用实例，另外一方面可以比较应用实例的 <code>lastDirtyTimestamp</code> 。当满足下面任意条件，Eureka-Server 返回 404 状态码：</p><ul><li>1）Eureka-Server 应用实例不存在，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/registry/AbstractInstanceRegistry.java#L438" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看触发条件代码位置。</li><li>2）Eureka-Server 应用实例状态为 <code>UNKNOWN</code>，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/registry/AbstractInstanceRegistry.java#L450" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看触发条件代码位置。为什么会是 <code>UNKNOWN</code> ，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/?self">《Eureka 源码解析 —— 应用实例注册发现（八）之覆盖状态》「 4.3 续租场景」</a> 有详细解析。</li><li>**3）**请求的 <code>lastDirtyTimestamp</code> 更大，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java#L306" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看触发条件代码位置。</li></ul><p>请求方接收到 404 状态码返回后，<strong>认为 Eureka-Server 应用实例实际是不存在的</strong>，重新发起应用实例的注册。以本文的 Heartbeat 为例子，代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// PeerEurekaNode#heartbeat(...)</span></div><div class="line">  <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line">  <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleFailure</span><span class="params">(<span class="keyword">int</span> statusCode, Object responseEntity)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">  <span class="number">3</span>:     <span class="keyword">super</span>.handleFailure(statusCode, responseEntity);</div><div class="line">  <span class="number">4</span>:     <span class="keyword">if</span> (statusCode == <span class="number">404</span>) &#123;</div><div class="line">  <span class="number">5</span>:         logger.warn(<span class="string">"&#123;&#125;: missing entry."</span>, getTaskName());</div><div class="line">  <span class="number">6</span>:         <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</div><div class="line">  <span class="number">7</span>:             logger.warn(<span class="string">"&#123;&#125;: cannot find instance id &#123;&#125; and hence replicating the instance with status &#123;&#125;"</span>,</div><div class="line">  <span class="number">8</span>:                     getTaskName(), info.getId(), info.getStatus());</div><div class="line">  <span class="number">9</span>:             register(info);</div><div class="line"> <span class="number">10</span>:         &#125;</div><div class="line"> <span class="number">11</span>:     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config.shouldSyncWhenTimestampDiffers()) &#123;</div><div class="line"> <span class="number">12</span>:         InstanceInfo peerInstanceInfo = (InstanceInfo) responseEntity;</div><div class="line"> <span class="number">13</span>:         <span class="keyword">if</span> (peerInstanceInfo != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">14</span>:             syncInstancesIfTimestampDiffers(appName, id, info, peerInstanceInfo);</div><div class="line"> <span class="number">15</span>:         &#125;</div><div class="line"> <span class="number">16</span>:     &#125;</div><div class="line"> <span class="number">17</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 4 至 10 行 ：接收到 404 状态码，调用 <code>#register(...)</code> 方法，向该被心跳同步操作失败的 Eureka-Server 发起注册<strong>本地的应用实例</strong>的请求。</p><ul><li>上述 <strong>3）</strong> ，会使用请求参数 <code>overriddenStatus</code> 存储到 Eureka-Server 的应用实例覆盖状态集合( <code>AbstractInstanceRegistry.overriddenInstanceStatusMap</code> )，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java#L123" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看触发条件代码位置。</li></ul></li><li><p>第 11 至 16 行 ：恰好是 <strong>3）</strong> 反过来的情况，本地的应用实例的 <code>lastDirtyTimestamp</code> 小于 Eureka-Server 该应用实例的，此时 Eureka-Server 返回 409 状态码，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java#L314" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看触发条件代码位置。调用 <code>#syncInstancesIfTimestampDiffers()</code> 方法，覆盖注册本地应用实例，点击 <a href="https://github.com/YunaiV/eureka/blob/7f868f9ca715a8862c0c10cac04e238bbf371db0/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java#L387" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看方法。</p></li></ul><p>OK，撒花！记住：Eureka 通过 Heartbeat 实现 Eureka-Server 集群同步的最终一致性。</p><h1>666. 彩蛋</h1><p>写的比较嗨皮，所以就送胖友一只胖友</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_08_07/04.png" alt=""></p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p><p>以下是草稿，可以凑合看</p><p>eureka server 集群假定是 s1 s2</p><p>1）client 向 s1 注册，有一个 lastDirtyTime ，正常情况下成功， s1 会向 s2 同步<br>2）client 向 s1 注册（成功，但是网络波动），然后 client 发生状态的变化，lastDirtyTime 变化，向 s2 注册。<br>这个时候，s1 s2 是冲突的，但是他们会互相同步，实际 s2 =&gt; s1 的注册会真正成功，s1 =&gt; s2 的注册不会返回失败，但是实际 s2 处理的时候，用的是自身的。</p><p>心跳只是最终去校验。</p><p>理论来说，心跳不应该带 lastDirtyTime 参数。带的原因就是为了做固定周期的比较。</p><p>最优解是 注册 就处理掉数据不一致<br>次优解是 心跳 处理掉数据不一致</p><p>如果在类比，</p><p>注册，相当于 insertOrUpdate<br>心跳，附加了校验是否要发起【注册】</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/Eureka/server-cluster/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 Eureka 1.8.X 版本&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a 
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 网络通信</title>
    <link href="http://www.iocoder.cn/Eureka/transport/"/>
    <id>http://www.iocoder.cn/Eureka/transport/</id>
    <published>2018-07-30T16:00:00.000Z</published>
    <updated>2017-10-18T15:23:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/Eureka/transport/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Eureka/transport/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/transport/">2. EurekaHttpClient</a><ul><li><a href="http://www.iocoder.cn/Eureka/transport/">2.1 EurekaJerseyClientImpl</a></li><li><a href="http://www.iocoder.cn/Eureka/transport/">2.2 EurekaJerseyClientBuilder</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/transport/">3. EurekaHttpClient</a><ul><li><a href="http://www.iocoder.cn/Eureka/transport/">3.1 EurekaHttpResponse</a></li><li><a href="http://www.iocoder.cn/Eureka/transport/">3.2 TransportClientFactory</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/transport/">4. AbstractJerseyEurekaHttpClient</a><ul><li><a href="http://www.iocoder.cn/Eureka/transport/">4.1 JerseyApplicationClient</a></li><li><a href="http://www.iocoder.cn/Eureka/transport/">4.2 JerseyReplicationClient</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/transport/">5. EurekaHttpClientDecorator</a><ul><li><a href="http://www.iocoder.cn/Eureka/transport/">5.1 MetricsCollectingEurekaHttpClient</a></li><li><a href="http://www.iocoder.cn/Eureka/transport/">5.2 RedirectingEurekaHttpClient</a></li><li><a href="http://www.iocoder.cn/Eureka/transport/">5.3 RetryableEurekaHttpClient</a></li><li><a href="http://www.iocoder.cn/Eureka/transport/">5.4 SessionedEurekaHttpClient</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/transport/">6. 创建网络通讯客户端</a></li><li><a href="http://www.iocoder.cn/Eureka/transport/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p>本文主要分享 <strong>Eureka 的网络通信部分</strong>。在不考虑 Eureka 2.x 的兼容的情况下，Eureka 1.x 主要两部分的网络通信：</p><ul><li>Eureka-Client 请求 Eureka-Server 的网络通信</li><li>Eureka-Server 集群内，Eureka-Server 请求 <strong>其它的Eureka-Server</strong> 的网络通信</li></ul><p>本文涉及类在 <code>com.netflix.discovery.shared.transport</code> 包下，涉及到主体类的类图如下( <a href="http://www.iocoder.cn/images/Eureka/2018_07_31/01.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_07_31/01.png" alt=""></p><ul><li>粉色部分 —— EurekaJerseyClient ，对基于 Jersey Server 的 Eureka-Server 的 Jersey 客户端封装。</li><li>绿色部分 —— EurekaHttpClient ，Eureka-Server HTTP 访问客户端，定义了具体的 Eureka-Server API 调用方法。如果把 DiscoveryClient 类比成 Service ，那么 EurekaHttpClient 可以类比城 Dao 。</li><li>综色部分 —— EurekaHttpClient 实现类，<strong>真正</strong>实现了具体的 Eureka-Server API 调用方法。</li><li>红色部分 —— EurekaHttpClient 委托类，提供了<strong>会话、重试、重定向、监控指标收集</strong>等特性。</li><li>黄色部分 —— EurekaHttpClientFactory，用于创建 EurekaHttpClient 。</li></ul><p>类图看起来很复杂，整体调用关系如下( <a href="http://www.iocoder.cn/images/Eureka/2018_07_31/02.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_07_31/02.png" alt=""></p><p>OK ，我们逐层解析，嗨起来。</p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1>2. EurekaHttpClient</h1><p><code>com.netflix.discovery.shared.transport.jersey.EurekaJerseyClient</code> ，EurekaHttpClient <strong>接口</strong>。接口代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EurekaJerseyClient</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function">ApacheHttpClient4 <span class="title">getClient</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroyResources</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><code>com.sun.jersey.client.apache4.ApacheHttpClient4</code> ，基于 Apache HttpClient4 实现的 Jersey Client 。</li></ul><h2>2.1 EurekaJerseyClientImpl</h2><p><code>com.netflix.discovery.shared.transport.jersey.EurekaJerseyClientImpl</code> ，EurekaHttpClient <strong>实现类</strong>。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaJerseyClientImpl</span> <span class="keyword">implements</span> <span class="title">EurekaJerseyClient</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 基于 Apache HttpClient4 实现的 Jersey Client</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApacheHttpClient4 apacheHttpClient;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Apache HttpClient 空闲连接清理器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApacheHttpClientConnectionCleaner apacheHttpClientConnectionCleaner;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Jersey Client 配置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    ClientConfig jerseyClientConfig;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EurekaJerseyClientImpl</span><span class="params">(<span class="keyword">int</span> connectionTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">final</span> <span class="keyword">int</span> connectionIdleTimeout,</span></span></div><div class="line"><span class="function"><span class="params">                                  ClientConfig clientConfig)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            jerseyClientConfig = clientConfig;</div><div class="line">            <span class="comment">// 创建  ApacheHttpClient</span></div><div class="line">            apacheHttpClient = ApacheHttpClient4.create(jerseyClientConfig);</div><div class="line"></div><div class="line">            <span class="comment">// 设置 连接参数</span></div><div class="line">            HttpParams params = apacheHttpClient.getClientHandler().getHttpClient().getParams();</div><div class="line">            HttpConnectionParams.setConnectionTimeout(params, connectionTimeout);</div><div class="line">            HttpConnectionParams.setSoTimeout(params, readTimeout);</div><div class="line"></div><div class="line">            <span class="comment">// 创建 ApacheHttpClientConnectionCleaner</span></div><div class="line">            <span class="keyword">this</span>.apacheHttpClientConnectionCleaner = <span class="keyword">new</span> ApacheHttpClientConnectionCleaner(apacheHttpClient, connectionIdleTimeout);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create Jersey client"</span>, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ApacheHttpClient4 <span class="title">getClient</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> apacheHttpClient;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyResources</span><span class="params">()</span> </span>&#123;</div><div class="line">        apacheHttpClientConnectionCleaner.shutdown();</div><div class="line">        apacheHttpClient.destroy();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><code>com.netflix.discovery.shared.transport.jersey.ApacheHttpClientConnectionCleaner</code> ，Apache HttpClient 空闲连接清理器，负责<strong>周期性</strong>关闭处于 <code>half-close</code> 状态的空闲连接。点击 <a href="https://github.com/YunaiV/eureka/blob/045686e7461ddac93384161eb342e89c3249dc69/eureka-client/src/main/java/com/netflix/discovery/shared/transport/jersey/ApacheHttpClientConnectionCleaner.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看带中文注释的 ApacheHttpClientConnectionCleaner。推荐阅读：<a href="http://seanhe.iteye.com/blog/234759" rel="external nofollow noopener noreferrer" target="_blank">《HttpClient容易忽视的细节——连接关闭》</a> 。</li></ul><h2>2.2 EurekaJerseyClientBuilder</h2><p>EurekaJerseyClientBuilder ，EurekaJerseyClientImpl <strong>内部类</strong>，用于创建 EurekaJerseyClientImpl 。</p><p>调用 <code>#build()</code> 方法，创建 EurekaJerseyClientImpl ，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// EurekaJerseyClientBuilder.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> EurekaJerseyClient <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">    MyDefaultApacheHttpClient4Config config = <span class="keyword">new</span> MyDefaultApacheHttpClient4Config();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EurekaJerseyClientImpl(connectionTimeout, readTimeout, connectionIdleTimeout, config);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create Jersey client "</span>, e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>MyDefaultApacheHttpClient4Config ，继承自 <code>com.sun.jersey.client.apache4.config.DefaultApacheHttpClient4Config</code> ，实现<strong>自定义配置</strong>。点击 <a href="https://github.com/YunaiV/eureka/blob/045686e7461ddac93384161eb342e89c3249dc69/eureka-client/src/main/java/com/netflix/discovery/shared/transport/jersey/EurekaJerseyClientImpl.java#L199" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看带中文注释的 MyDefaultApacheHttpClient4Config。例如 ：<ul><li>自定义的<strong>请求、响应的编解码器</strong> <code>com.netflix.discovery.provider.DiscoveryJerseyProvider</code> 。</li><li>禁用<strong>重定向</strong>，使用 RedirectingEurekaHttpClient 实现该特性。</li><li>自定义 UserAgent 。</li><li>自定义 Http Proxy 。</li><li>SSL 功能的增强。ApacheHttpClient4 使用的是 Apache HttpClient 4.1.1 版本，<code>com.netflix.discovery.shared.transport.jersey.SSLSocketFactoryAdapter</code> 将 Apache HttpClient 4.3.4 对 SSL 功能的增强适配到老版本 API 。点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-client/src/main/java/com/netflix/discovery/shared/transport/jersey/SSLSocketFactoryAdapter.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看带中文注释的 SSLSocketFactoryAdapter。</li></ul></li></ul><h1>3. EurekaHttpClient</h1><p><code>com.netflix.discovery.shared.transport.EurekaHttpClient</code> ，Eureka-Server HTTP 访问客户端，定义了具体的 Eureka-Server API 调用方法 。点击 <a href="https://github.com/YunaiV/eureka/blob/045686e7461ddac93384161eb342e89c3249dc69/eureka-client/src/main/java/com/netflix/discovery/shared/transport/EurekaHttpClient.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看带中文注释的 EurekaHttpClient。</p><h2>3.1 EurekaHttpResponse</h2><p><code>com.netflix.discovery.shared.transport.EurekaHttpResponse</code> ，请求响应对象，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaHttpResponse</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 返回状态码</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> statusCode;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 返回对象( Entity )</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T entity;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 返回 header</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; headers;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 重定向地址</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URI location;</div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略 setting / getting 和 Builder</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2>3.2 TransportClientFactory</h2><p><code>com.netflix.discovery.shared.transport.TransportClientFactory</code> ，创建 EurekaHttpClient 的工厂<strong>接口</strong>。接口代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransportClientFactory</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 创建 EurekaHttpClient</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> serviceUrl Eureka-Server 地址</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> EurekaHttpClient</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">EurekaHttpClient <span class="title">newClient</span><span class="params">(EurekaEndpoint serviceUrl)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 关闭工厂</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>大多数 EurekaHttpClient 实现类都有其对应的工厂实现类</strong>。</p><h1>4. AbstractJerseyEurekaHttpClient</h1><p><code>com.netflix.discovery.shared.transport.jersey.AbstractJerseyEurekaHttpClient</code> ，实现 EurekaHttpClient 的<strong>抽象类</strong>，<strong>真正</strong>实现了具体的 Eureka-Server API 调用方法。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractJerseyEurekaHttpClient</span> <span class="keyword">implements</span> <span class="title">EurekaHttpClient</span> </span>&#123;</div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>: <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AbstractJerseyEurekaHttpClient.class);</div><div class="line"> <span class="number">4</span>: </div><div class="line"> <span class="number">5</span>: <span class="comment">/**</span></div><div class="line"><span class="comment"> 6:  * Jersey Client</span></div><div class="line"><span class="comment"> 7:  */</span></div><div class="line"> <span class="number">8</span>: <span class="keyword">protected</span> <span class="keyword">final</span> Client jerseyClient;</div><div class="line"> <span class="number">9</span>: <span class="comment">/**</span></div><div class="line"><span class="comment">10:  * 请求的 Eureka-Server 地址</span></div><div class="line"><span class="comment">11:  */</span></div><div class="line"><span class="number">12</span>: <span class="keyword">protected</span> <span class="keyword">final</span> String serviceUrl;</div><div class="line"><span class="number">13</span>: </div><div class="line"><span class="number">14</span>: <span class="function"><span class="keyword">protected</span> <span class="title">AbstractJerseyEurekaHttpClient</span><span class="params">(Client jerseyClient, String serviceUrl)</span> </span>&#123;</div><div class="line"><span class="number">15</span>:     <span class="keyword">this</span>.jerseyClient = jerseyClient;</div><div class="line"><span class="number">16</span>:     <span class="keyword">this</span>.serviceUrl = serviceUrl;</div><div class="line"><span class="number">17</span>:     logger.debug(<span class="string">"Created client for url: &#123;&#125;"</span>, serviceUrl);</div><div class="line"><span class="number">18</span>: &#125;</div><div class="line"><span class="number">19</span>: </div><div class="line"><span class="number">20</span>: <span class="meta">@Override</span></div><div class="line"><span class="number">21</span>: <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">register</span><span class="params">(InstanceInfo info)</span> </span>&#123;</div><div class="line"><span class="number">22</span>:     <span class="comment">// 设置 请求地址</span></div><div class="line"><span class="number">23</span>:     String urlPath = <span class="string">"apps/"</span> + info.getAppName();</div><div class="line"><span class="number">24</span>:     ClientResponse response = <span class="keyword">null</span>;</div><div class="line"><span class="number">25</span>:     <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">26</span>:         Builder resourceBuilder = jerseyClient.resource(serviceUrl).path(urlPath).getRequestBuilder();</div><div class="line"><span class="number">27</span>:         <span class="comment">// 设置 请求头</span></div><div class="line"><span class="number">28</span>:         addExtraHeaders(resourceBuilder);</div><div class="line"><span class="number">29</span>:         <span class="comment">// 请求 Eureka-Server</span></div><div class="line"><span class="number">30</span>:         response = resourceBuilder</div><div class="line"><span class="number">31</span>:                 .header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>) <span class="comment">// GZIP</span></div><div class="line"><span class="number">32</span>:                 .type(MediaType.APPLICATION_JSON_TYPE) <span class="comment">// 请求参数格式 JSON</span></div><div class="line"><span class="number">33</span>:                 .accept(MediaType.APPLICATION_JSON) <span class="comment">// 响应结果格式 JSON</span></div><div class="line"><span class="number">34</span>:                 .post(ClientResponse.class, info); <span class="comment">// 请求参数</span></div><div class="line"><span class="number">35</span>:         <span class="comment">// 创建 EurekaHttpResponse</span></div><div class="line"><span class="number">36</span>:         <span class="keyword">return</span> anEurekaHttpResponse(response.getStatus()).headers(headersOf(response)).build();</div><div class="line"><span class="number">37</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">38</span>:         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line"><span class="number">39</span>:             logger.debug(<span class="string">"Jersey HTTP POST &#123;&#125;/&#123;&#125; with instance &#123;&#125;; statusCode=&#123;&#125;"</span>, serviceUrl, urlPath, info.getId(),</div><div class="line"><span class="number">40</span>:                     response == <span class="keyword">null</span> ? <span class="string">"N/A"</span> : response.getStatus());</div><div class="line"><span class="number">41</span>:         &#125;</div><div class="line"><span class="number">42</span>:         <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">43</span>:             response.close();</div><div class="line"><span class="number">44</span>:         &#125;</div><div class="line"><span class="number">45</span>:     &#125;</div><div class="line"><span class="number">46</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><code>jerseyClient</code> 属性，Jersey Client ，使用上文的 <code>EurekaHttpClient#getClient(...)</code> 方法，获取 ApacheHttpClient4 。</li><li><code>serviceUrl</code> 属性，请求的 Eureka-Server 地址。</li><li><code>#register()</code> 方法，实现向 Eureka-Server 注册应用实例。<strong>其他方法代码类似</strong>。<ul><li><p>第 22 至 26 行 ：设置请求地址。</p></li><li><p>第 28 行 ：调用 <code>#addExtraHeaders(...)</code> 方法，设置请求头( header  )。该方法是<strong>抽象方法</strong>，提供子类实现自定义的请求头。代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addExtraHeaders</span><span class="params">(Builder webResource)</span></span>;</div></pre></td></tr></table></figure></p><ul><li>x</li></ul></li><li><p>第 29 至 34 行 ：请求 Eureka-Server 。</p></li><li><p>第 35 至 36 行 ：解析响应结果，创建 EurekaHttpResponse 。</p></li></ul></li></ul><h2>4.1 JerseyApplicationClient</h2><p><code>com.netflix.discovery.shared.transport.jersey.JerseyApplicationClient</code> ，实现 Eureka-Client 请求 Eureka-Server 的网络通信。点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-client/src/main/java/com/netflix/discovery/shared/transport/jersey/JerseyApplicationClient.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看带中文注释的 JerseyApplicationClient。</p><h3>4.1.1 JerseyEurekaHttpClientFactory</h3><p><code>com.netflix.discovery.shared.transport.jersey.JerseyEurekaHttpClientFactory</code> ，创建 JerseyApplicationClient 的<strong>工厂类</strong>。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JerseyEurekaHttpClientFactory</span> <span class="keyword">implements</span> <span class="title">TransportClientFactory</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EurekaJerseyClient jerseyClient;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApacheHttpClient4 apacheClient;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApacheHttpClientConnectionCleaner cleaner;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; additionalHeaders;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JerseyEurekaHttpClientFactory</span><span class="params">(ApacheHttpClient4 apacheClient, <span class="keyword">long</span> connectionIdleTimeout, Map&lt;String, String&gt; additionalHeaders)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, apacheClient, connectionIdleTimeout, additionalHeaders);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JerseyEurekaHttpClientFactory</span><span class="params">(EurekaJerseyClient jerseyClient,</span></span></div><div class="line"><span class="function"><span class="params">                                          ApacheHttpClient4 apacheClient,</span></span></div><div class="line"><span class="function"><span class="params">                                          <span class="keyword">long</span> connectionIdleTimeout,</span></span></div><div class="line"><span class="function"><span class="params">                                          Map&lt;String, String&gt; additionalHeaders)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.jerseyClient = jerseyClient;</div><div class="line">        <span class="keyword">this</span>.apacheClient = jerseyClient != <span class="keyword">null</span> ? jerseyClient.getClient() : apacheClient;</div><div class="line">        <span class="keyword">this</span>.additionalHeaders = additionalHeaders;</div><div class="line">        <span class="keyword">this</span>.cleaner = <span class="keyword">new</span> ApacheHttpClientConnectionCleaner(<span class="keyword">this</span>.apacheClient, connectionIdleTimeout);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> EurekaHttpClient <span class="title">newClient</span><span class="params">(EurekaEndpoint endpoint)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JerseyApplicationClient(apacheClient, endpoint.getServiceUrl(), additionalHeaders);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line">        cleaner.shutdown();</div><div class="line">        <span class="keyword">if</span> (jerseyClient != <span class="keyword">null</span>) &#123;</div><div class="line">            jerseyClient.destroyResources();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            apacheClient.destroy();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3>4.1.2 JerseyEurekaHttpClientFactoryBuilder</h3><p>JerseyEurekaHttpClientFactoryBuilder ，JerseyEurekaHttpClientFactory <strong>内部类</strong>，用于创建 JerseyEurekaHttpClientFactory 。点击 <a href="https://github.com/YunaiV/eureka/blob/ff48fa728c7085ad8116517ede88398b0fd693c7/eureka-client/src/main/java/com/netflix/discovery/shared/transport/jersey/JerseyEurekaHttpClientFactory.java#L152" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看带中文注释的 JerseyEurekaHttpClientFactory。</p><p>调用 <code>JerseyEurekaHttpClientFactory#create(...)</code> 方法，创建 JerseyEurekaHttpClientFactory ，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JerseyEurekaHttpClientFactory <span class="title">create</span><span class="params">(EurekaClientConfig clientConfig,</span></span></div><div class="line"><span class="function"><span class="params">                                                  Collection&lt;ClientFilter&gt; additionalFilters,</span></span></div><div class="line"><span class="function"><span class="params">                                                  InstanceInfo myInstanceInfo,</span></span></div><div class="line"><span class="function"><span class="params">                                                  AbstractEurekaIdentity clientIdentity)</span> </span>&#123;</div><div class="line">   JerseyEurekaHttpClientFactoryBuilder clientBuilder = newBuilder()</div><div class="line">           .withAdditionalFilters(additionalFilters) <span class="comment">// 客户端附加过滤器</span></div><div class="line">           .withMyInstanceInfo(myInstanceInfo) <span class="comment">// 应用实例</span></div><div class="line">           .withUserAgent(<span class="string">"Java-EurekaClient"</span>) <span class="comment">// UA</span></div><div class="line">           .withClientConfig(clientConfig)</div><div class="line">           .withClientIdentity(clientIdentity);</div><div class="line"></div><div class="line">   <span class="comment">// 设置 Client Name</span></div><div class="line">   <span class="keyword">if</span> (<span class="string">"true"</span>.equals(System.getProperty(<span class="string">"com.netflix.eureka.shouldSSLConnectionsUseSystemSocketFactory"</span>))) &#123;</div><div class="line">       clientBuilder.withClientName(<span class="string">"DiscoveryClient-HTTPClient-System"</span>).withSystemSSLConfiguration();</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clientConfig.getProxyHost() != <span class="keyword">null</span> &amp;&amp; clientConfig.getProxyPort() != <span class="keyword">null</span>) &#123;</div><div class="line">       clientBuilder.withClientName(<span class="string">"Proxy-DiscoveryClient-HTTPClient"</span>)</div><div class="line">               .withProxy(</div><div class="line">                       clientConfig.getProxyHost(), Integer.parseInt(clientConfig.getProxyPort()),</div><div class="line">                       clientConfig.getProxyUserName(), clientConfig.getProxyPassword()</div><div class="line">               ); <span class="comment">// http proxy</span></div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       clientBuilder.withClientName(<span class="string">"DiscoveryClient-HTTPClient"</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">return</span> clientBuilder.build();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JerseyEurekaHttpClientFactoryBuilder <span class="title">newBuilder</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> JerseyEurekaHttpClientFactoryBuilder().withExperimental(<span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2>4.2 JerseyReplicationClient</h2><p><code>com.netflix.eureka.transport.JerseyReplicationClient</code> ，Eureka-Server 集群内，Eureka-Server 请求 <strong>其它的Eureka-Server</strong> 的网络通信。</p><ul><li><p>实现 <code>AbstractJerseyEurekaHttpClient#addExtraHeaders()</code> 方法，添加自定义头 <code>x-netflix-discovery-replication=true</code> ，代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addExtraHeaders</span><span class="params">(Builder webResource)</span> </span>&#123;</div><div class="line">   webResource.header(PeerEurekaNode.HEADER_REPLICATION, <span class="string">"true"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li><li><p>重写了 <code>#sendHeartBeat(...)</code> 方法，在 <a href="http://www.iocoder.cn/Eureka/server-cluster/?self">《Eureka 源码解析 —— Eureka-Server 集群同步》</a> 有详细解析。</p></li><li><p>实现 <code>com.netflix.eureka.cluster.HttpReplicationClient</code> 接口，实现了 <code>#submitBatchUpdates(...)</code> 方法，在 <a href="http://www.iocoder.cn/Eureka/server-cluster/?self">《Eureka 源码解析 —— Eureka-Server 集群同步》</a> 有详细解析。</p></li></ul><h3>4.2.1 没有工厂</h3><p>JerseyReplicationClient <strong>没有专属的工厂</strong>。</p><p>调用 <code>JerseyReplicationClient#createReplicationClient(...)</code> <strong>静态方法</strong>，创建 JerseyReplicationClient 。点击 <a href="https://github.com/YunaiV/eureka/blob/94a4a1ebd35a3350893369a05757c01b2534b702/eureka-core/src/main/java/com/netflix/eureka/transport/JerseyReplicationClient.java#L135" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看带中文注释的方法代码。</p><h1>5. EurekaHttpClientDecorator</h1><p><code>com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator</code>，EurekaHttpClient 委托者<strong>抽象类</strong>。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaHttpClientDecorator</span> <span class="keyword">implements</span> <span class="title">EurekaHttpClient</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 执行请求</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> requestExecutor 请求执行器</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;R&gt; 请求泛型</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 响应</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;R&gt; <span class="function">EurekaHttpResponse&lt;R&gt; <span class="title">execute</span><span class="params">(RequestExecutor&lt;R&gt; requestExecutor)</span></span>;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">register</span><span class="params">(<span class="keyword">final</span> InstanceInfo info)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> execute(<span class="keyword">new</span> RequestExecutor&lt;Void&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">execute</span><span class="params">(EurekaHttpClient delegate)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> delegate.register(info);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> RequestType <span class="title">getRequestType</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> RequestType.Register;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p><code>#execute(...)</code> <strong>抽象方法</strong>，子类实现该方法，实现自己的特性。</p></li><li><p><code>#register()</code> 方法，实现向 Eureka-Server 注册应用实例。<strong>其他方法代码类似</strong>。</p><ul><li>调用 <code>#execute(...)</code> 方法，并将原有的注册实现通过 RequestExecutor 传递进去。</li><li>子类在实现的 <code>#execute(...)</code> 方法，可以调用 <code>RequestExecutor#execute(...)</code> 方法，继续执行原有逻辑。</li><li>参考设计模式：<a href="http://blog.csdn.net/hguisu/article/details/7564039" rel="external nofollow noopener noreferrer" target="_blank">《设计模式 ( 十九 ) 模板方法模式Template method（类行为型）》</a> 。</li></ul></li><li><p>RequestType ，请求类型<strong>枚举类</strong>。代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// EurekaHttpClientDecorator.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RequestType &#123;</div><div class="line">   Register,</div><div class="line">   Cancel,</div><div class="line">   SendHeartBeat,</div><div class="line">   StatusUpdate,</div><div class="line">   DeleteStatusOverride,</div><div class="line">   GetApplications,</div><div class="line">   GetDelta,</div><div class="line">   GetVip,</div><div class="line">   GetSecureVip,</div><div class="line">   GetApplication,</div><div class="line">   GetInstance,</div><div class="line">   GetApplicationInstance</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li><li><p>RequestExecutor ，请求执行器<strong>接口</strong>。接口代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// EurekaHttpClientDecorator.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RequestExecutor</span>&lt;<span class="title">R</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 执行请求</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> delegate 委托的 EurekaHttpClient</span></div><div class="line"><span class="comment">    * <span class="doctag">@return</span> 响应</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="function">EurekaHttpResponse&lt;R&gt; <span class="title">execute</span><span class="params">(EurekaHttpClient delegate)</span></span>;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * <span class="doctag">@return</span> 请求类型</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="function">RequestType <span class="title">getRequestType</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li></ul><hr><p>EurekaHttpClientDecorator 的<strong>每个实现类实现一个特性</strong>，代码非常非常非常清晰。</p><blockquote><p>FROM <a href="https://zh.wikipedia.org/wiki/%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F" rel="external nofollow noopener noreferrer" target="_blank">《委托模式》</a><br>委托模式是软件设计模式中的一项基本技巧。在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。委托模式是一项基本技巧，许多其他的模式，如状态模式、策略模式、访问者模式本质上是在更特殊的场合采用了委托模式。委托模式使得我们可以用聚合来替代继承，它还使我们可以模拟mixin。</p></blockquote><p>我们在上图的基础上，<strong>增加委托的关系</strong>，如下图( <a href="http://www.iocoder.cn/images/Eureka/2018_07_31/03.jpeg">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_07_31/03.jpeg" alt=""></p><ul><li>请注意，每个委托着实现类，上面可能有类型为 EurekaHttpClientFactory 的属性，用于创建其委托的 EurekaHttpClient 。<strong>为什么会有 Factory</strong> ？例如，RetryableEurekaHttpClient 重试请求多个 Eureka-Server 地址时，每个 Eureka-Server 地址会创建一个 EurekaHttpClient 。所以，下文涉及到 EurekaHttpClientFactory 和<strong>委托的</strong> EurekaHttpClient 的地方，你都需要仔细理解。</li></ul><h2>5.1 MetricsCollectingEurekaHttpClient</h2><p><code>com.netflix.discovery.shared.transport.decorator.MetricsCollectingEurekaHttpClient</code> ，监控指标收集 EurekaHttpClient ，配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集。</p><p><code>#execute()</code> 方法，代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="keyword">protected</span> &lt;R&gt; <span class="function">EurekaHttpResponse&lt;R&gt; <span class="title">execute</span><span class="params">(RequestExecutor&lt;R&gt; requestExecutor)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="comment">// 获得 请求类型 的 请求指标</span></div><div class="line"> <span class="number">4</span>:     EurekaHttpClientRequestMetrics requestMetrics = metricsByRequestType.get(requestExecutor.getRequestType());</div><div class="line"> <span class="number">5</span>:     Stopwatch stopwatch = requestMetrics.latencyTimer.start();</div><div class="line"> <span class="number">6</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">7</span>:         <span class="comment">// 执行请求</span></div><div class="line"> <span class="number">8</span>:         EurekaHttpResponse&lt;R&gt; httpResponse = requestExecutor.execute(delegate);</div><div class="line"> <span class="number">9</span>:         <span class="comment">// 增加 请求指标</span></div><div class="line"><span class="number">10</span>:         requestMetrics.countersByStatus.get(mappedStatus(httpResponse)).increment();</div><div class="line"><span class="number">11</span>:         <span class="keyword">return</span> httpResponse;</div><div class="line"><span class="number">12</span>:     &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"><span class="number">13</span>:         requestMetrics.connectionErrors.increment();</div><div class="line"><span class="number">14</span>:         exceptionsMetric.count(e);</div><div class="line"><span class="number">15</span>:         <span class="keyword">throw</span> e;</div><div class="line"><span class="number">16</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">17</span>:         stopwatch.stop();</div><div class="line"><span class="number">18</span>:     &#125;</div><div class="line"><span class="number">19</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 10 行 ：调用 <code>RequestExecutor#execute(...)</code> 方法，继续执行请求。<ul><li><code>delegate</code> 属性，对应 JerseyApplicationClient 。</li></ul></li></ul><h2>5.2 RedirectingEurekaHttpClient</h2><p><code>com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient</code> ，<strong>寻找非 302 重定向</strong>的 Eureka-Server 的 EurekaHttpClient 。</p><p><code>#execute()</code> 方法，代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="keyword">protected</span> &lt;R&gt; <span class="function">EurekaHttpResponse&lt;R&gt; <span class="title">execute</span><span class="params">(RequestExecutor&lt;R&gt; requestExecutor)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     EurekaHttpClient currentEurekaClient = delegateRef.get();</div><div class="line"> <span class="number">4</span>:     <span class="keyword">if</span> (currentEurekaClient == <span class="keyword">null</span>) &#123; <span class="comment">// 未找到非 302 的 Eureka-Server</span></div><div class="line"> <span class="number">5</span>:         AtomicReference&lt;EurekaHttpClient&gt; currentEurekaClientRef = <span class="keyword">new</span> AtomicReference&lt;&gt;(factory.newClient(serviceEndpoint));</div><div class="line"> <span class="number">6</span>:         <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">7</span>:             EurekaHttpResponse&lt;R&gt; response = executeOnNewServer(requestExecutor, currentEurekaClientRef);</div><div class="line"> <span class="number">8</span>:             <span class="comment">// 关闭原有的委托 EurekaHttpClient ，并设置当前成功非 302 请求的 EurekaHttpClient</span></div><div class="line"> <span class="number">9</span>:             TransportUtils.shutdown(delegateRef.getAndSet(currentEurekaClientRef.get()));</div><div class="line"><span class="number">10</span>:             <span class="keyword">return</span> response;</div><div class="line"><span class="number">11</span>:         &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"><span class="number">12</span>:             logger.error(<span class="string">"Request execution error"</span>, e);</div><div class="line"><span class="number">13</span>:             TransportUtils.shutdown(currentEurekaClientRef.get());</div><div class="line"><span class="number">14</span>:             <span class="keyword">throw</span> e;</div><div class="line"><span class="number">15</span>:         &#125;</div><div class="line"><span class="number">16</span>:     &#125; <span class="keyword">else</span> &#123; <span class="comment">// 已经找到非 302 的 Eureka-Server</span></div><div class="line"><span class="number">17</span>:         <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">18</span>:             <span class="keyword">return</span> requestExecutor.execute(currentEurekaClient);</div><div class="line"><span class="number">19</span>:         &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"><span class="number">20</span>:             logger.error(<span class="string">"Request execution error"</span>, e);</div><div class="line"><span class="number">21</span>:             delegateRef.compareAndSet(currentEurekaClient, <span class="keyword">null</span>);</div><div class="line"><span class="number">22</span>:             currentEurekaClient.shutdown();</div><div class="line"><span class="number">23</span>:             <span class="keyword">throw</span> e;</div><div class="line"><span class="number">24</span>:         &#125;</div><div class="line"><span class="number">25</span>:     &#125;</div><div class="line"><span class="number">26</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><strong>注意</strong>：和我们理解的常规的 302 状态返回处理不同！！！</li><li>整个分成两部分：【第 4 至 15 行】、【第 16 至 24 行】。<ul><li>前者，意味着未找到非返回 302 状态码的 Eureka-Server ，此时通过在原始传递进来的 <code>serviceUrls</code> 执行请求，寻找非 302 状态码返回的 Eureka-Server。<ul><li>当返回非 302 状态码时，找到非返回 302 状态码的 Eureka-Server 。</li><li>当返回 302 状态码时，向新的重定向的 Eureka-Server 执行请求直到成功找到或超过最大次数。</li></ul></li><li>后者，意味着当前已经找到非返回 302 状态码的 Eureka-Server ，直接执行请求。<strong>注意</strong> ：此时 Eureka-Server 再返回 302 状态码，不再处理。</li><li>目前 Eureka 1.x 的 Eureka-Server 不存在返回 302 状态码，猜测和 Eureka 2.X TODO[0028]：写入集群和读取集群 有关。</li></ul></li><li>【前者】第 5 行 ：使用初始的 <code>serviceEndpoint</code> ( 相当于 <code>serviceUrls</code> ) 创建<strong>委托</strong> EurekaHttpClient 。</li><li>【前者】第 7 行 ：调用 <code>#executeOnNewServer(...)</code> 方法，通过执行请求的方式，寻找非 302 状态码返回的 Eureka-Server。实现代码，点击 <a href="https://github.com/YunaiV/eureka/blob/ed9a4241e60e3b558f939754f71188d3063771e2/eureka-client/src/main/java/com/netflix/discovery/shared/transport/decorator/RedirectingEurekaHttpClient.java#L111" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看带中文注释的代码实现。</li><li>【前者】【前者】第 9 行 ：关闭原有的 <code>delegateRef</code> ( 因为此处可能存在并发，多个线程都找到非 302 状态码返回的 Eureka-Server )，并设置当前成功非 302 请求的 EurekaHttpClient 到 <code>delegateRef</code>。</li><li>【前者】第 13 行 ：关闭 <code>currentEurekaClientRef</code> ，当请求发生异常或者超过最大重定向次数。</li><li>【后者】第 18 行 ：意味着当前已经找到非返回 302 状态码的 Eureka-Server ，直接执行请求。</li><li>【后者】第 21 至 22 行 ：执行请求发生异常，关闭 <code>currentEurekaClient</code> ，后面要重新非返回 302 状态码的 Eureka-Server 。</li></ul><h3>5.2.1 工厂</h3><p>RedirectingEurekaHttpClient 提供 <code>#createFactory(...)</code> <strong>静态方法</strong>获得创建其的工厂，点击 <a href="https://github.com/YunaiV/eureka/blob/ed9a4241e60e3b558f939754f71188d3063771e2/eureka-client/src/main/java/com/netflix/discovery/shared/transport/decorator/RedirectingEurekaHttpClient.java#L96" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看。</p><h2>5.3 RetryableEurekaHttpClient</h2><p><code>com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient</code> ，支持向多个 Eureka-Server 请求重试的 EurekaHttpClient 。</p><p><code>#execute()</code> 方法，代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="keyword">protected</span> &lt;R&gt; <span class="function">EurekaHttpResponse&lt;R&gt; <span class="title">execute</span><span class="params">(RequestExecutor&lt;R&gt; requestExecutor)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     List&lt;EurekaEndpoint&gt; candidateHosts = <span class="keyword">null</span>;</div><div class="line"> <span class="number">4</span>:     <span class="keyword">int</span> endpointIdx = <span class="number">0</span>;</div><div class="line"> <span class="number">5</span>:     <span class="keyword">for</span> (<span class="keyword">int</span> retry = <span class="number">0</span>; retry &lt; numberOfRetries; retry++) &#123;</div><div class="line"> <span class="number">6</span>:         EurekaHttpClient currentHttpClient = delegate.get();</div><div class="line"> <span class="number">7</span>:         EurekaEndpoint currentEndpoint = <span class="keyword">null</span>;</div><div class="line"> <span class="number">8</span>: </div><div class="line"> <span class="number">9</span>:         <span class="comment">// 当前委托的 EurekaHttpClient 不存在</span></div><div class="line"><span class="number">10</span>:         <span class="keyword">if</span> (currentHttpClient == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">11</span>:             <span class="comment">// 获得候选的 Eureka-Server 地址数组</span></div><div class="line"><span class="number">12</span>:             <span class="keyword">if</span> (candidateHosts == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">13</span>:                 candidateHosts = getHostCandidates();</div><div class="line"><span class="number">14</span>:                 <span class="keyword">if</span> (candidateHosts.isEmpty()) &#123;</div><div class="line"><span class="number">15</span>:                     <span class="keyword">throw</span> <span class="keyword">new</span> TransportException(<span class="string">"There is no known eureka server; cluster server list is empty"</span>);</div><div class="line"><span class="number">16</span>:                 &#125;</div><div class="line"><span class="number">17</span>:             &#125;</div><div class="line"><span class="number">18</span>: </div><div class="line"><span class="number">19</span>:             <span class="comment">// 超过候选的 Eureka-Server 地址数组上限</span></div><div class="line"><span class="number">20</span>:             <span class="keyword">if</span> (endpointIdx &gt;= candidateHosts.size()) &#123;</div><div class="line"><span class="number">21</span>:                 <span class="keyword">throw</span> <span class="keyword">new</span> TransportException(<span class="string">"Cannot execute request on any known server"</span>);</div><div class="line"><span class="number">22</span>:             &#125;</div><div class="line"><span class="number">23</span>: </div><div class="line"><span class="number">24</span>:             <span class="comment">// 创建候选的 EurekaHttpClient</span></div><div class="line"><span class="number">25</span>:             currentEndpoint = candidateHosts.get(endpointIdx++);</div><div class="line"><span class="number">26</span>:             currentHttpClient = clientFactory.newClient(currentEndpoint);</div><div class="line"><span class="number">27</span>:         &#125;</div><div class="line"><span class="number">28</span>: </div><div class="line"><span class="number">29</span>:         <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">30</span>:             <span class="comment">// 执行请求</span></div><div class="line"><span class="number">31</span>:             EurekaHttpResponse&lt;R&gt; response = requestExecutor.execute(currentHttpClient);</div><div class="line"><span class="number">32</span>:             <span class="comment">// 判断是否为可接受的相应，若是，返回。</span></div><div class="line"><span class="number">33</span>:             <span class="keyword">if</span> (serverStatusEvaluator.accept(response.getStatusCode(), requestExecutor.getRequestType())) &#123;</div><div class="line"><span class="number">34</span>:                 delegate.set(currentHttpClient);</div><div class="line"><span class="number">35</span>:                 <span class="keyword">if</span> (retry &gt; <span class="number">0</span>) &#123;</div><div class="line"><span class="number">36</span>:                     logger.info(<span class="string">"Request execution succeeded on retry #&#123;&#125;"</span>, retry);</div><div class="line"><span class="number">37</span>:                 &#125;</div><div class="line"><span class="number">38</span>:                 <span class="keyword">return</span> response;</div><div class="line"><span class="number">39</span>:             &#125;</div><div class="line"><span class="number">40</span>:             logger.warn(<span class="string">"Request execution failure with status code &#123;&#125;; retrying on another server if available"</span>, response.getStatusCode());</div><div class="line"><span class="number">41</span>:         &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"><span class="number">42</span>:             logger.warn(<span class="string">"Request execution failed with message: &#123;&#125;"</span>, e.getMessage());  <span class="comment">// just log message as the underlying client should log the stacktrace</span></div><div class="line"><span class="number">43</span>:         &#125;</div><div class="line"><span class="number">44</span>: </div><div class="line"><span class="number">45</span>:         <span class="comment">// 请求失败，若是 currentHttpClient ，清除 delegate</span></div><div class="line"><span class="number">46</span>:         <span class="comment">// Connection error or 5xx from the server that must be retried on another server</span></div><div class="line"><span class="number">47</span>:         delegate.compareAndSet(currentHttpClient, <span class="keyword">null</span>);</div><div class="line"><span class="number">48</span>: </div><div class="line"><span class="number">49</span>:         <span class="comment">// 请求失败，将 currentEndpoint 添加到隔离集合</span></div><div class="line"><span class="number">50</span>:         <span class="keyword">if</span> (currentEndpoint != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">51</span>:             quarantineSet.add(currentEndpoint);</div><div class="line"><span class="number">52</span>:         &#125;</div><div class="line"><span class="number">53</span>:     &#125;</div><div class="line"><span class="number">54</span>:     <span class="keyword">throw</span> <span class="keyword">new</span> TransportException(<span class="string">"Retry limit reached; giving up on completing the request"</span>);</div><div class="line"><span class="number">55</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 10 行 ：当前 <code>currentHttpClient</code> 不存在，意味着原有 <code>delegate</code> 不存在向 Eureka-Server 成功请求的 EurekaHttpClient 。</p><ul><li>此时需要从配置中的 Eureka-Server 数组重试请求，获得可以请求的 Eureka-Server 。</li><li>如果已经存在请求成功的 <code>delegate</code> ，直接使用它进行执行请求。</li></ul></li><li><p>第 11 至 17 行 ：调用 <code>#getHostCandidates()</code> 方法，获得候选的 Eureka-Server <code>serviceUrls</code> 数组。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> List&lt;EurekaEndpoint&gt; <span class="title">getHostCandidates</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// 获得候选的 Eureka-Server 地址数组</span></div><div class="line"> <span class="number">3</span>:     List&lt;EurekaEndpoint&gt; candidateHosts = clusterResolver.getClusterEndpoints();</div><div class="line"> <span class="number">4</span>: </div><div class="line"> <span class="number">5</span>:     <span class="comment">// 保留交集（移除 quarantineSet 不在 candidateHosts 的元素）</span></div><div class="line"> <span class="number">6</span>:     quarantineSet.retainAll(candidateHosts);</div><div class="line"> <span class="number">7</span>: </div><div class="line"> <span class="number">8</span>:     <span class="comment">// 在保证最小可用的候选的 Eureka-Server 地址数组，移除在隔离集合内的元素</span></div><div class="line"> <span class="number">9</span>:     <span class="comment">// If enough hosts are bad, we have no choice but start over again</span></div><div class="line"><span class="number">10</span>:     <span class="keyword">int</span> threshold = (<span class="keyword">int</span>) (candidateHosts.size() * transportConfig.getRetryableClientQuarantineRefreshPercentage()); <span class="comment">// 0.66</span></div><div class="line"><span class="number">11</span>:     <span class="keyword">if</span> (quarantineSet.isEmpty()) &#123;</div><div class="line"><span class="number">12</span>:         <span class="comment">// no-op</span></div><div class="line"><span class="number">13</span>:     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (quarantineSet.size() &gt;= threshold) &#123;</div><div class="line"><span class="number">14</span>:         logger.debug(<span class="string">"Clearing quarantined list of size &#123;&#125;"</span>, quarantineSet.size());</div><div class="line"><span class="number">15</span>:         quarantineSet.clear();</div><div class="line"><span class="number">16</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">17</span>:         List&lt;EurekaEndpoint&gt; remainingHosts = <span class="keyword">new</span> ArrayList&lt;&gt;(candidateHosts.size());</div><div class="line"><span class="number">18</span>:         <span class="keyword">for</span> (EurekaEndpoint endpoint : candidateHosts) &#123;</div><div class="line"><span class="number">19</span>:             <span class="keyword">if</span> (!quarantineSet.contains(endpoint)) &#123;</div><div class="line"><span class="number">20</span>:                 remainingHosts.add(endpoint);</div><div class="line"><span class="number">21</span>:             &#125;</div><div class="line"><span class="number">22</span>:         &#125;</div><div class="line"><span class="number">23</span>:         candidateHosts = remainingHosts;</div><div class="line"><span class="number">24</span>:     &#125;</div><div class="line"><span class="number">25</span>: </div><div class="line"><span class="number">26</span>:     <span class="keyword">return</span> candidateHosts;</div><div class="line"><span class="number">27</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 3 行 ：调用 <code>ClusterResolver#getClusterEndpoints()</code> 方法，获得候选的 Eureka-Server 地址数组( <code>candidateHosts</code> )。<strong>注意</strong>：该方法返回的 Eureka-Server 地址数组，使用以本机 IP 为<strong>随机种子</strong>，达到不同 IP 的应用实例获得的数组顺序不同，而相同 IP 的应用实例获得的数组顺序一致，<strong>效果类似基于 IP HASH 的负载均衡算法</strong>。实现该功能的代码，在 <a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/?self">《Eureka 源码解析 —— EndPoint 与 解析器》搜索关键字【ResolverUtils#randomize(...)】</a> 详细解析。</li><li>第 6 行 ：调用 <code>Set#retainAll()</code> 方法，移除隔离的故障 Eureka-Server 地址数组( <code>quarantineSet</code> ) 中不在 <code>candidateHosts</code> 的元素。</li><li>第 8 至 24 行 ：在保证最小可用的 <code>candidateHosts</code>，移除在 <code>quarantineSet</code> 的元素。<ul><li>第 10 行 ：最小可用的阀值，配置 <code>eureka.retryableClientQuarantineRefreshPercentage</code> 来设置百分比，默认值：<code>0.66</code> 。</li><li>最 13 至 15 行 ：<code>quarantineSet</code> 数量超过阀值，清空 <code>quarantineSet</code> ，全部 <code>candidateHosts</code> 重试。</li><li>第 17 至 24 行 ：<code>quarantineSet</code> 数量未超过阀值，移除 <code>candidateHosts</code> 中在 <code>quarantineSet</code> 的元素。</li></ul></li></ul></li><li><p>第 19 至 22 行 ：超过 <code>candidateHosts</code> 上限，全部 Eureka-Server 请求失败，抛出异常。</p></li><li><p>第 24 至 26 行 ：创建委托的 EurekaHttpClient ，用于下面请求执行。</p></li><li><p>第 31 行 ：执行请求。</p></li><li><p>第 33 行 ：调用 <code>ServerStatusEvaluator#accept()</code> 方法，判断响应状态码和请求类型是否能够接受。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ServerStatusEvaluators.java</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ServerStatusEvaluator LEGACY_EVALUATOR = <span class="keyword">new</span> ServerStatusEvaluator() &#123;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> statusCode, RequestType requestType)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (statusCode &gt;= <span class="number">200</span> &amp;&amp; statusCode &lt; <span class="number">300</span> || statusCode == <span class="number">302</span>) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (requestType == RequestType.Register &amp;&amp; statusCode == <span class="number">404</span>) &#123; <span class="comment">// 注册，404 可接受</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (requestType == RequestType.SendHeartBeat &amp;&amp; statusCode == <span class="number">404</span>) &#123; <span class="comment">// 心跳，404 可接受</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (requestType == RequestType.Cancel) &#123;  <span class="comment">// cancel is best effort 下线，接受全部</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (requestType == RequestType.GetDelta &amp;&amp; (statusCode == <span class="number">403</span> || statusCode == <span class="number">404</span>)) &#123; <span class="comment">// 增量获取注册信息，403 404 可接受</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p></li><li><p>第 34 行 ：请求成功，设置 <code>delegate</code> 。下次请求，优先使用 <code>delegate</code> ，失败才进行候选的 Eureka-Server 地址数组重试。</p></li><li><p>第 47 行 ：请求失败，<code>delegate</code> 若等于 <code>currentHttpClient</code> ，进行清除。</p></li><li><p>第 50 至 52 行 ：请求失败，将请求的 Eureka-Server 地址添加到 <code>quarantineSet</code> 。</p></li><li><p>总结来说：</p><ul><li>【第一步】若当前有请求成功的 EurekaHttpClient ，继续使用。若请求失败，执行【第二步】。</li><li>【第二步】若当前无请求成功的 EurekaHttpClient ，获取候选的 Eureka-Server 地址数组<strong>顺序</strong>创建新的 EurekaHttpClient，直到成功，或者超过最大重试次数。当请求成功，保存该 EurekaHttpClient ，下次继续使用，直到请求失败。</li></ul></li></ul><h3>5.3.1 工厂</h3><p>RetryableEurekaHttpClient 提供 <code>#createFactory(...)</code> <strong>静态方法</strong>获得创建其的工厂，点击 <a href="https://github.com/YunaiV/eureka/blob/94a4a1ebd35a3350893369a05757c01b2534b702/eureka-client/src/main/java/com/netflix/discovery/shared/transport/decorator/RetryableEurekaHttpClient.java#L135" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看。</p><h2>5.4 SessionedEurekaHttpClient</h2><p><code>com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient</code> ，支持会话的 EurekaHttpClient 。执行定期的重建会话，防止一个 Eureka-Client 永远只连接一个特定的 Eureka-Server 。反过来，这也保证了 Eureka-Server 集群变更时，Eureka-Client 对 Eureka-Server 连接的负载均衡。</p><p><code>#execute(...)</code> ，代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="keyword">protected</span> &lt;R&gt; <span class="function">EurekaHttpResponse&lt;R&gt; <span class="title">execute</span><span class="params">(RequestExecutor&lt;R&gt; requestExecutor)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line"> <span class="number">4</span>:     <span class="keyword">long</span> delay = now - lastReconnectTimeStamp;</div><div class="line"> <span class="number">5</span>: </div><div class="line"> <span class="number">6</span>:     <span class="comment">// 超过 当前会话时间，关闭当前委托的 EurekaHttpClient 。</span></div><div class="line"> <span class="number">7</span>:     <span class="keyword">if</span> (delay &gt;= currentSessionDurationMs) &#123;</div><div class="line"> <span class="number">8</span>:         logger.debug(<span class="string">"Ending a session and starting anew"</span>);</div><div class="line"> <span class="number">9</span>:         lastReconnectTimeStamp = now;</div><div class="line"><span class="number">10</span>:         currentSessionDurationMs = randomizeSessionDuration(sessionDurationMs);</div><div class="line"><span class="number">11</span>:         TransportUtils.shutdown(eurekaHttpClientRef.getAndSet(<span class="keyword">null</span>));</div><div class="line"><span class="number">12</span>:     &#125;</div><div class="line"><span class="number">13</span>: </div><div class="line"><span class="number">14</span>:     <span class="comment">// 获得委托的 EurekaHttpClient 。若不存在，则创建新的委托的 EurekaHttpClient 。</span></div><div class="line"><span class="number">15</span>:     EurekaHttpClient eurekaHttpClient = eurekaHttpClientRef.get();</div><div class="line"><span class="number">16</span>:     <span class="keyword">if</span> (eurekaHttpClient == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">17</span>:         eurekaHttpClient = TransportUtils.getOrSetAnotherClient(eurekaHttpClientRef, clientFactory.newClient());</div><div class="line"><span class="number">18</span>:     &#125;</div><div class="line"><span class="number">19</span>:     <span class="keyword">return</span> requestExecutor.execute(eurekaHttpClient);</div><div class="line"><span class="number">20</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 7 至 12 行 ：超过当前会话时间，关闭当前委托的 EurekaHttpClient 。</p><ul><li><p>第 10 行 ：调用 <code>#randomizeSessionDuration(...)</code> 方法，计算计算下一次会话超时时长，公式为 <code>sessionDurationMs * (0.5, 1.5)</code> ，代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">randomizeSessionDuration</span><span class="params">(<span class="keyword">long</span> sessionDurationMs)</span> </span>&#123;</div><div class="line">   <span class="keyword">long</span> delta = (<span class="keyword">long</span>) (sessionDurationMs * (random.nextDouble() - <span class="number">0.5</span>));</div><div class="line">   <span class="keyword">return</span> sessionDurationMs + delta;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>增加会话过期的随机性，实现所有 Eureka-Client 的会话过期重连的发生时间更加离散，避免集中时间过期。目前猜测这么做的目的和 TODO[0028]：写入集群和读取集群 有关，即返回 302 。关联 <a href="https://github.com/Netflix/eureka/pull/687" rel="external nofollow noopener noreferrer" target="_blank">1.x new transport enhancements</a> 。</li></ul></li></ul></li><li><p>第 15 至 18 行 ：获得委托的 EurekaHttpClient 。若不存在，创建新的委托的 EurekaHttpClient 。<code>TransportUtils#getOrSetAnotherClient(...)</code> 方法代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EurekaHttpClient <span class="title">getOrSetAnotherClient</span><span class="params">(AtomicReference&lt;EurekaHttpClient&gt; eurekaHttpClientRef, EurekaHttpClient another)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     EurekaHttpClient existing = eurekaHttpClientRef.get();</div><div class="line"> <span class="number">3</span>:     <span class="comment">// 为空才设置</span></div><div class="line"> <span class="number">4</span>:     <span class="keyword">if</span> (eurekaHttpClientRef.compareAndSet(<span class="keyword">null</span>, another)) &#123;</div><div class="line"> <span class="number">5</span>:         <span class="keyword">return</span> another;</div><div class="line"> <span class="number">6</span>:     &#125;</div><div class="line"> <span class="number">7</span>:     <span class="comment">// 设置失败，意味着另外一个线程已经设置</span></div><div class="line"> <span class="number">8</span>:     another.shutdown();</div><div class="line"> <span class="number">9</span>:     <span class="keyword">return</span> existing;</div><div class="line"><span class="number">10</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>该方法实现，获得 <code>eurekaHttpClientRef</code> 里的 EurekaHttpClient 。若获取不到，将 <code>another</code> 设置到 <code>eurekaHttpClientRef</code> 。当有多个线程设置时，有且只有一个线程设置成功，另外的设置失败的线程们，意味着当前 <code>eurekaHttpClientRef</code> 有 EurekaHttpClient ，返回 <code>eurekaHttpClientRef</code> 。</p></li><li><p>目前该方法存在 BUG ，失败的线程直接返回 <code>existing</code> 的是 <code>null</code> ，需要修改成 <code>return eurekaHttpClientRef.get()</code> 。模拟重现该 BUG 代码如下 ：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_07_31/04.png" alt=""></p></li></ul></li><li><p>第 19 行 ：执行请求。</p></li></ul><h3>5.4.1 没有工厂</h3><p>在 SessionedEurekaHttpClient 类里，没有实现创建其的工厂。在 <a href="#">「6. 创建网络通讯客户端」搜索 <code>canonicalClientFactory</code></a> ，可以看到 <code>EurekaHttpClients#canonicalClientFactory(...)</code> 方法，内部有 SessionedEurekaHttpClient 的创建工厂。</p><h1>6. 创建网络通讯客户端</h1><p>对于 Eureka-Server 来说，调用 <code>JerseyReplicationClient#createReplicationClient(...)</code> <strong>静态方法</strong>即可创建用于 Eureka-Server 集群内，Eureka-Server 请求 <strong>其它的Eureka-Server</strong> 的网络通信客户端。</p><p>对于 Eureka-Client 来说，分成用于<strong>注册应用实例( <code>registrationClient</code> )<strong>和</strong>查询注册信息( <code>newQueryClient</code> )<strong>的</strong>两个不同</strong>网络通信客户端。在 DiscoveryClient 初始化时进行创建，代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.class</span></div><div class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleServerEndpointTask</span><span class="params">(EurekaTransport eurekaTransport,</span></span></div><div class="line"><span class="function"><span class="params">  <span class="number">2</span>:                                         AbstractDiscoveryClientOptionalArgs args)</span> </span>&#123;</div><div class="line">  <span class="number">3</span>:         </div><div class="line">  <span class="number">4</span>:     Collection&lt;?&gt; additionalFilters = args == <span class="keyword">null</span></div><div class="line">  <span class="number">5</span>:             ? Collections.emptyList()</div><div class="line">  <span class="number">6</span>:             : args.additionalFilters;</div><div class="line">  <span class="number">7</span>: </div><div class="line">  <span class="number">8</span>:     EurekaJerseyClient providedJerseyClient = args == <span class="keyword">null</span></div><div class="line">  <span class="number">9</span>:             ? <span class="keyword">null</span></div><div class="line"> <span class="number">10</span>:             : args.eurekaJerseyClient;</div><div class="line"> <span class="number">11</span>:     </div><div class="line"> <span class="number">12</span>:     TransportClientFactories argsTransportClientFactories = <span class="keyword">null</span>;</div><div class="line"> <span class="number">13</span>:     <span class="keyword">if</span> (args != <span class="keyword">null</span> &amp;&amp; args.getTransportClientFactories() != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">14</span>:         argsTransportClientFactories = args.getTransportClientFactories();</div><div class="line"> <span class="number">15</span>:     &#125;</div><div class="line"> <span class="number">16</span>:     </div><div class="line"> <span class="number">17</span>:     <span class="comment">// Ignore the raw types warnings since the client filter interface changed between jersey 1/2</span></div><div class="line"> <span class="number">18</span>:     <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</div><div class="line"> <span class="number">19</span>:     TransportClientFactories transportClientFactories = argsTransportClientFactories == <span class="keyword">null</span></div><div class="line"> <span class="number">20</span>:             ? <span class="keyword">new</span> Jersey1TransportClientFactories()</div><div class="line"> <span class="number">21</span>:             : argsTransportClientFactories;</div><div class="line"> <span class="number">22</span>: </div><div class="line"> <span class="number">23</span>:     <span class="comment">// If the transport factory was not supplied with args, assume they are using jersey 1 for passivity</span></div><div class="line"> <span class="number">24</span>:     <span class="comment">// noinspection unchecked</span></div><div class="line"> <span class="number">25</span>:     eurekaTransport.transportClientFactory = providedJerseyClient == <span class="keyword">null</span></div><div class="line"> <span class="number">26</span>:             ? transportClientFactories.newTransportClientFactory(clientConfig, additionalFilters, applicationInfoManager.getInfo())</div><div class="line"> <span class="number">27</span>:             : transportClientFactories.newTransportClientFactory(additionalFilters, providedJerseyClient);</div><div class="line"> <span class="number">28</span>: </div><div class="line"> <span class="number">29</span>:     <span class="comment">// （省略代码）初始化 应用解析器的应用实例数据源 TODO[0028]写入集群和读取集群</span></div><div class="line"> <span class="number">30</span>: </div><div class="line"> <span class="number">31</span>:     <span class="comment">// （省略代码）创建 EndPoint 解析器</span></div><div class="line"> <span class="number">32</span>:     eurekaTransport.bootstrapResolver = EurekaHttpClients.newBootstrapResolver(...)</div><div class="line"> <span class="number">33</span>: </div><div class="line"> <span class="number">34</span>:     <span class="keyword">if</span> (clientConfig.shouldRegisterWithEureka()) &#123;</div><div class="line"> <span class="number">35</span>:         EurekaHttpClientFactory newRegistrationClientFactory = <span class="keyword">null</span>;</div><div class="line"> <span class="number">36</span>:         EurekaHttpClient newRegistrationClient = <span class="keyword">null</span>;</div><div class="line"> <span class="number">37</span>:         <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">38</span>:             newRegistrationClientFactory = EurekaHttpClients.registrationClientFactory(</div><div class="line"> <span class="number">39</span>:                     eurekaTransport.bootstrapResolver,</div><div class="line"> <span class="number">40</span>:                     eurekaTransport.transportClientFactory,</div><div class="line"> <span class="number">41</span>:                     transportConfig</div><div class="line"> <span class="number">42</span>:             );</div><div class="line"> <span class="number">43</span>:             newRegistrationClient = newRegistrationClientFactory.newClient();</div><div class="line"> <span class="number">44</span>:         &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"> <span class="number">45</span>:             logger.warn(<span class="string">"Transport initialization failure"</span>, e);</div><div class="line"> <span class="number">46</span>:         &#125;</div><div class="line"> <span class="number">47</span>:         eurekaTransport.registrationClientFactory = newRegistrationClientFactory;</div><div class="line"> <span class="number">48</span>:         eurekaTransport.registrationClient = newRegistrationClient;</div><div class="line"> <span class="number">49</span>:     &#125;</div><div class="line"> <span class="number">50</span>: </div><div class="line"> <span class="number">51</span>:     <span class="comment">// new method (resolve from primary servers for read)</span></div><div class="line"> <span class="number">52</span>:     <span class="comment">// Configure new transport layer (candidate for injecting in the future)</span></div><div class="line"> <span class="number">53</span>:     <span class="keyword">if</span> (clientConfig.shouldFetchRegistry()) &#123;</div><div class="line"> <span class="number">54</span>:         EurekaHttpClientFactory newQueryClientFactory = <span class="keyword">null</span>;</div><div class="line"> <span class="number">55</span>:         EurekaHttpClient newQueryClient = <span class="keyword">null</span>;</div><div class="line"> <span class="number">56</span>:         <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">57</span>:             newQueryClientFactory = EurekaHttpClients.queryClientFactory(</div><div class="line"> <span class="number">58</span>:                     eurekaTransport.bootstrapResolver,</div><div class="line"> <span class="number">59</span>:                     eurekaTransport.transportClientFactory,</div><div class="line"> <span class="number">60</span>:                     clientConfig,</div><div class="line"> <span class="number">61</span>:                     transportConfig,</div><div class="line"> <span class="number">62</span>:                     applicationInfoManager.getInfo(),</div><div class="line"> <span class="number">63</span>:                     applicationsSource</div><div class="line"> <span class="number">64</span>:             );</div><div class="line"> <span class="number">65</span>:             newQueryClient = newQueryClientFactory.newClient();</div><div class="line"> <span class="number">66</span>:         &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"> <span class="number">67</span>:             logger.warn(<span class="string">"Transport initialization failure"</span>, e);</div><div class="line"> <span class="number">68</span>:         &#125;</div><div class="line"> <span class="number">69</span>:         eurekaTransport.queryClientFactory = newQueryClientFactory;</div><div class="line"> <span class="number">70</span>:         eurekaTransport.queryClient = newQueryClient;</div><div class="line"> <span class="number">71</span>:     &#125;</div><div class="line"> <span class="number">72</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 18 至 27 行 ：调用 <code>Jersey1TransportClientFactories#newTransportClientFactory(...)</code> 方法，创建 <code>registrationClient</code> 和 <code>queryClient</code> 公用的委托的 EurekaHttpClientFactory ，代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Jersey1TransportClientFactories.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> TransportClientFactory <span class="title">newTransportClientFactory</span><span class="params">(<span class="keyword">final</span> EurekaClientConfig clientConfig,</span></span></div><div class="line"><span class="function"><span class="params">                                                              <span class="keyword">final</span> Collection&lt;ClientFilter&gt; additionalFilters,</span></span></div><div class="line"><span class="function"><span class="params">                                                              <span class="keyword">final</span> InstanceInfo myInstanceInfo)</span> </span>&#123;</div><div class="line">   <span class="comment">// JerseyEurekaHttpClientFactory</span></div><div class="line">   <span class="keyword">final</span> TransportClientFactory jerseyFactory = JerseyEurekaHttpClientFactory.create(</div><div class="line">           clientConfig,</div><div class="line">           additionalFilters,</div><div class="line">           myInstanceInfo,</div><div class="line">           <span class="keyword">new</span> EurekaClientIdentity(myInstanceInfo.getIPAddr())</div><div class="line">   );</div><div class="line"></div><div class="line">   <span class="comment">// TransportClientFactory</span></div><div class="line">   <span class="keyword">final</span> TransportClientFactory metricsFactory = MetricsCollectingEurekaHttpClient.createFactory(jerseyFactory); <span class="comment">// 委托 TransportClientFactory</span></div><div class="line"></div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> TransportClientFactory() &#123;</div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> EurekaHttpClient <span class="title">newClient</span><span class="params">(EurekaEndpoint serviceUrl)</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> metricsFactory.newClient(serviceUrl);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line">           metricsFactory.shutdown();</div><div class="line">           jerseyFactory.shutdown();</div><div class="line">       &#125;</div><div class="line">   &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>在 TransportClientFactory 里<strong>委托</strong> JerseyEurekaHttpClientFactory 。</li></ul></li><li><p>第 34 至 49 行 ：调用 <code>EurekaHttpClients#registrationClientFactory(...)</code> 方法，创建 <code>registrationClient</code> 的 EurekaHttpClientFactory ，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// EurekaHttpClients.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EurekaHttpClientFactory <span class="title">registrationClientFactory</span><span class="params">(ClusterResolver bootstrapResolver,</span></span></div><div class="line"><span class="function"><span class="params">                                                                TransportClientFactory transportClientFactory,</span></span></div><div class="line"><span class="function"><span class="params">                                                                EurekaTransportConfig transportConfig)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> canonicalClientFactory(EurekaClientNames.REGISTRATION, transportConfig, bootstrapResolver, transportClientFactory);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> EurekaHttpClientFactory <span class="title">canonicalClientFactory</span><span class="params">(<span class="keyword">final</span> String name,</span></span></div><div class="line"><span class="function"><span class="params">                                                     <span class="keyword">final</span> EurekaTransportConfig transportConfig,</span></span></div><div class="line"><span class="function"><span class="params">                                                     <span class="keyword">final</span> ClusterResolver&lt;EurekaEndpoint&gt; clusterResolver,</span></span></div><div class="line"><span class="function"><span class="params">                                                     <span class="keyword">final</span> TransportClientFactory transportClientFactory)</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> EurekaHttpClientFactory() &#123; <span class="comment">// SessionedEurekaHttpClientFactory</span></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> EurekaHttpClient <span class="title">newClient</span><span class="params">()</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">new</span> SessionedEurekaHttpClient(</div><div class="line">                   name,</div><div class="line">                   RetryableEurekaHttpClient.createFactory( <span class="comment">// RetryableEurekaHttpClient</span></div><div class="line">                           name,</div><div class="line">                           transportConfig,</div><div class="line">                           clusterResolver,</div><div class="line">                           RedirectingEurekaHttpClient.createFactory(transportClientFactory), <span class="comment">// RedirectingEurekaHttpClient</span></div><div class="line">                           ServerStatusEvaluators.legacyEvaluator()),</div><div class="line">                   transportConfig.getSessionedClientReconnectIntervalSeconds() * <span class="number">1000</span></div><div class="line">           );</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line">           wrapClosable(clusterResolver).shutdown();</div><div class="line">       &#125;</div><div class="line">   &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li><li><p>第 51 至 71 行 ：调用 <code>EurekaHttpClients#queryClientFactory(...)</code> 方法，创建 <code>queryClient</code> 的 EurekaHttpClientFactory ，代码如下 ：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// EurekaHttpClients.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EurekaHttpClientFactory <span class="title">queryClientFactory</span><span class="params">(ClusterResolver bootstrapResolver,</span></span></div><div class="line"><span class="function"><span class="params">                                                        TransportClientFactory transportClientFactory,</span></span></div><div class="line"><span class="function"><span class="params">                                                        EurekaClientConfig clientConfig,</span></span></div><div class="line"><span class="function"><span class="params">                                                        EurekaTransportConfig transportConfig,</span></span></div><div class="line"><span class="function"><span class="params">                                                        InstanceInfo myInstanceInfo,</span></span></div><div class="line"><span class="function"><span class="params">                                                        ApplicationsResolver.ApplicationsSource applicationsSource)</span> </span>&#123;</div><div class="line"></div><div class="line">   ClosableResolver queryResolver = transportConfig.useBootstrapResolverForQuery()</div><div class="line">           ? wrapClosable(bootstrapResolver)</div><div class="line">           : queryClientResolver(bootstrapResolver, transportClientFactory,</div><div class="line">           clientConfig, transportConfig, myInstanceInfo, applicationsSource);</div><div class="line">   <span class="keyword">return</span> canonicalClientFactory(EurekaClientNames.QUERY, transportConfig, queryResolver, transportClientFactory); <span class="comment">// 该方法上面有</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li></ul><h1>666. 彩蛋</h1><p>这次真的是彩蛋，我们将整体调用关系调整如下如下( <a href="http://www.iocoder.cn/images/Eureka/2018_07_31/05.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_07_31/05.png" alt=""></p><p>胖友，你学会了么？</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/Eureka/transport/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 Eureka 1.8.X 版本&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— EndPoint 与 解析器</title>
    <link href="http://www.iocoder.cn/Eureka/end-point-and-resolver/"/>
    <id>http://www.iocoder.cn/Eureka/end-point-and-resolver/</id>
    <published>2018-07-23T16:00:00.000Z</published>
    <updated>2017-10-16T11:13:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/Eureka/end-point-and-resolver/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">2. EndPoint</a><ul><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">2.1 EurekaEndpoint</a></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">2.2 DefaultEndpoint</a></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">2.3 AwsEndpoint</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">3. 解析器</a><ul><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">3.1 ClusterResolver</a></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">3.2 ClosableResolver</a></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">3.3 DnsTxtRecordClusterResolver</a></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">3.4 ConfigClusterResolver</a></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">3.5 ZoneAffinityClusterResolver</a></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">3.6 AsyncResolver</a><ul><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">3.6.1 定时任务</a></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">3.6.2 解析 EndPoint 集群</a></li></ul></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">4. 初始化解析器</a></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p>本文主要分享 <strong>EndPoint 与 解析器</strong>。</p><ul><li>EndPoint ，服务端点。例如，Eureka-Server 的访问地址。</li><li>EndPoint 解析器，将配置的 Eureka-Server 的访问地址解析成 EndPoint 。</li></ul><p>目前有多种 Eureka-Server 访问地址的配置方式，<strong>本文只分享 Eureka 1.x 的配置</strong>，不包含 Eureka 1.x 对 Eureka 2.x 的兼容配置：</p><ul><li>第一种，直接配置实际访问地址。例如，<code>eureka.serviceUrl.defaultZone=http://127.0.0.1:8080/v2</code> 。</li><li>第二种，基于 DNS 解析出访问地址。例如，<code>eureka.shouldUseDns=true</code> 并且  <code>eureka.eurekaServer.domainName=eureka.iocoder.cn</code> 。</li></ul><p>本文涉及类在 <code>com.netflix.discovery.shared.resolver</code> 包下，涉及到主体类的类图如下( <a href="http://www.iocoder.cn/images/Eureka/2018_07_24/01.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_07_24/01.png" alt=""></p><ul><li>红色部分 —— EndPoint</li><li>黄色部分 —— EndPoint 解析器</li></ul><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1>2. EndPoint</h1><h2>2.1 EurekaEndpoint</h2><p><code>com.netflix.discovery.shared.resolver.EurekaEndpoint</code> ，Eureka 服务端点<strong>接口</strong>，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EurekaEndpoint</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 完整的服务 URL</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">String <span class="title">getServiceUrl</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@deprecated</span> use &#123;<span class="doctag">@link</span> #getNetworkAddress()&#125;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Deprecated</span></div><div class="line">    <span class="function">String <span class="title">getHostName</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 网络地址</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">String <span class="title">getNetworkAddress</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 端口</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 是否安全( https )</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSecure</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 相对路径</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">String <span class="title">getRelativeUri</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2>2.2 DefaultEndpoint</h2><p><code>com.netflix.discovery.shared.resolver.DefaultEndpoint</code> ，默认 Eureka 服务端点<strong>实现类</strong>。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultEndpoint</span> <span class="keyword">implements</span> <span class="title">EurekaEndpoint</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 网络地址</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String networkAddress;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 端口</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 是否安全( https )</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isSecure;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 相对地址</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String relativeUri;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 完整的服务 URL</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String serviceUrl;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultEndpoint</span><span class="params">(String serviceUrl)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.serviceUrl = serviceUrl;</div><div class="line"></div><div class="line">        <span class="comment">// 将 serviceUrl 分解成 几个属性</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            URL url = <span class="keyword">new</span> URL(serviceUrl);</div><div class="line">            <span class="keyword">this</span>.networkAddress = url.getHost();</div><div class="line">            <span class="keyword">this</span>.port = url.getPort();</div><div class="line">            <span class="keyword">this</span>.isSecure = <span class="string">"https"</span>.equals(url.getProtocol());</div><div class="line">            <span class="keyword">this</span>.relativeUri = url.getPath();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Malformed serviceUrl: "</span> + serviceUrl);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultEndpoint</span><span class="params">(String networkAddress, <span class="keyword">int</span> port, <span class="keyword">boolean</span> isSecure, String relativeUri)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.networkAddress = networkAddress;</div><div class="line">        <span class="keyword">this</span>.port = port;</div><div class="line">        <span class="keyword">this</span>.isSecure = isSecure;</div><div class="line">        <span class="keyword">this</span>.relativeUri = relativeUri;</div><div class="line"></div><div class="line">        <span class="comment">// 几个属性 拼接成 serviceUrl</span></div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder().append(isSecure ? <span class="string">"https"</span> : <span class="string">"http"</span>).append(<span class="string">"://"</span>).append(networkAddress);</div><div class="line"><span class="keyword">if</span> (port &gt;= <span class="number">0</span>) &#123;</div><div class="line">sb.append(<span class="string">':'</span>).append(port);</div><div class="line">&#125;</div><div class="line">        <span class="keyword">if</span> (relativeUri != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (!relativeUri.startsWith(<span class="string">"/"</span>)) &#123;</div><div class="line">                sb.append(<span class="string">'/'</span>);</div><div class="line">            &#125;</div><div class="line">            sb.append(relativeUri);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.serviceUrl = sb.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>重写了 <code>#equals(...)</code> 和 <code>#hashCode(...)</code> 方法，标准实现方式，这里就不贴代码了。</li><li>重写了 <code>#compareTo(...)</code> 方法，基于 <code>serviceUrl</code> 属性做比较。</li></ul><h2>2.3 AwsEndpoint</h2><p><code>com.netflix.discovery.shared.resolver.aws.AwsEndpoint</code> ，基于 <code>region</code>、<code>zone</code> 的 Eureka 服务端点<strong>实现类</strong> ( 请不要在意 AWS 开头 )。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AwsEndpoint</span> <span class="keyword">extends</span> <span class="title">DefaultEndpoint</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 区域</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String region;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 可用区</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String zone;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>重写了 <code>#equals(...)</code> 和 <code>#hashCode(...)</code> 方法，标准实现方式，这里就不贴代码了。</li></ul><h1>3. 解析器</h1><p>EndPoint 解析器使用<strong>委托设计模式</strong>实现。所以，上文图片中我们看到好多个解析器，<strong>实际代码非常非常非常清晰</strong>。</p><blockquote><p>FROM <a href="https://zh.wikipedia.org/wiki/%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F" rel="external nofollow noopener noreferrer" target="_blank">《委托模式》</a><br>委托模式是软件设计模式中的一项基本技巧。在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。委托模式是一项基本技巧，许多其他的模式，如状态模式、策略模式、访问者模式本质上是在更特殊的场合采用了委托模式。委托模式使得我们可以用聚合来替代继承，它还使我们可以模拟mixin。</p></blockquote><p>我们在上图的基础上，<strong>增加委托的关系</strong>，如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_07_24/02.png" alt=""></p><h2>3.1 ClusterResolver</h2><p><code>com.netflix.discovery.shared.resolver.ClusterResolver</code> ，集群解析器<strong>接口</strong>。接口代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClusterResolver</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">EurekaEndpoint</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 地区</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">String <span class="title">getRegion</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> EndPoint 集群( 数组 )</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">List&lt;T&gt; <span class="title">getClusterEndpoints</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2>3.2 ClosableResolver</h2><p><code>com.netflix.discovery.shared.resolver.ClosableResolver</code> ，<strong>可关闭</strong>的解析器<strong>接口</strong>，继承自 ClusterResolver <strong>接口</strong>。接口代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClosableResolver</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">EurekaEndpoint</span>&gt; <span class="keyword">extends</span> <span class="title">ClusterResolver</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 关闭</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2>3.3 DnsTxtRecordClusterResolver</h2><p><code>com.netflix.discovery.shared.resolver.aws.DnsTxtRecordClusterResolver</code> ，基于 DNS <strong>TXT</strong> 记录类型的集群解析器。<strong>类属性</strong>代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DnsTxtRecordClusterResolver</span> <span class="keyword">implements</span> <span class="title">ClusterResolver</span>&lt;<span class="title">AwsEndpoint</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 地区</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String region;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 集群根地址，例如 txt.default.eureka.iocoder.cn</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String rootClusterDNS;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 是否解析可用区( zone )</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> extractZoneFromDNS;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 端口</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 是否安全</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isSecure;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 相对地址</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String relativeUri;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p>DnsTxtRecordClusterResolver 通过集群根地址( <code>rootClusterDNS</code> ) 解析出 EndPoint 集群。需要在 DNS 配置<strong>两层</strong>解析记录：</p><ul><li>第一层 ：<ul><li>主机记录 ：格式为 <code>TXT.${REGION}.${自定义二级域名}</code> 。</li><li>记录类型 ：<strong>TXT 记录类型</strong>。</li><li>记录值 ：第二层的<strong>主机记录</strong>。如有多个第二层级，使用<strong>空格</strong>分隔。</li></ul></li><li>第二层：<ul><li>主机记录 ：格式为 <code>TXT.${ZONE}.${自定义二级域名}</code> 或者 <code>${ZONE}.${自定义二级域名}</code>。</li><li>记录类型 ：<strong>TXT 记录类型</strong>。</li><li>记录值 ：EndPoint 的网络地址。如有多个 EndPoint，使用<strong>空格</strong>分隔。</li></ul></li><li>举个例子：<img src="http://www.iocoder.cn/images/Eureka/2018_07_24/03.png" alt=""></li></ul></li><li><p><code>rootClusterDNS</code> ，集群根地址。例如：<code>txt.default.eureka.iocoder.cn</code>，其· <code>txt.default.eureka</code> 为 DNS 解析记录的第一层的<strong>主机记录</strong>。</p></li><li><p><code>region</code> ：地区。需要和 <code>rootClusterDNS</code> 的 <code>${REGION}</code> 一致。</p></li><li><p><code>extractZoneFromDNS</code> ：是否解析 DNS 解析记录的第二层级的<strong>主机记录</strong>的 <code>${ZONE}</code> 可用区。</p></li></ul><hr><p><code>#getClusterEndpoints(...)</code> 方法，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> List&lt;AwsEndpoint&gt; <span class="title">getClusterEndpoints</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     List&lt;AwsEndpoint&gt; eurekaEndpoints = resolve(region, rootClusterDNS, extractZoneFromDNS, port, isSecure, relativeUri);</div><div class="line"> <span class="number">4</span>:     <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line"> <span class="number">5</span>:         logger.debug(<span class="string">"Resolved &#123;&#125; to &#123;&#125;"</span>, rootClusterDNS, eurekaEndpoints);</div><div class="line"> <span class="number">6</span>:     &#125;</div><div class="line"> <span class="number">7</span>:     <span class="keyword">return</span> eurekaEndpoints;</div><div class="line"> <span class="number">8</span>: &#125;</div><div class="line"> <span class="number">9</span>: </div><div class="line"><span class="number">10</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;AwsEndpoint&gt; <span class="title">resolve</span><span class="params">(String region, String rootClusterDNS, <span class="keyword">boolean</span> extractZone, <span class="keyword">int</span> port, <span class="keyword">boolean</span> isSecure, String relativeUri)</span> </span>&#123;</div><div class="line"><span class="number">11</span>:     <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">12</span>:         <span class="comment">// 解析 第一层 DNS 记录</span></div><div class="line"><span class="number">13</span>:         Set&lt;String&gt; zoneDomainNames = resolve(rootClusterDNS);</div><div class="line"><span class="number">14</span>:         <span class="keyword">if</span> (zoneDomainNames.isEmpty()) &#123;</div><div class="line"><span class="number">15</span>:             <span class="keyword">throw</span> <span class="keyword">new</span> ClusterResolverException(<span class="string">"Cannot resolve Eureka cluster addresses; there are no data in TXT record for DN "</span> + rootClusterDNS);</div><div class="line"><span class="number">16</span>:         &#125;</div><div class="line"><span class="number">17</span>:         <span class="comment">// 记录 第二层 DNS 记录</span></div><div class="line"><span class="number">18</span>:         List&lt;AwsEndpoint&gt; endpoints = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="number">19</span>:         <span class="keyword">for</span> (String zoneDomain : zoneDomainNames) &#123;</div><div class="line"><span class="number">20</span>:             String zone = extractZone ? ResolverUtils.extractZoneFromHostName(zoneDomain) : <span class="keyword">null</span>; <span class="comment">// </span></div><div class="line"><span class="number">21</span>:             Set&lt;String&gt; zoneAddresses = resolve(zoneDomain);</div><div class="line"><span class="number">22</span>:             <span class="keyword">for</span> (String address : zoneAddresses) &#123;</div><div class="line"><span class="number">23</span>:                 endpoints.add(<span class="keyword">new</span> AwsEndpoint(address, port, isSecure, relativeUri, region, zone));</div><div class="line"><span class="number">24</span>:             &#125;</div><div class="line"><span class="number">25</span>:         &#125;</div><div class="line"><span class="number">26</span>:         <span class="keyword">return</span> endpoints;</div><div class="line"><span class="number">27</span>:     &#125; <span class="keyword">catch</span> (NamingException e) &#123;</div><div class="line"><span class="number">28</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> ClusterResolverException(<span class="string">"Cannot resolve Eureka cluster addresses for root: "</span> + rootClusterDNS, e);</div><div class="line"><span class="number">29</span>:     &#125;</div><div class="line"><span class="number">30</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 12 至 16 行 ：调用 <code>#resolve(rootClusterDNS)</code> 解析<strong>第一层</strong> DNS 记录。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Set&lt;String&gt; <span class="title">resolve</span><span class="params">(String rootClusterDNS)</span> <span class="keyword">throws</span> NamingException </span>&#123;</div><div class="line"> <span class="number">2</span>:     Set&lt;String&gt; result;</div><div class="line"> <span class="number">3</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">4</span>:         result = DnsResolver.getCNamesFromTxtRecord(rootClusterDNS);</div><div class="line"> <span class="number">5</span>:         <span class="comment">// TODO 芋艿：这块是bug，不需要这一段</span></div><div class="line"> <span class="number">6</span>:         <span class="keyword">if</span> (!rootClusterDNS.startsWith(<span class="string">"txt."</span>)) &#123;</div><div class="line"> <span class="number">7</span>:             result = DnsResolver.getCNamesFromTxtRecord(<span class="string">"txt."</span> + rootClusterDNS);</div><div class="line"> <span class="number">8</span>:         &#125;</div><div class="line"> <span class="number">9</span>:     &#125; <span class="keyword">catch</span> (NamingException e) &#123;</div><div class="line"><span class="number">10</span>:         <span class="keyword">if</span> (!rootClusterDNS.startsWith(<span class="string">"txt."</span>)) &#123;</div><div class="line"><span class="number">11</span>:             result = DnsResolver.getCNamesFromTxtRecord(<span class="string">"txt."</span> + rootClusterDNS);</div><div class="line"><span class="number">12</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">13</span>:             <span class="keyword">throw</span> e;</div><div class="line"><span class="number">14</span>:         &#125;</div><div class="line"><span class="number">15</span>:     &#125;</div><div class="line"><span class="number">16</span>:     <span class="keyword">return</span> result;</div><div class="line"><span class="number">17</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 4 行 ： 调用 <code>DnsResolver#getCNamesFromTxtRecord(...)</code> 方法，解析 TXT 主机记录。点击<a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-client/src/main/java/com/netflix/discovery/endpoint/DnsResolver.java#L126" rel="external nofollow noopener noreferrer" target="_blank">链接</a>查看带中文注释的 DnsResolver 的代码，比较解析，笔者就不啰嗦了。</li><li>第 5 至 8 行 ：当传递参数 <code>rootClusterDNS</code> 不以 <code>txt.</code> 开头时，即使第 4 行解析成功，也会报错，此时是个 Eureka 的 BUG 。因此，配置 DNS 解析记录时，主机记录暂时必须以 <code>txt.</code> 开头。</li></ul></li><li><p>第 17 至 25 行 ：循环第一层 DNS 记录的解析结果，进一步解析第二层 DNS 记录。</p><ul><li>第 20 行 ：解析可用区( <code>zone</code> )。</li><li>第 21 行 ：调用 <code>#resolve(rootClusterDNS)</code> 解析<strong>第二层</strong> DNS 记录。</li></ul></li></ul><h2>3.4 ConfigClusterResolver</h2><p><code>com.netflix.discovery.shared.resolver.aws.ConfigClusterResolver</code> ，基于<strong>配置文件</strong>的集群解析器。<strong>类属性</strong>代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClusterResolver</span> <span class="keyword">implements</span> <span class="title">ClusterResolver</span>&lt;<span class="title">AwsEndpoint</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EurekaClientConfig clientConfig;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InstanceInfo myInstanceInfo;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConfigClusterResolver</span><span class="params">(EurekaClientConfig clientConfig, InstanceInfo myInstanceInfo)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.clientConfig = clientConfig;</div><div class="line">        <span class="keyword">this</span>.myInstanceInfo = myInstanceInfo;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><hr><p><code>#getClusterEndpoints(...)</code> 方法，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> List&lt;AwsEndpoint&gt; <span class="title">getClusterEndpoints</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="comment">// 使用 DNS 获取 EndPoint</span></div><div class="line"> <span class="number">4</span>:     <span class="keyword">if</span> (clientConfig.shouldUseDnsForFetchingServiceUrls()) &#123;</div><div class="line"> <span class="number">5</span>:         <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</div><div class="line"> <span class="number">6</span>:             logger.info(<span class="string">"Resolving eureka endpoints via DNS: &#123;&#125;"</span>, getDNSName());</div><div class="line"> <span class="number">7</span>:         &#125;</div><div class="line"> <span class="number">8</span>:         <span class="keyword">return</span> getClusterEndpointsFromDns();</div><div class="line"> <span class="number">9</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">10</span>:     <span class="comment">// 直接配置实际访问地址</span></div><div class="line"><span class="number">11</span>:         logger.info(<span class="string">"Resolving eureka endpoints via configuration"</span>);</div><div class="line"><span class="number">12</span>:         <span class="keyword">return</span> getClusterEndpointsFromConfig();</div><div class="line"><span class="number">13</span>:     &#125;</div><div class="line"><span class="number">14</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 3 至 8 行 ：基于 DNS 获取 EndPoint 集群，调用 <code>#getClusterEndpointsFromDns()</code> 方法，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> List&lt;AwsEndpoint&gt; <span class="title">getClusterEndpointsFromDns</span><span class="params">()</span> </span>&#123;</div><div class="line">   String discoveryDnsName = getDNSName(); <span class="comment">// 获取 集群根地址</span></div><div class="line">   <span class="keyword">int</span> port = Integer.parseInt(clientConfig.getEurekaServerPort()); <span class="comment">// 端口</span></div><div class="line"></div><div class="line">   <span class="comment">// cheap enough so just re-use</span></div><div class="line">   DnsTxtRecordClusterResolver dnsResolver = <span class="keyword">new</span> DnsTxtRecordClusterResolver(</div><div class="line">           getRegion(),</div><div class="line">           discoveryDnsName,</div><div class="line">           <span class="keyword">true</span>, <span class="comment">// 解析 zone</span></div><div class="line">           port,</div><div class="line">           <span class="keyword">false</span>,</div><div class="line">           clientConfig.getEurekaServerURLContext()</div><div class="line">   );</div><div class="line"></div><div class="line">   <span class="comment">// 调用 DnsTxtRecordClusterResolver 解析 EndPoint</span></div><div class="line">   List&lt;AwsEndpoint&gt; endpoints = dnsResolver.getClusterEndpoints();</div><div class="line"></div><div class="line">   <span class="keyword">if</span> (endpoints.isEmpty()) &#123;</div><div class="line">       logger.error(<span class="string">"Cannot resolve to any endpoints for the given dnsName: &#123;&#125;"</span>, discoveryDnsName);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">return</span> endpoints;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getDNSName</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="string">"txt."</span> + getRegion() + <span class="string">'.'</span> + clientConfig.getEurekaServerDNSName();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>必须配置 <code>eureka.shouldUseDns=true</code> ，开启基于 DNS 获取 EndPoint 集群。</li><li>必须配置 <code>eureka.eurekaServer.domainName=${xxxxx}</code> ，配置集群根地址。</li><li>选填配 <code>eureka.eurekaServer.port</code> ，<code>eureka.eurekaServer.context</code> 。</li><li>从代码中我们可以看出，使用 DnsTxtRecordClusterResolver 解析出 EndPoint 集群。</li></ul></li><li><p>第 9 至 13 行 ：直接<strong>配置文件</strong>填写实际 EndPoint 集群，调用 <code>#getClusterEndpointsFromConfig()</code> 方法，实现代码如下：</p></li></ul><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> List&lt;AwsEndpoint&gt; <span class="title">getClusterEndpointsFromConfig</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// 获得 可用区</span></div><div class="line"> <span class="number">3</span>:     String[] availZones = clientConfig.getAvailabilityZones(clientConfig.getRegion());</div><div class="line"> <span class="number">4</span>:     <span class="comment">// 获取 应用实例自己 的 可用区</span></div><div class="line"> <span class="number">5</span>:     String myZone = InstanceInfo.getZone(availZones, myInstanceInfo);</div><div class="line"> <span class="number">6</span>:     <span class="comment">// 获得 可用区与 serviceUrls 的映射</span></div><div class="line"> <span class="number">7</span>:     Map&lt;String, List&lt;String&gt;&gt; serviceUrls = EndpointUtils.getServiceUrlsMapFromConfig(clientConfig, myZone, clientConfig.shouldPreferSameZoneEureka());</div><div class="line"> <span class="number">8</span>:     <span class="comment">// 拼装 EndPoint 集群结果</span></div><div class="line"> <span class="number">9</span>:     List&lt;AwsEndpoint&gt; endpoints = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="number">10</span>:     <span class="keyword">for</span> (String zone : serviceUrls.keySet()) &#123;</div><div class="line"><span class="number">11</span>:         <span class="keyword">for</span> (String url : serviceUrls.get(zone)) &#123;</div><div class="line"><span class="number">12</span>:             <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">13</span>:                 endpoints.add(<span class="keyword">new</span> AwsEndpoint(url, getRegion(), zone));</div><div class="line"><span class="number">14</span>:             &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</div><div class="line"><span class="number">15</span>:                 logger.warn(<span class="string">"Invalid eureka server URI: &#123;&#125;; removing from the server pool"</span>, url);</div><div class="line"><span class="number">16</span>:             &#125;</div><div class="line"><span class="number">17</span>:         &#125;</div><div class="line"><span class="number">18</span>:     &#125;</div><div class="line"><span class="number">19</span>: </div><div class="line"><span class="number">20</span>:     <span class="comment">// 打印日志，EndPoint 集群</span></div><div class="line"><span class="number">21</span>:     <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line"><span class="number">22</span>:         logger.debug(<span class="string">"Config resolved to &#123;&#125;"</span>, endpoints);</div><div class="line"><span class="number">23</span>:     &#125;</div><div class="line"><span class="number">24</span>:     <span class="comment">// 打印日志，解析结果为空</span></div><div class="line"><span class="number">25</span>:     <span class="keyword">if</span> (endpoints.isEmpty()) &#123;</div><div class="line"><span class="number">26</span>:         logger.error(<span class="string">"Cannot resolve to any endpoints from provided configuration: &#123;&#125;"</span>, serviceUrls);</div><div class="line"><span class="number">27</span>:     &#125;</div><div class="line"><span class="number">28</span>: </div><div class="line"><span class="number">29</span>:     <span class="keyword">return</span> endpoints;</div><div class="line"><span class="number">30</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 3 行 ：获得可用区数组。通过 <code>eureka.${REGION}.availabilityZones</code> 配置。</p></li><li><p>第 5 行 ：调用 <code>InstanceInfo#getZone(...)</code> 方法，获得<strong>应用实例自己所在的可用区</strong>( <code>zone</code> )。非亚马逊 AWS 环境下，可用区数组的第一个元素就是<strong>应用实例自己所在的可用区</strong>。</p></li><li><p>第 7 行 ：调用 <code>EndpointUtils#getServiceUrlsMapFromConfig(...)</code> 方法，获得可用区与 <code>serviceUrls</code> 的映射。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// EndpointUtils.java</span></div><div class="line">  <span class="number">1</span>: <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; getServiceUrlsMapFromConfig(EurekaClientConfig clientConfig, String instanceZone, <span class="keyword">boolean</span> preferSameZone) &#123;</div><div class="line">  <span class="number">2</span>:     Map&lt;String, List&lt;String&gt;&gt; orderedUrls = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(); <span class="comment">// key：zone；value：serviceUrls</span></div><div class="line">  <span class="number">3</span>:     <span class="comment">// 获得 应用实例的 地区( region )</span></div><div class="line">  <span class="number">4</span>:     String region = getRegion(clientConfig);</div><div class="line">  <span class="number">5</span>:     <span class="comment">// 获得 应用实例的 可用区</span></div><div class="line">  <span class="number">6</span>:     String[] availZones = clientConfig.getAvailabilityZones(clientConfig.getRegion());</div><div class="line">  <span class="number">7</span>:     <span class="keyword">if</span> (availZones == <span class="keyword">null</span> || availZones.length == <span class="number">0</span>) &#123;</div><div class="line">  <span class="number">8</span>:         availZones = <span class="keyword">new</span> String[<span class="number">1</span>];</div><div class="line">  <span class="number">9</span>:         availZones[<span class="number">0</span>] = DEFAULT_ZONE;</div><div class="line"> <span class="number">10</span>:     &#125;</div><div class="line"> <span class="number">11</span>:     logger.debug(<span class="string">"The availability zone for the given region &#123;&#125; are &#123;&#125;"</span>, region, Arrays.toString(availZones));</div><div class="line"> <span class="number">12</span>:     <span class="comment">// 获得 开始位置</span></div><div class="line"> <span class="number">13</span>:     <span class="keyword">int</span> myZoneOffset = getZoneOffset(instanceZone, preferSameZone, availZones);</div><div class="line"> <span class="number">14</span>:     <span class="comment">// 将 开始位置 的 serviceUrls 添加到结果</span></div><div class="line"> <span class="number">15</span>:     String zone = availZones[myZoneOffset];</div><div class="line"> <span class="number">16</span>:     List&lt;String&gt; serviceUrls = clientConfig.getEurekaServerServiceUrls(zone);</div><div class="line"> <span class="number">17</span>:     <span class="keyword">if</span> (serviceUrls != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">18</span>:         orderedUrls.put(zone, serviceUrls);</div><div class="line"> <span class="number">19</span>:     &#125;</div><div class="line"> <span class="number">20</span>:     <span class="comment">// 从开始位置顺序遍历剩余的 serviceUrls 添加到结果</span></div><div class="line"> <span class="number">21</span>:     <span class="keyword">int</span> currentOffset = myZoneOffset == (availZones.length - <span class="number">1</span>) ? <span class="number">0</span> : (myZoneOffset + <span class="number">1</span>);</div><div class="line"> <span class="number">22</span>:     <span class="keyword">while</span> (currentOffset != myZoneOffset) &#123;</div><div class="line"> <span class="number">23</span>:         zone = availZones[currentOffset];</div><div class="line"> <span class="number">24</span>:         serviceUrls = clientConfig.getEurekaServerServiceUrls(zone);</div><div class="line"> <span class="number">25</span>:         <span class="keyword">if</span> (serviceUrls != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">26</span>:             orderedUrls.put(zone, serviceUrls);</div><div class="line"> <span class="number">27</span>:         &#125;</div><div class="line"> <span class="number">28</span>:         <span class="keyword">if</span> (currentOffset == (availZones.length - <span class="number">1</span>)) &#123;</div><div class="line"> <span class="number">29</span>:             currentOffset = <span class="number">0</span>;</div><div class="line"> <span class="number">30</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">31</span>:             currentOffset++;</div><div class="line"> <span class="number">32</span>:         &#125;</div><div class="line"> <span class="number">33</span>:     &#125;</div><div class="line"> <span class="number">34</span>: </div><div class="line"> <span class="number">35</span>:     <span class="comment">// 为空，报错</span></div><div class="line"> <span class="number">36</span>:     <span class="keyword">if</span> (orderedUrls.size() &lt; <span class="number">1</span>) &#123;</div><div class="line"> <span class="number">37</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"DiscoveryClient: invalid serviceUrl specified!"</span>);</div><div class="line"> <span class="number">38</span>:     &#125;</div><div class="line"> <span class="number">39</span>:     <span class="keyword">return</span> orderedUrls;</div><div class="line"> <span class="number">40</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 13 行 ：获得<strong>开始位置</strong>。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getZoneOffset</span><span class="params">(String myZone, <span class="keyword">boolean</span> preferSameZone, String[] availZones)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; availZones.length; i++) &#123;</div><div class="line">       <span class="keyword">if</span> (myZone != <span class="keyword">null</span> &amp;&amp; (availZones[i].equalsIgnoreCase(myZone.trim()) == preferSameZone)) &#123;</div><div class="line">           <span class="keyword">return</span> i;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   logger.warn(<span class="string">"DISCOVERY: Could not pick a zone based on preferred zone settings. My zone - &#123;&#125;,"</span> +</div><div class="line">           <span class="string">" preferSameZone- &#123;&#125;. Defaulting to "</span> + availZones[<span class="number">0</span>], myZone, preferSameZone);</div><div class="line"></div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>当方法参数 <code>preferSameZone=true</code> ，即 <code>eureka.preferSameZone=true</code>( 默认值 ：<code>true</code> ) 时，<strong>开始位置</strong>为可用区数组( <code>availZones</code> )的<strong>第一个</strong>和应用实例所在的可用区( <code>myZone</code> )【<strong>相等</strong>】元素的位置。</li><li>当方法参数 <code>preferSameZone=false</code> ，即 <code>eureka.preferSameZone=false</code>( 默认值 ：<code>true</code> ) 时，<strong>开始位置</strong>为可用区数组( <code>availZones</code> )的<strong>第一个</strong>和应用实例所在的可用区( <code>myZone</code> )【<strong>不相等</strong>】元素的位置。</li></ul></li><li><p>第 20 至 33 行 ：从开始位置<strong>顺序</strong>将剩余的可用区的 <code>serviceUrls</code> 添加到结果。<strong>顺序</strong>理解如下图：<img src="http://www.iocoder.cn/images/Eureka/2018_07_24/04.png" alt=""></p></li></ul></li><li><p>第 9 至 18 行 ：拼装 EndPoint 集群结果。</p></li></ul><h2>3.5 ZoneAffinityClusterResolver</h2><p><code>com.netflix.discovery.shared.resolver.aws.ZoneAffinityClusterResolver</code> ，使用可用区亲和的集群解析器。<strong>类属性</strong>代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZoneAffinityClusterResolver</span> <span class="keyword">implements</span> <span class="title">ClusterResolver</span>&lt;<span class="title">AwsEndpoint</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ZoneAffinityClusterResolver.class);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 委托的解析器</span></div><div class="line"><span class="comment">     * 目前代码里为 &#123;<span class="doctag">@link</span> ConfigClusterResolver&#125;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClusterResolver&lt;AwsEndpoint&gt; delegate;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用实例的可用区</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String myZone;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 是否可用区亲和</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> zoneAffinity;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZoneAffinityClusterResolver</span><span class="params">(ClusterResolver&lt;AwsEndpoint&gt; delegate, String myZone, <span class="keyword">boolean</span> zoneAffinity)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.delegate = delegate;</div><div class="line">        <span class="keyword">this</span>.myZone = myZone;</div><div class="line">        <span class="keyword">this</span>.zoneAffinity = zoneAffinity;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>属性 <code>delegate</code> ，委托的解析器。目前代码里使用的是 ConfigClusterResolver 。</li><li>属性 <code>zoneAffinity</code> ，是否可用区亲和。<ul><li><code>true</code> ：EndPoint 可用区为<strong>本地</strong>的优先被放在前面。</li><li><code>false</code> ：EndPoint 可用区<strong>非本地</strong>的优先被放在前面。</li></ul></li></ul><p><code>#getClusterEndpoints(...)</code> 方法，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> List&lt;AwsEndpoint&gt; <span class="title">getClusterEndpoints</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="comment">// 拆分成 本地的可用区和非本地的可用区的 EndPoint 集群</span></div><div class="line"> <span class="number">4</span>:     List&lt;AwsEndpoint&gt;[] parts = ResolverUtils.splitByZone(delegate.getClusterEndpoints(), myZone);</div><div class="line"> <span class="number">5</span>:     List&lt;AwsEndpoint&gt; myZoneEndpoints = parts[<span class="number">0</span>];</div><div class="line"> <span class="number">6</span>:     List&lt;AwsEndpoint&gt; remainingEndpoints = parts[<span class="number">1</span>];</div><div class="line"> <span class="number">7</span>:     <span class="comment">// 随机打乱 EndPoint 集群并进行合并</span></div><div class="line"> <span class="number">8</span>:     List&lt;AwsEndpoint&gt; randomizedList = randomizeAndMerge(myZoneEndpoints, remainingEndpoints);</div><div class="line"> <span class="number">9</span>:     <span class="comment">// 非可用区亲和，将非本地的可用区的 EndPoint 集群放在前面</span></div><div class="line"><span class="number">10</span>:     <span class="keyword">if</span> (!zoneAffinity) &#123;</div><div class="line"><span class="number">11</span>:         Collections.reverse(randomizedList);</div><div class="line"><span class="number">12</span>:     &#125;</div><div class="line"><span class="number">13</span>: </div><div class="line"><span class="number">14</span>:     <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line"><span class="number">15</span>:         logger.debug(<span class="string">"Local zone=&#123;&#125;; resolved to: &#123;&#125;"</span>, myZone, randomizedList);</div><div class="line"><span class="number">16</span>:     &#125;</div><div class="line"><span class="number">17</span>: </div><div class="line"><span class="number">18</span>:     <span class="keyword">return</span> randomizedList;</div><div class="line"><span class="number">19</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 2 行 ：调用 <code>ClusterResolver#getClusterEndpoints()</code> 方法，获得 EndPoint 集群。再调用 <code>ResolverUtils#splitByZone(...)</code> 方法，拆分成<strong>本地</strong>和<strong>非本地</strong>的可用区的 EndPoint 集群，点击<a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-client/src/main/java/com/netflix/discovery/shared/resolver/ResolverUtils.java#L55" rel="external nofollow noopener noreferrer" target="_blank">链接</a>查看实现。</p></li><li><p>第 8 行 ：调用 <code>#randomizeAndMerge(...)</code> 方法，<strong>分别</strong>随机打乱<strong>每个</strong> EndPoint 集群，并进行<strong>合并</strong>数组，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ZoneAffinityClusterResolver.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;AwsEndpoint&gt; <span class="title">randomizeAndMerge</span><span class="params">(List&lt;AwsEndpoint&gt; myZoneEndpoints, List&lt;AwsEndpoint&gt; remainingEndpoints)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (myZoneEndpoints.isEmpty()) &#123;</div><div class="line">       <span class="keyword">return</span> ResolverUtils.randomize(remainingEndpoints); <span class="comment">// 打乱</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (remainingEndpoints.isEmpty()) &#123;</div><div class="line">       <span class="keyword">return</span> ResolverUtils.randomize(myZoneEndpoints); <span class="comment">// 打乱</span></div><div class="line">   &#125;</div><div class="line">   List&lt;AwsEndpoint&gt; mergedList = ResolverUtils.randomize(myZoneEndpoints); <span class="comment">// 打乱</span></div><div class="line">   mergedList.addAll(ResolverUtils.randomize(remainingEndpoints)); <span class="comment">// 打乱</span></div><div class="line">   <span class="keyword">return</span> mergedList;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ResolverUtils.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends EurekaEndpoint&gt; <span class="function">List&lt;T&gt; <span class="title">randomize</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</div><div class="line">   <span class="comment">// 数组大小为 0 或者 1 ，不进行打乱</span></div><div class="line">   List&lt;T&gt; randomList = <span class="keyword">new</span> ArrayList&lt;&gt;(list);</div><div class="line">   <span class="keyword">if</span> (randomList.size() &lt; <span class="number">2</span>) &#123;</div><div class="line">       <span class="keyword">return</span> randomList;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 以本地IP为随机种子，有如下好处：</span></div><div class="line">   <span class="comment">// 多个主机，实现对同一个 EndPoint 集群负载均衡的效果。</span></div><div class="line">   <span class="comment">// 单个主机，同一个 EndPoint 集群按照固定顺序访问。Eureka-Server 不是强一致性的注册中心，Eureka-Client 对同一个 Eureka-Server 拉取注册信息，保证两者之间增量同步的一致性。</span></div><div class="line">   Random random = <span class="keyword">new</span> Random(LOCAL_IPV4_ADDRESS.hashCode());</div><div class="line">   <span class="keyword">int</span> last = randomList.size() - <span class="number">1</span>;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; last; i++) &#123;</div><div class="line">       <span class="keyword">int</span> pos = random.nextInt(randomList.size() - i);</div><div class="line">       <span class="keyword">if</span> (pos != i) &#123;</div><div class="line">           Collections.swap(randomList, i, pos);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> randomList;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><strong>注意，<code>ResolverUtils#randomize(...)</code> 使用以本机IP为随机种子</strong>，有如下好处：<ul><li>多个主机，实现对同一个 EndPoint 集群负载均衡的效果。</li><li>单个主机，同一个 EndPoint 集群按照固定顺序访问。Eureka-Server 不是强一致性的注册中心，Eureka-Client 对同一个 Eureka-Server 拉取注册信息，保证两者之间增量同步的一致性。</li></ul></li></ul></li><li><p>第 10 至 12 行 ：非可用区亲和，将非本地的可用区的 EndPoint 集群放在前面。</p></li></ul><h2>3.6 AsyncResolver</h2><p><code>com.netflix.discovery.shared.resolver.AsyncResolver</code> ，<strong>异步执行</strong>解析的集群解析器。AsyncResolver 属性较多，而且复杂的多，我们拆分到具体方法里分享。</p><h3>3.6.1 定时任务</h3><p>AsyncResolver 内置定时任务，<strong>定时</strong>刷新 EndPoint 集群解析结果。</p><p><strong>为什么要刷新</strong>？例如，Eureka-Server 的 <code>serviceUrls</code> 基于 DNS 配置。</p><p><strong>定时任务代码如下</strong>：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 是否已经调度定时任务 &#123;<span class="doctag">@link</span> #updateTask&#125;</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean scheduled = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 委托的解析器</span></div><div class="line"><span class="comment">* 目前代码为 &#123;<span class="doctag">@link</span> com.netflix.discovery.shared.resolver.aws.ZoneAffinityClusterResolver&#125;</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClusterResolver&lt;T&gt; delegate;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 定时服务</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService executorService;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 线程池执行器</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor threadPoolExecutor;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 后台任务</span></div><div class="line"><span class="comment">* 定时解析 EndPoint 集群</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> TimedSupervisorTask backgroundTask;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 解析 EndPoint 集群结果</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;List&lt;T&gt;&gt; resultsRef;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 定时解析 EndPoint 集群的频率</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> refreshIntervalMs;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 预热超时时间，单位：毫秒</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> warmUpTimeoutMs;</div><div class="line"></div><div class="line"><span class="comment">// Metric timestamp, tracking last time when data were effectively changed.</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastLoadTimestamp = -<span class="number">1</span>;</div><div class="line"></div><div class="line">AsyncResolver(String name,</div><div class="line">             ClusterResolver&lt;T&gt; delegate,</div><div class="line">             List&lt;T&gt; initialValue,</div><div class="line">             <span class="keyword">int</span> executorThreadPoolSize,</div><div class="line">             <span class="keyword">int</span> refreshIntervalMs,</div><div class="line">             <span class="keyword">int</span> warmUpTimeoutMs) &#123;</div><div class="line">   <span class="keyword">this</span>.name = name;</div><div class="line">   <span class="keyword">this</span>.delegate = delegate;</div><div class="line">   <span class="keyword">this</span>.refreshIntervalMs = refreshIntervalMs;</div><div class="line">   <span class="keyword">this</span>.warmUpTimeoutMs = warmUpTimeoutMs;</div><div class="line"></div><div class="line">   <span class="comment">// 初始化 定时服务</span></div><div class="line">   <span class="keyword">this</span>.executorService = Executors.newScheduledThreadPool(<span class="number">1</span>, <span class="comment">// 线程大小=1</span></div><div class="line">           <span class="keyword">new</span> ThreadFactoryBuilder()</div><div class="line">                   .setNameFormat(<span class="string">"AsyncResolver-"</span> + name + <span class="string">"-%d"</span>)</div><div class="line">                   .setDaemon(<span class="keyword">true</span>)</div><div class="line">                   .build());</div><div class="line"></div><div class="line">   <span class="comment">// 初始化 线程池执行器</span></div><div class="line">   <span class="keyword">this</span>.threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</div><div class="line">           <span class="number">1</span>, <span class="comment">// 线程大小=1</span></div><div class="line">           executorThreadPoolSize, <span class="number">0</span>, TimeUnit.SECONDS,</div><div class="line">           <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),  <span class="comment">// use direct handoff</span></div><div class="line">           <span class="keyword">new</span> ThreadFactoryBuilder()</div><div class="line">                   .setNameFormat(<span class="string">"AsyncResolver-"</span> + name + <span class="string">"-executor-%d"</span>)</div><div class="line">                   .setDaemon(<span class="keyword">true</span>)</div><div class="line">                   .build()</div><div class="line">   );</div><div class="line"></div><div class="line">   <span class="comment">// 初始化 后台任务</span></div><div class="line">   <span class="keyword">this</span>.backgroundTask = <span class="keyword">new</span> TimedSupervisorTask(</div><div class="line">           <span class="keyword">this</span>.getClass().getSimpleName(),</div><div class="line">           executorService,</div><div class="line">           threadPoolExecutor,</div><div class="line">           refreshIntervalMs,</div><div class="line">           TimeUnit.MILLISECONDS,</div><div class="line">           <span class="number">5</span>,</div><div class="line">           updateTask</div><div class="line">   );</div><div class="line"></div><div class="line">   <span class="keyword">this</span>.resultsRef = <span class="keyword">new</span> AtomicReference&lt;&gt;(initialValue);</div><div class="line">   Monitors.registerObject(name, <span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><code>backgroundTask</code> ，后台任务，定时解析 EndPoint 集群。<ul><li><p>TimedSupervisorTask ，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-renew/?self">《Eureka 源码解析 —— 应用实例注册发现（二）之续租》「2.3 TimedSupervisorTask」</a> 有详细解析。</p></li><li><p><code>updateTask</code> 实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable updateTask = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            List&lt;T&gt; newList = delegate.getClusterEndpoints(); <span class="comment">// 调用 委托的解析器 解析 EndPoint 集群</span></div><div class="line">            <span class="keyword">if</span> (newList != <span class="keyword">null</span>) &#123;</div><div class="line">                resultsRef.getAndSet(newList);</div><div class="line">                lastLoadTimestamp = System.currentTimeMillis();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                logger.warn(<span class="string">"Delegate returned null list of cluster endpoints"</span>);</div><div class="line">            &#125;</div><div class="line">            logger.debug(<span class="string">"Resolved to &#123;&#125;"</span>, newList);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            logger.warn(<span class="string">"Failed to retrieve cluster endpoints from the delegate"</span>, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><ul><li><code>delegate</code> ，委托的解析器，目前代码为 ZoneAffinityClusterResolver。</li></ul></li><li><p>后台任务的<strong>发起</strong>在 <code>#getClusterEndpoints()</code> 方法，在 <a href="#">「3.6.2 解析 EndPoint 集群」</a> 详细解析。</p></li></ul></li></ul><h3>3.6.2 解析 EndPoint 集群</h3><p>调用 <code>#getClusterEndpoints()</code> 方法，解析 EndPoint 集群，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getClusterEndpoints</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="keyword">long</span> delay = refreshIntervalMs;</div><div class="line"> <span class="number">4</span>:     <span class="comment">// 若未预热解析 EndPoint 集群结果，进行预热</span></div><div class="line"> <span class="number">5</span>:     <span class="keyword">if</span> (warmedUp.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</div><div class="line"> <span class="number">6</span>:         <span class="keyword">if</span> (!doWarmUp()) &#123;</div><div class="line"> <span class="number">7</span>:             delay = <span class="number">0</span>; <span class="comment">// 预热失败，取消定时任务的第一次延迟</span></div><div class="line"> <span class="number">8</span>:         &#125;</div><div class="line"> <span class="number">9</span>:     &#125;</div><div class="line"><span class="number">10</span>:     <span class="comment">// 若未调度定时任务，进行调度</span></div><div class="line"><span class="number">11</span>:     <span class="keyword">if</span> (scheduled.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</div><div class="line"><span class="number">12</span>:         scheduleTask(delay);</div><div class="line"><span class="number">13</span>:     &#125;</div><div class="line"><span class="number">14</span>:     <span class="comment">// 返回 EndPoint 集群</span></div><div class="line"><span class="number">15</span>:     <span class="keyword">return</span> resultsRef.get();</div><div class="line"><span class="number">16</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 5 至 9 行 ：<strong>若未预热解析 EndPoint 集群结果</strong>，调用 <code>#doWarmUp()</code> 方法，进行预热。若预热失败，取消定时任务的第一次延迟。<code>#doWarmUp()</code> 方法实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">doWarmUp</span><span class="params">()</span> </span>&#123;</div><div class="line">   Future future = <span class="keyword">null</span>;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       future = threadPoolExecutor.submit(updateTask);</div><div class="line">       future.get(warmUpTimeoutMs, TimeUnit.MILLISECONDS);  <span class="comment">// block until done or timeout</span></div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">       logger.warn(<span class="string">"Best effort warm up failed"</span>, e);</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       <span class="keyword">if</span> (future != <span class="keyword">null</span>) &#123;</div><div class="line">           future.cancel(<span class="keyword">true</span>);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>调用 <code>updateTask</code> ，解析 EndPoint 集群。</li></ul></li><li><p>第 10 至 13 行 ： <strong>若未调度定时任务，进行调度</strong>，调用 <code>#scheduleTask()</code> 方法，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTask</span><span class="params">(<span class="keyword">long</span> delay)</span> </span>&#123;</div><div class="line">   executorService.schedule(backgroundTask, delay, TimeUnit.MILLISECONDS);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>x</li></ul></li><li><p>第 15 行 ：返回 EndPoint 集群。<strong>当第一次预热失败，会返回空，直到定时任务获得到结果</strong>。</p></li></ul><h1>4. 初始化解析器</h1><p>Eureka-Client 在初始化时，调用 <code>DiscoveryClient#scheduleServerEndpointTask()</code> 方法，初始化 AsyncResolver 解析器。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleServerEndpointTask</span><span class="params">(EurekaTransport eurekaTransport,</span></span></div><div class="line"><span class="function"><span class="params">                                            AbstractDiscoveryClientOptionalArgs args)</span> </span>&#123;</div><div class="line">                                            </div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line"></div><div class="line">   <span class="comment">// 创建 EndPoint 解析器</span></div><div class="line">   eurekaTransport.bootstrapResolver = EurekaHttpClients.newBootstrapResolver(</div><div class="line">           clientConfig,</div><div class="line">           transportConfig,</div><div class="line">           eurekaTransport.transportClientFactory,</div><div class="line">           applicationInfoManager.getInfo(),</div><div class="line">           applicationsSource</div><div class="line">   );</div><div class="line">   </div><div class="line">   <span class="comment">// ... 省略无关代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p>调用 <code>EurekaHttpClients#newBootstrapResolver(...)</code> 方法，创建 EndPoint 解析器，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String COMPOSITE_BOOTSTRAP_STRATEGY = <span class="string">"composite"</span>;</div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClosableResolver&lt;AwsEndpoint&gt; <span class="title">newBootstrapResolver</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">4</span>:         <span class="keyword">final</span> EurekaClientConfig clientConfig,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">5</span>:         <span class="keyword">final</span> EurekaTransportConfig transportConfig,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">6</span>:         <span class="keyword">final</span> TransportClientFactory transportClientFactory,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">7</span>:         <span class="keyword">final</span> InstanceInfo myInstanceInfo,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">8</span>:         <span class="keyword">final</span> ApplicationsResolver.ApplicationsSource applicationsSource)</span></span></div><div class="line"><span class="function"> 9: </span>&#123;</div><div class="line"><span class="number">10</span>:     <span class="keyword">if</span> (COMPOSITE_BOOTSTRAP_STRATEGY.equals(transportConfig.getBootstrapResolverStrategy())) &#123;</div><div class="line"><span class="number">11</span>:         <span class="keyword">if</span> (clientConfig.shouldFetchRegistry()) &#123;</div><div class="line"><span class="number">12</span>:             <span class="keyword">return</span> compositeBootstrapResolver(</div><div class="line"><span class="number">13</span>:                     clientConfig,</div><div class="line"><span class="number">14</span>:                     transportConfig,</div><div class="line"><span class="number">15</span>:                     transportClientFactory,</div><div class="line"><span class="number">16</span>:                     myInstanceInfo,</div><div class="line"><span class="number">17</span>:                     applicationsSource</div><div class="line"><span class="number">18</span>:             );</div><div class="line"><span class="number">19</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">20</span>:             logger.warn(<span class="string">"Cannot create a composite bootstrap resolver if registry fetch is disabled."</span> +</div><div class="line"><span class="number">21</span>:                     <span class="string">" Falling back to using a default bootstrap resolver."</span>);</div><div class="line"><span class="number">22</span>:         &#125;</div><div class="line"><span class="number">23</span>:     &#125;</div><div class="line"><span class="number">24</span>: </div><div class="line"><span class="number">25</span>:     <span class="comment">// if all else fails, return the default</span></div><div class="line"><span class="number">26</span>:     <span class="keyword">return</span> defaultBootstrapResolver(clientConfig, myInstanceInfo);</div><div class="line"><span class="number">27</span>: &#125;</div><div class="line"><span class="number">28</span>: </div><div class="line"><span class="number">29</span>: <span class="comment">/**</span></div><div class="line"><span class="comment">30:  * <span class="doctag">@return</span> a bootstrap resolver that resolves eureka server endpoints based on either DNS or static config,</span></div><div class="line"><span class="comment">31:  *         depending on configuration for one or the other. This resolver will warm up at the start.</span></div><div class="line"><span class="comment">32:  */</span></div><div class="line"><span class="number">33</span>: <span class="function"><span class="keyword">static</span> ClosableResolver&lt;AwsEndpoint&gt; <span class="title">defaultBootstrapResolver</span><span class="params">(<span class="keyword">final</span> EurekaClientConfig clientConfig,</span></span></div><div class="line"><span class="function"><span class="params"><span class="number">34</span>:                                                               <span class="keyword">final</span> InstanceInfo myInstanceInfo)</span> </span>&#123;</div><div class="line"><span class="number">35</span>:     <span class="comment">// 获得 可用区集合</span></div><div class="line"><span class="number">36</span>:     String[] availZones = clientConfig.getAvailabilityZones(clientConfig.getRegion());</div><div class="line"><span class="number">37</span>:     <span class="comment">// 获得 应用实例的 可用区</span></div><div class="line"><span class="number">38</span>:     String myZone = InstanceInfo.getZone(availZones, myInstanceInfo);</div><div class="line"><span class="number">39</span>: </div><div class="line"><span class="number">40</span>:     <span class="comment">// 创建 ZoneAffinityClusterResolver</span></div><div class="line"><span class="number">41</span>:     ClusterResolver&lt;AwsEndpoint&gt; delegateResolver = <span class="keyword">new</span> ZoneAffinityClusterResolver(</div><div class="line"><span class="number">42</span>:             <span class="keyword">new</span> ConfigClusterResolver(clientConfig, myInstanceInfo),</div><div class="line"><span class="number">43</span>:             myZone,</div><div class="line"><span class="number">44</span>:             <span class="keyword">true</span></div><div class="line"><span class="number">45</span>:     );</div><div class="line"><span class="number">46</span>: </div><div class="line"><span class="number">47</span>:     <span class="comment">// 第一次 EndPoint 解析</span></div><div class="line"><span class="number">48</span>:     List&lt;AwsEndpoint&gt; initialValue = delegateResolver.getClusterEndpoints();</div><div class="line"><span class="number">49</span>: </div><div class="line"><span class="number">50</span>:     <span class="comment">// 解析不到 Eureka-Server EndPoint ，快速失败</span></div><div class="line"><span class="number">51</span>:     <span class="keyword">if</span> (initialValue.isEmpty()) &#123;</div><div class="line"><span class="number">52</span>:         String msg = <span class="string">"Initial resolution of Eureka server endpoints failed. Check ConfigClusterResolver logs for more info"</span>;</div><div class="line"><span class="number">53</span>:         logger.error(msg);</div><div class="line"><span class="number">54</span>:         failFastOnInitCheck(clientConfig, msg);</div><div class="line"><span class="number">55</span>:     &#125;</div><div class="line"><span class="number">56</span>: </div><div class="line"><span class="number">57</span>:     <span class="comment">// 创建 AsyncResolver</span></div><div class="line"><span class="number">58</span>:     <span class="keyword">return</span> <span class="keyword">new</span> AsyncResolver&lt;&gt;(</div><div class="line"><span class="number">59</span>:             EurekaClientNames.BOOTSTRAP,</div><div class="line"><span class="number">60</span>:             delegateResolver,</div><div class="line"><span class="number">61</span>:             initialValue,</div><div class="line"><span class="number">62</span>:             <span class="number">1</span>,</div><div class="line"><span class="number">63</span>:             clientConfig.getEurekaServiceUrlPollIntervalSeconds() * <span class="number">1000</span></div><div class="line"><span class="number">64</span>:     );</div><div class="line"><span class="number">65</span>: &#125;</div></pre></td></tr></table></figure></p></li></ul><pre><code>* 第 10 至 23 行 ：组合解析器，用于 Eureka 1.x 对 Eureka 2.x 的兼容配置，暂时不需要了解。TODO[0028]写入集群和读取集群* 第 26 行 ：调用 `#defaultBootstrapResolver()` 方法，创建默认的解析器 AsyncResolver 。* 第 40 至 45 行 ：创建 ZoneAffinityClusterResolver 。在 ZoneAffinityClusterResolver 构造方法的参数，我们看到创建 ConfigClusterResolver 作为 `delegate` 参数。* 第 48 行 ：调用 `ZoneAffinityClusterResolver#getClusterEndpoints()` 方法，**第一次 Eureka-Server EndPoint 集群解析**。* 第 51 至 55 行 ：解析不到 Eureka-Server EndPoint 集群时，可以通过配置( `eureka.experimental.clientTransportFailFastOnInit=true` )，使 Eureka-Client 初始化失败。`#failFastOnInitCheck(...)` 方法，实现代码如下：    <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// potential future feature, guarding with experimental flag for now</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">failFastOnInitCheck</span><span class="params">(EurekaClientConfig clientConfig, String msg)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (<span class="string">"true"</span>.equals(clientConfig.getExperimental(<span class="string">"clientTransportFailFastOnInit"</span>))) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(msg);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>    * x</code></pre><ul><li><p>第 58 至 64 行 ：创建 AsyncResolver 。从代码上，我们可以看到，<code>AsyncResolver.resultsRef</code> 属性一开始已经用 <code>initialValue</code> 传递给 AsyncResolver 构造方法。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsyncResolver</span><span class="params">(String name,</span></span></div><div class="line"><span class="function"><span class="params">                      ClusterResolver&lt;T&gt; delegate,</span></span></div><div class="line"><span class="function"><span class="params">                      List&lt;T&gt; initialValues,</span></span></div><div class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> executorThreadPoolSize,</span></span></div><div class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> refreshIntervalMs)</span> </span>&#123;</div><div class="line">     <span class="keyword">this</span>(</div><div class="line">             name,</div><div class="line">             delegate,</div><div class="line">             initialValues,</div><div class="line">             executorThreadPoolSize,</div><div class="line">             refreshIntervalMs,</div><div class="line">             <span class="number">0</span></div><div class="line">     );</div><div class="line">    </div><div class="line">     <span class="comment">// 设置已经预热</span></div><div class="line">     warmedUp.set(<span class="keyword">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>x</li></ul></li></ul><h1>666. 彩蛋</h1><p>T T  一开始看解析器，没反应过来是委托设计模式，一脸懵逼+一脸懵逼+一脸懵逼。后面理顺了，发现超级奈斯( Nice ) 啊 ！！！！</p><p>胖友，你学会了么？</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/Eureka/end-point-and-resolver/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 Eureka 1.8.X 版本&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 任务批处理</title>
    <link href="http://www.iocoder.cn/Eureka/batch-tasks/"/>
    <id>http://www.iocoder.cn/Eureka/batch-tasks/</id>
    <published>2018-07-16T16:00:00.000Z</published>
    <updated>2017-10-17T14:06:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/Eureka/batch-tasks/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">2. 整体流程</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">3. 任务处理器</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">4. 创建任务分发器</a><ul><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">4.1 批量任务执行分发器</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">4.2 单任务执行分发器</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">5. 创建任务接收执行器</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">6. 创建任务执行器</a><ul><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">6.1 创建批量任务执行器</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">6.2 创建单任务执行器</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">6.3 工作线程抽象类</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">7. 网络通信整形器</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">8. 任务接收执行器【处理任务】</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">9. 任务接收线程【调度任务】</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">10. 任务执行器【执行任务】</a><ul><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">10.1 批量任务工作线程</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">10.2 单任务工作线程</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p>本文主要分享 <strong>任务批处理</strong>。Eureka-Server 集群通过任务批处理同步应用实例注册实例，所以本文也是为 Eureka-Server 集群同步的分享做铺垫。</p><p>本文涉及类在 <code>com.netflix.eureka.util.batcher</code> 包下，涉及到主体类的类图如下( <a href="http://www.iocoder.cn/images/Eureka/2018_07_17/02.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_07_17/02.png" alt=""></p><ul><li>紫色部分 —— 任务分发器</li><li>蓝色部分 —— 任务接收器</li><li>红色部分 —— 任务执行器</li><li>绿色部分 —— 任务处理器</li><li>黄色部分 —— 任务持有者( 任务 )</li></ul><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1>2. 整体流程</h1><p>任务执行的整体流程如下( <a href="http://www.iocoder.cn/images/Eureka/2018_07_17/01.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_07_17/01.png" alt=""></p><ul><li><p>细箭头 —— 任务执行经历的操作</p></li><li><p>粗箭头 —— 任务队列流转的方向</p></li><li><p><strong>不同于</strong>一般情况下，任务提交了<strong>立即</strong>同步或异步执行，任务的执行拆分了<strong>三层队列</strong>：</p><ul><li><p>第一层，接收队列( <code>acceptorQueue</code> )，重新处理队列( <code>reprocessQueue</code> )。</p><ul><li>蓝线：分发器在收到任务执行请求后，提交到接收队列，<strong>任务实际未执行</strong>。</li><li>黄线：执行器的工作线程处理任务失败，将符合条件( 见 <a href="#">「3. 任务处理器」</a> )的失败任务提交到重新执行队列。</li></ul></li><li><p>第二层，待执行队列( <code>processingOrder</code> )</p><ul><li>粉线：接收线程( Runner )将重新执行队列，接收队列提交到待执行队列。</li></ul></li><li><p>第三层，工作队列( <code>workQueue</code> )</p><ul><li>粉线：接收线程( Runner )将待执行队列的任务根据参数( <code>maxBatchingSize</code> )将任务合并成<strong>批量任务</strong>，调度( 提交 )到工作队列。</li><li>黄线：执行器的工作线程<strong>池</strong>，一个工作线程可以拉取一个<strong>批量任务</strong>进行执行。</li></ul></li></ul></li><li><p><strong>三层队列的好处</strong>：</p><ul><li>接收队列，避免处理任务的阻塞等待。</li><li>接收线程( Runner )合并任务，将相同任务编号( <strong>是的，任务是带有编号的</strong> )的任务合并，只执行一次。</li><li>Eureka-Server 为集群同步提供批量操作<strong>多个</strong>应用实例的<strong>接口</strong>，一个<strong>批量任务</strong>可以一次调度接口完成，避免多次调用的开销。当然，这样做的前提是合并任务，这也导致 Eureka-Server 集群之间对应用实例的注册和下线带来更大的延迟。<strong>毕竟，Eureka 是在 CAP 之间，选择了 AP</strong>。</li></ul></li></ul><h1>3. 任务处理器</h1><p><code>com.netflix.eureka.util.batcher.TaskProcessor</code> ，任务处理器<strong>接口</strong>。接口代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TaskProcessor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * A processed task/task list ends up in one of the following states:</span></div><div class="line"><span class="comment">     * &lt;ul&gt;</span></div><div class="line"><span class="comment">     *     &lt;li&gt;&#123;<span class="doctag">@code</span> Success&#125; processing finished successfully&lt;/li&gt;</span></div><div class="line"><span class="comment">     *     &lt;li&gt;&#123;<span class="doctag">@code</span> TransientError&#125; processing failed, but shall be retried later&lt;/li&gt;</span></div><div class="line"><span class="comment">     *     &lt;li&gt;&#123;<span class="doctag">@code</span> PermanentError&#125; processing failed, and is non recoverable&lt;/li&gt;</span></div><div class="line"><span class="comment">     * &lt;/ul&gt;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">enum</span> ProcessingResult &#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 成功</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        Success,</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 拥挤错误</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        Congestion,</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 瞬时错误</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        TransientError,</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 永久错误</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        PermanentError</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 处理单任务</span></div><div class="line"><span class="comment">     * In non-batched mode a single task is processed at a time.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">ProcessingResult <span class="title">process</span><span class="params">(T task)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 处理批量任务</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * For batched mode a collection of tasks is run at a time. The result is provided for the aggregated result,</span></div><div class="line"><span class="comment">     * and all tasks are handled in the same way according to what is returned (for example are rescheduled, if the</span></div><div class="line"><span class="comment">     * error is transient).</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">ProcessingResult <span class="title">process</span><span class="params">(List&lt;T&gt; tasks)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>ProcessingResult ，处理任务结果。<ul><li><code>Success</code> ，成功。</li><li><code>Congestion</code> ，拥挤错误，<strong>任务将会被重试</strong>。例如，请求被限流。</li><li><code>TransientError</code> ，瞬时错误，<strong>任务将会被重试</strong>。例如，网络请求超时。</li><li><code>PermanentError</code> ，永久错误，<strong>任务将会被丢弃</strong>。例如，执行时发生程序异常。</li></ul></li><li><code>#process(task)</code> 方法，处理单任务。</li><li><code>#process(tasks)</code> 方法，处理批量任务。</li></ul><h1>4. 创建任务分发器</h1><p><code>com.netflix.eureka.util.batcher.TaskDispatcher</code> ，任务分发器<strong>接口</strong>。接口代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TaskDispatcher</span>&lt;<span class="title">ID</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(ID id, T task, <span class="keyword">long</span> expiryTime)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><code>#process(...)</code> 方法，提交任务编号，任务，任务过期时间给任务分发器处理。</li></ul><p><code>com.netflix.eureka.util.batcher.TaskDispatchers</code> ，任务分发器<strong>工厂类</strong>，用于创建任务分发器。其内部提供两种任务分发器的实现：</p><ul><li><strong>批量任务</strong>执行的分发器，用于 Eureka-Server 集群注册信息的同步任务。</li><li><strong>单任务</strong>执行的分发器，用于 Eureka-Server 向亚马逊 AWS 的 ASG ( Autoscaling Group ) 同步状态。虽然本系列暂时对 AWS 相关的不做解析，从工具类的角度来说，本文会对该分发器进行分享。</li></ul><p><code>com.netflix.eureka.cluster.ReplicationTaskProcessor</code> ，实现 TaskDispatcher ，Eureka-Server 集群任务处理器。感兴趣的同学，可以点击<a href="https://github.com/YunaiV/eureka/blob/6e1b694898aa2f4c155936420c2ce5850f142742/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a>自己研究，我们将在 <a href="http://www.iocoder.cn/Eureka/server-cluster/?self">《Eureka 源码解析 —— Eureka-Server 集群同步》</a> 有详细解析。</p><h2>4.1 批量任务执行分发器</h2><p>调用 <code>TaskDispatchers#createBatchingTaskDispatcher(...)</code> 方法，创建<strong>批量任务</strong>执行的分发器，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TaskDispatchers.java</span></div><div class="line">  <span class="number">1</span>: <span class="comment">/**</span></div><div class="line"><span class="comment">  2:  * 创建批量任务执行的分发器</span></div><div class="line"><span class="comment">  3:  *</span></div><div class="line"><span class="comment">  4:  * <span class="doctag">@param</span> id 任务执行器编号</span></div><div class="line"><span class="comment">  5:  * <span class="doctag">@param</span> maxBufferSize 待执行队列最大数量</span></div><div class="line"><span class="comment">  6:  * <span class="doctag">@param</span> workloadSize 单个批量任务包含任务最大数量</span></div><div class="line"><span class="comment">  7:  * <span class="doctag">@param</span> workerCount 任务执行器工作线程数</span></div><div class="line"><span class="comment">  8:  * <span class="doctag">@param</span> maxBatchingDelay 批量任务等待最大延迟时长，单位：毫秒</span></div><div class="line"><span class="comment">  9:  * <span class="doctag">@param</span> congestionRetryDelayMs 请求限流延迟重试时间，单位：毫秒</span></div><div class="line"><span class="comment"> 10:  * <span class="doctag">@param</span> networkFailureRetryMs 网络失败延迟重试时长，单位：毫秒</span></div><div class="line"><span class="comment"> 11:  * <span class="doctag">@param</span> taskProcessor 任务处理器</span></div><div class="line"><span class="comment"> 12:  * <span class="doctag">@param</span> &lt;ID&gt; 任务编号泛型</span></div><div class="line"><span class="comment"> 13:  * <span class="doctag">@param</span> &lt;T&gt; 任务泛型</span></div><div class="line"><span class="comment"> 14:  * <span class="doctag">@return</span> 批量任务执行的分发器</span></div><div class="line"><span class="comment"> 15:  */</span></div><div class="line"> <span class="number">16</span>: <span class="keyword">public</span> <span class="keyword">static</span> &lt;ID, T&gt; <span class="function">TaskDispatcher&lt;ID, T&gt; <span class="title">createBatchingTaskDispatcher</span><span class="params">(String id,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">17</span>:                                                                          <span class="keyword">int</span> maxBufferSize,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">18</span>:                                                                          <span class="keyword">int</span> workloadSize,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">19</span>:                                                                          <span class="keyword">int</span> workerCount,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">20</span>:                                                                          <span class="keyword">long</span> maxBatchingDelay,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">21</span>:                                                                          <span class="keyword">long</span> congestionRetryDelayMs,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">22</span>:                                                                          <span class="keyword">long</span> networkFailureRetryMs,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">23</span>:                                                                          TaskProcessor&lt;T&gt; taskProcessor)</span> </span>&#123;</div><div class="line"> <span class="number">24</span>:     <span class="comment">// 创建 任务接收执行器</span></div><div class="line"> <span class="number">25</span>:     <span class="keyword">final</span> AcceptorExecutor&lt;ID, T&gt; acceptorExecutor = <span class="keyword">new</span> AcceptorExecutor&lt;&gt;(</div><div class="line"> <span class="number">26</span>:             id, maxBufferSize, workloadSize, maxBatchingDelay, congestionRetryDelayMs, networkFailureRetryMs</div><div class="line"> <span class="number">27</span>:     );</div><div class="line"> <span class="number">28</span>:     <span class="comment">// 创建 批量任务执行器</span></div><div class="line"> <span class="number">29</span>:     <span class="keyword">final</span> TaskExecutors&lt;ID, T&gt; taskExecutor = TaskExecutors.batchExecutors(id, workerCount, taskProcessor, acceptorExecutor);</div><div class="line"> <span class="number">30</span>:     <span class="comment">// 创建 批量任务分发器</span></div><div class="line"> <span class="number">31</span>:     <span class="keyword">return</span> <span class="keyword">new</span> TaskDispatcher&lt;ID, T&gt;() &#123;</div><div class="line"> <span class="number">32</span>:         <span class="meta">@Override</span></div><div class="line"> <span class="number">33</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(ID id, T task, <span class="keyword">long</span> expiryTime)</span> </span>&#123;</div><div class="line"> <span class="number">34</span>:             acceptorExecutor.process(id, task, expiryTime);</div><div class="line"> <span class="number">35</span>:         &#125;</div><div class="line"> <span class="number">36</span>: </div><div class="line"> <span class="number">37</span>:         <span class="meta">@Override</span></div><div class="line"> <span class="number">38</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">39</span>:             acceptorExecutor.shutdown();</div><div class="line"> <span class="number">40</span>:             taskExecutor.shutdown();</div><div class="line"> <span class="number">41</span>:         &#125;</div><div class="line"> <span class="number">42</span>:     &#125;;</div><div class="line"> <span class="number">43</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 1 至 23 行 ：方法参数。比较多哈，请耐心理解。<ul><li><code>workloadSize</code> 参数，单个批量任务包含任务最大数量。</li><li><code>taskProcessor</code> 参数，<strong>自定义任务执行器实现</strong>。</li></ul></li><li>第 24 至 27 行 ：创建任务<strong>接收</strong>执行器。在 <a href="#">「5. 创建任务接收器」</a> 详细解析。</li><li>第 28 至 29 行 ：创建<strong>批量</strong>任务执行器。在 <a href="#">「6.1 创建批量任务执行器」</a> 详细解析。</li><li>第 30 至 42 行 ：创建<strong>批量</strong>任务分发器。<ul><li>第 32 至 35 行 ：<code>#process()</code> 方法的实现，调用 <code>AcceptorExecutor#process(...)</code> 方法，提交 [ 任务编号 , 任务 , 任务过期时间 ] 给任务分发器处理。</li></ul></li></ul><h2>4.2 单任务执行分发器</h2><p>调用 <code>TaskDispatchers#createNonBatchingTaskDispatcher(...)</code> 方法，创建<strong>单任务</strong>执行的分发器，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="comment">/**</span></div><div class="line"><span class="comment"> 2:  * 创建单任务执行的分发器</span></div><div class="line"><span class="comment"> 3:  *</span></div><div class="line"><span class="comment"> 4:  * <span class="doctag">@param</span> id 任务执行器编号</span></div><div class="line"><span class="comment"> 5:  * <span class="doctag">@param</span> maxBufferSize 待执行队列最大数量</span></div><div class="line"><span class="comment"> 6:  * <span class="doctag">@param</span> workerCount 任务执行器工作线程数</span></div><div class="line"><span class="comment"> 7:  * <span class="doctag">@param</span> maxBatchingDelay 批量任务等待最大延迟时长，单位：毫秒</span></div><div class="line"><span class="comment"> 8:  * <span class="doctag">@param</span> congestionRetryDelayMs 请求限流延迟重试时间，单位：毫秒</span></div><div class="line"><span class="comment"> 9:  * <span class="doctag">@param</span> networkFailureRetryMs 网络失败延迟重试时长，单位：毫秒</span></div><div class="line"><span class="comment">10:  * <span class="doctag">@param</span> taskProcessor 任务处理器</span></div><div class="line"><span class="comment">11:  * <span class="doctag">@param</span> &lt;ID&gt; 任务编号泛型</span></div><div class="line"><span class="comment">12:  * <span class="doctag">@param</span> &lt;T&gt; 任务泛型</span></div><div class="line"><span class="comment">13:  * <span class="doctag">@return</span> 单任务执行的分发器</span></div><div class="line"><span class="comment">14:  */</span></div><div class="line"><span class="number">15</span>: <span class="keyword">public</span> <span class="keyword">static</span> &lt;ID, T&gt; <span class="function">TaskDispatcher&lt;ID, T&gt; <span class="title">createNonBatchingTaskDispatcher</span><span class="params">(String id,</span></span></div><div class="line"><span class="function"><span class="params"><span class="number">16</span>:                                                                             <span class="keyword">int</span> maxBufferSize,</span></span></div><div class="line"><span class="function"><span class="params"><span class="number">17</span>:                                                                             <span class="keyword">int</span> workerCount,</span></span></div><div class="line"><span class="function"><span class="params"><span class="number">18</span>:                                                                             <span class="keyword">long</span> maxBatchingDelay,</span></span></div><div class="line"><span class="function"><span class="params"><span class="number">19</span>:                                                                             <span class="keyword">long</span> congestionRetryDelayMs,</span></span></div><div class="line"><span class="function"><span class="params"><span class="number">20</span>:                                                                             <span class="keyword">long</span> networkFailureRetryMs,</span></span></div><div class="line"><span class="function"><span class="params"><span class="number">21</span>:                                                                             TaskProcessor&lt;T&gt; taskProcessor)</span> </span>&#123;</div><div class="line"><span class="number">22</span>:     <span class="comment">// 创建 任务接收执行器</span></div><div class="line"><span class="number">23</span>:     <span class="keyword">final</span> AcceptorExecutor&lt;ID, T&gt; acceptorExecutor = <span class="keyword">new</span> AcceptorExecutor&lt;&gt;(</div><div class="line"><span class="number">24</span>:             id, maxBufferSize, <span class="comment">/* workloadSize = 1 */</span><span class="number">1</span>, maxBatchingDelay, congestionRetryDelayMs, networkFailureRetryMs</div><div class="line"><span class="number">25</span>:     );</div><div class="line"><span class="number">26</span>:     <span class="keyword">final</span> TaskExecutors&lt;ID, T&gt; taskExecutor = TaskExecutors.singleItemExecutors(id, workerCount, taskProcessor, acceptorExecutor);</div><div class="line"><span class="number">27</span>:     <span class="keyword">return</span> <span class="keyword">new</span> TaskDispatcher&lt;ID, T&gt;() &#123;</div><div class="line"><span class="number">28</span>:         <span class="meta">@Override</span></div><div class="line"><span class="number">29</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(ID id, T task, <span class="keyword">long</span> expiryTime)</span> </span>&#123;</div><div class="line"><span class="number">30</span>:             acceptorExecutor.process(id, task, expiryTime);</div><div class="line"><span class="number">31</span>:         &#125;</div><div class="line"><span class="number">32</span>: </div><div class="line"><span class="number">33</span>:         <span class="meta">@Override</span></div><div class="line"><span class="number">34</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">35</span>:             acceptorExecutor.shutdown();</div><div class="line"><span class="number">36</span>:             taskExecutor.shutdown();</div><div class="line"><span class="number">37</span>:         &#125;</div><div class="line"><span class="number">38</span>:     &#125;;</div><div class="line"><span class="number">39</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 1 至 21 行 ：方法参数。比较多哈，请耐心理解。<ul><li><s><code>workloadSize</code> 参数</s>，相比 <code>#createBatchingTaskDispatcher(...)</code> 少这个参数。<strong>在第 24 行，你会发现该参数传递给 AcceptorExecutor 使用 1 噢</strong>。</li><li><code>taskProcessor</code> 参数，<strong>自定义任务执行器实现</strong>。</li></ul></li><li>第 21 至 25 行 ：创建任务<strong>接收</strong>执行器。和 <code>#createBatchingTaskDispatcher(...)</code> 只差 <code>workloadSize = 1</code> 参数。在 <a href="#">「5. 创建任务接收器」</a> 详细解析。</li><li>第 28 至 29 行 ：创建<strong>单</strong>任务执行器。<strong>和 <code>#createBatchingTaskDispatcher(...)</code> 差别很大</strong>。<a href="#">「6.2 创建单任务执行器」</a> 详细解析。</li><li>第 30 至 42 行 ：创建<strong>单</strong>任务分发器。和 <code>#createBatchingTaskDispatcher(...)</code> 一样。</li></ul><h1>5. 创建任务接收执行器</h1><p><code>com.netflix.eureka.util.batcher.AcceptorExecutor</code> ，任务接收执行器。创建构造方法代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="class"><span class="keyword">class</span> <span class="title">AcceptorExecutor</span>&lt;<span class="title">ID</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>:     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AcceptorExecutor.class);</div><div class="line"> <span class="number">4</span>: </div><div class="line"> <span class="number">5</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment"> 6:      * 待执行队列最大数量</span></div><div class="line"><span class="comment"> 7:      * &#123;<span class="doctag">@link</span> #processingOrder&#125;</span></div><div class="line"><span class="comment"> 8:      */</span></div><div class="line"> <span class="number">9</span>:     <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxBufferSize;</div><div class="line"><span class="number">10</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">11:      * 单个批量任务包含任务最大数量</span></div><div class="line"><span class="comment">12:      */</span></div><div class="line"><span class="number">13</span>:     <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxBatchingSize;</div><div class="line"><span class="number">14</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">15:      * 批量任务等待最大延迟时长，单位：毫秒</span></div><div class="line"><span class="comment">16:      */</span></div><div class="line"><span class="number">17</span>:     <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxBatchingDelay;</div><div class="line"><span class="number">18</span>: </div><div class="line"><span class="number">19</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">20:      * 是否关闭</span></div><div class="line"><span class="comment">21:      */</span></div><div class="line"><span class="number">22</span>:     <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean isShutdown = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</div><div class="line"><span class="number">23</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">24:      * 接收任务队列</span></div><div class="line"><span class="comment">25:      */</span></div><div class="line"><span class="number">26</span>:     <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;TaskHolder&lt;ID, T&gt;&gt; acceptorQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class="line"><span class="number">27</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">28:      * 重新执行任务队列</span></div><div class="line"><span class="comment">29:      */</span></div><div class="line"><span class="number">30</span>:     <span class="keyword">private</span> <span class="keyword">final</span> BlockingDeque&lt;TaskHolder&lt;ID, T&gt;&gt; reprocessQueue = <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;();</div><div class="line"><span class="number">31</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">32:      * 接收任务线程</span></div><div class="line"><span class="comment">33:      */</span></div><div class="line"><span class="number">34</span>:     <span class="keyword">private</span> <span class="keyword">final</span> Thread acceptorThread;</div><div class="line"><span class="number">35</span>: </div><div class="line"><span class="number">36</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">37:      * 待执行任务映射</span></div><div class="line"><span class="comment">38:      */</span></div><div class="line"><span class="number">39</span>:     <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ID, TaskHolder&lt;ID, T&gt;&gt; pendingTasks = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"><span class="number">40</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">41:      * 待执行队列</span></div><div class="line"><span class="comment">42:      */</span></div><div class="line"><span class="number">43</span>:     <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;ID&gt; processingOrder = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line"><span class="number">44</span>: </div><div class="line"><span class="number">45</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">46:      * 单任务工作请求信号量</span></div><div class="line"><span class="comment">47:      */</span></div><div class="line"><span class="number">48</span>:     <span class="keyword">private</span> <span class="keyword">final</span> Semaphore singleItemWorkRequests = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</div><div class="line"><span class="number">49</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">50:      * 单任务工作队列</span></div><div class="line"><span class="comment">51:      */</span></div><div class="line"><span class="number">52</span>:     <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;TaskHolder&lt;ID, T&gt;&gt; singleItemWorkQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class="line"><span class="number">53</span>: </div><div class="line"><span class="number">54</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">55:      * 批量任务工作请求信号量</span></div><div class="line"><span class="comment">56:      */</span></div><div class="line"><span class="number">57</span>:     <span class="keyword">private</span> <span class="keyword">final</span> Semaphore batchWorkRequests = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</div><div class="line"><span class="number">58</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">59:      * 批量任务工作队列</span></div><div class="line"><span class="comment">60:      */</span></div><div class="line"><span class="number">61</span>:     <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;List&lt;TaskHolder&lt;ID, T&gt;&gt;&gt; batchWorkQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class="line"><span class="number">62</span>: </div><div class="line"><span class="number">63</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">64:      * 网络通信整形器</span></div><div class="line"><span class="comment">65:      */</span></div><div class="line"><span class="number">66</span>:     <span class="keyword">private</span> <span class="keyword">final</span> TrafficShaper trafficShaper;</div><div class="line"><span class="number">67</span>: </div><div class="line"><span class="number">68</span>:     AcceptorExecutor(String id,</div><div class="line"><span class="number">69</span>:                      <span class="keyword">int</span> maxBufferSize,</div><div class="line"><span class="number">70</span>:                      <span class="keyword">int</span> maxBatchingSize,</div><div class="line"><span class="number">71</span>:                      <span class="keyword">long</span> maxBatchingDelay,</div><div class="line"><span class="number">72</span>:                      <span class="keyword">long</span> congestionRetryDelayMs,</div><div class="line"><span class="number">73</span>:                      <span class="keyword">long</span> networkFailureRetryMs) &#123;</div><div class="line"><span class="number">74</span>:         <span class="keyword">this</span>.maxBufferSize = maxBufferSize;</div><div class="line"><span class="number">75</span>:         <span class="keyword">this</span>.maxBatchingSize = maxBatchingSize;</div><div class="line"><span class="number">76</span>:         <span class="keyword">this</span>.maxBatchingDelay = maxBatchingDelay;</div><div class="line"><span class="number">77</span>: </div><div class="line"><span class="number">78</span>:         <span class="comment">// 创建 网络通信整形器</span></div><div class="line"><span class="number">79</span>:         <span class="keyword">this</span>.trafficShaper = <span class="keyword">new</span> TrafficShaper(congestionRetryDelayMs, networkFailureRetryMs);</div><div class="line"><span class="number">80</span>: </div><div class="line"><span class="number">81</span>:         <span class="comment">// 创建 接收任务线程</span></div><div class="line"><span class="number">82</span>:         ThreadGroup threadGroup = <span class="keyword">new</span> ThreadGroup(<span class="string">"eurekaTaskExecutors"</span>);</div><div class="line"><span class="number">83</span>:         <span class="keyword">this</span>.acceptorThread = <span class="keyword">new</span> Thread(threadGroup, <span class="keyword">new</span> AcceptorRunner(), <span class="string">"TaskAcceptor-"</span> + id);</div><div class="line"><span class="number">84</span>:         <span class="keyword">this</span>.acceptorThread.setDaemon(<span class="keyword">true</span>);</div><div class="line"><span class="number">85</span>:         <span class="keyword">this</span>.acceptorThread.start();</div><div class="line"><span class="number">86</span>: </div><div class="line"><span class="number">87</span>:         <span class="comment">// TODO （省略代码）芋艿：监控相关，暂时无视</span></div><div class="line"><span class="number">88</span>:     &#125;</div><div class="line"><span class="number">89</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 5 至 61 行 ：属性。比较多哈，请耐心理解。<ul><li>眼尖如你，会发现 AcceptorExecutor 即存在单任务工作队列( <code>singleItemWorkQueue</code> )，又存在批量任务工作队列( <code>batchWorkQueue</code> ) ，在 <a href="#">「9. 任务接收线程【调度任务】」</a> 会解答这个疑惑。</li></ul></li><li>第 78 至 79 行 ：创建网络通信整形器。在 <a href="#">「7. 网络通信整形器」</a> 详细解析。</li><li>第 81 至 85 行 ：<strong>创建接收任务线程</strong>。</li></ul><h1>6. 创建任务执行器</h1><p><code>com.netflix.eureka.util.batcher.TaskExecutors</code> ，任务执行器。<strong>其内部提供创建单任务和批量任务执行器的两种方法</strong>。TaskExecutors 构造方法如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskExecutors</span>&lt;<span class="title">ID</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(TaskExecutors.class);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 是否关闭</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean isShutdown;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 工作线程池</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Thread&gt; workerThreads;</div><div class="line"></div><div class="line">    TaskExecutors(WorkerRunnableFactory&lt;ID, T&gt; workerRunnableFactory, <span class="keyword">int</span> workerCount, AtomicBoolean isShutdown) &#123;</div><div class="line">        <span class="keyword">this</span>.isShutdown = isShutdown;</div><div class="line">        <span class="keyword">this</span>.workerThreads = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="comment">// 创建 工作线程池</span></div><div class="line">        ThreadGroup threadGroup = <span class="keyword">new</span> ThreadGroup(<span class="string">"eurekaTaskExecutors"</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; workerCount; i++) &#123;</div><div class="line">            WorkerRunnable&lt;ID, T&gt; runnable = workerRunnableFactory.create(i);</div><div class="line">            Thread workerThread = <span class="keyword">new</span> Thread(threadGroup, runnable, runnable.getWorkerName());</div><div class="line">            workerThreads.add(workerThread);</div><div class="line">            workerThread.setDaemon(<span class="keyword">true</span>);</div><div class="line">            workerThread.start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 创建工作线程工厂</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;ID&gt; 任务编号泛型</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 批量任务执行器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">WorkerRunnableFactory</span>&lt;<span class="title">ID</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line">        <span class="function">WorkerRunnable&lt;ID, T&gt; <span class="title">create</span><span class="params">(<span class="keyword">int</span> idx)</span></span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><code>workerThreads</code> 属性，工作线程<strong>池</strong>。<strong>工作任务队列会被工作线程池并发拉取，并发执行</strong>。</li><li><code>com.netflix.eureka.util.batcher.TaskExecutors.WorkerRunnableFactory</code> ，创建工作线程工厂<strong>接口</strong>。单任务和批量任务执行器的工作线程实现不同，通过自定义工厂实现类创建。</li></ul><h2>6.1 创建批量任务执行器</h2><p>调用 <code>TaskExecutors#batchExecutors(...)</code> 方法，创建批量任务执行器。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 创建批量任务执行器</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> name 任务执行器名</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> workerCount 任务执行器工作线程数</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> processor 任务处理器</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> acceptorExecutor 接收任务执行器</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> &lt;ID&gt; 任务编号泛型</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> &lt;T&gt; 任务泛型</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 批量任务执行器</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">static</span> &lt;ID, T&gt; <span class="function">TaskExecutors&lt;ID, T&gt; <span class="title">batchExecutors</span><span class="params">(<span class="keyword">final</span> String name,</span></span></div><div class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> workerCount,</span></span></div><div class="line"><span class="function"><span class="params">                                                  <span class="keyword">final</span> TaskProcessor&lt;T&gt; processor,</span></span></div><div class="line"><span class="function"><span class="params">                                                  <span class="keyword">final</span> AcceptorExecutor&lt;ID, T&gt; acceptorExecutor)</span> </span>&#123;</div><div class="line">   <span class="keyword">final</span> AtomicBoolean isShutdown = <span class="keyword">new</span> AtomicBoolean();</div><div class="line">   <span class="keyword">final</span> TaskExecutorMetrics metrics = <span class="keyword">new</span> TaskExecutorMetrics(name);</div><div class="line">   <span class="comment">// 创建批量任务执行器</span></div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> TaskExecutors&lt;&gt;(<span class="keyword">new</span> WorkerRunnableFactory&lt;ID, T&gt;() &#123; <span class="comment">// 批量任务工作线程工厂</span></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> WorkerRunnable&lt;ID, T&gt; <span class="title">create</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">new</span> BatchWorkerRunnable&lt;&gt;(<span class="string">"TaskBatchingWorker-"</span> + name + <span class="string">'-'</span> + idx <span class="comment">/* 线程名 */</span>, isShutdown, metrics, processor, acceptorExecutor);</div><div class="line">       &#125;</div><div class="line">   &#125;, workerCount, isShutdown);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><code>com.netflix.eureka.util.batcher.TaskExecutors.WorkerRunnable.BatchWorkerRunnable</code> ，批量任务工作线程。</li></ul><h2>6.2 创建单任务执行器</h2><p>调用 <code>TaskExecutors#singleItemExecutors(...)</code> 方法，创建批量任务执行器。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 创建单任务执行器</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> name 任务执行器名</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> workerCount 任务执行器工作线程数</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> processor 任务处理器</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> acceptorExecutor 接收任务执行器</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> &lt;ID&gt; 任务编号泛型</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> &lt;T&gt; 任务泛型</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 单任务执行器</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">static</span> &lt;ID, T&gt; <span class="function">TaskExecutors&lt;ID, T&gt; <span class="title">singleItemExecutors</span><span class="params">(<span class="keyword">final</span> String name,</span></span></div><div class="line"><span class="function"><span class="params">                                                       <span class="keyword">int</span> workerCount,</span></span></div><div class="line"><span class="function"><span class="params">                                                       <span class="keyword">final</span> TaskProcessor&lt;T&gt; processor,</span></span></div><div class="line"><span class="function"><span class="params">                                                       <span class="keyword">final</span> AcceptorExecutor&lt;ID, T&gt; acceptorExecutor)</span> </span>&#123;</div><div class="line">   <span class="keyword">final</span> AtomicBoolean isShutdown = <span class="keyword">new</span> AtomicBoolean();</div><div class="line">   <span class="keyword">final</span> TaskExecutorMetrics metrics = <span class="keyword">new</span> TaskExecutorMetrics(name);</div><div class="line">   <span class="comment">// 创建单任务执行器</span></div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> TaskExecutors&lt;&gt;(<span class="keyword">new</span> WorkerRunnableFactory&lt;ID, T&gt;() &#123; <span class="comment">// 单任务工作线程工厂</span></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> WorkerRunnable&lt;ID, T&gt; <span class="title">create</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">new</span> SingleTaskWorkerRunnable&lt;&gt;(<span class="string">"TaskNonBatchingWorker-"</span> + name + <span class="string">'-'</span> + idx <span class="comment">/* 线程名 */</span>, isShutdown, metrics, processor, acceptorExecutor);</div><div class="line">       &#125;</div><div class="line">   &#125;, workerCount, isShutdown);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><code>com.netflix.eureka.util.batcher.TaskExecutors.WorkerRunnable.SingleTaskWorkerRunnable</code> ，单任务工作线程。</li></ul><h2>6.3 工作线程抽象类</h2><p><code>com.netflix.eureka.util.batcher.TaskExecutors.WorkerRunnable</code> ，任务工作线程抽象类。BatchWorkerRunnable 和 SingleTaskWorkerRunnable 都实现该类，差异在 <code>#run()</code> 的自定义实现。WorkerRunnable 实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerRunnable</span>&lt;<span class="title">ID</span>, <span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 线程名</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">final</span> String workerName;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 是否关闭</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">final</span> AtomicBoolean isShutdown;</div><div class="line">   <span class="keyword">final</span> TaskExecutorMetrics metrics;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 任务处理器</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">final</span> TaskProcessor&lt;T&gt; processor;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 任务接收执行器</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">final</span> AcceptorExecutor&lt;ID, T&gt; taskDispatcher;</div><div class="line">   </div><div class="line">   <span class="comment">// ... 省略构造方法和 getting 方法。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h1>7. 网络通信整形器</h1><p><code>com.netflix.eureka.util.batcher.TrafficShaper</code> ，网络通信整形器。当任务执行发生请求限流，或是请求网络失败的情况，则延时 AcceptorRunner 将任务提交到工作任务队列，从而避免任务很快去执行，再次发生上述情况。TrafficShaper 实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrafficShaper</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Upper bound on delay provided by configuration.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MAX_DELAY = <span class="number">30</span> * <span class="number">1000</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 请求限流延迟重试时间，单位：毫秒</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> congestionRetryDelayMs;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 网络失败延迟重试时长，单位：毫秒</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> networkFailureRetryMs;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 最后请求限流时间戳，单位：毫秒</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastCongestionError;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 最后网络失败时间戳，单位：毫秒</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastNetworkFailure;</div><div class="line"></div><div class="line">    TrafficShaper(<span class="keyword">long</span> congestionRetryDelayMs, <span class="keyword">long</span> networkFailureRetryMs) &#123;</div><div class="line">        <span class="keyword">this</span>.congestionRetryDelayMs = Math.min(MAX_DELAY, congestionRetryDelayMs);</div><div class="line">        <span class="keyword">this</span>.networkFailureRetryMs = Math.min(MAX_DELAY, networkFailureRetryMs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerFailure</span><span class="params">(ProcessingResult processingResult)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (processingResult == ProcessingResult.Congestion) &#123;</div><div class="line">            lastCongestionError = System.currentTimeMillis();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (processingResult == ProcessingResult.TransientError) &#123;</div><div class="line">            lastNetworkFailure = System.currentTimeMillis();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 计算提交延迟，单位：毫秒</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 延迟</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">long</span> <span class="title">transmissionDelay</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 无延迟</span></div><div class="line">        <span class="keyword">if</span> (lastCongestionError == -<span class="number">1</span> &amp;&amp; lastNetworkFailure == -<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line"></div><div class="line">        <span class="comment">// 计算最后请求限流带来的延迟</span></div><div class="line">        <span class="keyword">if</span> (lastCongestionError != -<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">long</span> congestionDelay = now - lastCongestionError;</div><div class="line">            <span class="keyword">if</span> (congestionDelay &gt;= <span class="number">0</span> &amp;&amp; congestionDelay &lt; congestionRetryDelayMs) &#123; <span class="comment">// 范围内</span></div><div class="line">                <span class="keyword">return</span> congestionRetryDelayMs - congestionDelay; <span class="comment">// 补充延迟</span></div><div class="line">            &#125;</div><div class="line">            lastCongestionError = -<span class="number">1</span>; <span class="comment">// 重置时间戳</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 计算最后网络失败带来的延迟</span></div><div class="line">        <span class="keyword">if</span> (lastNetworkFailure != -<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">long</span> failureDelay = now - lastNetworkFailure;</div><div class="line">            <span class="keyword">if</span> (failureDelay &gt;= <span class="number">0</span> &amp;&amp; failureDelay &lt; networkFailureRetryMs) &#123; <span class="comment">// 范围内</span></div><div class="line">                <span class="keyword">return</span> networkFailureRetryMs - failureDelay; <span class="comment">// 补充延迟</span></div><div class="line">            &#125;</div><div class="line">            lastNetworkFailure = -<span class="number">1</span>; <span class="comment">// 重置时间戳</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 无延迟</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><code>#registerFailure(...)</code> ，在任务执行失败时，提交任务结果给 TrafficShaper ，记录发生时间。在 <a href="#">「10. 任务执行器【执行任务】」</a> 会看到调用该方法。</li><li><code>#transmissionDelay(...)</code> ，计算提交延迟，单位：毫秒。<a href="#">「9. 任务接收线程【调度任务】」</a> 会看到调用该方法。</li></ul><h1>8. 任务接收执行器【处理任务】</h1><p>调用 <code>AcceptorExecutor#process(...)</code> 方法，添加任务到接收任务队列。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AcceptorExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(ID id, T task, <span class="keyword">long</span> expiryTime)</span> </span>&#123;</div><div class="line">   acceptorQueue.add(<span class="keyword">new</span> TaskHolder&lt;ID, T&gt;(id, task, expiryTime));</div><div class="line">   acceptedTasks++;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><p><code>com.netflix.eureka.util.batcher.TaskHolder</code> ，任务持有者，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskHolder</span>&lt;<span class="title">ID</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 任务编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ID id;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 任务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T task;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 任务过期时间戳</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> expiryTime;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 任务提交时间戳</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> submitTimestamp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li></ul><h1>9. 任务接收线程【调度任务】</h1><p>后台线程执行 <code>AcceptorRunner#run(...)</code> 方法，调度任务。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="keyword">long</span> scheduleTime = <span class="number">0</span>;</div><div class="line"> <span class="number">4</span>:     <span class="keyword">while</span> (!isShutdown.get()) &#123;</div><div class="line"> <span class="number">5</span>:         <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">6</span>:             <span class="comment">// 处理完输入队列( 接收队列 + 重新执行队列 )</span></div><div class="line"> <span class="number">7</span>:             drainInputQueues();</div><div class="line"> <span class="number">8</span>: </div><div class="line"> <span class="number">9</span>:             <span class="comment">// 待执行任务数量</span></div><div class="line"><span class="number">10</span>:             <span class="keyword">int</span> totalItems = processingOrder.size();</div><div class="line"><span class="number">11</span>: </div><div class="line"><span class="number">12</span>:             <span class="comment">// 计算调度时间</span></div><div class="line"><span class="number">13</span>:             <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line"><span class="number">14</span>:             <span class="keyword">if</span> (scheduleTime &lt; now) &#123;</div><div class="line"><span class="number">15</span>:                 scheduleTime = now + trafficShaper.transmissionDelay();</div><div class="line"><span class="number">16</span>:             &#125;</div><div class="line"><span class="number">17</span>: </div><div class="line"><span class="number">18</span>:             <span class="comment">// 调度</span></div><div class="line"><span class="number">19</span>:             <span class="keyword">if</span> (scheduleTime &lt;= now) &#123;</div><div class="line"><span class="number">20</span>:                 <span class="comment">// 调度批量任务</span></div><div class="line"><span class="number">21</span>:                 assignBatchWork();</div><div class="line"><span class="number">22</span>:                 <span class="comment">// 调度单任务</span></div><div class="line"><span class="number">23</span>:                 assignSingleItemWork();</div><div class="line"><span class="number">24</span>:             &#125;</div><div class="line"><span class="number">25</span>: </div><div class="line"><span class="number">26</span>:             <span class="comment">// 1）任务执行器无任务请求，正在忙碌处理之前的任务；或者 2）任务延迟调度。睡眠 10 秒，避免资源浪费。</span></div><div class="line"><span class="number">27</span>:             <span class="comment">// If no worker is requesting data or there is a delay injected by the traffic shaper,</span></div><div class="line"><span class="number">28</span>:             <span class="comment">// sleep for some time to avoid tight loop.</span></div><div class="line"><span class="number">29</span>:             <span class="keyword">if</span> (totalItems == processingOrder.size()) &#123;</div><div class="line"><span class="number">30</span>:                 Thread.sleep(<span class="number">10</span>);</div><div class="line"><span class="number">31</span>:             &#125;</div><div class="line"><span class="number">32</span>:         &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</div><div class="line"><span class="number">33</span>:             <span class="comment">// Ignore</span></div><div class="line"><span class="number">34</span>:         &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"><span class="number">35</span>:             <span class="comment">// Safe-guard, so we never exit this loop in an uncontrolled way.</span></div><div class="line"><span class="number">36</span>:             logger.warn(<span class="string">"Discovery AcceptorThread error"</span>, e);</div><div class="line"><span class="number">37</span>:         &#125;</div><div class="line"><span class="number">38</span>:     &#125;</div><div class="line"><span class="number">39</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 4 行 ：无限循环执行调度，直到关闭。</p></li><li><p>第 6 至 7 行 ：调用 <code>#drainInputQueues()</code> 方法，<strong>循环</strong>处理完输入队列( 接收队列 + 重新执行队列 )，<strong>直到</strong>有待执行的任务。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drainInputQueues</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="keyword">do</span> &#123;</div><div class="line"> <span class="number">3</span>:         <span class="comment">// 处理完重新执行队列</span></div><div class="line"> <span class="number">4</span>:         drainReprocessQueue();</div><div class="line"> <span class="number">5</span>:         <span class="comment">// 处理完接收队列</span></div><div class="line"> <span class="number">6</span>:         drainAcceptorQueue();</div><div class="line"> <span class="number">7</span>: </div><div class="line"> <span class="number">8</span>:         <span class="comment">// 所有队列为空，等待 10 ms，看接收队列是否有新任务</span></div><div class="line"> <span class="number">9</span>:         <span class="keyword">if</span> (!isShutdown.get()) &#123;</div><div class="line"><span class="number">10</span>:             <span class="comment">// If all queues are empty, block for a while on the acceptor queue</span></div><div class="line"><span class="number">11</span>:             <span class="keyword">if</span> (reprocessQueue.isEmpty() &amp;&amp; acceptorQueue.isEmpty() &amp;&amp; pendingTasks.isEmpty()) &#123;</div><div class="line"><span class="number">12</span>:                 TaskHolder&lt;ID, T&gt; taskHolder = acceptorQueue.poll(<span class="number">10</span>, TimeUnit.MILLISECONDS);</div><div class="line"><span class="number">13</span>:                 <span class="keyword">if</span> (taskHolder != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">14</span>:                     appendTaskHolder(taskHolder);</div><div class="line"><span class="number">15</span>:                 &#125;</div><div class="line"><span class="number">16</span>:             &#125;</div><div class="line"><span class="number">17</span>:         &#125;</div><div class="line"><span class="number">18</span>:     &#125; <span class="keyword">while</span> (!reprocessQueue.isEmpty() || !acceptorQueue.isEmpty() || pendingTasks.isEmpty()); <span class="comment">// 处理完输入队列( 接收队列 + 重新执行队列 )</span></div><div class="line"><span class="number">19</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 2 行 &amp;&amp; 第 18 行 ：<strong>循环</strong>，直到<strong>同时</strong>满足如下全部条件：</p><ul><li>重新执行队列( <code>reprocessQueue</code> ) 和接收队列( <code>acceptorQueue</code> )为空</li><li>待执行任务映射( <code>pendingTasks</code> )<strong>不为空</strong></li></ul></li><li><p>第 3 至 4 行 ：处理完重新执行队列( <code>reprocessQueue</code> )。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drainReprocessQueue</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line"> <span class="number">3</span>:     <span class="keyword">while</span> (!reprocessQueue.isEmpty() &amp;&amp; !isFull()) &#123;</div><div class="line"> <span class="number">4</span>:         TaskHolder&lt;ID, T&gt; taskHolder = reprocessQueue.pollLast(); <span class="comment">// 优先拿较新的任务</span></div><div class="line"> <span class="number">5</span>:         ID id = taskHolder.getId();</div><div class="line"> <span class="number">6</span>:         <span class="keyword">if</span> (taskHolder.getExpiryTime() &lt;= now) &#123; <span class="comment">// 过期</span></div><div class="line"> <span class="number">7</span>:             expiredTasks++;</div><div class="line"> <span class="number">8</span>:         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pendingTasks.containsKey(id)) &#123; <span class="comment">// 已存在</span></div><div class="line"> <span class="number">9</span>:             overriddenTasks++;</div><div class="line"><span class="number">10</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">11</span>:             pendingTasks.put(id, taskHolder);</div><div class="line"><span class="number">12</span>:             processingOrder.addFirst(id); <span class="comment">// 提交到队头</span></div><div class="line"><span class="number">13</span>:         &#125;</div><div class="line"><span class="number">14</span>:     &#125;</div><div class="line"><span class="number">15</span>:     <span class="comment">// 如果待执行队列已满，清空重新执行队列，放弃较早的任务</span></div><div class="line"><span class="number">16</span>:     <span class="keyword">if</span> (isFull()) &#123;</div><div class="line"><span class="number">17</span>:         queueOverflows += reprocessQueue.size();</div><div class="line"><span class="number">18</span>:         reprocessQueue.clear();</div><div class="line"><span class="number">19</span>:     &#125;</div><div class="line"><span class="number">20</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li>第 4 行 ：优先从重新执行任务的队尾拿较新的任务，从而实现保留更新的任务在待执行任务映射( <code>pendingTasks</code> ) 里。</li><li>第 12 行 ：添加任务编号到待执行队列( <code>processingOrder</code> ) 的头部。效果如下图：<img src="http://www.iocoder.cn/images/Eureka/2018_07_17/03.png" alt=""></li><li>第 15 至 18 行 ：如果待执行队列( <code>pendingTasks</code> )已满，清空重新执行队列( <code>processingOrder</code> )，放弃较早的任务。</li></ul></li><li><p>第 5 至 6 行 ：处理完接收队列( <code>acceptorQueue</code> )，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drainAcceptorQueue</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">while</span> (!acceptorQueue.isEmpty()) &#123; <span class="comment">// 循环，直到接收队列为空</span></div><div class="line">      appendTaskHolder(acceptorQueue.poll());</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendTaskHolder</span><span class="params">(TaskHolder&lt;ID, T&gt; taskHolder)</span> </span>&#123;</div><div class="line">  <span class="comment">// 如果待执行队列已满，移除待处理队列，放弃较早的任务</span></div><div class="line">  <span class="keyword">if</span> (isFull()) &#123;</div><div class="line">      pendingTasks.remove(processingOrder.poll());</div><div class="line">      queueOverflows++;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 添加到待执行队列</span></div><div class="line">  TaskHolder&lt;ID, T&gt; previousTask = pendingTasks.put(taskHolder.getId(), taskHolder);</div><div class="line">  <span class="keyword">if</span> (previousTask == <span class="keyword">null</span>) &#123;</div><div class="line">      processingOrder.add(taskHolder.getId());</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">      overriddenTasks++;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li><li><p>第 8 至 17 行 ：当所有队列为空，阻塞从接收队列( <code>acceptorQueue</code> ) 拉取任务 10 ms。若拉取到，添加到待执行队列( <code>processingOrder</code> )。</p></li></ul></li><li><p>第 12 至 16 行 ：计算可调度任务的最小时间( <code>scheduleTime</code> )。</p><ul><li>当 <code>scheduleTime</code> 小于当前时间，不重新计算，即此时需要延迟等待调度。</li><li>当 <code>scheduleTime</code> 大于等于当前时间，配合 <code>TrafficShaper#transmissionDelay(...)</code> 重新计算。</li></ul></li><li><p>第 19 行 ：当 <code>scheduleTime</code> 小于当前时间，执行任务的调度。</p></li><li><p>第 21 行 ：调用 <code>#assignBatchWork()</code> 方法，调度批量任务。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">void</span> <span class="title">assignBatchWork</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="keyword">if</span> (hasEnoughTasksForNextBatch()) &#123;</div><div class="line"> <span class="number">3</span>:         <span class="comment">// 获取 批量任务工作请求信号量</span></div><div class="line"> <span class="number">4</span>:         <span class="keyword">if</span> (batchWorkRequests.tryAcquire(<span class="number">1</span>)) &#123;</div><div class="line"> <span class="number">5</span>:             <span class="comment">// 获取批量任务</span></div><div class="line"> <span class="number">6</span>:             <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line"> <span class="number">7</span>:             <span class="keyword">int</span> len = Math.min(maxBatchingSize, processingOrder.size());</div><div class="line"> <span class="number">8</span>:             List&lt;TaskHolder&lt;ID, T&gt;&gt; holders = <span class="keyword">new</span> ArrayList&lt;&gt;(len);</div><div class="line"> <span class="number">9</span>:             <span class="keyword">while</span> (holders.size() &lt; len &amp;&amp; !processingOrder.isEmpty()) &#123;</div><div class="line"><span class="number">10</span>:                 ID id = processingOrder.poll();</div><div class="line"><span class="number">11</span>:                 TaskHolder&lt;ID, T&gt; holder = pendingTasks.remove(id);</div><div class="line"><span class="number">12</span>:                 <span class="keyword">if</span> (holder.getExpiryTime() &gt; now) &#123; <span class="comment">// 过期</span></div><div class="line"><span class="number">13</span>:                     holders.add(holder);</div><div class="line"><span class="number">14</span>:                 &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">15</span>:                     expiredTasks++;</div><div class="line"><span class="number">16</span>:                 &#125;</div><div class="line"><span class="number">17</span>:             &#125;</div><div class="line"><span class="number">18</span>:             <span class="comment">//</span></div><div class="line"><span class="number">19</span>:             <span class="keyword">if</span> (holders.isEmpty()) &#123; <span class="comment">// 未调度到批量任务，释放请求信号量</span></div><div class="line"><span class="number">20</span>:                 batchWorkRequests.release();</div><div class="line"><span class="number">21</span>:             &#125; <span class="keyword">else</span> &#123; <span class="comment">// 添加批量任务到批量任务工作队列</span></div><div class="line"><span class="number">22</span>:                 batchSizeMetric.record(holders.size(), TimeUnit.MILLISECONDS);</div><div class="line"><span class="number">23</span>:                 batchWorkQueue.add(holders);</div><div class="line"><span class="number">24</span>:             &#125;</div><div class="line"><span class="number">25</span>:         &#125;</div><div class="line"><span class="number">26</span>:     &#125;</div><div class="line"><span class="number">27</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 2 行 ：调用 <code>#hasEnoughTasksForNextBatch()</code> 方法，判断是否有足够任务进行下一次批量任务调度：1）待执行任务( <code>processingOrder</code> )映射已满；或者 2）到达批量任务处理最大等待延迟。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasEnoughTasksForNextBatch</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 待执行队列为空</span></div><div class="line">    <span class="keyword">if</span> (processingOrder.isEmpty()) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 待执行任务映射已满</span></div><div class="line">    <span class="keyword">if</span> (pendingTasks.size() &gt;= maxBufferSize) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 到达批量任务处理最大等待延迟( 通过待处理队列的头部任务判断 )</span></div><div class="line">    TaskHolder&lt;ID, T&gt; nextHolder = pendingTasks.get(processingOrder.peek());</div><div class="line">    <span class="keyword">long</span> delay = System.currentTimeMillis() - nextHolder.getSubmitTimestamp();</div><div class="line">    <span class="keyword">return</span> delay &gt;= maxBatchingDelay;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>x</li></ul></li><li><p>第 5 至 17 行 ：获取批量任务( <code>holders</code> )。😈 你会发现，本文说了半天的批量任务，实际是 <code>List&lt;TaskHolder&lt;ID, T&gt;&gt;</code> 哈。</p></li><li><p>第 4 行 ：获取批量任务工作请求信号量( <code>batchWorkRequests</code> ) 。在任务执行器的批量任务执行器，每次执行时，发出 <code>batchWorkRequests</code> 。<strong>每一个信号量需要保证获取到一个批量任务</strong>。</p></li><li><p>第 19 至 20 行 ：未调度到批量任务，释放请求信号量，<strong>代表请求实际未完成，每一个信号量需要保证获取到一个批量任务</strong>。</p></li><li><p>第 21 至 24 行 ：添加批量任务到批量任务工作队列。</p></li><li><p>第 23 行 ：调用 <code>#assignSingleItemWork()</code> 方法，调度单任务。</p></li></ul></li><li><p>第 23 行 ：调用 <code>#assignSingleItemWork()</code> 方法，调度单任务，和 <code>#assignBatchWork()</code> 方法<strong>类似</strong>。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">assignSingleItemWork</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!processingOrder.isEmpty()) &#123; <span class="comment">// 待执行任队列不为空</span></div><div class="line">      <span class="comment">// 获取 单任务工作请求信号量</span></div><div class="line">      <span class="keyword">if</span> (singleItemWorkRequests.tryAcquire(<span class="number">1</span>)) &#123;</div><div class="line">          <span class="comment">// 【循环】获取单任务</span></div><div class="line">          <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line">          <span class="keyword">while</span> (!processingOrder.isEmpty()) &#123;</div><div class="line">              ID id = processingOrder.poll(); <span class="comment">// 一定不为空</span></div><div class="line">              TaskHolder&lt;ID, T&gt; holder = pendingTasks.remove(id);</div><div class="line">              <span class="keyword">if</span> (holder.getExpiryTime() &gt; now) &#123;</div><div class="line">                  singleItemWorkQueue.add(holder);</div><div class="line">                  <span class="keyword">return</span>;</div><div class="line">              &#125;</div><div class="line">              expiredTasks++;</div><div class="line">          &#125;</div><div class="line">          <span class="comment">// 获取不到单任务，释放请求信号量</span></div><div class="line">          singleItemWorkRequests.release();</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>x</li></ul></li><li><p>第 26 至 31 行 ：当调度任务前的待执行任务数( <code>totalItems</code> )等于当前待执行队列( <code>processingOrder</code> )的任务数，意味着：1）任务执行器无任务请求，正在忙碌处理之前的任务；或者 2）任务延迟调度。睡眠 10 秒，避免资源浪费。</p></li></ul><h1>10. 任务执行器【执行任务】</h1><h2>10.1 批量任务工作线程</h2><p>批量任务工作后台线程( BatchWorkerRunnable )执行 <code>#run(...)</code> 方法，调度任务。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// </span></div><div class="line">  <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line">  <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="number">3</span>:     <span class="keyword">try</span> &#123;</div><div class="line">  <span class="number">4</span>:         <span class="keyword">while</span> (!isShutdown.get()) &#123;</div><div class="line">  <span class="number">5</span>:             <span class="comment">// 获取批量任务</span></div><div class="line">  <span class="number">6</span>:             List&lt;TaskHolder&lt;ID, T&gt;&gt; holders = getWork();</div><div class="line">  <span class="number">7</span>: </div><div class="line">  <span class="number">8</span>:             <span class="comment">// TODO 芋艿：监控相关，暂时无视</span></div><div class="line">  <span class="number">9</span>:             metrics.registerExpiryTimes(holders);</div><div class="line"> <span class="number">10</span>: </div><div class="line"> <span class="number">11</span>:             <span class="comment">// 获得实际批量任务</span></div><div class="line"> <span class="number">12</span>:             List&lt;T&gt; tasks = getTasksOf(holders);</div><div class="line"> <span class="number">13</span>:             <span class="comment">// 调用处理器执行任务</span></div><div class="line"> <span class="number">14</span>:             ProcessingResult result = processor.process(tasks);</div><div class="line"> <span class="number">15</span>:             <span class="keyword">switch</span> (result) &#123;</div><div class="line"> <span class="number">16</span>:                 <span class="keyword">case</span> Success:</div><div class="line"> <span class="number">17</span>:                     <span class="keyword">break</span>;</div><div class="line"> <span class="number">18</span>:                 <span class="keyword">case</span> Congestion:</div><div class="line"> <span class="number">19</span>:                 <span class="keyword">case</span> TransientError:</div><div class="line"> <span class="number">20</span>:                     taskDispatcher.reprocess(holders, result); <span class="comment">// 提交重新处理</span></div><div class="line"> <span class="number">21</span>:                     <span class="keyword">break</span>;</div><div class="line"> <span class="number">22</span>:                 <span class="keyword">case</span> PermanentError:</div><div class="line"> <span class="number">23</span>:                     logger.warn(<span class="string">"Discarding &#123;&#125; tasks of &#123;&#125; due to permanent error"</span>, holders.size(), workerName);</div><div class="line"> <span class="number">24</span>:             &#125;</div><div class="line"> <span class="number">25</span>: </div><div class="line"> <span class="number">26</span>:             <span class="comment">// TODO 芋艿：监控相关，暂时无视</span></div><div class="line"> <span class="number">27</span>:             metrics.registerTaskResult(result, tasks.size());</div><div class="line"> <span class="number">28</span>:         &#125;</div><div class="line"> <span class="number">29</span>:     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line"> <span class="number">30</span>:         <span class="comment">// Ignore</span></div><div class="line"> <span class="number">31</span>:     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"> <span class="number">32</span>:         <span class="comment">// Safe-guard, so we never exit this loop in an uncontrolled way.</span></div><div class="line"> <span class="number">33</span>:         logger.warn(<span class="string">"Discovery WorkerThread error"</span>, e);</div><div class="line"> <span class="number">34</span>:     &#125;</div><div class="line"> <span class="number">35</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 4 行 ：无限循环执行调度，直到关闭。</p></li><li><p>第 6 行 ：调用 <code>getWork()</code> 方法，获取<strong>一个</strong>批量任务直到成功。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">private</span> List&lt;TaskHolder&lt;ID, T&gt;&gt; getWork() <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// 发起请求信号量，并获得批量任务的工作队列</span></div><div class="line"> <span class="number">3</span>:     BlockingQueue&lt;List&lt;TaskHolder&lt;ID, T&gt;&gt;&gt; workQueue = taskDispatcher.requestWorkItems();</div><div class="line"> <span class="number">4</span>:     <span class="comment">// 【循环】获取批量任务，直到成功</span></div><div class="line"> <span class="number">5</span>:     List&lt;TaskHolder&lt;ID, T&gt;&gt; result;</div><div class="line"> <span class="number">6</span>:     <span class="keyword">do</span> &#123;</div><div class="line"> <span class="number">7</span>:         result = workQueue.poll(<span class="number">1</span>, TimeUnit.SECONDS);</div><div class="line"> <span class="number">8</span>:     &#125; <span class="keyword">while</span> (!isShutdown.get() &amp;&amp; result == <span class="keyword">null</span>);</div><div class="line"> <span class="number">9</span>:     <span class="keyword">return</span> result;</div><div class="line"><span class="number">10</span>: &#125;</div></pre></td></tr></table></figure></p><ul><li><p>第 3 行 ：调用 <code>TaskDispatcher#requestWorkItems()</code> 方法，发起请求信号量，并获得批量任务的工作队列。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TaskDispatcher.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 批量任务工作请求信号量</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Semaphore batchWorkRequests = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 批量任务工作队列</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;List&lt;TaskHolder&lt;ID, T&gt;&gt;&gt; batchWorkQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class="line"></div><div class="line">BlockingQueue&lt;List&lt;TaskHolder&lt;ID, T&gt;&gt;&gt; requestWorkItems() &#123;</div><div class="line">   batchWorkRequests.release();</div><div class="line">   <span class="keyword">return</span> batchWorkQueue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><strong>注意</strong>，批量任务工作队列( <code>batchWorkQueue</code> ) 和单任务工作队列( <code>singleItemWorkQueue</code> ) 是<strong>不同的队列</strong>。</li></ul></li><li><p>第 5 至 8 行 ：<strong>循环</strong>获取<strong>一个</strong>批量任务，直到成功。</p></li></ul></li><li><p>第 12 行 ：调用 <code>#getTasksOf(...)</code> 方法，获得<strong>实际</strong>批量任务。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> List&lt;T&gt; <span class="title">getTasksOf</span><span class="params">(List&lt;TaskHolder&lt;ID, T&gt;&gt; holders)</span> </span>&#123;</div><div class="line">    List&lt;T&gt; tasks = <span class="keyword">new</span> ArrayList&lt;&gt;(holders.size());</div><div class="line">    <span class="keyword">for</span> (TaskHolder&lt;ID, T&gt; holder : holders) &#123;</div><div class="line">        tasks.add(holder.getTask());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> tasks;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>x</li></ul></li><li><p>第 14 至 24 行 ：调用处理器( TaskProcessor ) 执行任务。当任务执行结果为 <code>Congestion</code> 或 <code>TransientError</code> ，调用 <code>AcceptorExecutor#reprocess(...)</code> 提交<strong>整个批量任务</strong>重新处理，实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AcceptorExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">reprocess</span><span class="params">(List&lt;TaskHolder&lt;ID, T&gt;&gt; holders, ProcessingResult processingResult)</span> </span>&#123;</div><div class="line">   <span class="comment">// 添加到 重新执行队列</span></div><div class="line">   reprocessQueue.addAll(holders);</div><div class="line"></div><div class="line">   <span class="comment">// TODO 芋艿：监控相关，暂时无视</span></div><div class="line">   replayedTasks += holders.size();</div><div class="line">   </div><div class="line">   <span class="comment">// 提交任务结果给 TrafficShaper</span></div><div class="line">   trafficShaper.registerFailure(processingResult);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></li></ul><h2>10.2 单任务工作线程</h2><p>单任务工作后台线程( SingleTaskWorkerRunnable )执行 <code>#run(...)</code> 方法，调度任务，和 <code>BatchWorkerRunnable#run(...)</code> 基本类似，就不啰嗦了。实现代码如下：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="comment">// SingleTaskWorkerRunnable.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">while</span> (!isShutdown.get()) &#123;</div><div class="line">          <span class="comment">// 发起请求信号量，并获得单任务的工作队列</span></div><div class="line">          BlockingQueue&lt;TaskHolder&lt;ID, T&gt;&gt; workQueue = taskDispatcher.requestWorkItem();</div><div class="line">          TaskHolder&lt;ID, T&gt; taskHolder;</div><div class="line">          <span class="comment">// 【循环】获取单任务，直到成功</span></div><div class="line">          <span class="keyword">while</span> ((taskHolder = workQueue.poll(<span class="number">1</span>, TimeUnit.SECONDS)) == <span class="keyword">null</span>) &#123;</div><div class="line">              <span class="keyword">if</span> (isShutdown.get()) &#123;</div><div class="line">                  <span class="keyword">return</span>;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">          <span class="comment">// TODO 芋艿：监控相关，暂时无视</span></div><div class="line">          metrics.registerExpiryTime(taskHolder);</div><div class="line">          <span class="keyword">if</span> (taskHolder != <span class="keyword">null</span>) &#123;</div><div class="line">              <span class="comment">// 调用处理器执行任务</span></div><div class="line">              ProcessingResult result = processor.process(taskHolder.getTask());</div><div class="line">              <span class="keyword">switch</span> (result) &#123;</div><div class="line">                  <span class="keyword">case</span> Success:</div><div class="line">                      <span class="keyword">break</span>;</div><div class="line">                  <span class="keyword">case</span> Congestion:</div><div class="line">                  <span class="keyword">case</span> TransientError:</div><div class="line">                      taskDispatcher.reprocess(taskHolder, result); <span class="comment">// 提交重新处理</span></div><div class="line">                      <span class="keyword">break</span>;</div><div class="line">                  <span class="keyword">case</span> PermanentError:</div><div class="line">                      logger.warn(<span class="string">"Discarding a task of &#123;&#125; due to permanent error"</span>, workerName);</div><div class="line">              &#125;</div><div class="line">              <span class="comment">// TODO 芋艿：监控相关，暂时无视</span></div><div class="line">              metrics.registerTaskResult(result, <span class="number">1</span>);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">      <span class="comment">// Ignore</span></div><div class="line">  &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">      <span class="comment">// Safe-guard, so we never exit this loop in an uncontrolled way.</span></div><div class="line">      logger.warn(<span class="string">"Discovery WorkerThread error"</span>, e);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h1>666. 彩蛋</h1><p>😈 又是一篇长文。建议边看代码，边对照着整体流程图，理解实际不难。</p><p>当然，欢迎你有任何疑问，在我的公众号( <strong>芋道源码</strong> ) 留言。</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/Eureka/batch-tasks/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要基于 Eureka 1.8.X 版本&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a hre
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— Eureka源码解析 —— 应用实例注册发现 （九）之岁月是把萌萌的读写锁</title>
    <link href="http://www.iocoder.cn/Eureka/instance-registry-read-write-lock/"/>
    <id>http://www.iocoder.cn/Eureka/instance-registry-read-write-lock/</id>
    <published>2018-07-13T16:00:00.000Z</published>
    <updated>2017-10-20T01:19:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 http://www.iocoder.cn/Eureka/instance-registry-read-write-lock/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-read-write-lock/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-read-write-lock/">2. 读写锁</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-read-write-lock/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p>本文主要分享 <strong>Eureka 注册中心的那把读写锁</strong>，让我瘙痒难耐，却不得其解。在某次意外的抠脚的一刻( 笔者不抽烟，如果抽烟的话，此处应该就不是抠脚了 )，突然顿悟，爽，这好比... 比喻有点猥琐，笔者就省略 100 字。</p><p>不瞎比比，上代码：</p><p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractInstanceRegistry</span> <span class="keyword">implements</span> <span class="title">InstanceRegistry</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock read = readWriteLock.readLock();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock write = readWriteLock.writeLock();</div><div class="line"></div><div class="line">    <span class="comment">// ... 省略其他代码</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1>2. 读写锁</h1><p>我们把设计到读写锁的方法整理如下：</p><table><thead><tr><th>方法</th><th>读锁</th><th>写锁</th><th>不使用</th></tr></thead><tbody><tr><td><code>#register(...)</code></td><td>√</td><td></td><td></td></tr><tr><td><code>#cancel(...)</code></td><td>√</td><td></td><td></td></tr><tr><td><code>#evict(...)</code></td><td>√</td><td></td><td></td></tr><tr><td><code>#renew(...)</code></td><td></td><td></td><td>√</td></tr><tr><td><code>#statusUpdate(...)</code></td><td>√</td><td></td><td></td></tr><tr><td><code>#deleteStatusOverride(...)</code></td><td>√</td><td></td><td></td></tr><tr><td><code>#getApplicationDeltasFromMultipleRegions(...)</code></td><td></td><td>√</td><td></td></tr><tr><td><code>#getApplicationsFromMultipleRegions(...)</code></td><td></td><td></td><td>√</td></tr></tbody></table><p>是否看到这读写感到几丝诡异的味道？OK，我们把问题梳理如下：</p><ul><li>A. 为什么 <code>#register(...)</code> / <code>#cancel(...)</code> / <code>#evict(...)</code> / <code>#statusUpdate(...)</code> / <code>#deleteStatusOverride(...)</code> 等<strong>写操作</strong>使用<strong>读锁</strong></li><li>B. 为什么 <code>#renew(...)</code> <strong>写操作</strong>不使用<strong>锁</strong></li><li>C. 为什么 <code>#getApplicationDeltasFromMultipleRegions(...)</code> <strong>读操作</strong>使用<strong>写锁</strong></li><li>D. 为什么 <code>getApplicationsFromMultipleRegions(...)</code> <strong>读操作</strong>不使用<strong>锁</strong></li></ul><hr><p><strong>先解释 A + C</strong> ：</p><p>我们来回想下，在 Eureka 应用集合一致性哈希码的公式：<code>appsHashCode = ${status}_${count}_</code> 。( 不了解的同学可以加载下 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">《Eureka 源码解析 —— 应用实例注册发现（七）之增量获取》「 2. 应用集合一致性哈希码 」</a> )</p><p><s>应用实例的数量和状态都会影响<strong>哈希码</strong>的计算结果。也就是说，上述<strong>前六个</strong>( 包括不使用锁的 <code>#renew(...)</code> 方法 )方法的调用都会影响哈希码。</s></p><p>我们把目光移向唯一使用<strong>写锁</strong>的 <code>#getApplicationDeltasFromMultipleRegions(...)</code> 方法，该方法执行过程中，需要保证 <code>recentlyChangedQueue</code> 和 <code>registry</code> 共享变量的<strong>应用实例的状态一致</strong>，不然返回的增量应用实例集合的状态是不准确的。此时能够达到该效果，必须让 <code>#getApplicationDeltasFromMultipleRegions(...)</code> 和前六个方法<strong>互斥</strong>。方案如下：</p><ul><li>a. 全部 <code>synchronized</code></li><li>b. <code>#getApplicationDeltasFromMultipleRegions(...)</code> 使用<strong>读锁</strong>，前六个方法使用<strong>写锁</strong></li><li>c. <code>#getApplicationDeltasFromMultipleRegions(...)</code> 使用<strong>写锁</strong>，前六个方法使用<strong>读锁</strong></li></ul><p>Eureka 选择了<strong>方案c</strong>，原因如下：</p><ul><li>a. 性能太差</li><li>b. 前六个方法使用<strong>写锁</strong>，势必冲突太大，虽然读肯定比写多。</li><li>c. <code>#getApplicationDeltasFromMultipleRegions(...)</code> 使用<strong>写锁</strong>，配合 ResponseCache ，即减少了<strong>写锁</strong>使用的频率，每次缓存过期才使用，又避免了前六个方法因为<strong>方案b</strong>中的<strong>写锁</strong>导致互斥。( 不了解 ResponseCache 的同学可以加载下 <a href="hhttp://www.iocoder.cn/Eureka/instance-registry-fetch-all/">《Eureka 源码解析 —— 应用实例注册发现（六）之全量获取》「 3.2 响应缓存 ResponseCache 」</a> )</li></ul><hr><p><strong>再解释 D</strong></p><p><code>#getApplicationsFromMultipleRegions(...)</code> 方法的逻辑，只依赖 <code>registry</code> 共享变量，不存在应用实例的状态一致的困扰，所以不使用锁。</p><hr><p><strong>最后解释 B</strong></p><p><code>#renew(...)</code> 方法的逻辑，虽然会影响应用实例的状态，但是是极小概率，考虑到它调用的比较频繁，比起因为锁给这个方法带来的性能降低，不如返回的结果暂时不够准确。( 想了解极小概率发生原因的同学可以加载 <a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/?self">《Eureka 源码解析 —— 应用实例注册发现（八）之覆盖状态》「 4.3 续租场景 」</a> )</p><hr><p>TODO [0029] 读写锁</p><p>笔者路上突然又想了问题，可能不是上述原因，可能和 ResponseCache 有关系，参见 <code>#invalidateCache(...)</code> 方法的每次调用。也就是说，这个读写锁是针对 ResponseCache 的读写锁。</p><h1>666. 彩蛋</h1><p>开森 ！</p><p>本来以为需要跟 Eureka 官方提交 issue 提问，并且做好了获得不到答案的准备，结果无意中的抠脚( 请允许我热爱抠脚给我带来的灵感 )解答了自己的疑惑。</p><p>岁月是把纠结而又萌萌哒的锁，你不知道你的困扰，哪天不经意的被打开。</p><p>愿大喜大悲，不枉仅知的这一生。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 http://www.iocoder.cn/Eureka/instance-registry-read-write-lock/ 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.iocoder.cn/
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
</feed>
