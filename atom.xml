<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>芋道源码 —— 纯源码解析BLOG</title>
  
  <subtitle>愿半生编码，如一生老友！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.iocoder.cn/"/>
  <updated>2017-11-02T07:50:16.000Z</updated>
  <id>http://www.iocoder.cn/</id>
  
  <author>
    <name>王文斌</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RxJava 源码解析 —— Observable#subscribeOn(Scheduler)</title>
    <link href="http://www.iocoder.cn/RxJava/observable-subscribe-on-scheduler/"/>
    <id>http://www.iocoder.cn/RxJava/observable-subscribe-on-scheduler/</id>
    <published>2019-01-21T16:00:00.000Z</published>
    <updated>2017-11-02T07:50:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/RxJava/observable-subscribe-on-scheduler/">http://www.iocoder.cn/RxJava/observable-subscribe-on-scheduler/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 RxJava 1.2.X 版本</strong>  </p><p>本系列写作目的，为了辅助 Hystrix 的理解，因此会较为零散与琐碎，望见谅见谅。</p><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><p><code>Observable#subscribeOn(Scheduler)</code> 方法，用途如下 ：</p><blockquote><p>FROM <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/SubscribeOn.html" rel="external nofollow noopener noreferrer" target="_blank">《ReactiveX文档中文翻译 —— SubscribeOn》</a><br>指定 Observable <strong>自身</strong>在哪个调度器上执行<br><img src="http://www.iocoder.cn/images/RxJava/2019_01_22/01.png" alt=""><br>很多 ReactiveX 实现都使用调度器 <code>&quot;Scheduler&quot;</code> 来管理多线程环境中Observable 的转场。你可以使用 SubscribeOn 操作符指定 Observable 在一个特定的调度器上运转。</p></blockquote><p>从概念上可能比较模糊，或者我们换一种说法 ：</p><blockquote><p>FROM <a href="http://gank.io/post/560e15be2dca930e00da1083#toc_14" rel="external nofollow noopener noreferrer" target="_blank">《给 Android 开发者的 RxJava 详解》「 3. 线程控制 —— Scheduler (一) 」</a><br><code>#subscribeOn()</code> ：指定 <code>#subscribe()</code> 所发生的线程，即 <code>Observable.OnSubscribe</code> 被激活时所处的线程。<strong>或者叫做事件产生的线程</strong>。</p></blockquote><p>来来来，一起瞅瞅源码，更加清理的理解。<code>Observable#subscribeOn(Scheduler)</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Observable.java</span></div><div class="line"></div><div class="line"><span class="keyword">final</span> OnSubscribe&lt;T&gt; onSubscribe;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Observable</span><span class="params">(OnSubscribe&lt;T&gt; f)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.onSubscribe = f;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> ScalarSynchronousObservable) &#123;</div><div class="line">        <span class="keyword">return</span> ((ScalarSynchronousObservable&lt;T&gt;)<span class="keyword">this</span>).scalarScheduleOn(scheduler);</div><div class="line">   &#125;</div><div class="line">    <span class="keyword">return</span> create(<span class="keyword">new</span> OperatorSubscribeOn&lt;T&gt;(<span class="keyword">this</span>, scheduler));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(OnSubscribe&lt;T&gt; f)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Observable&lt;T&gt;(RxJavaHooks.onCreate(f));</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>ScalarSynchronousObservable ，跳过，不在本文范围内。</li><li>创建 OperatorSubscribeOn 对象，将 Observable ( <code>this</code> ) 和 Scheduler ( <code>scheduler</code> ) 传入。</li></ul><hr><p>OperatorSubscribeOn 类，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OperatorSubscribeOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">OnSubscribe</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>:     <span class="keyword">final</span> Scheduler scheduler;</div><div class="line"> <span class="number">4</span>:     <span class="keyword">final</span> Observable&lt;T&gt; source;</div><div class="line"> <span class="number">5</span>: </div><div class="line"> <span class="number">6</span>:     <span class="function"><span class="keyword">public</span> <span class="title">OperatorSubscribeOn</span><span class="params">(Observable&lt;T&gt; source, Scheduler scheduler)</span> </span>&#123;</div><div class="line"> <span class="number">7</span>:         <span class="keyword">this</span>.scheduler = scheduler;</div><div class="line"> <span class="number">8</span>:         <span class="keyword">this</span>.source = source;</div><div class="line"> <span class="number">9</span>:     &#125;</div><div class="line"><span class="number">10</span>: </div><div class="line"><span class="number">11</span>:     <span class="meta">@Override</span></div><div class="line"><span class="number">12</span>:     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span> </span>&#123;</div><div class="line"><span class="number">13</span>:         <span class="keyword">final</span> Worker inner = scheduler.createWorker();</div><div class="line"><span class="number">14</span>:         subscriber.add(inner);</div><div class="line"><span class="number">15</span>: </div><div class="line"><span class="number">16</span>:         inner.schedule(<span class="keyword">new</span> Action0() &#123;</div><div class="line"><span class="number">17</span>:             <span class="meta">@Override</span></div><div class="line"><span class="number">18</span>:             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">19</span>:                 <span class="keyword">final</span> Thread t = Thread.currentThread();</div><div class="line"><span class="number">20</span>: </div><div class="line"><span class="number">21</span>:                 Subscriber&lt;T&gt; s = <span class="keyword">new</span> Subscriber&lt;T&gt;(subscriber) &#123;</div><div class="line"><span class="number">22</span>:                     <span class="meta">@Override</span></div><div class="line"><span class="number">23</span>:                     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</div><div class="line"><span class="number">24</span>:                         subscriber.onNext(t);</div><div class="line"><span class="number">25</span>:                     &#125;</div><div class="line"><span class="number">26</span>: </div><div class="line"><span class="number">27</span>:                     <span class="meta">@Override</span></div><div class="line"><span class="number">28</span>:                     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line"><span class="number">29</span>:                         <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">30</span>:                             subscriber.onError(e);</div><div class="line"><span class="number">31</span>:                         &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">32</span>:                             inner.unsubscribe();</div><div class="line"><span class="number">33</span>:                         &#125;</div><div class="line"><span class="number">34</span>:                     &#125;</div><div class="line"><span class="number">35</span>: </div><div class="line"><span class="number">36</span>:                     <span class="meta">@Override</span></div><div class="line"><span class="number">37</span>:                     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">38</span>:                         <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">39</span>:                             subscriber.onCompleted();</div><div class="line"><span class="number">40</span>:                         &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">41</span>:                             inner.unsubscribe();</div><div class="line"><span class="number">42</span>:                         &#125;</div><div class="line"><span class="number">43</span>:                     &#125;</div><div class="line"><span class="number">44</span>: </div><div class="line"><span class="number">45</span>:                     <span class="meta">@Override</span></div><div class="line"><span class="number">46</span>:                     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProducer</span><span class="params">(<span class="keyword">final</span> Producer p)</span> </span>&#123;</div><div class="line"><span class="number">47</span>:                         subscriber.setProducer(<span class="keyword">new</span> Producer() &#123;</div><div class="line"><span class="number">48</span>:                             <span class="meta">@Override</span></div><div class="line"><span class="number">49</span>:                             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> n)</span> </span>&#123;</div><div class="line"><span class="number">50</span>:                                 <span class="keyword">if</span> (t == Thread.currentThread()) &#123;</div><div class="line"><span class="number">51</span>:                                     p.request(n);</div><div class="line"><span class="number">52</span>:                                 &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">53</span>:                                     inner.schedule(<span class="keyword">new</span> Action0() &#123;</div><div class="line"><span class="number">54</span>:                                         <span class="meta">@Override</span></div><div class="line"><span class="number">55</span>:                                         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">56</span>:                                             p.request(n);</div><div class="line"><span class="number">57</span>:                                         &#125;</div><div class="line"><span class="number">58</span>:                                     &#125;);</div><div class="line"><span class="number">59</span>:                                 &#125;</div><div class="line"><span class="number">60</span>:                             &#125;</div><div class="line"><span class="number">61</span>:                         &#125;);</div><div class="line"><span class="number">62</span>:                     &#125;</div><div class="line"><span class="number">63</span>:                 &#125;;</div><div class="line"><span class="number">64</span>: </div><div class="line"><span class="number">65</span>:                 source.unsafeSubscribe(s);</div><div class="line"><span class="number">66</span>:             &#125;</div><div class="line"><span class="number">67</span>:         &#125;);</div><div class="line"><span class="number">68</span>:     &#125;</div><div class="line"><span class="number">69</span>: &#125;</div></pre></td></tr></table></figure><ul><li><code>scheduler</code>，<code>source</code> 属性就不用说了，上文我们已经看到。</li><li><p>可能有同学对 <code>OnSubscribe#call(Subscriber)</code> 方法的调用链路不太熟悉，我们手撸一个实例，并且打个断点感受下 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RxDemo11</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        Observable.just(<span class="string">"1"</span>, <span class="string">"2"</span>)</div><div class="line">                .subscribeOn(Schedulers.newThread()) <span class="comment">// Scheduler 开启新线程</span></div><div class="line">                .subscribe(s -&gt; System.out.println(s)); <span class="comment">// Subscriber 打印</span></div><div class="line">        Thread.sleep(Long.MAX_VALUE); <span class="comment">// Scheduler 异步，Sleep 等待</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>在<strong>第 13 行</strong>处打断点，方法的调用链路如下图 ：<img src="http://www.iocoder.cn/images/RxJava/2019_01_22/02.png" alt="">  </li></ul></li><li><p>第 13 行 ：使用 Scheduler 创建 Worker 。在 <a href="http://www.iocoder.cn/RxJava/scheduler/?self">《RxJava 源码解析 —— Scheduler》</a> 有详细解析。 </p></li><li>第 14 行 ：将 Worker 添加到 <code>subscriber.subscriptions</code> 里。Worker 类实现了 <code>rx.Subscription</code> <strong>接口</strong>。</li><li>第 16 至 66 行 ：使用 Worker 执行操作。例如 Scheduler 为 NewThreadScheduler 时，此处的 Worker 对应 NewThreadWorker ，执行操作时使用<strong>新线程</strong>，而不是当前线程。<ul><li>第 19 行 ：获取执行操作的当前线程，用于第 50 行的判断。</li><li>第 21 至 63 行 ：创建<strong>新的</strong> Subscriber 。比较关键的是 <code>#setProducer()</code> 方法，判断 <code>#request()</code> 时，线程是否是 <code>t</code> ( Worker 的线程 )，如果不是，重新使用 Worker 执行 <code>#request()</code> 方法。通过这样的方式，达到上文所说的 <em>“指定 <code>#subscribe()</code> 所发生的线程，即 <code>Observable.OnSubscribe</code> 被激活时所处的线程。<strong>或者叫做事件产生的线程</strong>。”</em>。</li></ul></li><li>第 65 行 ：调用 <code>Observable#unsafeSubscribe(...)</code> 方法，<strong>继续订阅逻辑</strong>。</li><li><p>另外，想要触发<strong>第 53 行</strong>的情况，示例代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RxDemo10</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        Observable.defer(() -&gt; Observable.just(<span class="string">"1"</span>, <span class="string">"2"</span>)</div><div class="line">                    .subscribeOn(Schedulers.newThread()) <span class="comment">// Scheduler</span></div><div class="line">                )</div><div class="line">                .subscribeOn(Schedulers.newThread()) <span class="comment">// Scheduler</span></div><div class="line">                .subscribe(s -&gt; System.out.println(s));</div><div class="line">        Thread.sleep(Long.MAX_VALUE); <span class="comment">// Scheduler 异步，Sleep 等待</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/RxJava/observable-subscribe-on-scheduler/&quot;&gt;http://www.iocoder.cn/RxJava/observable-subscribe-on-s
      
    
    </summary>
    
      <category term="RxJava" scheme="http://www.iocoder.cn/categories/RxJava/"/>
    
    
  </entry>
  
  <entry>
    <title>RxJava 源码解析 —— Scheduler</title>
    <link href="http://www.iocoder.cn/RxJava/scheduler/"/>
    <id>http://www.iocoder.cn/RxJava/scheduler/</id>
    <published>2019-01-14T16:00:00.000Z</published>
    <updated>2017-11-01T18:55:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/RxJava/scheduler/">http://www.iocoder.cn/RxJava/scheduler/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 RxJava 1.2.X 版本</strong>  </p><p>本系列写作目的，为了辅助 Hystrix 的理解，因此会较为零散与琐碎，望见谅见谅。</p><ul><li><a href="http://www.iocoder.cn/RxJava/scheduler/">1. Scheduler</a></li><li><a href="http://www.iocoder.cn/RxJava/scheduler/">2. Worker</a></li><li><a href="http://www.iocoder.cn/RxJava/scheduler/">3. 默认调度器实现</a></li><li><a href="http://www.iocoder.cn/RxJava/scheduler/">4. 操作符与调度器</a></li><li><a href="http://www.iocoder.cn/RxJava/scheduler/">5. 使用示例</a></li><li><a href="http://www.iocoder.cn/RxJava/scheduler/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-Scheduler"><a href="#1-Scheduler" class="headerlink" title="1. Scheduler"></a>1. Scheduler</h1><p><code>rx.Scheduler</code> ，<strong>抽象类</strong>，一个可以调度工作单元( <code>rx.Scheduler.Worker</code> )<strong>们</strong>的对象。</p><blockquote><p>FROM <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/Scheduler.html" rel="external nofollow noopener noreferrer" target="_blank">《ReactiveX文档中文翻译 —— Scheduler》</a><br>如果你想给 Observable 操作符链添加<strong>多线程</strong>功能，你可以指定操作符( 或者特定的Observable )在特定的调度器( Scheduler )上执行。</p><p>某些 ReactiveX 的 Observable 操作符有一些变体，它们可以接受一个 Scheduler 参数。这个参数指定操作符将它们的部分或全部任务放在一个特定的调度器上执行。</p><p><strong>使用 ObserveOn 和 SubscribeOn 操作符</strong>，你可以让 Observable 在一个特定的调度器上执行。  </p><ul><li>ObserveOn 指示一个 Observable 在一个特定的调度器上调用观察者的 onNext , onError 和 onCompleted 方法。</li><li>SubscribeOn 更进一步，它指示 Observable 将全部的处理过程( 包括发射数据和通知 )放在特定的调度器上执行。</li></ul></blockquote><ul><li><a href="https://github.com/ReactiveX/RxJava/blob/5b2394c9ee91f298661fff5e043744c84b425808/src/main/java/rx/Observable.java#L10404" rel="external nofollow noopener noreferrer" target="_blank"><code>Observable#subscribeOn(Scheduler)</code></a> ，在 <a href="http://www.iocoder.cn/RxJava/observable-subscribe-on-scheduler/">《RxJava 源码解析 —— Observable#subscribeOn(Scheduler)》</a> 详细解析。</li></ul><p>为什么是<strong>抽象类</strong>，而不是<strong>接口</strong>呢？官方说明如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Why is this an abstract class instead of an interface?</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *  : Java doesn't support extension methods and there are many overload methods needing default</span></div><div class="line"><span class="comment"> *    implementations.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *  : Virtual extension methods aren't available until Java8 which RxJava will not set as a minimum target for</span></div><div class="line"><span class="comment"> *    a long time.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *  : If only an interface were used Scheduler implementations would then need to extend from an</span></div><div class="line"><span class="comment"> *    AbstractScheduler pair that gives all of the functionality unless they intend on copy/pasting the</span></div><div class="line"><span class="comment"> *    functionality.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *  : Without virtual extension methods even additive changes are breaking and thus severely impede library</span></div><div class="line"><span class="comment"> *    maintenance.</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure><ul><li>【第一、二点】Java 在 8.0 版本之前，接口不支持默认实现方法，而 Scheduler 需要多个方法提供默认实现。RxJava 考虑到兼容性，将长期使用低版本的 Java 。</li><li>【第三、四点】如果将 Scheduler 定义为接口，那么需要添加一个 AbstractScheduler 抽象类，实现接口的默认方法实现。</li></ul><p>Scheduler 提供方法如下 ：</p><ul><li><a href="https://github.com/ReactiveX/RxJava/blob/5b2394c9ee91f298661fff5e043744c84b425808/src/main/java/rx/Scheduler.java#L54" rel="external nofollow noopener noreferrer" target="_blank"><code>#createWorker()</code></a> <strong>抽象</strong>方法 ：创建 Worker 。</li><li><a href="https://github.com/ReactiveX/RxJava/blob/5b2394c9ee91f298661fff5e043744c84b425808/src/main/java/rx/Scheduler.java#L129" rel="external nofollow noopener noreferrer" target="_blank"><code>#now()</code></a> <strong>默认</strong>方法 ：返回当前时间。</li><li><del><a href="https://github.com/ReactiveX/RxJava/blob/5b2394c9ee91f298661fff5e043744c84b425808/src/main/java/rx/Scheduler.java#L208" rel="external nofollow noopener noreferrer" target="_blank"><code>#when(...)</code></a> <strong>默认</strong>方法 ：跳过，Hystrix 暂未使用。</del></li></ul><h1 id="2-Worker"><a href="#2-Worker" class="headerlink" title="2. Worker"></a>2. Worker</h1><p><code>rx.Scheduler.Worker</code> ，工作单元对象<strong>抽象类</strong>，执行 Scheduler 调度的操作( <code>rx.functions.Action0</code> )。</p><p>Worker 提供方法如下 ：</p><ul><li><a href="https://github.com/ReactiveX/RxJava/blob/5b2394c9ee91f298661fff5e043744c84b425808/src/main/java/rx/Scheduler.java#L70" rel="external nofollow noopener noreferrer" target="_blank"><code>#schedule(Action0)</code></a> <strong>抽象</strong>方法 ：<strong>立即</strong>调度操作。</li><li><a href="https://github.com/ReactiveX/RxJava/blob/5b2394c9ee91f298661fff5e043744c84b425808/src/main/java/rx/Scheduler.java#L87" rel="external nofollow noopener noreferrer" target="_blank"><code>#schedulePeriodically(Action0, long, long, TimeUnit)</code></a> <strong>抽象</strong>方法：<strong>延迟</strong>调度操作。</li><li><del><a href="https://github.com/ReactiveX/RxJava/blob/5b2394c9ee91f298661fff5e043744c84b425808/src/main/java/rx/Scheduler.java#L109" rel="external nofollow noopener noreferrer" target="_blank"><code>#schedulePeriodically(Action0, long, long, TimeUnit)</code></a> <strong>默认</strong>方法 ：<strong>周期性</strong>操作。跳过，Hystrix 暂未使用。</del></li><li><a href="https://github.com/ReactiveX/RxJava/blob/5b2394c9ee91f298661fff5e043744c84b425808/src/main/java/rx/Scheduler.java#L119" rel="external nofollow noopener noreferrer" target="_blank"><code>#now()</code></a> <strong>默认</strong>方法 ：返回当前时间。</li></ul><p>Worker 实现 <code>rx.Subscription</code> <strong>接口</strong>，但是并未实现对应的方法，需要子类实现，用于 ：</p><ul><li><code>#unsubscribe()</code> ：<strong>原意</strong>取消订阅，<strong>实意</strong>取消操作。</li><li><code>#isUnsubscribed()</code> ：<strong>原意</strong>订阅是否取消，<strong>实意</strong>操作是否取消。</li></ul><h1 id="3-默认调度器实现"><a href="#3-默认调度器实现" class="headerlink" title="3. 默认调度器实现"></a>3. 默认调度器实现</h1><p>在 <code>rx.internal.schedulers</code> 包下，提供了多种默认调度器的实现。</p><p><img src="http://www.iocoder.cn/images/RxJava/2019_01_15/01.png" alt=""></p><p><a href="https://github.com/ReactiveX/RxJava/blob/5b2394c9ee91f298661fff5e043744c84b425808/src/main/java/rx/schedulers/Schedulers.java" rel="external nofollow noopener noreferrer" target="_blank"><code>rx.schedulers.Schedulers</code></a> ，默认调度器单例工厂，创建上图调度器工厂并进行管理。</p><blockquote><p>参考 <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/Scheduler.html#调度器的种类" rel="external nofollow noopener noreferrer" target="_blank">《ReactiveX文档中文翻译 —— Scheduler》「调度器的种类」</a></p></blockquote><table><thead><tr><th>单例</th><th>类</th><th>说明</th></tr></thead><tbody><tr><td><code>Schedulers#io()</code></td><td>CachedThreadScheduler</td><td>用于 IO 密集型任务，如异步阻塞 IO 操作，这个调度器的线程池会根据需要增长</td></tr><tr><td><code>Schedulers#computation()</code></td><td>EventLoopsScheduler</td><td>用于普通的计算任务，默认线程数等于处理器的数量</td></tr><tr><td><code>Schedulers#from(Executor)</code></td><td>ExecutorScheduler</td><td>使用指定的 Executor 作为调度器</td></tr><tr><td><code>Schedulers#immediate()</code></td><td>ImmediateScheduler</td><td>在当前线程立即开始执行任务</td></tr><tr><td><code>Schedulers#newThread()</code></td><td>NewThreadScheduler</td><td>为每个任务创建一个新线程</td></tr><tr><td><code>Schedulers#trampoline()</code></td><td>TrampolineScheduler</td><td>当其它排队的任务完成后，在当前线程排队开始执行</td></tr></tbody></table><p>在 Hystrix 里，继承 Scheduler <strong>抽象类</strong>，实现了<strong>自定义</strong>的 Scheduler 。</p><p>因此，跳过默认调度器的源码解析。</p><h1 id="4-操作符与调度器"><a href="#4-操作符与调度器" class="headerlink" title="4. 操作符与调度器"></a>4. 操作符与调度器</h1><p>点击 <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/Scheduler.html#默认调度器" rel="external nofollow noopener noreferrer" target="_blank">《ReactiveX文档中文翻译 —— Scheduler》「默认调度器」</a> 查看。</p><h1 id="5-使用示例"><a href="#5-使用示例" class="headerlink" title="5. 使用示例"></a>5. 使用示例</h1><p>点击 <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/Scheduler.html#使用调度器" rel="external nofollow noopener noreferrer" target="_blank">《ReactiveX文档中文翻译 —— Scheduler》「使用调度器」</a> 查看。</p><p>可能你会觉得示例有丢丢“奇怪”，在 <a href="http://www.iocoder.cn/RxJava/observable-subscribe-on-scheduler/">《RxJava 源码解析 —— Observable#subscribeOn(Scheduler)》</a> 你将获得答案。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>本文偏介绍性，大量内容引用 <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/Scheduler.html" rel="external nofollow noopener noreferrer" target="_blank">《ReactiveX文档中文翻译 —— Scheduler》</a> 。</p><p>后续根据需要，可能解析默认调度器的源码实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/RxJava/scheduler/&quot;&gt;http://www.iocoder.cn/RxJava/scheduler/&lt;/a&gt; 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong
      
    
    </summary>
    
      <category term="RxJava" scheme="http://www.iocoder.cn/categories/RxJava/"/>
    
    
  </entry>
  
  <entry>
    <title>RxJava 源码解析 —— BlockingObservable</title>
    <link href="http://www.iocoder.cn/RxJava/blocking-observable/"/>
    <id>http://www.iocoder.cn/RxJava/blocking-observable/</id>
    <published>2019-01-07T16:00:00.000Z</published>
    <updated>2017-11-01T18:48:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/RxJava/blocking-observable/">http://www.iocoder.cn/RxJava/blocking-observable/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 RxJava 1.2.X 版本</strong>  </p><p>本系列写作目的，为了辅助 Hystrix 的理解，因此会较为零散与琐碎，望见谅见谅。</p><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><blockquote><p><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Blocking-Observable-Operators.html" rel="external nofollow noopener noreferrer" target="_blank">《ReactiveX/RxJava文档中文版 —— 阻塞操作》</a><br>BlockingObservable 的方法不是将一个 Observable 变换为另一个，也不是过滤Observables，它们会打断 Observable 的调用链，会阻塞等待直到 Observable 发射了想要的数据，然后返回这个数据（而不是一个 Observable ）。</p></blockquote><h1 id="1-toBlocking"><a href="#1-toBlocking" class="headerlink" title="1. toBlocking"></a>1. toBlocking</h1><p>调用 <code>Observable#toBlocking()</code> 或 <code>BlockingObservable#from(Observable)</code> 方法，将 Observable 转换成 BlockingObservable 。代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// BlockingObservable.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingObservable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Observable&lt;? extends T&gt; o;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BlockingObservable</span><span class="params">(Observable&lt;? extends T&gt; o)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.o = o;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">BlockingObservable&lt;T&gt; <span class="title">from</span><span class="params">(<span class="keyword">final</span> Observable&lt;? extends T&gt; o)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BlockingObservable&lt;T&gt;(o);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Observable.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> BlockingObservable&lt;T&gt; <span class="title">toBlocking</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> BlockingObservable.from(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>从代码上我们可以看到，BlockingObservable 并未将 Observable 转换成新的，而是简单的包了一层。</li></ul><h1 id="2-toFuture"><a href="#2-toFuture" class="headerlink" title="2. toFuture"></a>2. toFuture</h1><blockquote><p><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/To.html#tofuture" rel="external nofollow noopener noreferrer" target="_blank">《ReactiveX/RxJava文档中文版 —— TO》</a><br><img src="http://www.iocoder.cn/images/Hystrix/2018_10_08/04.png" alt=""><br><code>#toFuture()</code> 操作符也是只能用于 BlockingObservable 。这个操作符将Observable 转换为一个返回<strong>单个数据项</strong>的 Future 。</p><ul><li>如果原始 Observable 发射多个数据项，Future会收到一个IllegalArgumentException；</li><li>如果原始 Observable 没有发射任何数据，Future会收到一个NoSuchElementException。</li></ul><p>如果你想将发射多个数据项的 Observable 转换为 Future ，可以这样用：<code>myObservable.toList().toBlocking().toFuture()</code> 。</p></blockquote><p>点击<a href="https://github.com/ReactiveX/RxJava/blob/396b6104e419b80002c45faf76ac38f00d2ff64a/src/main/java/rx/internal/operators/BlockingOperatorToFuture.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 <code>#toFuture()</code> 的代码实现：</p><ul><li>通过向传入 Observable 订阅 Subscriber ，打断 Observable 的调用链，会阻塞等待直到 Observable 发射了想要的数据。<ul><li><code>#onNext()</code> 方法，设置执行的返回值( <code>value</code> )。</li><li><code>#onCompleted()</code> 方法，CountDownLatch (<code>finished</code>) 减一。</li><li><code>#onError()</code> 方法，设置执行时发生的异常( <code>error</code> )，并 CountDownLatch (<code>finished</code>) 减一。</li></ul></li><li>返回的 Future ，通过 CountDownLatch ( <code>error</code> ) 判断是否执行完成；通过 <code>value</code> ， <code>error</code> 获得执行的结果。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/RxJava/blocking-observable/&quot;&gt;http://www.iocoder.cn/RxJava/blocking-observable/&lt;/a&gt; 「芋道源码」欢迎转载，保留摘
      
    
    </summary>
    
      <category term="RxJava" scheme="http://www.iocoder.cn/categories/RxJava/"/>
    
    
  </entry>
  
  <entry>
    <title>RxJava 源码解析 —— Observable#defer(...)</title>
    <link href="http://www.iocoder.cn/RxJava/observable-defer/"/>
    <id>http://www.iocoder.cn/RxJava/observable-defer/</id>
    <published>2018-12-31T16:00:00.000Z</published>
    <updated>2017-11-01T18:47:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/RxJava/observable-defer/">http://www.iocoder.cn/RxJava/observable-defer/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 RxJava 1.2.X 版本</strong>  </p><p>本系列写作目的，为了辅助 Hystrix 的理解，因此会较为零散与琐碎，望见谅见谅。</p><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><p>在一些业务场景下，我们需要 Observable 是<strong>动态</strong>的，例如说，<a href="http://www.iocoder.cn/Hystrix/command-execute-result-cache/?self">《Hystrix 源码解析 —— 执行结果缓存》</a> 分享的缓存 Observable ，无法在创建 Observable 阶段就知道是否有缓存，通过 <code>Observable#defer(...)</code> 方法，声明<strong>动态</strong>的 Observable 。示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">   Observable.defer(<span class="keyword">new</span> Func0&lt;Observable&lt;String&gt;&gt;() &#123; <span class="comment">// #defer(...)</span></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">           String name = Math.random() &gt; <span class="number">0.5</span> ? <span class="string">"小明"</span> : <span class="string">"小贾"</span>; <span class="comment">// 随机名字</span></div><div class="line">           <span class="keyword">return</span> Observable.just(name);</div><div class="line">       &#125;</div><div class="line">   &#125;).subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123; <span class="comment">// #subscribe(...)</span></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">           System.out.println(s);</div><div class="line">       &#125;</div><div class="line">   &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><p><code>Observable#defer(...)</code> 方法，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Observable.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">defer</span><span class="params">(Func0&lt;Observable&lt;T&gt;&gt; observableFactory)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> create(<span class="keyword">new</span> OnSubscribeDefer&lt;T&gt;(observableFactory));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(OnSubscribe&lt;T&gt; f)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Observable&lt;T&gt;(RxJavaHooks.onCreate(f));</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>使用传入 <code>observableFactory</code> 参数，生成<strong>动态</strong>的 Observable 。  </li></ul><hr><p>OnSubscribeDefer 类，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OnSubscribeDefer</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">OnSubscribe</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">final</span> Func0&lt;? extends Observable&lt;? extends T&gt;&gt; observableFactory;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OnSubscribeDefer</span><span class="params">(Func0&lt;? extends Observable&lt;? extends T&gt;&gt; observableFactory)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.observableFactory = observableFactory;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; s)</span> </span>&#123;</div><div class="line">        Observable&lt;? extends T&gt; o;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            o = observableFactory.call();</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            Exceptions.throwOrReport(t, s);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        o.unsafeSubscribe(Subscribers.wrap(s));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>在 <code>Observable#subscribe(...)</code> 方法调用时，调用 <code>OnSubscribeDefer#call(...)</code> 方法 ：<ul><li>调用 <code>Func0#call()</code> 方法，创建<strong>动态</strong>的 Observable 。</li><li>调用 <code>Observable#unsafeSubscribe(...)</code> 方法，<strong>继续订阅逻辑</strong>。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/RxJava/observable-defer/&quot;&gt;http://www.iocoder.cn/RxJava/observable-defer/&lt;/a&gt; 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;
      
    
    </summary>
    
      <category term="RxJava" scheme="http://www.iocoder.cn/categories/RxJava/"/>
    
    
  </entry>
  
  <entry>
    <title>Hystrix 源码解析 —— 命令执行（二）之执行隔离策略</title>
    <link href="http://www.iocoder.cn/Hystrix/command-execute-second-isolation-strategy/"/>
    <id>http://www.iocoder.cn/Hystrix/command-execute-second-isolation-strategy/</id>
    <published>2018-10-24T16:00:00.000Z</published>
    <updated>2017-11-04T16:09:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Hystrix/command-execute-second-isolation-strategy/">http://www.iocoder.cn/Hystrix/command-execute-second-isolation-strategy/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/Hystrix/command-execute-second-isolation-strategy/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-second-isolation-strategy/">2. HystrixThreadPoolProperties</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-second-isolation-strategy/">3. HystrixThreadPoolKey</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-second-isolation-strategy/">4. HystrixConcurrencyStrategy</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-second-isolation-strategy/">5. HystrixThreadPool</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-second-isolation-strategy/">6. HystrixScheduler</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-second-isolation-strategy/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Hystrix 命令执行（二）之执行隔离策略</strong>。</p><p>建议 ：对 RxJava 已经有一定的了解的基础上阅读本文。</p><p>Hystrix 提供两种执行隔离策略( ExecutionIsolationStrategy ) ：</p><ul><li><code>SEMAPHORE</code> ：信号量，命令在<strong>调用线程</strong>执行。在<a href="http://www.iocoder.cn/Hystrix/command-execute-first-run/?self">《Hystrix 源码解析 —— 命令执行（一）之正常执行逻辑》「3. TryableSemaphore」</a> 已经详细解析。</li><li><code>THREAD</code> ：线程池，命令在<strong>线程池</strong>执行。在<a href="http://www.iocoder.cn/Hystrix/command-execute-first-run/?self">《Hystrix 源码解析 —— 命令执行（一）之正常执行逻辑》「5. #executeCommandWithSpecifiedIsolation(…)」</a> 的 <code>#executeCommandWithSpecifiedIsolation(...)</code> 方法中，调用 <code>Observable#subscribeOn(Scheduler)</code> 方法，指定在 RxJava Scheduler 执行。<ul><li>如果你暂时不了解 Scheduler ，可以阅读 <a href="http://www.iocoder.cn/RxJava/scheduler/?self">《RxJava 源码解析 —— Scheduler》</a> 。</li><li>如果你暂时不了解 <code>Observable#subscribeOn(Scheduler)</code> ，可以阅读 <a href="http://www.iocoder.cn/RxJava/observable-subscribe-on-scheduler/?self">《RxJava 源码解析 —— Observable#subscribeOn(Scheduler)》</a> 。</li></ul></li></ul><p>两种方式的<strong>优缺点比较</strong>，推荐阅读 <a href="http://youdang.github.io/2016/02/05/translate-hystrix-wiki-how-it-works/#依赖隔离" rel="external nofollow noopener noreferrer" target="_blank">《【翻译】Hystrix文档-实现原理》「依赖隔离」</a>。</p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-HystrixThreadPoolProperties"><a href="#2-HystrixThreadPoolProperties" class="headerlink" title="2. HystrixThreadPoolProperties"></a>2. HystrixThreadPoolProperties</h1><p><code>com.netflix.hystrix.HystrixThreadPoolProperties</code> ，Hystrix 线程池属性配置<strong>抽象类</strong>，点击 <a href="https://github.com/YunaiV/Hystrix/blob/ba86690747b365482c306ec3a0725e0be4bab739/hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPoolProperties.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看，已添加中文注释说明。</p><p><code>com.netflix.hystrix.strategy.properties.HystrixPropertiesThreadPoolDefault</code> ，Hystrix 线程池配置<strong>实现类</strong>，点击 <a href="https://github.com/YunaiV/Hystrix/blob/ba86690747b365482c306ec3a0725e0be4bab739/hystrix-core/src/main/java/com/netflix/hystrix/strategy/properties/HystrixPropertiesThreadPoolDefault.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看。实际上没什么内容，官方如是说 ：</p><blockquote><p>Default implementation of {@link HystrixThreadPoolProperties} using Archaius (<a href="https://github.com/Netflix/archaius" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/Netflix/archaius</a>)</p></blockquote><h1 id="3-HystrixThreadPoolKey"><a href="#3-HystrixThreadPoolKey" class="headerlink" title="3. HystrixThreadPoolKey"></a>3. HystrixThreadPoolKey</h1><p><code>com.netflix.hystrix.HystrixThreadPoolKey</code> ，Hystrix 线程池标识<strong>接口</strong>。</p><blockquote><p>FROM HystrixThreadPoolKey 接口注释<br>A key to represent a {@link HystrixThreadPool} for monitoring, metrics publishing, caching and other such uses.<br>This interface is intended to work natively with Enums so that implementing code can be an enum that implements this interface.</p></blockquote><ul><li>直白的说 ，希望通过相同的 <code>name</code> ( 标识 ) 获得同 HystrixThreadPoolKey 对象。通过在内部维持一个 <code>name</code> 与 HystrixThreadPoolKey 对象的映射，以达到<strong>枚举</strong>的效果。</li></ul><p>HystrixThreadPoolKey 代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HystrixThreadPoolKey</span> <span class="keyword">extends</span> <span class="title">HystrixKey</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:         <span class="function"><span class="keyword">private</span> <span class="title">Factory</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">4</span>:         &#125;</div><div class="line"> <span class="number">5</span>: </div><div class="line"> <span class="number">6</span>:         <span class="comment">// used to intern instances so we don't keep re-creating them millions of times for the same key</span></div><div class="line"> <span class="number">7</span>:         <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InternMap&lt;String, HystrixThreadPoolKey&gt; intern</div><div class="line"> <span class="number">8</span>:                 = <span class="keyword">new</span> InternMap&lt;String, HystrixThreadPoolKey&gt;(</div><div class="line"> <span class="number">9</span>:                 <span class="keyword">new</span> InternMap.ValueConstructor&lt;String, HystrixThreadPoolKey&gt;() &#123;</div><div class="line"><span class="number">10</span>:                     <span class="meta">@Override</span></div><div class="line"><span class="number">11</span>:                     <span class="function"><span class="keyword">public</span> HystrixThreadPoolKey <span class="title">create</span><span class="params">(String key)</span> </span>&#123;</div><div class="line"><span class="number">12</span>:                         <span class="keyword">return</span> <span class="keyword">new</span> HystrixThreadPoolKeyDefault(key);</div><div class="line"><span class="number">13</span>:                     &#125;</div><div class="line"><span class="number">14</span>:                 &#125;);</div><div class="line"><span class="number">15</span>: </div><div class="line"><span class="number">16</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HystrixThreadPoolKey <span class="title">asKey</span><span class="params">(String name)</span> </span>&#123;</div><div class="line"><span class="number">17</span>:            <span class="keyword">return</span> intern.interned(name);</div><div class="line"><span class="number">18</span>:         &#125;</div><div class="line"><span class="number">19</span>: </div><div class="line"><span class="number">20</span>:         <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixThreadPoolKeyDefault</span> <span class="keyword">extends</span> <span class="title">HystrixKeyDefault</span> <span class="keyword">implements</span> <span class="title">HystrixThreadPoolKey</span> </span>&#123;</div><div class="line"><span class="number">21</span>:             <span class="function"><span class="keyword">public</span> <span class="title">HystrixThreadPoolKeyDefault</span><span class="params">(String name)</span> </span>&#123;</div><div class="line"><span class="number">22</span>:                 <span class="keyword">super</span>(name);</div><div class="line"><span class="number">23</span>:             &#125;</div><div class="line"><span class="number">24</span>:         &#125;</div><div class="line"><span class="number">25</span>: </div><div class="line"><span class="number">26</span>:         <span class="comment">/* package-private */</span> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getThreadPoolCount</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">27</span>:             <span class="keyword">return</span> intern.size();</div><div class="line"><span class="number">28</span>:         &#125;</div><div class="line"><span class="number">29</span>:     &#125;</div><div class="line"><span class="number">30</span>: &#125;</div></pre></td></tr></table></figure><ul><li>HystrixThreadPoolKey 实现 <code>com.netflix.hystrix.HystrixKey</code> <strong>接口</strong>，点击 <a href="https://github.com/Netflix/Hystrix/blob/d838f4d1ba65ce55755ab1c73f74c980f04572bf/hystrix-core/src/main/java/com/netflix/hystrix/HystrixKey.java#L6" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看。该接口定义的 <code>#name()</code> 方法，即是上文我们所说的标识( Key )。</li><li><code>intern</code> 属性，<code>name</code> 与 HystrixThreadPoolKey 对象的映射，以达到<strong>枚举</strong>的效果。<ul><li><code>com.netflix.hystrix.util.InternMap</code> ，点击 <a href="https://github.com/YunaiV/Hystrix/blob/853258ce3f499e1f525130064f0d6cb055088b29/hystrix-core/src/main/java/com/netflix/hystrix/util/InternMap.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看带中文注释的代码。</li></ul></li><li><code>#asKey(name)</code> 方法，从 <code>intern</code> 获得 HystrixThreadPoolKey 对象。</li><li><code>#getThreadPoolCount()</code> 方法，获得 HystrixThreadPoolKey 数量。</li></ul><hr><p>在 AbstractCommand <strong>构造方法</strong>里，初始化命令的 <code>threadPoolKey</code> 属性，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> HystrixThreadPoolKey threadPoolKey;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractCommand</span><span class="params">(HystrixCommandGroupKey group, HystrixCommandKey key, HystrixThreadPoolKey threadPoolKey, HystrixCircuitBreaker circuitBreaker, HystrixThreadPool threadPool,</span></span></div><div class="line"><span class="function"><span class="params">       HystrixCommandProperties.Setter commandPropertiesDefaults, HystrixThreadPoolProperties.Setter threadPoolPropertiesDefaults,</span></span></div><div class="line"><span class="function"><span class="params">       HystrixCommandMetrics metrics, TryableSemaphore fallbackSemaphore, TryableSemaphore executionSemaphore,</span></span></div><div class="line"><span class="function"><span class="params">       HystrixPropertiesStrategy propertiesStrategy, HystrixCommandExecutionHook executionHook)</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="comment">// ... 省略无关代码</span></div><div class="line"></div><div class="line">   <span class="keyword">this</span>.commandGroup = initGroupKey(group);</div><div class="line">   <span class="keyword">this</span>.commandKey = initCommandKey(key, getClass());</div><div class="line">   <span class="keyword">this</span>.properties = initCommandProperties(<span class="keyword">this</span>.commandKey, propertiesStrategy, commandPropertiesDefaults);</div><div class="line">   <span class="comment">// 初始化 threadPoolKey</span></div><div class="line">   <span class="keyword">this</span>.threadPoolKey = initThreadPoolKey(threadPoolKey, <span class="keyword">this</span>.commandGroup, <span class="keyword">this</span>.properties.executionIsolationThreadPoolKeyOverride().get());</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>#initThreadPoolKey(...)</code> 方法，创建最终的 <code>threadPoolKey</code> 属性。代码如下 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HystrixThreadPoolKey <span class="title">initThreadPoolKey</span><span class="params">(HystrixThreadPoolKey threadPoolKey, HystrixCommandGroupKey groupKey, String threadPoolKeyOverride)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (threadPoolKeyOverride == <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="comment">// we don't have a property overriding the value so use either HystrixThreadPoolKey or HystrixCommandGroup</span></div><div class="line">       <span class="keyword">if</span> (threadPoolKey == <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="comment">/* use HystrixCommandGroup if HystrixThreadPoolKey is null */</span></div><div class="line">           <span class="keyword">return</span> HystrixThreadPoolKey.Factory.asKey(groupKey.name());</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">return</span> threadPoolKey;</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">// threadPoolKeyOverride 可覆盖属性</span></div><div class="line">       <span class="comment">// we have a property defining the thread-pool so use it instead</span></div><div class="line">       <span class="keyword">return</span> HystrixThreadPoolKey.Factory.asKey(threadPoolKeyOverride);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>优先级 ：<code>threadPoolKeyOverride</code> &gt; <code>threadPoolKey</code> &gt; <code>groupKey</code></li></ul></li></ul><h1 id="4-HystrixConcurrencyStrategy"><a href="#4-HystrixConcurrencyStrategy" class="headerlink" title="4. HystrixConcurrencyStrategy"></a>4. HystrixConcurrencyStrategy</h1><p><code>com.netflix.hystrix.strategy.concurrency.HystrixConcurrencyStrategy</code> ，Hystrix 并发策略<strong>抽象类</strong>。</p><p><code>HystrixConcurrencyStrategy#getThreadPool(...)</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> ThreadPoolExecutor <span class="title">getThreadPool</span><span class="params">(<span class="keyword">final</span> HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolProperties threadPoolProperties)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="keyword">final</span> ThreadFactory threadFactory = getThreadFactory(threadPoolKey);</div><div class="line"> <span class="number">3</span>: </div><div class="line"> <span class="number">4</span>:     <span class="keyword">final</span> <span class="keyword">boolean</span> allowMaximumSizeToDivergeFromCoreSize = threadPoolProperties.getAllowMaximumSizeToDivergeFromCoreSize().get();</div><div class="line"> <span class="number">5</span>:     <span class="keyword">final</span> <span class="keyword">int</span> dynamicCoreSize = threadPoolProperties.coreSize().get();</div><div class="line"> <span class="number">6</span>:     <span class="keyword">final</span> <span class="keyword">int</span> keepAliveTime = threadPoolProperties.keepAliveTimeMinutes().get();</div><div class="line"> <span class="number">7</span>:     <span class="keyword">final</span> <span class="keyword">int</span> maxQueueSize = threadPoolProperties.maxQueueSize().get();</div><div class="line"> <span class="number">8</span>: </div><div class="line"> <span class="number">9</span>:     <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue = getBlockingQueue(maxQueueSize);</div><div class="line"><span class="number">10</span>: </div><div class="line"><span class="number">11</span>:     <span class="keyword">if</span> (allowMaximumSizeToDivergeFromCoreSize) &#123;</div><div class="line"><span class="number">12</span>:         <span class="keyword">final</span> <span class="keyword">int</span> dynamicMaximumSize = threadPoolProperties.maximumSize().get();</div><div class="line"><span class="number">13</span>:         <span class="keyword">if</span> (dynamicCoreSize &gt; dynamicMaximumSize) &#123;</div><div class="line"><span class="number">14</span>:             logger.error(<span class="string">"Hystrix ThreadPool configuration at startup for : "</span> + threadPoolKey.name() + <span class="string">" is trying to set coreSize = "</span> +</div><div class="line"><span class="number">15</span>:                     dynamicCoreSize + <span class="string">" and maximumSize = "</span> + dynamicMaximumSize + <span class="string">".  Maximum size will be set to "</span> +</div><div class="line"><span class="number">16</span>:                     dynamicCoreSize + <span class="string">", the coreSize value, since it must be equal to or greater than the coreSize value"</span>);</div><div class="line"><span class="number">17</span>:             <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(dynamicCoreSize, dynamicCoreSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);</div><div class="line"><span class="number">18</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">19</span>:             <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(dynamicCoreSize, dynamicMaximumSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);</div><div class="line"><span class="number">20</span>:         &#125;</div><div class="line"><span class="number">21</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">22</span>:         <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(dynamicCoreSize, dynamicCoreSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);</div><div class="line"><span class="number">23</span>:     &#125;</div><div class="line"><span class="number">24</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 2 行 ：调用 <code>#getThreadFactory(...)</code> 方法，获得 ThreadFactory 。点击 <a href="https://github.com/Netflix/Hystrix/blob/1f64fced24289ea435f1e2d5a47a068bf7b79729/hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixConcurrencyStrategy.java#L118" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看方法代码。<ul><li><code>PlatformSpecific#getAppEngineThreadFactory()</code> 方法，无需细看，适用于 Google App Engine 场景。</li></ul></li><li>第 4 至 7 行 ：<a href="#">「2. HystrixThreadPoolProperties」</a> 有详细解析。</li><li>第 9 行 ：调用 <code>#getBlockingQueue()</code> 方法，获得线程池的阻塞队列。点击 <a href="https://github.com/Netflix/Hystrix/blob/1f64fced24289ea435f1e2d5a47a068bf7b79729/hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixConcurrencyStrategy.java#L150" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看方法代码。<ul><li>当 <code>maxQueueSize &lt;= 0</code> 时( 默认值 ：<code>-1</code> ) 时，使用 SynchronousQueue 。超过线程池的 <code>maximumPoolSize</code> 时，提交任务<strong>被拒绝</strong>。<ul><li><a href="http://ifeve.com/java-synchronousqueue/" rel="external nofollow noopener noreferrer" target="_blank">《Java并发包中的同步队列SynchronousQueue实现原理》</a></li></ul></li><li>当 <code>SynchronousQueue &gt; 0</code> 时，使用 LinkedBlockingQueue 。超过线程池的 <code>maximumPoolSize</code> 时，任务被拒绝。超过线程池的 <code>maximumPoolSize</code> + 线程池队列的 <code>maxQueueSize</code> 时，提交任务<strong>被阻塞等待</strong>。<ul><li><a href="https://fangjian0423.github.io/2016/05/10/java-arrayblockingqueue-linkedblockingqueue-analysis/" rel="external nofollow noopener noreferrer" target="_blank">《Java阻塞队列ArrayBlockingQueue和LinkedBlockingQueue实现原理分析》</a> <ul><li>推荐 ：<a href="http://www.infoq.com/cn/articles/java-threadPool" rel="external nofollow noopener noreferrer" target="_blank">《聊聊并发（三）——JAVA线程池的分析和使用》</a></li><li>推荐 ：<a href="http://www.infoq.com/cn/articles/java-blocking-queue" rel="external nofollow noopener noreferrer" target="_blank">《聊聊并发（七）——Java中的阻塞队列》</a></li></ul></li></ul></li></ul></li><li>第 11 至 23 行 ：创建 ThreadPoolExecutor 。看起来代码比较多，根据 <code>allowMaximumSizeToDivergeFromCoreSize</code> 的情况，计算线程池的 <code>maximumPoolSize</code> 属性。计算的方式和 <a href="https://github.com/Netflix/Hystrix/blob/1f64fced24289ea435f1e2d5a47a068bf7b79729/hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPoolProperties.java#L138" rel="external nofollow noopener noreferrer" target="_blank"><code>HystrixThreadPoolProperties#actualMaximumSize()</code></a> 方法是一致的。 </li></ul><hr><p><code>com.netflix.hystrix.strategy.concurrency.HystrixConcurrencyStrategyDefault</code> ，Hystrix 并发策略<strong>实现类</strong>。代码如下( 基本没做啥 ) ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixConcurrencyStrategyDefault</span> <span class="keyword">extends</span> <span class="title">HystrixConcurrencyStrategy</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 单例</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HystrixConcurrencyStrategyDefault INSTANCE = <span class="keyword">new</span> HystrixConcurrencyStrategyDefault();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HystrixConcurrencyStrategy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> INSTANCE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HystrixConcurrencyStrategyDefault</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><p>在 AbstractCommand <strong>构造方法</strong>里，初始化命令的 <code>threadPoolKey</code> 属性，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> HystrixConcurrencyStrategy concurrencyStrategy;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractCommand</span><span class="params">(HystrixCommandGroupKey group, HystrixCommandKey key, HystrixThreadPoolKey threadPoolKey, HystrixCircuitBreaker circuitBreaker, HystrixThreadPool threadPool,</span></span></div><div class="line"><span class="function"><span class="params">       HystrixCommandProperties.Setter commandPropertiesDefaults, HystrixThreadPoolProperties.Setter threadPoolPropertiesDefaults,</span></span></div><div class="line"><span class="function"><span class="params">       HystrixCommandMetrics metrics, TryableSemaphore fallbackSemaphore, TryableSemaphore executionSemaphore,</span></span></div><div class="line"><span class="function"><span class="params">       HystrixPropertiesStrategy propertiesStrategy, HystrixCommandExecutionHook executionHook)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line">   </div><div class="line">    <span class="comment">// 初始化 并发策略</span></div><div class="line">    <span class="keyword">this</span>.concurrencyStrategy = HystrixPlugins.getInstance().getConcurrencyStrategy();</div><div class="line">   </div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>HystrixPlugins ，Hystrix <strong>插件</strong>体系，<a href="https://github.com/Netflix/Hystrix/wiki/Plugins" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/Netflix/Hystrix/wiki/Plugins</a> 有详细解析。</li><li>调用 <code>HystrixPlugins#getConcurrencyStrategy()</code> 获得 HystrixConcurrencyStrategy 对象。默认情况下，使用 HystrixConcurrencyStrategyDefault 。当然你也可以参考 Hystrix 插件体系，实现<strong>自定义</strong>的 HystrixConcurrencyStrategy 实现，以达到<strong>覆写</strong> <code>#getThreadPool()</code>，<code>#getBlockingQueue()</code> 等方法。点击 <a href="https://github.com/YunaiV/Hystrix/blob/853258ce3f499e1f525130064f0d6cb055088b29/hystrix-core/src/main/java/com/netflix/hystrix/strategy/HystrixPlugins.java#L164" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看该方法代码。</li></ul><h1 id="5-HystrixThreadPool"><a href="#5-HystrixThreadPool" class="headerlink" title="5. HystrixThreadPool"></a>5. HystrixThreadPool</h1><p><code>com.netflix.hystrix.HystrixThreadPool</code> ，Hystrix 线程池<strong>接口</strong>。当 Hystrix 命令使用 <code>THREAD</code> 执行隔离策略时，<code>HystrixCommand#run()</code> 方法在<strong>线程池执行</strong>。点击 <a href="https://github.com/YunaiV/Hystrix/blob/853258ce3f499e1f525130064f0d6cb055088b29/hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPool.java#L47" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看。HystrixThreadPool 定义接口如下 ：</p><ul><li><code>#getExecutor()</code> ：获得 ExecutorService 。</li><li><code>#getScheduler()</code> / <code>#getScheduler(Func0&lt;Boolean&gt;)</code> ：获得 RxJava Scheduler 。</li><li><code>#isQueueSpaceAvailable()</code> ：线程池队列是否有<strong>空余</strong>。</li><li><code>#markThreadExecution()</code> / <code>#markThreadCompletion()</code> / <code>#markThreadRejection()</code> ：TODO 【2002】【metrics】</li></ul><h2 id="5-1-HystrixThreadPoolDefault"><a href="#5-1-HystrixThreadPoolDefault" class="headerlink" title="5.1 HystrixThreadPoolDefault"></a>5.1 HystrixThreadPoolDefault</h2><p><code>com.netflix.hystrix.HystrixThreadPool.HystrixThreadPoolDefault</code> ，Hystrix 线程池<strong>实现类</strong>。 </p><p><strong>构造方法</strong>，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">private</span> <span class="keyword">final</span> HystrixThreadPoolProperties properties;</div><div class="line"> <span class="number">2</span>: <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; queue;</div><div class="line"> <span class="number">3</span>: <span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor threadPool;</div><div class="line"> <span class="number">4</span>: <span class="keyword">private</span> <span class="keyword">final</span> HystrixThreadPoolMetrics metrics;</div><div class="line"> <span class="number">5</span>: <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> queueSize;</div><div class="line"> <span class="number">6</span>: </div><div class="line"> <span class="number">7</span>: <span class="function"><span class="keyword">public</span> <span class="title">HystrixThreadPoolDefault</span><span class="params">(HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolProperties.Setter propertiesDefaults)</span> </span>&#123;</div><div class="line"> <span class="number">8</span>:     <span class="comment">// 初始化 HystrixThreadPoolProperties</span></div><div class="line"> <span class="number">9</span>:     <span class="keyword">this</span>.properties = HystrixPropertiesFactory.getThreadPoolProperties(threadPoolKey, propertiesDefaults);</div><div class="line"><span class="number">10</span>:     <span class="comment">// 获得 HystrixConcurrencyStrategy</span></div><div class="line"><span class="number">11</span>:     HystrixConcurrencyStrategy concurrencyStrategy = HystrixPlugins.getInstance().getConcurrencyStrategy();</div><div class="line"><span class="number">12</span>:     <span class="comment">// 队列大小</span></div><div class="line"><span class="number">13</span>:     <span class="keyword">this</span>.queueSize = properties.maxQueueSize().get();</div><div class="line"><span class="number">14</span>: </div><div class="line"><span class="number">15</span>:     <span class="comment">// TODO 【2002】【metrics】</span></div><div class="line"><span class="number">16</span>:     <span class="keyword">this</span>.metrics = HystrixThreadPoolMetrics.getInstance(threadPoolKey,</div><div class="line"><span class="number">17</span>:             concurrencyStrategy.getThreadPool(threadPoolKey, properties), <span class="comment">// 初始化 ThreadPoolExecutor</span></div><div class="line"><span class="number">18</span>:             properties);</div><div class="line"><span class="number">19</span>: </div><div class="line"><span class="number">20</span>:     <span class="comment">// 获得 ThreadPoolExecutor</span></div><div class="line"><span class="number">21</span>:     <span class="keyword">this</span>.threadPool = <span class="keyword">this</span>.metrics.getThreadPool();</div><div class="line"><span class="number">22</span>:     <span class="keyword">this</span>.queue = <span class="keyword">this</span>.threadPool.getQueue(); <span class="comment">// 队列</span></div><div class="line"><span class="number">23</span>: </div><div class="line"><span class="number">24</span>:     <span class="comment">// TODO 【2002】【metrics】</span></div><div class="line"><span class="number">25</span>:     <span class="comment">/* strategy: HystrixMetricsPublisherThreadPool */</span></div><div class="line"><span class="number">26</span>:     HystrixMetricsPublisherFactory.createOrRetrievePublisherForThreadPool(threadPoolKey, <span class="keyword">this</span>.metrics, <span class="keyword">this</span>.properties);</div><div class="line"><span class="number">27</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 9 行 ：初始化 HystrixThreadPoolProperties 。</li><li>第 11 行 ：初始化 HystrixConcurrencyStrategy 。</li><li>第 13 行 ：初始化 <code>queueSize</code> 。</li><li>第 16 至 18 行 ：TODO 【2002】【metrics】<ul><li>第 17 行 ：调用 <code>HystrixConcurrencyStrategy#getThreadPool(...)</code> 方法，初始化 ThreadPoolExecutor 。</li></ul></li><li>第 21 行 ：<strong>获得</strong> ThreadPoolExecutor 。</li><li>第 22 行 ：<strong>获得</strong> ThreadPoolExecutor 的队列。</li><li>第 26 行 ：TODO 【2002】【metrics】</li></ul><hr><p><code>#getExecutor()</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ThreadPoolExecutor <span class="title">getExecutor</span><span class="params">()</span> </span>&#123;</div><div class="line">    touchConfig();</div><div class="line">    <span class="keyword">return</span> threadPool;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>#touchConfig()</code> 方法，<strong>动态</strong>调整 <code>threadPool</code> 的 <code>coreSize</code> / <code>maximumSize</code> / <code>keepAliveTime</code> 参数。点击 <a href="https://github.com/YunaiV/Hystrix/blob/853258ce3f499e1f525130064f0d6cb055088b29/hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPool.java#L188" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看该方法。</li></ul><hr><p><code>#getScheduler()</code> / <code>#getScheduler(Func0&lt;Boolean&gt;)</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Scheduler <span class="title">getScheduler</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//by default, interrupt underlying threads on timeout</span></div><div class="line">    <span class="keyword">return</span> getScheduler(<span class="keyword">new</span> Func0&lt;Boolean&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Scheduler <span class="title">getScheduler</span><span class="params">(Func0&lt;Boolean&gt; shouldInterruptThread)</span> </span>&#123;</div><div class="line">    touchConfig();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HystrixContextScheduler(HystrixPlugins.getInstance().getConcurrencyStrategy(), <span class="keyword">this</span>, shouldInterruptThread);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>HystrixContextScheduler 和 <code>shouldInterruptThread</code> 都在 <a href="#">「6. HystrixContextScheduler」</a> 详细解析。</li></ul><hr><p><code>#isQueueSpaceAvailable()</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isQueueSpaceAvailable</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (queueSize &lt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// we don't have a queue so we won't look for space but instead</span></div><div class="line">        <span class="comment">// let the thread-pool reject or not</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> threadPool.getQueue().size() &lt; properties.queueSizeRejectionThreshold().get();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>由于线程池的队列大小不能<strong>动态</strong>调整，该方法的<strong>实现</strong>通过 <a href="https://github.com/YunaiV/Hystrix/blob/853258ce3f499e1f525130064f0d6cb055088b29/hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPoolProperties.java#L85" rel="external nofollow noopener noreferrer" target="_blank"><code>HystrixThreadPoolProperties.queueSizeRejectionThreshold</code></a> 属性控制。</li><li>注意 <code>queueSize</code> 属性，决定了线程池的队列类型。<ul><li><code>queueSize &lt;= 0</code> 时，<code>#isQueueSpaceAvailable()</code> 都返回 <code>true</code> 的原因是，线程池使用 SynchronousQueue 作为队列，不支持<strong>新</strong>任务排队，任务超过线程池的 <code>maximumPoolSize</code> 时，新任务被拒绝。</li><li><code>queueSize &gt; 0</code> 时，<code>#isQueueSpaceAvailable()</code> 根据情况<code>true</code>/<code>false</code> 的原因是，线程池使用 LinkedBlockingQueue 作为队列，支持<strong>一定数量</strong>的<strong>阻塞</strong>排队，但是这个数量无法调整。通过 <code>#isQueueSpaceAvailable()</code> 方法的判断，<strong>动态</strong>调整。另外，初始<strong>配置</strong>的 <code>queueSize</code> 要<strong>相对大</strong>，否则即使 <code>queueSizeRejectionThreshold</code> 配置的大于 <code>queueSize</code> ，实际提交任务到线程池，也会被<strong>拒绝</strong>。</li></ul></li></ul><h2 id="5-2-Factory"><a href="#5-2-Factory" class="headerlink" title="5.2 Factory"></a>5.2 Factory</h2><p><code>com.netflix.hystrix.HystrixThreadPool.Factory</code> ，HystrixThreadPool 工厂类，不仅限于 HystrixThreadPool 的创建，也提供了 HystrixThreadPool 的管理( HystrixThreadPool 的容器 )。</p><p><code>threadPools</code> 属性，维护创建的 HystrixThreadPool 对应的映射，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, HystrixThreadPool&gt; threadPools = <span class="keyword">new</span> ConcurrentHashMap&lt;String, HystrixThreadPool&gt;();</div></pre></td></tr></table></figure><ul><li>Key 为 <code>HystrixThreadPoolKey#name()</code> ，每个 HystrixThreadPoolKey 对应一个 HystrixThreadPool 对象。</li></ul><hr><p><code>#getInstance(...)</code> 方法，获得 HystrixThreadPool 对象，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/* package */</span><span class="function"><span class="keyword">static</span> HystrixThreadPool <span class="title">getInstance</span><span class="params">(HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolProperties.Setter propertiesBuilder)</span> </span>&#123;</div><div class="line">    <span class="comment">// get the key to use instead of using the object itself so that if people forget to implement equals/hashcode things will still work</span></div><div class="line">    String key = threadPoolKey.name();</div><div class="line"></div><div class="line">    <span class="comment">// this should find it for all but the first time</span></div><div class="line">    HystrixThreadPool previouslyCached = threadPools.get(key);</div><div class="line">    <span class="keyword">if</span> (previouslyCached != <span class="keyword">null</span>) &#123;</div><div class="line">         <span class="keyword">return</span> previouslyCached;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">// if we get here this is the first time so we need to initialize</span></div><div class="line">     <span class="keyword">synchronized</span> (HystrixThreadPool.class) &#123;</div><div class="line">        <span class="keyword">if</span> (!threadPools.containsKey(key)) &#123;</div><div class="line">            threadPools.put(key, <span class="keyword">new</span> HystrixThreadPoolDefault(threadPoolKey, propertiesBuilder));</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> threadPools.get(key);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>根据 <code>threadPoolKey</code> 先从 <code>threadPool</code> 获取已创建的 HystrixThreadPool ；获取不到，创建对应的 HystrixThreadPool 返回，并添加到 <code>threadPool</code> 。</li></ul><hr><p><code>#shutdown()</code> / <code>#shutdown(timeout, unit)</code> 方法，比较易懂，点击 <a href="https://github.com/YunaiV/Hystrix/blob/853258ce3f499e1f525130064f0d6cb055088b29/hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPool.java#L128" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看。</p><h2 id="5-3-初始化"><a href="#5-3-初始化" class="headerlink" title="5.3 初始化"></a>5.3 初始化</h2><p>在 AbstractCommand <strong>构造方法</strong>里，初始化命令的 <code>threadPool</code> 属性，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> HystrixThreadPool threadPool;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractCommand</span><span class="params">(HystrixCommandGroupKey group, HystrixCommandKey key, HystrixThreadPoolKey threadPoolKey, HystrixCircuitBreaker circuitBreaker, HystrixThreadPool threadPool,</span></span></div><div class="line"><span class="function"><span class="params">       HystrixCommandProperties.Setter commandPropertiesDefaults, HystrixThreadPoolProperties.Setter threadPoolPropertiesDefaults,</span></span></div><div class="line"><span class="function"><span class="params">       HystrixCommandMetrics metrics, TryableSemaphore fallbackSemaphore, TryableSemaphore executionSemaphore,</span></span></div><div class="line"><span class="function"><span class="params">       HystrixPropertiesStrategy propertiesStrategy, HystrixCommandExecutionHook executionHook)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ... 省略其他代码</span></div><div class="line"></div><div class="line">    <span class="comment">// 初始化 threadPoolKey</span></div><div class="line">    <span class="keyword">this</span>.threadPoolKey = initThreadPoolKey(threadPoolKey, <span class="keyword">this</span>.commandGroup, <span class="keyword">this</span>.properties.executionIsolationThreadPoolKeyOverride().get());</div><div class="line">    <span class="comment">// 初始化 threadPool</span></div><div class="line">    <span class="keyword">this</span>.threadPool = initThreadPool(threadPool, <span class="keyword">this</span>.threadPoolKey, threadPoolPropertiesDefaults);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>#initThreadPool(...)</code> 方法，获得 HystrixThreadPool ，点击 <a href="https://github.com/YunaiV/Hystrix/blob/853258ce3f499e1f525130064f0d6cb055088b29/hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java#L286" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看。</li></ul><h1 id="6-HystrixScheduler"><a href="#6-HystrixScheduler" class="headerlink" title="6. HystrixScheduler"></a>6. HystrixScheduler</h1><p>Hystrix 实现了<strong>自定义的</strong> RxJava Scheduler ，整体类图如下 ：</p><p><img src="http://www.iocoder.cn/images/Hystrix/2018_10_25/01.png" alt=""></p><ul><li>HystrixContextScheduler ( 实现 RxJava Scheduler <strong>抽象类</strong> )，内嵌类型为 ThreadPoolScheduler ( 实现 RxJava Scheduler <strong>抽象类</strong> )的 <code>actualScheduler</code> 属性。</li><li>HystrixContextWorker ( 实现 RxJava Worker <strong>抽象类</strong> )，内嵌类型为 ThreadPoolWorker ( 实现 RxJava Worker <strong>抽象类</strong> )的 <code>worker</code> 属性。</li></ul><h2 id="6-1-HystrixContextScheduler"><a href="#6-1-HystrixContextScheduler" class="headerlink" title="6.1 HystrixContextScheduler"></a>6.1 HystrixContextScheduler</h2><p><strong>构造方法</strong>，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixContextScheduler</span> <span class="keyword">extends</span> <span class="title">Scheduler</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HystrixConcurrencyStrategy concurrencyStrategy;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Scheduler actualScheduler;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HystrixThreadPool threadPool;</div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HystrixContextScheduler</span><span class="params">(HystrixConcurrencyStrategy concurrencyStrategy, HystrixThreadPool threadPool, Func0&lt;Boolean&gt; shouldInterruptThread)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.concurrencyStrategy = concurrencyStrategy;</div><div class="line">        <span class="keyword">this</span>.threadPool = threadPool;</div><div class="line">        <span class="keyword">this</span>.actualScheduler = <span class="keyword">new</span> ThreadPoolScheduler(threadPool, shouldInterruptThread);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>actualScheduler</code> 属性，类型为 ThreadPoolScheduler 。</li></ul><hr><p><code>#createWorker()</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Worker <span class="title">createWorker</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HystrixContextSchedulerWorker(actualScheduler.createWorker());</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>使用 <code>actualScheduler</code> 创建 ThreadPoolWorker ，传参给 HystrixContextSchedulerWorker 。</li></ul><h2 id="6-2-HystrixContextSchedulerWorker"><a href="#6-2-HystrixContextSchedulerWorker" class="headerlink" title="6.2 HystrixContextSchedulerWorker"></a>6.2 HystrixContextSchedulerWorker</h2><p><strong>构造方法</strong>，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixContextSchedulerWorker</span> <span class="keyword">extends</span> <span class="title">Worker</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Worker worker;</div><div class="line"></div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HystrixContextSchedulerWorker</span><span class="params">(Worker actualWorker)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.worker = actualWorker;</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>worker</code> 属性，类型为 ThreadPoolWorker 。</li></ul><hr><p><code>#schedule(Action0)</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Subscription <span class="title">schedule</span><span class="params">(Action0 action)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (threadPool != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (!threadPool.isQueueSpaceAvailable()) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Rejected command because thread-pool queueSize is at rejection threshold."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> worker.schedule(<span class="keyword">new</span> HystrixContexSchedulerAction(concurrencyStrategy, action));</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>ThreadPool#isQueueSpaceAvailable()</code> 方法，判断线程池队列是否有<strong>空余</strong>。这个就是 HystrixContextScheduler 的<strong>实际</strong>用途。</li></ul><hr><p><code>#unsubscribe()</code> / <code>#isUnsubscribed()</code> 方法，使用 <code>worker</code> 判断，点击 <a href="https://github.com/YunaiV/Hystrix/blob/853258ce3f499e1f525130064f0d6cb055088b29/hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixContextScheduler.java#L80" rel="external nofollow noopener noreferrer" target="_blank">链接</a>查看。 </p><h2 id="6-3-ThreadPoolScheduler"><a href="#6-3-ThreadPoolScheduler" class="headerlink" title="6.3 ThreadPoolScheduler"></a>6.3 ThreadPoolScheduler</h2><p>ThreadPoolScheduler 比较简单，点击 <a href="https://github.com/YunaiV/Hystrix/blob/853258ce3f499e1f525130064f0d6cb055088b29/hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixContextScheduler.java#L111" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看。</p><h2 id="6-4-ThreadPoolWorker"><a href="#6-4-ThreadPoolWorker" class="headerlink" title="6.4 ThreadPoolWorker"></a>6.4 ThreadPoolWorker</h2><p><strong>构造方法</strong>，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolWorker</span> <span class="keyword">extends</span> <span class="title">Worker</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HystrixThreadPool threadPool;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CompositeSubscription subscription = <span class="keyword">new</span> CompositeSubscription();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Func0&lt;Boolean&gt; shouldInterruptThread;</div><div class="line"></div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolWorker</span><span class="params">(HystrixThreadPool threadPool, Func0&lt;Boolean&gt; shouldInterruptThread)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.threadPool = threadPool;</div><div class="line">        <span class="keyword">this</span>.shouldInterruptThread = shouldInterruptThread;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>subscription</code> 属性，订阅信息。</li></ul><hr><p><code>#schedule(Action0)</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> Subscription <span class="title">schedule</span><span class="params">(<span class="keyword">final</span> Action0 action)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="comment">// 未订阅，返回</span></div><div class="line"> <span class="number">4</span>:     <span class="keyword">if</span> (subscription.isUnsubscribed()) &#123;</div><div class="line"> <span class="number">5</span>:         <span class="comment">// don't schedule, we are unsubscribed</span></div><div class="line"> <span class="number">6</span>:         <span class="keyword">return</span> Subscriptions.unsubscribed();</div><div class="line"> <span class="number">7</span>:     &#125;</div><div class="line"> <span class="number">8</span>: </div><div class="line"> <span class="number">9</span>:     <span class="comment">// 创建 ScheduledAction</span></div><div class="line"><span class="number">10</span>:     <span class="comment">// This is internal RxJava API but it is too useful.</span></div><div class="line"><span class="number">11</span>:     ScheduledAction sa = <span class="keyword">new</span> ScheduledAction(action);</div><div class="line"><span class="number">12</span>: </div><div class="line"><span class="number">13</span>:     <span class="comment">// 添加到 订阅</span></div><div class="line"><span class="number">14</span>:     subscription.add(sa);</div><div class="line"><span class="number">15</span>:     sa.addParent(subscription);</div><div class="line"><span class="number">16</span>: </div><div class="line"><span class="number">17</span>:     <span class="comment">// 提交 任务</span></div><div class="line"><span class="number">18</span>:     ThreadPoolExecutor executor = (ThreadPoolExecutor) threadPool.getExecutor();</div><div class="line"><span class="number">19</span>:     FutureTask&lt;?&gt; f = (FutureTask&lt;?&gt;) executor.submit(sa);</div><div class="line"><span class="number">20</span>:     sa.add(<span class="keyword">new</span> FutureCompleterWithConfigurableInterrupt(f, shouldInterruptThread, executor));</div><div class="line"><span class="number">21</span>: </div><div class="line"><span class="number">22</span>:     <span class="keyword">return</span> sa;</div><div class="line"><span class="number">23</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 4 至 7 行 ：未订阅，返回。</li><li>第 11 行 ： 创建 ScheduledAction 。在 <a href="">TODO 【2013】【ScheduledAction】</a> 详细解析。</li><li>第 14 至 15 行 ：添加到订阅( <code>subscription</code> )。</li><li>第 18 至 20 行 ：使用 <code>threadPool</code> ，提交任务，并创建 FutureCompleterWithConfigurableInterrupt 添加到订阅( <code>sa</code> )。</li><li>第 22 行 ：返回订阅( <code>sa</code> )。整体订阅关系如下 ：<img src="http://www.iocoder.cn/images/Hystrix/2018_10_25/02.png" alt=""></li></ul><hr><p><code>#unsubscribe()</code> / <code>#isUnsubscribed()</code> 方法，使用 <code>subscription</code> 判断，点击 <a href="https://github.com/YunaiV/Hystrix/blob/853258ce3f499e1f525130064f0d6cb055088b29/hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixContextScheduler.java#L149" rel="external nofollow noopener noreferrer" target="_blank">链接</a>查看。</p><h2 id="6-5-FutureCompleterWithConfigurableInterrupt"><a href="#6-5-FutureCompleterWithConfigurableInterrupt" class="headerlink" title="6.5 FutureCompleterWithConfigurableInterrupt"></a>6.5 FutureCompleterWithConfigurableInterrupt</h2><p><code>com.netflix.hystrix.strategy.concurrency.HystrixContextScheduler.FutureCompleterWithConfigurableInterrupt</code> ，实现类似 <code>rx.internal.schedulers.ScheduledAction.FutureCompleter</code> ，在它的基础上，支持配置 <code>FutureTask#cancel(Boolean)</code> 是否可<strong>打断</strong>运行( <code>mayInterruptIfRunning</code> )。</p><p><strong>构造方法</strong>，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureCompleterWithConfigurableInterrupt</span> <span class="keyword">implements</span> <span class="title">Subscription</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FutureTask&lt;?&gt; f;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Func0&lt;Boolean&gt; shouldInterruptThread;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor executor;</div><div class="line"></div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FutureCompleterWithConfigurableInterrupt</span><span class="params">(FutureTask&lt;?&gt; f, Func0&lt;Boolean&gt; shouldInterruptThread, ThreadPoolExecutor executor)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.f = f;</div><div class="line">        <span class="keyword">this</span>.shouldInterruptThread = shouldInterruptThread;</div><div class="line">        <span class="keyword">this</span>.executor = executor;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><p><strong>当命令执行超时，或是主动取消命令执行时，调用 <code>#unsubscribe()</code> 方法，取消执行</strong>。<br><strong>当命令执行超时，或是主动取消命令执行时，调用 <code>#unsubscribe()</code> 方法，取消执行</strong>。<br><strong>当命令执行超时，或是主动取消命令执行时，调用 <code>#unsubscribe()</code> 方法，取消执行</strong>。  </p><p><code>#unsubscribe()</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 从 线程池 移除 任务</span></div><div class="line">    executor.remove(f);</div><div class="line">    <span class="comment">// 根据 shouldInterruptThread 配置，是否强制取消</span></div><div class="line">    <span class="keyword">if</span> (shouldInterruptThread.call()) &#123;</div><div class="line">        f.cancel(<span class="keyword">true</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        f.cancel(<span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>根据 <code>shouldInterruptThread</code> 方法，判断是否<strong>强制</strong>取消。</li><li><code>shouldInterruptThread</code> 对应的方法，实现代码如下 ：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">subscribeOn(threadPool.getScheduler(<span class="keyword">new</span> Func0&lt;Boolean&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> properties.executionIsolationThreadInterruptOnTimeout().get() &amp;&amp; _cmd.isCommandTimedOut.get() == TimedOutStatus.TIMED_OUT;</div><div class="line">    &#125;</div><div class="line">&#125;));</div></pre></td></tr></table></figure><ul><li>当 <code>executionIsolationThreadInterruptOnTimeout = true</code> 时，命令可执行<strong>超时</strong>。当命令可执行<strong>超时</strong>时，<strong>强制</strong>取消。</li><li>当使用 <code>HystrixCommand.queue()</code> 返回的 Future ，可以使用 <code>Future#cancel(Boolean)</code> 取消命令执行。从 <code>shouldInterruptThread</code> 对应的方法可以看到，如果此时不满足命令执行<strong>超时</strong>的条件，命令执行取消的方式是<strong>非强制</strong>的。此时当 <code>executionIsolationThreadInterruptOnFutureCancel = true</code> 时，并且调用 <code>Future#cancel(Boolean)</code> 传递 <code>mayInterruptIfRunning = true</code> ，强制取消命令执行。<ul><li>模拟测试用例 ：<a href="https://github.com/YunaiV/Hystrix/blob/HEAD/hystrix-examples/src/main/java/com/netflix/hystrix/examples/basic/CommandHelloWorld.java#L118" rel="external nofollow noopener noreferrer" target="_blank"><code>CommandHelloWorld#testAsynchronous3()</code></a> </li><li><code>HystrixCommand#queue()</code> ：点击 <a href="https://github.com/YunaiV/Hystrix/blob/ba86690747b365482c306ec3a0725e0be4bab739/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommand.java#L378" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 <code>Future#cancel(Boolean)</code> 方法。</li></ul></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>一边写一边想明白了 RxJava 的一些东西，挺舒服的赶脚。</p><p>继续 Go On ~ 周末嗨不停。</p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Hystrix/command-execute-second-isolation-strategy/&quot;&gt;http://www.iocoder.cn/Hystrix/command-execute
      
    
    </summary>
    
      <category term="Hystrix" scheme="http://www.iocoder.cn/categories/Hystrix/"/>
    
    
  </entry>
  
  <entry>
    <title>Hystrix 源码解析 —— 命令执行（一）之正常执行逻辑</title>
    <link href="http://www.iocoder.cn/Hystrix/command-execute-first-run/"/>
    <id>http://www.iocoder.cn/Hystrix/command-execute-first-run/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2017-11-04T12:16:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Hystrix/command-execute-first-run/">http://www.iocoder.cn/Hystrix/command-execute-first-run/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/Hystrix/command-execute-first-run/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-first-run/">2. #applyHystrixSemantics(…)</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-first-run/">3. TryableSemaphore</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-first-run/">4. #executeCommandAndObserve(…)</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-first-run/">5. #executeCommandWithSpecifiedIsolation(…)</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-first-run/">6. #getUserExecutionObservable(…)</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-first-run/">7. #getExecutionObservable()</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-first-run/">8. CommandState</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-first-run/">9. ThreadState</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-first-run/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Hystrix 命令执行（一）之正常执行逻辑</strong>。</p><p>建议 ：对 RxJava 已经有一定的了解的基础上阅读本文。</p><p>Hystrix 执行命令整体流程如下图：</p><blockquote><p>FROM <a href="http://youdang.github.io/2016/02/05/translate-hystrix-wiki-how-it-works/#流程图" rel="external nofollow noopener noreferrer" target="_blank">《【翻译】Hystrix文档-实现原理》「流程图」</a><br><img src="http://www.iocoder.cn/images/Hystrix/2018_10_22/01.jpeg" alt=""></p></blockquote><ul><li><strong>红</strong>框 ：Hystrix 命令执行的过程。</li><li><strong>蓝</strong>圈 ：本文分享的部分 —— 正常执行逻辑。</li></ul><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-applyHystrixSemantics-…"><a href="#2-applyHystrixSemantics-…" class="headerlink" title="2. #applyHystrixSemantics(…)"></a>2. #applyHystrixSemantics(…)</h1><p>在 <a href="http://www.iocoder.cn/Hystrix/command-execute-result-cache/?self">《Hystrix 源码解析 —— 执行结果缓存》</a> 里，我们看到 <code>#toObservable()</code> 方法里的<strong>第 11 至 19 行</strong>，当缓存特性<strong>未开启</strong>，或者缓存<strong>未命中</strong>时，使用 <code>applyHystrixSemantics</code> 传入 <code>Observable#defer(...)</code> 方法，声明<strong>执行命令</strong>的 Observable。</p><p>创建 <code>applyHystrixSemantics</code> 变量，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// `AbstractCommand#toObservable()` 方法</span></div><div class="line">  <span class="number">1</span>: <span class="keyword">final</span> Func0&lt;Observable&lt;R&gt;&gt; applyHystrixSemantics = <span class="keyword">new</span> Func0&lt;Observable&lt;R&gt;&gt;() &#123;</div><div class="line">  <span class="number">2</span>:     <span class="meta">@Override</span></div><div class="line">  <span class="number">3</span>:     <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="number">4</span>:         <span class="comment">// commandState 处于 UNSUBSCRIBED 时，不执行命令</span></div><div class="line">  <span class="number">5</span>:         <span class="keyword">if</span> (commandState.get().equals(CommandState.UNSUBSCRIBED)) &#123;</div><div class="line">  <span class="number">6</span>:             <span class="keyword">return</span> Observable.never();</div><div class="line">  <span class="number">7</span>:         &#125;</div><div class="line">  <span class="number">8</span>:         <span class="comment">// 获得 执行Observable</span></div><div class="line">  <span class="number">9</span>:         <span class="keyword">return</span> applyHystrixSemantics(_cmd);</div><div class="line"> <span class="number">10</span>:     &#125;</div><div class="line"> <span class="number">11</span>: &#125;;</div></pre></td></tr></table></figure><ul><li>第 5 至 7 行 ：当 <code>commandState</code> 处于 <code>UNSUBSCRIBED</code> 时，不执行命令。</li><li>第 9 行 ：调用 <code>#applyHystrixSemantics(...)</code> 方法，获得执行 Observable 。</li></ul><hr><p><code>#applyHystrixSemantics(...)</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> Observable&lt;R&gt; <span class="title">applyHystrixSemantics</span><span class="params">(<span class="keyword">final</span> AbstractCommand&lt;R&gt; _cmd)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// TODO 【2003】【HOOK】</span></div><div class="line"> <span class="number">3</span>:     <span class="comment">// mark that we're starting execution on the ExecutionHook</span></div><div class="line"> <span class="number">4</span>:     <span class="comment">// if this hook throws an exception, then a fast-fail occurs with no fallback.  No state is left inconsistent</span></div><div class="line"> <span class="number">5</span>:     executionHook.onStart(_cmd);</div><div class="line"> <span class="number">6</span>: </div><div class="line"> <span class="number">7</span>:     <span class="comment">/* determine if we're allowed to execute */</span></div><div class="line"> <span class="number">8</span>:     <span class="keyword">if</span> (circuitBreaker.attemptExecution()) &#123;</div><div class="line"> <span class="number">9</span>:         <span class="comment">// 获得 信号量</span></div><div class="line"><span class="number">10</span>:         <span class="keyword">final</span> TryableSemaphore executionSemaphore = getExecutionSemaphore();</div><div class="line"><span class="number">11</span>: </div><div class="line"><span class="number">12</span>:         <span class="comment">// 信号量释放Action</span></div><div class="line"><span class="number">13</span>:         <span class="keyword">final</span> AtomicBoolean semaphoreHasBeenReleased = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</div><div class="line"><span class="number">14</span>:         <span class="keyword">final</span> Action0 singleSemaphoreRelease = <span class="keyword">new</span> Action0() &#123;</div><div class="line"><span class="number">15</span>:             <span class="meta">@Override</span></div><div class="line"><span class="number">16</span>:             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">17</span>:                 <span class="keyword">if</span> (semaphoreHasBeenReleased.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</div><div class="line"><span class="number">18</span>:                     executionSemaphore.release();</div><div class="line"><span class="number">19</span>:                 &#125;</div><div class="line"><span class="number">20</span>:             &#125;</div><div class="line"><span class="number">21</span>:         &#125;;</div><div class="line"><span class="number">22</span>: </div><div class="line"><span class="number">23</span>:         <span class="comment">// TODO 【2011】【Hystrix 事件机制】</span></div><div class="line"><span class="number">24</span>:         <span class="keyword">final</span> Action1&lt;Throwable&gt; markExceptionThrown = <span class="keyword">new</span> Action1&lt;Throwable&gt;() &#123;</div><div class="line"><span class="number">25</span>:             <span class="meta">@Override</span></div><div class="line"><span class="number">26</span>:             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Throwable t)</span> </span>&#123;</div><div class="line"><span class="number">27</span>:                 eventNotifier.markEvent(HystrixEventType.EXCEPTION_THROWN, commandKey);</div><div class="line"><span class="number">28</span>:             &#125;</div><div class="line"><span class="number">29</span>:         &#125;;</div><div class="line"><span class="number">30</span>: </div><div class="line"><span class="number">31</span>:         <span class="comment">// 信号量 获得</span></div><div class="line"><span class="number">32</span>:         <span class="keyword">if</span> (executionSemaphore.tryAcquire()) &#123;</div><div class="line"><span class="number">33</span>:             <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">34</span>:                 <span class="comment">// 标记 executionResult 调用开始时间</span></div><div class="line"><span class="number">35</span>:                 <span class="comment">/* used to track userThreadExecutionTime */</span></div><div class="line"><span class="number">36</span>:                 executionResult = executionResult.setInvocationStartTime(System.currentTimeMillis());</div><div class="line"><span class="number">37</span>: </div><div class="line"><span class="number">38</span>:                 <span class="comment">// 获得 执行Observable</span></div><div class="line"><span class="number">39</span>:                 <span class="keyword">return</span> executeCommandAndObserve(_cmd)</div><div class="line"><span class="number">40</span>:                         .doOnError(markExceptionThrown)</div><div class="line"><span class="number">41</span>:                         .doOnTerminate(singleSemaphoreRelease)</div><div class="line"><span class="number">42</span>:                         .doOnUnsubscribe(singleSemaphoreRelease);</div><div class="line"><span class="number">43</span>:             &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</div><div class="line"><span class="number">44</span>:                 <span class="keyword">return</span> Observable.error(e);</div><div class="line"><span class="number">45</span>:             &#125;</div><div class="line"><span class="number">46</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">47</span>:             <span class="keyword">return</span> handleSemaphoreRejectionViaFallback();</div><div class="line"><span class="number">48</span>:         &#125;</div><div class="line"><span class="number">49</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">50</span>:         <span class="keyword">return</span> handleShortCircuitViaFallback();</div><div class="line"><span class="number">51</span>:     &#125;</div><div class="line"><span class="number">52</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 5 行 ：TODO 【2003】【HOOK】</li><li>第 8 行 ：TODO 【2012】【链路健康度】</li><li>第 10 行 ：调用 <code>#getExecutionSemaphore()</code> 方法，获得<strong>信号量</strong>( TryableSemaphore )对象，在 <a href="#">「3. TryableSemaphore」</a> 详细解析。</li><li>第 13 至 21 行 ：信号量释放 Action ，用于下面【执行命令 Observable】的 <code>#doOnTerminate(Action)</code> 和 <code>#doOnUnsubscribe(Action)</code> 方法( 见第 41 至 42 行 )。</li><li>第 24 至 29 行 ：TODO 【2011】【Hystrix 事件机制】</li><li>第 32 行 ：调用 <code>TryableSemaphore#tryAcquire()</code> 方法，<strong>信号量</strong>( TryableSemaphore )使用成功，在 <a href="#">「3. TryableSemaphore」</a> 详细解析。</li><li>第 36 行 ：标记 <code>executionResult</code> 的<strong>调用</strong>开始时间。</li><li>第 39 行 ：调用 <code>#executeCommandAndObserve()</code> 方法，获得【执行命令 Observable】。在 <a href="#">「4. #executeCommandAndObserve(…)」</a> 详细解析。</li><li>第 43 至 45 行 ：若发生异常，调用 <code>Observable#error(Exception)</code> 方法返回 Observable 。</li><li>第 46 至 48 行 ：<strong>信号量</strong>( TryableSemaphore )使用失败，调用 <code>#handleSemaphoreRejectionViaFallback()</code> 方法，处理信号量拒绝的失败回退逻辑，在 <a href="TODO 【2004】【执行与fallbak】">《Hystrix 源码解析 —— 命令执行（四）之失败回退逻辑》</a> 详细解析。</li><li>第 49 至 51 行 ：链路处于<strong>熔断</strong>状态，调用 <code>#handleShortCircuitViaFallback()</code> 方法，处理链路熔断的失败回退逻辑，在 <a href="TODO 【2004】【执行与fallbak】">《Hystrix 源码解析 —— 命令执行（四）之失败回退逻辑》</a> 详细解析。</li></ul><h1 id="3-TryableSemaphore"><a href="#3-TryableSemaphore" class="headerlink" title="3. TryableSemaphore"></a>3. TryableSemaphore</h1><p><code>com.netflix.hystrix.AbstractCommand.TryableSemaphore</code> ，Hystrix 定义的信号量<strong>接口</strong>。代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TryableSemaphore</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumberOfPermitsUsed</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>从 API 上，Java 自带的 <code>java.util.concurrent.Semaphore</code> 都能满足，为什么不使用它呢？继续一起往下看。</li></ul><p>TryableSemaphore 共有两个子类实现 ：</p><ul><li>TryableSemaphoreNoOp</li><li>TryableSemaphoreActual</li></ul><h2 id="3-1-TryableSemaphoreNoOp"><a href="#3-1-TryableSemaphoreNoOp" class="headerlink" title="3.1 TryableSemaphoreNoOp"></a>3.1 TryableSemaphoreNoOp</h2><p><code>com.netflix.hystrix.AbstractCommand.TryableSemaphoreNoOp</code> ，<strong>无操作</strong>的信号量。代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/* package */</span><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TryableSemaphoreNoOp</span> <span class="keyword">implements</span> <span class="title">TryableSemaphore</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> TryableSemaphore DEFAULT = <span class="keyword">new</span> TryableSemaphoreNoOp();</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</div><div class="line"> </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberOfPermitsUsed</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>从实现上看，<code>#tryAcquire()</code> 方法，每次都返回的是 <code>true</code> ；<code>#release()</code> 方法，无任何操作。这个是<strong>为什么</strong>？在 Hystrix 里提供了两种<strong>执行隔离策略</strong>  ：<ul><li><code>Thread</code> ，该方式不使用信号量，因此使用 TryableSemaphoreNoOp ，这样每次调用 <code>#tryAcquire()</code> 都能返回 <code>true</code> 。在 <a href="TODO 【2004】【执行与fallbak】">《TODO 【2004】【执行与fallbak】》</a> 详细解析该方式。</li><li><code>Semaphore</code> ，该方式使用信号量，因此使用 TryableSemaphoreActual ，这样每次调用 <code>#tryAcquire()</code> 根据情况返回 <code>true / false</code> 。在 <a href="#">「3.2 TryableSemaphoreActual」</a> 详细解析。</li></ul></li></ul><h2 id="3-2-TryableSemaphoreActual"><a href="#3-2-TryableSemaphoreActual" class="headerlink" title="3.2 TryableSemaphoreActual"></a>3.2 TryableSemaphoreActual</h2><p><code>com.netflix.hystrix.AbstractCommand.TryableSemaphoreActual</code> ，<strong>真正的</strong>的信号量实现。不过实际上，TryableSemaphoreActual 更加像一个<strong>计数器</strong>。代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/* package */</span><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TryableSemaphoreActual</span> <span class="keyword">implements</span> <span class="title">TryableSemaphore</span> </span>&#123;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> HystrixProperty&lt;Integer&gt; numberOfPermits;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TryableSemaphoreActual</span><span class="params">(HystrixProperty&lt;Integer&gt; numberOfPermits)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.numberOfPermits = numberOfPermits;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> currentCount = count.incrementAndGet();</div><div class="line">        <span class="keyword">if</span> (currentCount &gt; numberOfPermits.get()) &#123;</div><div class="line">            count.decrementAndGet();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</div><div class="line">        count.decrementAndGet();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberOfPermitsUsed</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> count.get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>numberOfPermits</code> 属性，信号量<strong>上限</strong>。<code>com.netflix.hystrix.strategy.properties.HystrixProperty</code> 是一个接口，当其使用类似 <code>com.netflix.hystrix.strategy.properties.archaius.IntegerDynamicProperty</code> <strong>动态</strong>属性的实现时，可以实现动态调整信号量的<strong>上限</strong>，这就是上文提到的为什么不使用 <code>java.util.concurrent.Semaphore</code> 的原因之一。</li><li><code>count</code> 属性，信号量使用数量。🙂，这是为什么说 TryableSemaphoreActual 更加像一个<strong>计数器</strong> 的原因。</li><li>另一个不使用 <code>java.util.concurrent.Semaphore</code> 的原因，TryableSemaphoreActual 无<strong>阻塞</strong>获取信号量的需求，使用 AtomicInteger 可以达到更轻量级的实现。</li></ul><h2 id="3-3-getExecutionSemaphore"><a href="#3-3-getExecutionSemaphore" class="headerlink" title="3.3 #getExecutionSemaphore()"></a>3.3 #getExecutionSemaphore()</h2><p>调用 <code>#getExecutionSemaphore()</code> 方法，获得信号量对象，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 执行命令（正常执行）信号量映射</span></div><div class="line"><span class="comment">* KEY ：命令名 &#123;<span class="doctag">@link</span> #commandKey&#125;</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="comment">/* each circuit has a semaphore to restrict concurrent fallback execution */</span></div><div class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, TryableSemaphore&gt; executionSemaphorePerCircuit = <span class="keyword">new</span> ConcurrentHashMap&lt;String, TryableSemaphore&gt;();</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">protected</span> TryableSemaphore <span class="title">getExecutionSemaphore</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (properties.executionIsolationStrategy().get() == ExecutionIsolationStrategy.SEMAPHORE) &#123;</div><div class="line">        <span class="keyword">if</span> (executionSemaphoreOverride == <span class="keyword">null</span>) &#123;</div><div class="line">            TryableSemaphore _s = executionSemaphorePerCircuit.get(commandKey.name());</div><div class="line">            <span class="keyword">if</span> (_s == <span class="keyword">null</span>) &#123; <span class="comment">// 不存在时，创建 TryableSemaphoreActual</span></div><div class="line">                <span class="comment">// we didn't find one cache so setup</span></div><div class="line">               executionSemaphorePerCircuit.putIfAbsent(commandKey.name(), <span class="keyword">new</span> TryableSemaphoreActual(properties.executionIsolationSemaphoreMaxConcurrentRequests()));</div><div class="line">                <span class="comment">// assign whatever got set (this or another thread)</span></div><div class="line">                <span class="keyword">return</span> executionSemaphorePerCircuit.get(commandKey.name());</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> _s;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> executionSemaphoreOverride;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// return NoOp implementation since we're not using SEMAPHORE isolation</span></div><div class="line">        <span class="keyword">return</span> TryableSemaphoreNoOp.DEFAULT;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>根据<strong>执行隔离策略</strong>不同获取不同的信号量实现 ：<ul><li><code>Thread</code> ，该方式不使用信号量，因此使用 TryableSemaphoreNoOp 。</li><li><code>Semaphore</code> ，该方式使用信号量，因此使用 TryableSemaphoreActual 。<ul><li>相同的 <code>commandKey</code> ，使用相同的 TryableSemaphoreActual 。</li></ul></li></ul></li></ul><h1 id="4-executeCommandAndObserve-…"><a href="#4-executeCommandAndObserve-…" class="headerlink" title="4. #executeCommandAndObserve(…)"></a>4. #executeCommandAndObserve(…)</h1><p>调用 <code>#executeCommandAndObserve(...)</code> 方法，获得【执行命令 Observable】。代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> Observable&lt;R&gt; <span class="title">executeCommandAndObserve</span><span class="params">(<span class="keyword">final</span> AbstractCommand&lt;R&gt; _cmd)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// TODO 【】</span></div><div class="line"> <span class="number">3</span>:     <span class="keyword">final</span> HystrixRequestContext currentRequestContext = HystrixRequestContext.getContextForCurrentThread();</div><div class="line"> <span class="number">4</span>: </div><div class="line"> <span class="number">5</span>:     <span class="comment">// TODO 【2007】【executionResult】用途</span></div><div class="line"> <span class="number">6</span>:     <span class="keyword">final</span> Action1&lt;R&gt; markEmits = <span class="keyword">new</span> Action1&lt;R&gt;() &#123;</div><div class="line"> <span class="number">7</span>:         <span class="meta">@Override</span></div><div class="line"> <span class="number">8</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(R r)</span> </span>&#123;</div><div class="line"> <span class="number">9</span>:             <span class="keyword">if</span> (shouldOutputOnNextEvents()) &#123;</div><div class="line"><span class="number">10</span>:                 executionResult = executionResult.addEvent(HystrixEventType.EMIT);</div><div class="line"><span class="number">11</span>:                 eventNotifier.markEvent(HystrixEventType.EMIT, commandKey);</div><div class="line"><span class="number">12</span>:             &#125;</div><div class="line"><span class="number">13</span>:             <span class="keyword">if</span> (commandIsScalar()) &#123;</div><div class="line"><span class="number">14</span>:                 <span class="keyword">long</span> latency = System.currentTimeMillis() - executionResult.getStartTimestamp();</div><div class="line"><span class="number">15</span>:                 eventNotifier.markEvent(HystrixEventType.SUCCESS, commandKey);</div><div class="line"><span class="number">16</span>:                 executionResult = executionResult.addEvent((<span class="keyword">int</span>) latency, HystrixEventType.SUCCESS);</div><div class="line"><span class="number">17</span>:                 eventNotifier.markCommandExecution(getCommandKey(), properties.executionIsolationStrategy().get(), (<span class="keyword">int</span>) latency, executionResult.getOrderedList());</div><div class="line"><span class="number">18</span>:                 circuitBreaker.markSuccess();</div><div class="line"><span class="number">19</span>:             &#125;</div><div class="line"><span class="number">20</span>:         &#125;</div><div class="line"><span class="number">21</span>:     &#125;;</div><div class="line"><span class="number">22</span>: </div><div class="line"><span class="number">23</span>:     <span class="comment">// TODO 【2007】【executionResult】用途</span></div><div class="line"><span class="number">24</span>:     <span class="keyword">final</span> Action0 markOnCompleted = <span class="keyword">new</span> Action0() &#123;</div><div class="line"><span class="number">25</span>:         <span class="meta">@Override</span></div><div class="line"><span class="number">26</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">27</span>:             <span class="keyword">if</span> (!commandIsScalar()) &#123;</div><div class="line"><span class="number">28</span>:                 <span class="keyword">long</span> latency = System.currentTimeMillis() - executionResult.getStartTimestamp();</div><div class="line"><span class="number">29</span>:                 eventNotifier.markEvent(HystrixEventType.SUCCESS, commandKey);</div><div class="line"><span class="number">30</span>:                 executionResult = executionResult.addEvent((<span class="keyword">int</span>) latency, HystrixEventType.SUCCESS);</div><div class="line"><span class="number">31</span>:                 eventNotifier.markCommandExecution(getCommandKey(), properties.executionIsolationStrategy().get(), (<span class="keyword">int</span>) latency, executionResult.getOrderedList());</div><div class="line"><span class="number">32</span>:                 circuitBreaker.markSuccess();</div><div class="line"><span class="number">33</span>:             &#125;</div><div class="line"><span class="number">34</span>:         &#125;</div><div class="line"><span class="number">35</span>:     &#125;;</div><div class="line"><span class="number">36</span>: </div><div class="line"><span class="number">37</span>:     <span class="comment">// TODO 【2004】【执行与fallbak】</span></div><div class="line"><span class="number">38</span>:     <span class="keyword">final</span> Func1&lt;Throwable, Observable&lt;R&gt;&gt; handleFallback = <span class="keyword">new</span> Func1&lt;Throwable, Observable&lt;R&gt;&gt;() &#123;</div><div class="line"><span class="number">39</span>:         <span class="meta">@Override</span></div><div class="line"><span class="number">40</span>:         <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">(Throwable t)</span> </span>&#123;</div><div class="line"><span class="number">41</span>:             circuitBreaker.markNonSuccess();</div><div class="line"><span class="number">42</span>:             Exception e = getExceptionFromThrowable(t);</div><div class="line"><span class="number">43</span>:             executionResult = executionResult.setExecutionException(e);</div><div class="line"><span class="number">44</span>:             <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RejectedExecutionException) &#123;</div><div class="line"><span class="number">45</span>:                 <span class="keyword">return</span> handleThreadPoolRejectionViaFallback(e);</div><div class="line"><span class="number">46</span>:             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> HystrixTimeoutException) &#123;</div><div class="line"><span class="number">47</span>:                 <span class="keyword">return</span> handleTimeoutViaFallback();</div><div class="line"><span class="number">48</span>:             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> HystrixBadRequestException) &#123;</div><div class="line"><span class="number">49</span>:                 <span class="keyword">return</span> handleBadRequestByEmittingError(e);</div><div class="line"><span class="number">50</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">51</span>:                 <span class="comment">/*</span></div><div class="line"><span class="comment">52:                  * Treat HystrixBadRequestException from ExecutionHook like a plain HystrixBadRequestException.</span></div><div class="line"><span class="comment">53:                  */</span></div><div class="line"><span class="number">54</span>:                 <span class="keyword">if</span> (e <span class="keyword">instanceof</span> HystrixBadRequestException) &#123;</div><div class="line"><span class="number">55</span>:                     eventNotifier.markEvent(HystrixEventType.BAD_REQUEST, commandKey);</div><div class="line"><span class="number">56</span>:                     <span class="keyword">return</span> Observable.error(e);</div><div class="line"><span class="number">57</span>:                 &#125;</div><div class="line"><span class="number">58</span>: </div><div class="line"><span class="number">59</span>:                 <span class="keyword">return</span> handleFailureViaFallback(e);</div><div class="line"><span class="number">60</span>:             &#125;</div><div class="line"><span class="number">61</span>:         &#125;</div><div class="line"><span class="number">62</span>:     &#125;;</div><div class="line"><span class="number">63</span>: </div><div class="line"><span class="number">64</span>:     <span class="comment">// TODO 【2008】【请求缓存】</span></div><div class="line"><span class="number">65</span>:     <span class="keyword">final</span> Action1&lt;Notification&lt;? <span class="keyword">super</span> R&gt;&gt; setRequestContext = <span class="keyword">new</span> Action1&lt;Notification&lt;? <span class="keyword">super</span> R&gt;&gt;() &#123;</div><div class="line"><span class="number">66</span>:         <span class="meta">@Override</span></div><div class="line"><span class="number">67</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Notification&lt;? <span class="keyword">super</span> R&gt; rNotification)</span> </span>&#123;</div><div class="line"><span class="number">68</span>:             setRequestContextIfNeeded(currentRequestContext);</div><div class="line"><span class="number">69</span>:         &#125;</div><div class="line"><span class="number">70</span>:     &#125;;</div><div class="line"><span class="number">71</span>: </div><div class="line"><span class="number">72</span>:     Observable&lt;R&gt; execution;</div><div class="line"><span class="number">73</span>:     <span class="keyword">if</span> (properties.executionTimeoutEnabled().get()) &#123;</div><div class="line"><span class="number">74</span>:         execution = executeCommandWithSpecifiedIsolation(_cmd)</div><div class="line"><span class="number">75</span>:                 .lift(<span class="keyword">new</span> HystrixObservableTimeoutOperator&lt;R&gt;(_cmd)); <span class="comment">// TODO 【2009】【执行超时】</span></div><div class="line"><span class="number">76</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">77</span>:         execution = executeCommandWithSpecifiedIsolation(_cmd);</div><div class="line"><span class="number">78</span>:     &#125;</div><div class="line"><span class="number">79</span>: </div><div class="line"><span class="number">80</span>:     <span class="keyword">return</span> execution.doOnNext(markEmits)</div><div class="line"><span class="number">81</span>:             .doOnCompleted(markOnCompleted)</div><div class="line"><span class="number">82</span>:             .onErrorResumeNext(handleFallback)</div><div class="line"><span class="number">83</span>:             .doOnEach(setRequestContext);</div><div class="line"><span class="number">84</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 3 行 ：TODO 【2012】【请求上下文】</li><li>第 6 至 21 行 ：TODO 【2007】【executionResult】用途</li><li>第 24 至 35 行 ：TODO 【2007】【executionResult】用途</li><li>第 38 至 62 行 ：TODO 【2004】【执行与fallbak】</li><li>第 65 至 70 行 ：TODO 【2012】【请求上下文】</li><li>第 72 至 78 行 ：调用 <code>#executeCommandWithSpecifiedIsolation(...)</code> 方法，获得【执行命令 Observable】，在 <a href="#">「5. #executeCommandWithSpecifiedIsolation(…)」</a> 详细解析。<ul><li>若执行命令超时特性<strong>开启</strong>，调用 <code>Observable#lift(HystrixObservableTimeoutOperator)</code> 方法，实现执行命令超时功能。在 <a href="#">TODO 【2009】【执行超时】</a> 详细解析。</li></ul></li><li>第 80 至 83 行 ：返回【执行命令 Observable】。</li></ul><h1 id="5-executeCommandWithSpecifiedIsolation-…"><a href="#5-executeCommandWithSpecifiedIsolation-…" class="headerlink" title="5. #executeCommandWithSpecifiedIsolation(…)"></a>5. #executeCommandWithSpecifiedIsolation(…)</h1><p>调用 <code>#executeCommandWithSpecifiedIsolation(...)</code> 方法，获得【执行命令 Observable】。代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">private</span> Observable&lt;R&gt; <span class="title">executeCommandWithSpecifiedIsolation</span><span class="params">(<span class="keyword">final</span> AbstractCommand&lt;R&gt; _cmd)</span> </span>&#123;</div><div class="line">  <span class="number">2</span>:     <span class="keyword">if</span> (properties.executionIsolationStrategy().get() == ExecutionIsolationStrategy.THREAD) &#123;</div><div class="line">  <span class="number">3</span>:         <span class="comment">// mark that we are executing in a thread (even if we end up being rejected we still were a THREAD execution and not SEMAPHORE)</span></div><div class="line">  <span class="number">4</span>:         <span class="keyword">return</span> Observable.defer(<span class="keyword">new</span> Func0&lt;Observable&lt;R&gt;&gt;() &#123;</div><div class="line">  <span class="number">5</span>:             <span class="meta">@Override</span></div><div class="line">  <span class="number">6</span>:             <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="number">7</span>: </div><div class="line">  <span class="number">8</span>:                 <span class="comment">// 标记 executionResult 执行已发生</span></div><div class="line">  <span class="number">9</span>:                 executionResult = executionResult.setExecutionOccurred();</div><div class="line"> <span class="number">10</span>: </div><div class="line"> <span class="number">11</span>:                 <span class="comment">// 设置 commandState 为 USER_CODE_EXECUTED</span></div><div class="line"> <span class="number">12</span>:                 <span class="keyword">if</span> (!commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.USER_CODE_EXECUTED)) &#123;</div><div class="line"> <span class="number">13</span>:                     <span class="keyword">return</span> Observable.error(<span class="keyword">new</span> IllegalStateException(<span class="string">"execution attempted while in state : "</span> + commandState.get().name()));</div><div class="line"> <span class="number">14</span>:                 &#125;</div><div class="line"> <span class="number">15</span>: </div><div class="line"> <span class="number">16</span>:                 <span class="comment">// TODO 【2002】【metrics】</span></div><div class="line"> <span class="number">17</span>:                 metrics.markCommandStart(commandKey, threadPoolKey, ExecutionIsolationStrategy.THREAD);</div><div class="line"> <span class="number">18</span>: </div><div class="line"> <span class="number">19</span>:                 <span class="comment">// TODO 【2009】【执行超时】</span></div><div class="line"> <span class="number">20</span>:                 <span class="keyword">if</span> (isCommandTimedOut.get() == TimedOutStatus.TIMED_OUT) &#123;</div><div class="line"> <span class="number">21</span>:                     <span class="comment">// the command timed out in the wrapping thread so we will return immediately</span></div><div class="line"> <span class="number">22</span>:                     <span class="comment">// and not increment any of the counters below or other such logic</span></div><div class="line"> <span class="number">23</span>:                     <span class="keyword">return</span> Observable.error(<span class="keyword">new</span> RuntimeException(<span class="string">"timed out before executing run()"</span>));</div><div class="line"> <span class="number">24</span>:                 &#125;</div><div class="line"> <span class="number">25</span>: </div><div class="line"> <span class="number">26</span>:                 <span class="comment">// 设置 线程状态 为 ThreadState.STARTED</span></div><div class="line"> <span class="number">27</span>:                 <span class="keyword">if</span> (threadState.compareAndSet(ThreadState.NOT_USING_THREAD, ThreadState.STARTED)) &#123;</div><div class="line"> <span class="number">28</span>:                     <span class="comment">// TODO 【2002】【metrics】</span></div><div class="line"> <span class="number">29</span>:                     <span class="comment">//we have not been unsubscribed, so should proceed</span></div><div class="line"> <span class="number">30</span>:                     HystrixCounters.incrementGlobalConcurrentThreads();</div><div class="line"> <span class="number">31</span>:                     threadPool.markThreadExecution();</div><div class="line"> <span class="number">32</span>: </div><div class="line"> <span class="number">33</span>:                     <span class="comment">// TODO 【2010】【endCurrentThreadExecutingCommand】</span></div><div class="line"> <span class="number">34</span>:                     <span class="comment">// store the command that is being run</span></div><div class="line"> <span class="number">35</span>:                     endCurrentThreadExecutingCommand = Hystrix.startCurrentThreadExecutingCommand(getCommandKey());</div><div class="line"> <span class="number">36</span>: </div><div class="line"> <span class="number">37</span>:                     <span class="comment">// 标记 executionResult 使用线程执行</span></div><div class="line"> <span class="number">38</span>:                     executionResult = executionResult.setExecutedInThread();</div><div class="line"> <span class="number">39</span>:                     <span class="comment">/**</span></div><div class="line"><span class="comment"> 40:                      * If any of these hooks throw an exception, then it appears as if the actual execution threw an error</span></div><div class="line"><span class="comment"> 41:                      */</span></div><div class="line"> <span class="number">42</span>:                     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">43</span>:                         <span class="comment">// TODO 【2003】【HOOK】</span></div><div class="line"> <span class="number">44</span>:                         executionHook.onThreadStart(_cmd);</div><div class="line"> <span class="number">45</span>:                         executionHook.onRunStart(_cmd);</div><div class="line"> <span class="number">46</span>:                         executionHook.onExecutionStart(_cmd);</div><div class="line"> <span class="number">47</span>: </div><div class="line"> <span class="number">48</span>:                         <span class="comment">// 获得 执行Observable</span></div><div class="line"> <span class="number">49</span>:                         <span class="keyword">return</span> getUserExecutionObservable(_cmd);</div><div class="line"> <span class="number">50</span>:                     &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line"> <span class="number">51</span>:                         <span class="keyword">return</span> Observable.error(ex);</div><div class="line"> <span class="number">52</span>:                     &#125;</div><div class="line"> <span class="number">53</span>:                 &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">54</span>:                     <span class="comment">//command has already been unsubscribed, so return immediately</span></div><div class="line"> <span class="number">55</span>:                     <span class="keyword">return</span> Observable.empty();</div><div class="line"> <span class="number">56</span>:                 &#125;</div><div class="line"> <span class="number">57</span>:             &#125;</div><div class="line"> <span class="number">58</span>:         &#125;).doOnTerminate(<span class="keyword">new</span> Action0() &#123;</div><div class="line"> <span class="number">59</span>:             <span class="meta">@Override</span></div><div class="line"> <span class="number">60</span>:             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">61</span>:                 <span class="keyword">if</span> (threadState.compareAndSet(ThreadState.STARTED, ThreadState.TERMINAL)) &#123;</div><div class="line"> <span class="number">62</span>:                     handleThreadEnd(_cmd);</div><div class="line"> <span class="number">63</span>:                 &#125;</div><div class="line"> <span class="number">64</span>:                 <span class="keyword">if</span> (threadState.compareAndSet(ThreadState.NOT_USING_THREAD, ThreadState.TERMINAL)) &#123;</div><div class="line"> <span class="number">65</span>:                     <span class="comment">//if it was never started and received terminal, then no need to clean up (I don't think this is possible)</span></div><div class="line"> <span class="number">66</span>:                 &#125;</div><div class="line"> <span class="number">67</span>:                 <span class="comment">//if it was unsubscribed, then other cleanup handled it</span></div><div class="line"> <span class="number">68</span>:             &#125;</div><div class="line"> <span class="number">69</span>:         &#125;).doOnUnsubscribe(<span class="keyword">new</span> Action0() &#123;</div><div class="line"> <span class="number">70</span>:             <span class="meta">@Override</span></div><div class="line"> <span class="number">71</span>:             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">72</span>:                 <span class="keyword">if</span> (threadState.compareAndSet(ThreadState.STARTED, ThreadState.UNSUBSCRIBED)) &#123;</div><div class="line"> <span class="number">73</span>:                     handleThreadEnd(_cmd);</div><div class="line"> <span class="number">74</span>:                 &#125;</div><div class="line"> <span class="number">75</span>:                 <span class="keyword">if</span> (threadState.compareAndSet(ThreadState.NOT_USING_THREAD, ThreadState.UNSUBSCRIBED)) &#123;</div><div class="line"> <span class="number">76</span>:                     <span class="comment">//if it was never started and was cancelled, then no need to clean up</span></div><div class="line"> <span class="number">77</span>:                 &#125;</div><div class="line"> <span class="number">78</span>:                 <span class="comment">//if it was terminal, then other cleanup handled it</span></div><div class="line"> <span class="number">79</span>:             &#125;</div><div class="line"> <span class="number">80</span>:         &#125;).subscribeOn(threadPool.getScheduler(<span class="keyword">new</span> Func0&lt;Boolean&gt;() &#123; <span class="comment">// TODO 芋艿：Scheduler</span></div><div class="line"> <span class="number">81</span>:             <span class="meta">@Override</span></div><div class="line"> <span class="number">82</span>:             <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">83</span>:                 <span class="keyword">return</span> properties.executionIsolationThreadInterruptOnTimeout().get() &amp;&amp; _cmd.isCommandTimedOut.get() == TimedOutStatus.TIMED_OUT;</div><div class="line"> <span class="number">84</span>:             &#125;</div><div class="line"> <span class="number">85</span>:         &#125;));</div><div class="line"> <span class="number">86</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">87</span>:         <span class="keyword">return</span> Observable.defer(<span class="keyword">new</span> Func0&lt;Observable&lt;R&gt;&gt;() &#123;</div><div class="line"> <span class="number">88</span>:             <span class="meta">@Override</span></div><div class="line"> <span class="number">89</span>:             <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">90</span>:                 <span class="comment">// 标记 executionResult 执行已发生</span></div><div class="line"> <span class="number">91</span>:                 executionResult = executionResult.setExecutionOccurred();</div><div class="line"> <span class="number">92</span>: </div><div class="line"> <span class="number">93</span>:                 <span class="comment">// 设置 commandState 为 USER_CODE_EXECUTED</span></div><div class="line"> <span class="number">94</span>:                 <span class="keyword">if</span> (!commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.USER_CODE_EXECUTED)) &#123;</div><div class="line"> <span class="number">95</span>:                     <span class="keyword">return</span> Observable.error(<span class="keyword">new</span> IllegalStateException(<span class="string">"execution attempted while in state : "</span> + commandState.get().name()));</div><div class="line"> <span class="number">96</span>:                 &#125;</div><div class="line"> <span class="number">97</span>: </div><div class="line"> <span class="number">98</span>:                 <span class="comment">// TODO 【2002】【metrics】</span></div><div class="line"> <span class="number">99</span>:                 metrics.markCommandStart(commandKey, threadPoolKey, ExecutionIsolationStrategy.SEMAPHORE);</div><div class="line"><span class="number">100</span>: </div><div class="line"><span class="number">101</span>:                 <span class="comment">// TODO 【2010】【endCurrentThreadExecutingCommand】</span></div><div class="line"><span class="number">102</span>:                 <span class="comment">// semaphore isolated</span></div><div class="line"><span class="number">103</span>:                 <span class="comment">// store the command that is being run</span></div><div class="line"><span class="number">104</span>:                 endCurrentThreadExecutingCommand = Hystrix.startCurrentThreadExecutingCommand(getCommandKey());</div><div class="line"><span class="number">105</span>:                 <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">106</span>:                     <span class="comment">// TODO 【2003】【HOOK】</span></div><div class="line"><span class="number">107</span>:                     executionHook.onRunStart(_cmd);</div><div class="line"><span class="number">108</span>:                     executionHook.onExecutionStart(_cmd);</div><div class="line"><span class="number">109</span>: </div><div class="line"><span class="number">110</span>:                     <span class="comment">// 获得 执行Observable</span></div><div class="line"><span class="number">111</span>:                     <span class="keyword">return</span> getUserExecutionObservable(_cmd);  <span class="comment">//the getUserExecutionObservable method already wraps sync exceptions, so this shouldn't throw</span></div><div class="line"><span class="number">112</span>:                 &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line"><span class="number">113</span>:                     <span class="comment">//If the above hooks throw, then use that as the result of the run method</span></div><div class="line"><span class="number">114</span>:                     <span class="keyword">return</span> Observable.error(ex);</div><div class="line"><span class="number">115</span>:                 &#125;</div><div class="line"><span class="number">116</span>:             &#125;</div><div class="line"><span class="number">117</span>:         &#125;);</div><div class="line"><span class="number">118</span>:     &#125;</div><div class="line"><span class="number">119</span>: &#125;</div></pre></td></tr></table></figure><ul><li>根据<strong>执行隔离策略</strong>不同，创建<strong>不同</strong>的【执行命令 Observable】。仔细对比下，大体逻辑都是相同的，差别在于<strong>执行隔离策略</strong>为 <code>Thread</code> 时，使用 RxJava Scheduler 以及对<strong>线程</strong>的处理。</li><li><p>第 2 至 85 行 ：<strong>执行隔离策略</strong>为 <code>Thread</code> ：</p><ul><li>第 9 行 ：标记 <code>executionResult</code> 执行已发生。</li><li>第 12 至 14 行 ：设置 <code>commandState</code> 为 <code>USER_CODE_EXECUTED</code> 。若设置失败，调用 <code>Observable#error(Exception)</code> 方法返回 Observable 。 </li><li>第 17 行 ：TODO 【2002】【metrics】</li><li>第 20 至 24 行 ：TODO 【2009】【执行超时】</li><li>第 27 行 ：设置 <code>threadState</code> 为 <code>ThreadState.STARTED</code> 成功。<ul><li>第 30 至 31 行 ：TODO 【2002】【metrics】</li><li>第 35 行 ：TODO 【2010】【endCurrentThreadExecutingCommand】</li><li>第 38 行 ：标记 <code>executionResult</code> 使用<strong>线程</strong>执行。</li><li>第 44 至 46 行 ：TODO 【2003】【HOOK】</li><li>第 49 行 ：调用 <code>#getUserExecutionObservable(...)</code> 方法，<strong>创建</strong>【执行命令 Observable】。</li><li>第 50 至 52 行 ：若发生异常，调用 <code>Observable#error(Exception)</code> 方法返回 Observable 。</li></ul></li><li>第 53 至 56 行 ：设置 <code>threadState</code> 为 <code>ThreadState.STARTED</code> 失败，执行命令此时已经被<strong>取消</strong>，调用 <code>Observable#empty()</code> 方法返回 Observable 。</li><li>第 58 至 68 行 ：调用 <code>Observable#doOnTerminate(...)</code> 方法，添加 Action0 。<code>#handleThreadEnd(...)</code> 方法，点击 <a href="https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java#L1103" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看。</li><li>第 69 至 79 行 ：调用 <code>Observable#doOnUnsubscribe(...)</code> 方法，添加 Action0 。</li><li>第 80 至 85 行 ：调用 <code>Observable#subscribeOn(Scheduler)</code> 方法，指定 Observable <strong>自身</strong>在哪个调度器上执行。<ul><li>RxJava Scheduler ，在 <a href="http://www.iocoder.cn/RxJava/observable-subscribe-on-scheduler/?self">《RxJava 源码解析 —— Scheduler》</a> 有详细解析。 </li><li><code>Observable#subscribeOn(Scheduler)</code> ，在 <a href="http://www.iocoder.cn/RxJava/observable-subscribe-on-scheduler/?self">《RxJava 源码解析 —— Observable#subscribeOn(Scheduler)》</a> 有详细解析。</li><li>调用 <code>ThreadPool#getScheduler(Func0&lt;Boolean&gt;)</code> 方法，获得 Hystrix 自定义实现的 RxJava Scheduler ，在 <a href="#">TODO 【2004】【执行与fallbak】</a> 详细解析。</li></ul></li></ul></li><li><p>第 86 至 118 行 ：<strong>执行隔离策略</strong>为 <code>SEMAPHORE</code> ：</p><ul><li>第 91 行 ：[ 与第 9 行<strong>相同</strong> ]。</li><li>第 94 至 96 行 ：[ 与第 12 至 14行<strong>相同</strong> ]。</li><li>第 99 行 ：[ 与第 17 行<strong>类似</strong> ]。</li><li>第 104 行 ：[ 与第 35 行<strong>相同</strong> ]。</li><li>第 107 至 108 行 ：[ 与第 45 至 46 行<strong>相同</strong> ]。</li><li>第 111 行 ：[ 与第 49 行<strong>相同</strong> ]。</li><li>第 112 至 115 行 ：[ 与第 50 至 52 行<strong>相同</strong> ]。</li></ul></li></ul><h1 id="6-getUserExecutionObservable-…"><a href="#6-getUserExecutionObservable-…" class="headerlink" title="6. #getUserExecutionObservable(…)"></a>6. #getUserExecutionObservable(…)</h1><p>调用 <code>#getUserExecutionObservable(...)</code> 方法，创建【执行命令 Observable】。代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> Observable&lt;R&gt; <span class="title">getUserExecutionObservable</span><span class="params">(<span class="keyword">final</span> AbstractCommand&lt;R&gt; _cmd)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     Observable&lt;R&gt; userObservable;</div><div class="line"> <span class="number">3</span>: </div><div class="line"> <span class="number">4</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">5</span>:         userObservable = getExecutionObservable();</div><div class="line"> <span class="number">6</span>:     &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line"> <span class="number">7</span>:         <span class="comment">// the run() method is a user provided implementation so can throw instead of using Observable.onError</span></div><div class="line"> <span class="number">8</span>:         <span class="comment">// so we catch it here and turn it into Observable.error</span></div><div class="line"> <span class="number">9</span>:         userObservable = Observable.error(ex);</div><div class="line"><span class="number">10</span>:     &#125;</div><div class="line"><span class="number">11</span>: </div><div class="line"><span class="number">12</span>:     <span class="keyword">return</span> userObservable</div><div class="line"><span class="number">13</span>:             .lift(<span class="keyword">new</span> ExecutionHookApplication(_cmd)) <span class="comment">// TODO 【2003】【HOOK】</span></div><div class="line"><span class="number">14</span>:             .lift(<span class="keyword">new</span> DeprecatedOnRunHookApplication(_cmd)); <span class="comment">// 已废弃</span></div><div class="line"><span class="number">15</span>: &#125;</div></pre></td></tr></table></figure><ul><li><p>第 5 行 ：调用 <code>#getExecutionObservable()</code> 方法，创建【执行命令 Observable】。<code>#getExecutionObservable()</code> 是个<strong>抽象</strong>方法，代码如下 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Observable&lt;R&gt; <span class="title">getExecutionObservable</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure><ul><li>HystrixCommand 实现了该方法，在 <a href="#">「7. #getExecutionObservable」</a> 详细解析。</li></ul></li><li><p>第 6 至 10 行 ：若发生异常，调用 <code>Observable#error(Exception)</code> 方法返回 Observable 。</p></li><li>第 12 至 14 行 ：返回【执行命令 Observable】。<ul><li>第 13 行 ：TODO 【2003】【HOOK】</li></ul></li></ul><h1 id="7-getExecutionObservable"><a href="#7-getExecutionObservable" class="headerlink" title="7. #getExecutionObservable()"></a>7. #getExecutionObservable()</h1><p>调用 <code>HystrixCommand#getExecutionObservable()</code> 方法，创建【执行命令 Observable】。代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">final</span> <span class="keyword">protected</span> Observable&lt;R&gt; <span class="title">getExecutionObservable</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="keyword">return</span> Observable.defer(<span class="keyword">new</span> Func0&lt;Observable&lt;R&gt;&gt;() &#123;</div><div class="line"> <span class="number">4</span>:         <span class="meta">@Override</span></div><div class="line"> <span class="number">5</span>:         <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">6</span>:             <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">7</span>:                 <span class="keyword">return</span> Observable.just(run());</div><div class="line"> <span class="number">8</span>:             &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line"> <span class="number">9</span>:                 <span class="keyword">return</span> Observable.error(ex);</div><div class="line"><span class="number">10</span>:             &#125;</div><div class="line"><span class="number">11</span>:         &#125;</div><div class="line"><span class="number">12</span>:     &#125;).doOnSubscribe(<span class="keyword">new</span> Action0() &#123;</div><div class="line"><span class="number">13</span>:         <span class="meta">@Override</span></div><div class="line"><span class="number">14</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">15</span>:             <span class="comment">// 记录 执行线程</span></div><div class="line"><span class="number">16</span>:             <span class="comment">// Save thread on which we get subscribed so that we can interrupt it later if needed</span></div><div class="line"><span class="number">17</span>:             executionThread.set(Thread.currentThread());</div><div class="line"><span class="number">18</span>:         &#125;</div><div class="line"><span class="number">19</span>:     &#125;);</div><div class="line"><span class="number">20</span>: &#125;</div><div class="line"><span class="number">21</span>: </div><div class="line"><span class="number">22</span>: <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> R <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div></pre></td></tr></table></figure><ul><li>第 3 至 11 行 ：调用 <code>Observable#defer(Func0&lt;Observable&lt;R&gt;)</code> 方法，创建【执行命令 Observable】。<ul><li>第 7 行 ：调用 <code>#run()</code> 方法，<strong>运行正常执逻辑</strong>。通过 <code>Observable#just(...)</code> 方法，返回创建【执行命令 Observable】。</li></ul></li><li>第 12 至 19 行 ：调用 <code>#doOnSubscribe(...)</code> 方法，添加 Action 。该操作记录执行线程( <code>executionThread</code> ) 。<code>executionThread</code> 用于 <code>HystrixCommand#queue()</code> 方法，返回的 Future 结果，可以调用 <code>Future#cancel(Boolean)</code> 方法，点击 <a href="https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommand.java#L380" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看该方法。</li><li>第 22 行 ：<code>#run()</code> <strong>抽象</strong>方法，实现该方法，<strong>运行正常执逻辑</strong>。</li></ul><h1 id="8-CommandState"><a href="#8-CommandState" class="headerlink" title="8. CommandState"></a>8. CommandState</h1><p><code>com.netflix.hystrix.AbstractCommand.CommandState</code> ，命令状态，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">enum</span> CommandState &#123;</div><div class="line">    NOT_STARTED, OBSERVABLE_CHAIN_CREATED, USER_CODE_EXECUTED, UNSUBSCRIBED, TERMINAL</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>状态变迁如下图 ：</p><p><img src="http://www.iocoder.cn/images/Hystrix/2018_10_22/02.png" alt=""></p><h1 id="9-ThreadState"><a href="#9-ThreadState" class="headerlink" title="9. ThreadState"></a>9. ThreadState</h1><p><code>com.netflix.hystrix.AbstractCommand.ThreadState</code> ，线程状态，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">enum</span> ThreadState &#123;</div><div class="line">   NOT_USING_THREAD, STARTED, UNSUBSCRIBED, TERMINAL</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>状态变迁如下图 ：</p><p><img src="http://www.iocoder.cn/images/Hystrix/2018_10_22/03.png" alt=""></p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>对 Hystrix 和 RxJava 慢慢更有感觉了。</p><p>柳暗花明又一村。</p><p>继续加油！</p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Hystrix/command-execute-first-run/&quot;&gt;http://www.iocoder.cn/Hystrix/command-execute-first-run/&lt;/a&gt; 
      
    
    </summary>
    
      <category term="Hystrix" scheme="http://www.iocoder.cn/categories/Hystrix/"/>
    
    
  </entry>
  
  <entry>
    <title>Hystrix 源码解析 —— 执行结果缓存</title>
    <link href="http://www.iocoder.cn/Hystrix/command-execute-result-cache/"/>
    <id>http://www.iocoder.cn/Hystrix/command-execute-result-cache/</id>
    <published>2018-10-14T16:00:00.000Z</published>
    <updated>2017-11-01T05:18:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Hystrix/command-execute-result-cache/">http://www.iocoder.cn/Hystrix/command-execute-result-cache/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/Hystrix/command-execute-result-cache/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-result-cache/">2. 好处</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-result-cache/">3. Observable#defer(…)</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-result-cache/">4. AbstractCommand#toObservavle(…)</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-result-cache/">5. HystrixCachedObservable</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-result-cache/">6. HystrixCommandResponseFromCache</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-result-cache/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Hystrix 执行命令的结果缓存</strong>。</p><p>建议 ：对 RxJava 已经有一定的了解的基础上阅读本文。</p><p>Hystrix 执行命令整体流程如下图：</p><blockquote><p>FROM <a href="http://youdang.github.io/2016/02/05/translate-hystrix-wiki-how-it-works/#流程图" rel="external nofollow noopener noreferrer" target="_blank">《【翻译】Hystrix文档-实现原理》「流程图」</a><br><img src="http://www.iocoder.cn/images/Hystrix/2018_10_15/01.jpeg" alt=""></p></blockquote><ul><li>红圈 ：在 <a href="http://www.iocoder.cn/Hystrix/command-execute-mode/?self">《Hystrix 源码解析 —— 执行命令方式》</a> 有详细解析。</li><li>紫圈 ：在 <code>#toObservable()</code> 方法里，如果请求结果缓存这个特性被<strong>启用</strong>，并且<strong>缓存命中</strong>，则缓存的回应会立即通过一个 Observable 对象的形式返回；如果<strong>缓存未命中</strong>，则返回【<strong>订阅了执行命令的 Observable</strong>】的 ReplySubject 对象缓存执行结果。<ul><li>ReplySubject 能够<strong>重放</strong>执行结果，从而实现缓存的功效。本文不对 ReplySubject 做太多拓展，感兴趣的同学可以阅读 <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/Subject.html" rel="external nofollow noopener noreferrer" target="_blank">《ReactiveX/RxJava文档中文版 —— Subject》</a> 。</li></ul></li></ul><p>在官方提供的示例中，我们使用 <a href="https://github.com/Netflix/Hystrix/blob/1f64fced24289ea435f1e2d5a47a068bf7b79729/hystrix-examples/src/main/java/com/netflix/hystrix/examples/basic/CommandUsingRequestCache.java" rel="external nofollow noopener noreferrer" target="_blank">CommandUsingRequestCache</a> 进行调试 。</p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-好处"><a href="#2-好处" class="headerlink" title="2. 好处"></a>2. 好处</h1><p>点击 <a href="http://youdang.github.io/2016/02/05/translate-hystrix-wiki-how-it-works/#请求缓存" rel="external nofollow noopener noreferrer" target="_blank">《【翻译】Hystrix文档-实现原理》「请求缓存」</a> ，查看对<strong>请求缓存</strong>的好处分享，写的真的很赞。</p><h1 id="3-Observable-defer-…"><a href="#3-Observable-defer-…" class="headerlink" title="3. Observable#defer(…)"></a>3. Observable#defer(…)</h1><p>本小节为<strong>拓展内容</strong>，源码解析 RxJava ( 非 Hystrix ) 的 <code>Observable#defer(...)</code> 的方法实现。考虑到 Hystrix 大量使用，为了更好的理解，解析下源码。</p><p><a href="http://www.iocoder.cn/RxJava/observable-defer/">《RxJava 源码解析 —— Observable#defer(…)》</a></p><h1 id="4-AbstractCommand-toObservavle-…"><a href="#4-AbstractCommand-toObservavle-…" class="headerlink" title="4. AbstractCommand#toObservavle(…)"></a>4. AbstractCommand#toObservavle(…)</h1><p><code>AbstractCommand#toObservavle(...)</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">toObservable</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="keyword">final</span> AbstractCommand&lt;R&gt; _cmd = <span class="keyword">this</span>;</div><div class="line"> <span class="number">3</span>: </div><div class="line"> <span class="number">4</span>:     <span class="comment">//doOnCompleted handler already did all of the SUCCESS work</span></div><div class="line"> <span class="number">5</span>:     <span class="comment">//doOnError handler already did all of the FAILURE/TIMEOUT/REJECTION/BAD_REQUEST work</span></div><div class="line"> <span class="number">6</span>:     <span class="keyword">final</span> Action0 terminateCommandCleanup = <span class="keyword">new</span> Action0() &#123;&#125; <span class="comment">// ... 省略</span></div><div class="line"> <span class="number">7</span>: </div><div class="line"> <span class="number">8</span>:     <span class="comment">//mark the command as CANCELLED and store the latency (in addition to standard cleanup)</span></div><div class="line"> <span class="number">9</span>:     <span class="keyword">final</span> Action0 unsubscribeCommandCleanup = <span class="keyword">new</span> Action0() &#123;&#125; <span class="comment">// ... 省略</span></div><div class="line"><span class="number">10</span>: </div><div class="line"><span class="number">11</span>:     <span class="keyword">final</span> Func0&lt;Observable&lt;R&gt;&gt; applyHystrixSemantics = <span class="keyword">new</span> Func0&lt;Observable&lt;R&gt;&gt;() &#123;</div><div class="line"><span class="number">12</span>:         <span class="meta">@Override</span></div><div class="line"><span class="number">13</span>:         <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">14</span>:             <span class="keyword">if</span> (commandState.get().equals(CommandState.UNSUBSCRIBED)) &#123;</div><div class="line"><span class="number">15</span>:                 <span class="keyword">return</span> Observable.never();</div><div class="line"><span class="number">16</span>:             &#125;</div><div class="line"><span class="number">17</span>:             <span class="keyword">return</span> applyHystrixSemantics(_cmd);</div><div class="line"><span class="number">18</span>:         &#125;</div><div class="line"><span class="number">19</span>:     &#125;;</div><div class="line"><span class="number">20</span>: </div><div class="line"><span class="number">21</span>:     <span class="keyword">final</span> Func1&lt;R, R&gt; wrapWithAllOnNextHooks = <span class="keyword">new</span> Func1&lt;R, R&gt;() &#123;&#125; <span class="comment">// ... 省略 </span></div><div class="line"><span class="number">22</span>: </div><div class="line"><span class="number">23</span>:     <span class="keyword">final</span> Action0 fireOnCompletedHook = <span class="keyword">new</span> Action0() &#123;&#125; <span class="comment">// ... 省略 </span></div><div class="line"><span class="number">24</span>: </div><div class="line"><span class="number">25</span>:     <span class="keyword">return</span> Observable.defer(<span class="keyword">new</span> Func0&lt;Observable&lt;R&gt;&gt;() &#123;</div><div class="line"><span class="number">26</span>:         <span class="meta">@Override</span></div><div class="line"><span class="number">27</span>:         <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">28</span>:             <span class="comment">/* this is a stateful object so can only be used once */</span></div><div class="line"><span class="number">29</span>:             <span class="keyword">if</span> (!commandState.compareAndSet(CommandState.NOT_STARTED, CommandState.OBSERVABLE_CHAIN_CREATED)) &#123;</div><div class="line"><span class="number">30</span>:                 IllegalStateException ex = <span class="keyword">new</span> IllegalStateException(<span class="string">"This instance can only be executed once. Please instantiate a new instance."</span>);</div><div class="line"><span class="number">31</span>:                 <span class="comment">//TODO make a new error type for this</span></div><div class="line"><span class="number">32</span>:                 <span class="keyword">throw</span> <span class="keyword">new</span> HystrixRuntimeException(FailureType.BAD_REQUEST_EXCEPTION, _cmd.getClass(), getLogMessagePrefix() + <span class="string">" command executed multiple times - this is not permitted."</span>, ex, <span class="keyword">null</span>);</div><div class="line"><span class="number">33</span>:             &#125;</div><div class="line"><span class="number">34</span>: </div><div class="line"><span class="number">35</span>:             <span class="comment">// 命令开始时间戳</span></div><div class="line"><span class="number">36</span>:             commandStartTimestamp = System.currentTimeMillis();</div><div class="line"><span class="number">37</span>: </div><div class="line"><span class="number">38</span>:             <span class="comment">// TODO【2001】【打印日志】</span></div><div class="line"><span class="number">39</span>:             <span class="keyword">if</span> (properties.requestLogEnabled().get()) &#123;</div><div class="line"><span class="number">40</span>:                 <span class="comment">// log this command execution regardless of what happened</span></div><div class="line"><span class="number">41</span>:                 <span class="keyword">if</span> (currentRequestLog != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">42</span>:                     currentRequestLog.addExecutedCommand(_cmd);</div><div class="line"><span class="number">43</span>:                 &#125;</div><div class="line"><span class="number">44</span>:             &#125;</div><div class="line"><span class="number">45</span>: </div><div class="line"><span class="number">46</span>:             <span class="comment">// 缓存开关、缓存KEY</span></div><div class="line"><span class="number">47</span>:             <span class="keyword">final</span> <span class="keyword">boolean</span> requestCacheEnabled = isRequestCachingEnabled();</div><div class="line"><span class="number">48</span>:             <span class="keyword">final</span> String cacheKey = getCacheKey();</div><div class="line"><span class="number">49</span>: </div><div class="line"><span class="number">50</span>:             <span class="comment">// 优先从缓存中获取</span></div><div class="line"><span class="number">51</span>:             <span class="comment">/* try from cache first */</span></div><div class="line"><span class="number">52</span>:             <span class="keyword">if</span> (requestCacheEnabled) &#123;</div><div class="line"><span class="number">53</span>:                 HystrixCommandResponseFromCache&lt;R&gt; fromCache = (HystrixCommandResponseFromCache&lt;R&gt;) requestCache.get(cacheKey);</div><div class="line"><span class="number">54</span>:                 <span class="keyword">if</span> (fromCache != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">55</span>:                     isResponseFromCache = <span class="keyword">true</span>; <span class="comment">// 标记 从缓存中结果</span></div><div class="line"><span class="number">56</span>:                     <span class="keyword">return</span> handleRequestCacheHitAndEmitValues(fromCache, _cmd);</div><div class="line"><span class="number">57</span>:                 &#125;</div><div class="line"><span class="number">58</span>:             &#125;</div><div class="line"><span class="number">59</span>: </div><div class="line"><span class="number">60</span>:             <span class="comment">// 获得 执行命令Observable</span></div><div class="line"><span class="number">61</span>:             Observable&lt;R&gt; hystrixObservable =</div><div class="line"><span class="number">62</span>:                     Observable.defer(applyHystrixSemantics)</div><div class="line"><span class="number">63</span>:                             .map(wrapWithAllOnNextHooks);</div><div class="line"><span class="number">64</span>: </div><div class="line"><span class="number">65</span>:             <span class="comment">// 获得 缓存Observable</span></div><div class="line"><span class="number">66</span>:             Observable&lt;R&gt; afterCache;</div><div class="line"><span class="number">67</span>:             <span class="comment">// put in cache</span></div><div class="line"><span class="number">68</span>:             <span class="keyword">if</span> (requestCacheEnabled &amp;&amp; cacheKey != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">69</span>:                 <span class="comment">// wrap it for caching</span></div><div class="line"><span class="number">70</span>:                 HystrixCachedObservable&lt;R&gt; toCache = HystrixCachedObservable.from(hystrixObservable, _cmd);</div><div class="line"><span class="number">71</span>:                 <span class="comment">// 并发若不存在</span></div><div class="line"><span class="number">72</span>:                 HystrixCommandResponseFromCache&lt;R&gt; fromCache = (HystrixCommandResponseFromCache&lt;R&gt;) requestCache.putIfAbsent(cacheKey, toCache);</div><div class="line"><span class="number">73</span>:                 <span class="keyword">if</span> (fromCache != <span class="keyword">null</span>) &#123; <span class="comment">// 添加失败</span></div><div class="line"><span class="number">74</span>:                     <span class="comment">// another thread beat us so we'll use the cached value instead</span></div><div class="line"><span class="number">75</span>:                     toCache.unsubscribe();</div><div class="line"><span class="number">76</span>:                     isResponseFromCache = <span class="keyword">true</span>; <span class="comment">// 标记 从缓存中结果</span></div><div class="line"><span class="number">77</span>:                     <span class="keyword">return</span> handleRequestCacheHitAndEmitValues(fromCache, _cmd);</div><div class="line"><span class="number">78</span>:                 &#125; <span class="keyword">else</span> &#123; <span class="comment">// 添加成功</span></div><div class="line"><span class="number">79</span>:                     <span class="comment">// we just created an ObservableCommand so we cast and return it</span></div><div class="line"><span class="number">80</span>:                     afterCache = toCache.toObservable();</div><div class="line"><span class="number">81</span>:                 &#125;</div><div class="line"><span class="number">82</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">83</span>:                 afterCache = hystrixObservable;</div><div class="line"><span class="number">84</span>:             &#125;</div><div class="line"><span class="number">85</span>: </div><div class="line"><span class="number">86</span>:             <span class="comment">//</span></div><div class="line"><span class="number">87</span>:             <span class="keyword">return</span> afterCache</div><div class="line"><span class="number">88</span>:                     .doOnTerminate(terminateCommandCleanup)     <span class="comment">// perform cleanup once (either on normal terminal state (this line), or unsubscribe (next line))</span></div><div class="line"><span class="number">89</span>:                     .doOnUnsubscribe(unsubscribeCommandCleanup) <span class="comment">// perform cleanup once</span></div><div class="line"><span class="number">90</span>:                     .doOnCompleted(fireOnCompletedHook);</div><div class="line"><span class="number">91</span>:         &#125;</div><div class="line"><span class="number">92</span>:     &#125;);</div><div class="line"><span class="number">93</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 2 行 ：<code>_cmd</code> 指向当前命令对象，用于下面实现 FuncX ，ActionX 内部类使用。</li><li>第 11 至 19 行 ：当缓存特性<strong>未开启</strong>，或者缓存<strong>未命中</strong>时，使用 <code>applyHystrixSemantics</code> 传入 <code>Observable#defer(...)</code> 方法，声明<strong>执行命令</strong>的 Observable。</li><li><p>第 25 行 ：声明缓存 Observable 。Hystrix 执行命令的 Observable 声明关系如下：</p><p>  <img src="http://www.iocoder.cn/images/Hystrix/2018_10_15/02.png" alt=""></p></li><li><p>第 29 至 33 行 ：<strong>一条命令只能执行一次</strong>。</p></li><li>第 36 行 ：记录命令<strong>开始</strong>时间戳。</li><li>第 38 至 44 行 ：TODO【2001】【打印日志】</li><li>第 47 至 48 行 ：缓存存开关、KEY 。</li><li>第 52 至 58 行 ：如果请求结果缓存这个特性被<strong>启用</strong>，并且<strong>缓存命中</strong>，则缓存的回应会立即通过一个 Observable 对象的形式返回。<ul><li>第 53 行 ：<code>requestCache</code> 缓存，在 <a href="#">TODO 【2008】【请求缓存】</a> 详细解析。</li><li>第 53 行 ：<a href="#">「6. HystrixCommandResponseFromCache」</a> 详细解析。</li><li>第 56 行 ：<code>#handleRequestCacheHitAndEmitValues(...)</code> 方法，在<strong>第 78 行</strong>详细解析。</li></ul></li><li>第 61 至 63 行 ：获取<strong>执行命令</strong>的 Observable 。在 <a href="#">TODO 【2004】【执行与fallbak】</a> 详细解析。</li><li>第 68 至 81 行 ：当缓存特性<strong>开启</strong>，并且缓存<strong>未命中</strong>时，创建【<strong>订阅了执行命令的 Observable</strong>】的 HystrixCommandResponseFromCache 。<ul><li>第 69 至 72 行 ：创建 HystrixCommandResponseFromCache ，并添加到 <code>requestCache</code> 。哟，<code>HystrixRequestCache#putIfAbsent(...)</code> 方法，<strong>多个线程</strong>添加时，只有一个线程添加成功。</li><li>第 73 至 77 行 ：添加<strong>失败</strong>的线程( <strong>们</strong> )：<ul><li>第 75 行 ：调用 <code>HystrixCommandResponseFromCache#unsubscribe()</code> 方法，取消 HystrixCommandResponseFromCache 的订阅。这一步很关键，因为我们<strong>不希望缓存不存在时，多个线程去执行命令，最好有且只有一个线程执行命令</strong>。在 <a href="#">「5. HystrixCachedObservable」</a> 详细解析。</li><li>第 77 行 ：<a href="#">「6. HystrixCommandResponseFromCache」</a> 详细解析。<ul><li>第 80 行 ：调用 <code>HystrixCommandResponseFromCachetoObservable()</code> 方法，获得缓存 Observable 。</li></ul></li></ul></li></ul></li><li>第 82 至 84 行 ：当缓存特性<strong>未开启</strong>，使用执行命令 Observable 。</li><li>第 87 至 91 行 ：在返回的 Observable 上，订阅一些清理的处理逻辑。对这几个方法有疑惑的同学，可以阅读 <a href="http://gank.io/post/560e15be2dca930e00da1083#toc_10" rel="external nofollow noopener noreferrer" target="_blank">《给 Android 开发者的 RxJava 详解》「 3) Subscribe (订阅) 」</a> 。</li></ul><h1 id="5-HystrixCachedObservable"><a href="#5-HystrixCachedObservable" class="headerlink" title="5. HystrixCachedObservable"></a>5. HystrixCachedObservable</h1><p><code>com.netflix.hystrix.HystrixCachedObservable</code> ，缓存 Observable 。</p><p>HystrixCachedObservable <strong>构造方法</strong>，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixCachedObservable</span>&lt;<span class="title">R</span>&gt; </span>&#123;</div><div class="line"> <span class="number">2</span>: <span class="comment">/**</span></div><div class="line"><span class="comment"> 3:  * 订阅</span></div><div class="line"><span class="comment"> 4:  */</span></div><div class="line"> <span class="number">5</span>: <span class="keyword">protected</span> <span class="keyword">final</span> Subscription originalSubscription;</div><div class="line"> <span class="number">6</span>: <span class="comment">/**</span></div><div class="line"><span class="comment"> 7:  * 缓存 cachedObservable</span></div><div class="line"><span class="comment"> 8:  */</span></div><div class="line"> <span class="number">9</span>: <span class="keyword">protected</span> <span class="keyword">final</span> Observable&lt;R&gt; cachedObservable;</div><div class="line"><span class="number">10</span>: <span class="comment">/**</span></div><div class="line"><span class="comment">11:  * TODO 【2006】【outstandingSubscriptions】</span></div><div class="line"><span class="comment">12:  */</span></div><div class="line"><span class="number">13</span>: <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> outstandingSubscriptions = <span class="number">0</span>;</div><div class="line"><span class="number">14</span>: <span class="comment">//private AtomicInteger outstandingSubscriptions2 = new AtomicInteger(0);</span></div><div class="line"><span class="number">15</span>: </div><div class="line"><span class="number">16</span>: <span class="function"><span class="keyword">protected</span> <span class="title">HystrixCachedObservable</span><span class="params">(<span class="keyword">final</span> Observable&lt;R&gt; originalObservable)</span> </span>&#123;</div><div class="line"><span class="number">17</span>:     ReplaySubject&lt;R&gt; replaySubject = ReplaySubject.create();</div><div class="line"><span class="number">18</span>:     <span class="keyword">this</span>.originalSubscription = originalObservable</div><div class="line"><span class="number">19</span>:             .subscribe(replaySubject);</div><div class="line"><span class="number">20</span>: </div><div class="line"><span class="number">21</span>:     <span class="keyword">this</span>.cachedObservable = replaySubject</div><div class="line"><span class="number">22</span>:             .doOnUnsubscribe(<span class="keyword">new</span> Action0() &#123;</div><div class="line"><span class="number">23</span>:                 <span class="meta">@Override</span></div><div class="line"><span class="number">24</span>:                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">25</span>:                     outstandingSubscriptions--;</div><div class="line"><span class="number">26</span>:                     <span class="keyword">if</span> (outstandingSubscriptions == <span class="number">0</span>) &#123;</div><div class="line"><span class="number">27</span>:                         originalSubscription.unsubscribe();</div><div class="line"><span class="number">28</span>:                     &#125;</div><div class="line"><span class="number">29</span>:                 &#125;</div><div class="line"><span class="number">30</span>:             &#125;)</div><div class="line"><span class="number">31</span>:             .doOnSubscribe(<span class="keyword">new</span> Action0() &#123;</div><div class="line"><span class="number">32</span>:                 <span class="meta">@Override</span></div><div class="line"><span class="number">33</span>:                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">34</span>:                     outstandingSubscriptions++;</div><div class="line"><span class="number">35</span>:                 &#125;</div><div class="line"><span class="number">36</span>:             &#125;);</div><div class="line"><span class="number">37</span>: &#125;</div></pre></td></tr></table></figure><ul><li><p>第 17 至 19 行 ：实际上，<strong>HystrixCachedObservable 不是一个 Observable 的子类</strong>，而是对传入的 Observable <strong>封装</strong> ：使用 ReplaySubject 向传入的 Observable 发起订阅，通过 ReplaySubject 能够<strong>重放</strong>执行结果，从而实现缓存的功效。这里有几个卡到笔者的并且很有趣的点，我们一一道来 ：从上文中，我们可以看到，传入的 <code>originalObservable</code> 为 <code>hystrixObservable</code> 执行命令 Observable 。在 Hystrix 里，提供了两种执行命令的隔离方式 ：线程池( <code>THREAD</code> ) 和信号量( <code>SEMAPHORE</code> )。</p><ul><li>当使用 <code>THREAD</code> 隔离时，<code>#subscribe(replaySubject)</code> 调用完成时，<strong>实际命令并未开始执行</strong>，或者说，这是一个<strong>异步</strong>的执行命令的过程。那么，<strong>会不会影响返回执行结果呢</strong>？答案当然是不会，BlockingObservable 在得到执行完成才会<strong>结束阻塞</strong>，此时已经有执行结果。</li><li><p>当使用 <code>SEMAPHORE</code> 隔离时，<code>#subscribe(replaySubject)</code> 调用完成时，<strong>实际命令已经执行完成</strong>，所以即使 <code>AbstractCommand#toObservavle(...)</code> 的第 75 行 ：调用 <code>HystrixCommandResponseFromCache#unsubscribe()</code> 方法，也会浪费，<strong>重复</strong>执行命令。而对于 <code>THREAD</code> 隔离的情况，通过取消订阅的方式，只会执行<strong>一次</strong>命令。当然，如果“恶搞” <code>THREAD</code> 隔离的情况，增加 <code>sleep</code> 的调用如下，就能达到<strong>重复</strong>执行命令的效果。</p><p>  <img src="http://www.iocoder.cn/images/Hystrix/2018_10_15/03.png" alt=""></p></li></ul></li><li><p>第 21 至 36 行 ：TODO 【2006】【outstandingSubscriptions】原子性没问题么？历史版本使用的是 AtomicInteger 。</p></li></ul><hr><p>HystrixCachedObservable 的其他方法，点击 <a href="https://github.com/Netflix/Hystrix/blob/1f64fced24289ea435f1e2d5a47a068bf7b79729/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCachedObservable.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看。</p><h1 id="6-HystrixCommandResponseFromCache"><a href="#6-HystrixCommandResponseFromCache" class="headerlink" title="6. HystrixCommandResponseFromCache"></a>6. HystrixCommandResponseFromCache</h1><p><code>com.netflix.hystrix.HystrixCommandResponseFromCache</code> ，是 HystrixCachedObservable 的子类。在父类的基础上，增加了对 <code>AbstractCommand.executionResult</code> 的关注。</p><p><code>HystrixCachedObservable#from(Observable, AbstractCommand)</code> 方法，创建 HystrixCommandResponseFromCache 对象，点击 <a href="https://github.com/Netflix/Hystrix/blob/1f64fced24289ea435f1e2d5a47a068bf7b79729/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCachedObservable.java#L36" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看。</p><hr><p><code>HystrixCommandResponseFromCache#toObservableWithStateCopiedInto(...)</code> 方法，点击 <a href="https://github.com/Netflix/Hystrix/blob/1f64fced24289ea435f1e2d5a47a068bf7b79729/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommandResponseFromCache.java#L17" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看。</p><ul><li>通过 <code>completionLogicRun</code> 属性，保证 <code>#doOnError()</code> ，<code>#doOnCompleted()</code> ，<code>#doOnUnsubscribe()</code> 方法有且只有一个方法执行具体逻辑。<ul><li><code>#doOnError()</code> ，<code>#doOnCompleted()</code> 执行时，调用 <code>#commandCompleted()</code> 方法，从缓存命令( <code>HystrixCommandResponseFromCache.originalCommand</code> ) 复制 <code>executionResult</code> 属性给当前命令( <code>commandToCopyStateInto</code> ) 。</li><li><code>#doOnUnsubscribe()</code> 执行时，调用 <code>#commandUnsubscribed()</code> 方法，使用当前命令( <code>commandToCopyStateInto</code> )<strong>自己</strong>的 <code>executionResult</code> ，不进行复制。</li></ul></li><li>TODO 【2007】【executionResult】用途</li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>如鲠在喉的感觉，从周六开始磨了四天多，一直没写到一个比较舒服的状态。</p><p>先发现发，如果有不清晰的地方，烦请指出，谢谢。</p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Hystrix/command-execute-result-cache/&quot;&gt;http://www.iocoder.cn/Hystrix/command-execute-result-cache
      
    
    </summary>
    
      <category term="Hystrix" scheme="http://www.iocoder.cn/categories/Hystrix/"/>
    
    
  </entry>
  
  <entry>
    <title>Hystrix 源码解析 —— 执行命令方式</title>
    <link href="http://www.iocoder.cn/Hystrix/command-execute-mode/"/>
    <id>http://www.iocoder.cn/Hystrix/command-execute-mode/</id>
    <published>2018-10-09T16:00:00.000Z</published>
    <updated>2017-11-01T05:19:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Hystrix/command-execute-mode/">http://www.iocoder.cn/Hystrix/command-execute-mode/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/Hystrix/command-execute-mode/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-mode/">2. 实现</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-mode/">3. BlockingObservable</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-execute-mode/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Hystrix 执行命令方法</strong>。</p><p>建议 ：对 RxJava 已经有一定的了解的基础上阅读本文。</p><p>在官方提供的示例中，我们看到 <a href="https://github.com/Netflix/Hystrix/blob/d838f4d1ba65ce55755ab1c73f74c980f04572bf/hystrix-examples/src/main/java/com/netflix/hystrix/examples/basic/CommandHelloWorld.java" rel="external nofollow noopener noreferrer" target="_blank">CommandHelloWorld</a> 通过继承 <a href="https://github.com/Netflix/Hystrix/blob/d838f4d1ba65ce55755ab1c73f74c980f04572bf/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommand.java" rel="external nofollow noopener noreferrer" target="_blank">HystrixCommand</a> 抽象类，有四种调用方式：</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left"><code>#execute()</code></td><td style="text-align:left"><strong>同步</strong>调用，返回<strong>直接</strong>结果</td><td></td></tr><tr><td style="text-align:left"><code>#queue()</code></td><td style="text-align:left"><strong>异步</strong>调用，返回 <code>java.util.concurrent.Future</code></td><td></td></tr><tr><td style="text-align:left"><code>#observe()</code></td><td style="text-align:left"><strong>异步</strong>调用，返回 <code>rx.Observable</code> 。向 Observable 注册 <code>rx.Subscriber</code> 处理结果</td><td></td></tr><tr><td style="text-align:left"><code>#toObservable()</code></td><td style="text-align:left"><strong>未调用</strong>，返回 <code>rx.Observable</code> 。向 Observable 注册 <code>rx.Subscriber</code> 处理结果</td></tr></tbody></table><ul><li>第四种方式，点击 <a href="https://github.com/YunaiV/Hystrix/blob/master/hystrix-examples/src/main/java/com/netflix/hystrix/examples/basic/CommandHelloWorld.java#L165" rel="external nofollow noopener noreferrer" target="_blank"><code>#testToObservable()</code></a> 查看笔者补充的示例。</li></ul><p><img src="http://www.iocoder.cn/images/Hystrix/2018_10_08/01.jpeg" alt=""></p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractCommand.java</span></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCommand</span>&lt;<span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">HystrixInvokableInfo</span>&lt;<span class="title">R</span>&gt;, <span class="title">HystrixObservable</span>&lt;<span class="title">R</span>&gt; </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略无关属性与方法</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">toObservable</span><span class="params">()</span> </span>&#123;</div><div class="line">    </div><div class="line">        <span class="keyword">return</span> Observable.defer(<span class="keyword">new</span> Func0&lt;Observable&lt;R&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="comment">// ....</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;R&gt; <span class="title">observe</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// us a ReplaySubject to buffer the eagerly subscribed-to Observable</span></div><div class="line">        ReplaySubject&lt;R&gt; subject = ReplaySubject.create();</div><div class="line">        <span class="comment">// eagerly kick off subscription</span></div><div class="line">        <span class="keyword">final</span> Subscription sourceSubscription = toObservable().subscribe(subject);</div><div class="line">        <span class="comment">// return the subject that can be subscribed to later while the execution has already started</span></div><div class="line">        <span class="keyword">return</span> subject.doOnUnsubscribe(<span class="keyword">new</span> Action0() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">                sourceSubscription.unsubscribe();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// HystrixCommand.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixCommand</span>&lt;<span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCommand</span>&lt;<span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">HystrixExecutable</span>&lt;<span class="title">R</span>&gt;, <span class="title">HystrixInvokableInfo</span>&lt;<span class="title">R</span>&gt;, <span class="title">HystrixObservable</span>&lt;<span class="title">R</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ... 省略无关属性与方法</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> Future&lt;R&gt; <span class="title">queue</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Future&lt;R&gt; delegate = toObservable().toBlocking().toFuture();</div><div class="line">        <span class="keyword">final</span> Future&lt;R&gt; f = <span class="keyword">new</span> Future&lt;R&gt;() &#123;</div><div class="line">            <span class="comment">// ... 包装 delegate</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">        <span class="keyword">return</span> f;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> queue().get();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            <span class="keyword">throw</span> Exceptions.sneakyThrow(decomposeException(e));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> R <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>#toObservable()</code> 方法 ：<strong>未</strong>做订阅，返回干净的 Observable 。<strong>这就是为什么上文说“未调用”</strong> 。</li><li><code>#observe()</code> 方法 ：调用 <code>#toObservable()</code> 方法的基础上，向 Observable 注册 <code>rx.subjects.ReplaySubject</code> <strong>发起订阅</strong> 。<ul><li>ReplaySubject 会发射所有来自原始 Observable 的数据给观察者，无论它们是何时订阅的。感兴趣的同学可以阅读 <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/Subject.html" rel="external nofollow noopener noreferrer" target="_blank">《ReactiveX/RxJava文档中文版 —— Subject》</a> 。</li></ul></li><li><code>#queue()</code> 方法 ：调用 <code>#toObservable()</code> 方法的基础上，调用：<ul><li><code>Observable#toBlocking()</code> 方法 ：将 Observable 转换成<strong>阻塞</strong>的 <code>rx.observables.BlockingObservable</code> 。</li><li><code>BlockingObservable#toFuture()</code> 方法 ：返回可获得 <code>#run()</code> <strong>抽象方法</strong>执行结果的 Future 。<ul><li><code>#run()</code> 方法 ：子类实现该方法，执行<strong>正常的业务逻辑</strong>。<ul><li>BlockingObservable 在 <a href="#">「3. BlockingObservable」</a> 详细解析。</li></ul></li></ul></li></ul></li><li><code>#execute()</code> 方法 ：调用 <code>#queue()</code> 方法的基础上，调用 <code>Future#get()</code> 方法，<strong>同步</strong>返回 <code>#run()</code> 的执行结果。</li><li><p>整理四种调用方式如下：</p><p>  <img src="http://www.iocoder.cn/images/Hystrix/2018_10_08/02.png" alt=""></p><blockquote><p>FROM <a href="http://youdang.github.io/2016/02/05/translate-hystrix-wiki-how-it-works/#problem9" rel="external nofollow noopener noreferrer" target="_blank">《【翻译】Hystrix文档-实现原理》</a><br><img src="http://www.iocoder.cn/images/Hystrix/2018_10_08/03.png" alt=""></p></blockquote></li></ul><h1 id="3-BlockingObservable"><a href="#3-BlockingObservable" class="headerlink" title="3. BlockingObservable"></a>3. BlockingObservable</h1><p>本小节为<strong>拓展内容</strong>，源码解析 RxJava ( 非 Hystrix ) 的 <code>rx.observables.BlockingObservable</code> 的实现，所以你可以选择：</p><ul><li>1 ) 跳过本小节，不影响对本文的理解。</li><li>2 ) 选择阅读 <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Blocking-Observable-Operators.html" rel="external nofollow noopener noreferrer" target="_blank">《ReactiveX/RxJava文档中文版 —— 阻塞操作》</a> ，理解 BlockingObservable 的原理。</li><li>3 ) 选择阅读本小节，理解 BlockingObservable 的原理以及实现。</li></ul><p><a href="http://www.iocoder.cn/RxJava/blocking-observable/">《RxJava 源码解析 —— BlockingObservable》</a></p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>第一篇 Hystrix 正式的源码解析。</p><p>梳理 Hystrix 的源码还是蛮痛苦的，主要是因为对 RxJava 不够熟悉。</p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Hystrix/command-execute-mode/&quot;&gt;http://www.iocoder.cn/Hystrix/command-execute-mode/&lt;/a&gt; 「芋道源码」欢迎转载
      
    
    </summary>
    
      <category term="Hystrix" scheme="http://www.iocoder.cn/categories/Hystrix/"/>
    
    
  </entry>
  
  <entry>
    <title>Hystrix 源码解析 —— 调试环境搭建</title>
    <link href="http://www.iocoder.cn/Hystrix/build-debugging-environment/"/>
    <id>http://www.iocoder.cn/Hystrix/build-debugging-environment/</id>
    <published>2018-09-30T16:00:00.000Z</published>
    <updated>2017-11-01T05:45:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Hystrix/build-debugging-environment/">http://www.iocoder.cn/Hystrix/build-debugging-environment/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/Hystrix/build-debugging-environment/">1. 依赖工具</a></li><li><a href="http://www.iocoder.cn/Hystrix/build-debugging-environment/">2. 源码拉取</a></li><li><a href="http://www.iocoder.cn/Hystrix/build-debugging-environment/">3. 运行示例</a></li><li><a href="http://www.iocoder.cn/Hystrix/build-debugging-environment/">4. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-依赖工具"><a href="#1-依赖工具" class="headerlink" title="1. 依赖工具"></a>1. 依赖工具</h1><ul><li>Gradle</li><li>JDK</li><li>IntelliJ IDEA</li></ul><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-源码拉取"><a href="#2-源码拉取" class="headerlink" title="2. 源码拉取"></a>2. 源码拉取</h1><p>从官方仓库 <a href="https://github.com/Netflix/Hystrix.git" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/Netflix/Hystrix.git</a> <code>Fork</code> 出属于自己的仓库。为什么要 <code>Fork</code> ？既然开始阅读、调试源码，我们可能会写一些注释，有了自己的仓库，可以进行自由的提交。😈</p><p>使用 <code>IntelliJ IDEA</code> 从 <code>Fork</code> 出来的仓库拉取代码。在项目路径下，在<strong>命令行</strong>执行 <code>./gradlew</code> 命令，<code>Gradle</code> 会下载依赖包，可能会花费一些时间，耐心等待下。其间可能会出现因为网络原因( 我相信你懂的 )，可能会出现失败的情况，淡定，重新执行上述命令直到成功。此刻，你就是一个 <code>while(true)</code> 的小强。</p><p>本文基于 <code>master</code> 分支。</p><h1 id="3-运行示例"><a href="#3-运行示例" class="headerlink" title="3. 运行示例"></a>3. 运行示例</h1><p>在 <code>hystrix-examples</code> 子项目下，提供了<strong>大量</strong>的示例，如下图：</p><p><img src="http://www.iocoder.cn/images/Hystrix/2018_10_01/01.png" alt=""></p><ul><li><code>basic</code> 包 ：针对 Hystrix 每个特性提供小的单元测试示例。你可以从 CommandHelloWorld 开始尝试。</li><li><code>demo</code> 包 ：结合实际场景的实战小例子。运行入口为 HystrixCommandDemo 或者 HystrixCommandAsyncDemo 。恩，聪慧如你，从名字能看出它们的区别点。</li></ul><p>可能有部分同学对 Hystrix 的特性了解的不是很清晰，笔者推荐如下文章：</p><ul><li><a href="http://youdang.github.io/2016/02/05/translate-hystrix-wiki-how-it-works/" rel="external nofollow noopener noreferrer" target="_blank">《【翻译】Hystrix 文档 - 实现原理》</a></li><li><a href="http://tech.lede.com/2017/06/15/rd/server/hystrix/" rel="external nofollow noopener noreferrer" target="_blank">《hystrix 在 spring mvc 的使用》</a></li></ul><p>另外，笔者也整理了下 Hystrix 的特性如下( 可能不是很严谨，主要辅助理解 ) ：</p><ul><li>断路器机制<ul><li>计算线路健康度</li></ul></li><li>Fallback ( 失败回退 )</li><li>资源隔离<ul><li>方式<ul><li>线程池</li><li>信号量</li></ul></li><li>依赖隔离</li></ul></li><li>执行模型<ul><li>同步执行</li><li>异步执行</li><li>Reactive模式执行<ul><li>observe</li><li>toObservable</li></ul></li></ul></li><li>运维平台<ul><li>基础 Dashboard</li><li>整合 Turbine</li></ul></li><li>缓存</li><li>请求合并( HystrixCollapser )</li></ul><h1 id="4-彩蛋"><a href="#4-彩蛋" class="headerlink" title="4. 彩蛋"></a>4. 彩蛋</h1><p>为了显得本文的诚意( 真的不是水更 )，友情提示如下：</p><p>Hystrix 基于 RxJava 实现，所以笔者推荐阅读如下文章 ：</p><ul><li><a href="http://gank.io/post/560e15be2dca930e00da1083" rel="external nofollow noopener noreferrer" target="_blank">《给 Android 开发者的 RxJava 详解》</a></li><li><a href="http://www.jianshu.com/p/856297523728" rel="external nofollow noopener noreferrer" target="_blank">《大话 RxJava》系列</a></li><li><a href="https://www.gitbook.com/book/mcxiaoke/rxdocs/details" rel="external nofollow noopener noreferrer" target="_blank">《ReactiveX/RxJava文档中文版》</a></li></ul><p>可能一开始理解会比较困难，保持耐心，你即将打开一个新的世界。对了，<strong>变换</strong>( <code>#lift(Operator)</code> ) 会是一个难点，我相信你可以理解。</p><hr><p>胖友，分享一波朋友圈可好！</p><p>对了，这是一个系列文，所以，千万不要错过。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Hystrix/build-debugging-environment/&quot;&gt;http://www.iocoder.cn/Hystrix/build-debugging-environment/&lt;
      
    
    </summary>
    
      <category term="Hystrix" scheme="http://www.iocoder.cn/categories/Hystrix/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— StringCache</title>
    <link href="http://www.iocoder.cn/Eureka/string-cache/"/>
    <id>http://www.iocoder.cn/Eureka/string-cache/</id>
    <published>2018-08-20T16:00:00.000Z</published>
    <updated>2017-10-19T15:47:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/string-cache/">http://www.iocoder.cn/Eureka/string-cache/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/Eureka/string-cache/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/string-cache/">2. StringCache</a></li><li><a href="http://www.iocoder.cn/Eureka/string-cache/">3. 使用场景</a></li><li><a href="http://www.iocoder.cn/Eureka/string-cache/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Eureka 自己实现的 StringCache</strong>。</p><p>先一起来看下美团点评技术团队对 <code>String#intern(...)</code> 的分享：</p><blockquote><p>FROM <a href="https://tech.meituan.com/in_depth_understanding_string_intern.html" rel="external nofollow noopener noreferrer" target="_blank">《深入解析String#intern》「 引言 」</a><br>在 JAVA 语言中有8中基本类型和一种比较特殊的类型 <code>String</code>。这些类型为了使他们在运行过程中速度更快，更节省内存，都提供了一种常量池的概念。常量池就类似一个 JAVA 系统级别提供的缓存。<br>8 种基本类型的常量池都是系统协调的，<code>String</code> 类型的常量池比较特殊。它的主要使用方法有两种：  </p><ul><li>直接使用双引号声明出来的 <code>String</code> 对象会直接存储在常量池中</li><li>如果不是用双引号声明的 <code>String</code> 对象，可以使用String提供的 <code>intern</code> 方法。<code>intern</code> 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中</li></ul></blockquote><ul><li>字符串常量池能带来速度更快，更节省内存的好处</li><li><strong>非双引号声明</strong>的 String 对象，需要使用 <code>String#intern()</code> 方法，将字符串存储到字符串常量池。</li></ul><p>看起来一切都非常非常非常美好，那为什么 Eureka 自己实现了 StringCache ？</p><p>继续参见美团点评技术团队对 <code>String#intern(...)</code> 的分享：</p><blockquote><p>FROM <a href="https://tech.meituan.com/in_depth_understanding_string_intern.html" rel="external nofollow noopener noreferrer" target="_blank">《深入解析String#intern》「 native 代码 」</a><br>JAVA 使用 JNI 调用 c++ 实现的 StringTable 的 <code>intern</code> 方法, StringTable的 <code>intern</code> 方法跟 Java 中的 HashMap 的实现是差不多的, 只是不能自动扩容。<strong>默认大小是1009</strong>。  </p><p>要注意的是，String 的 String Pool 是一个<strong>固定大小</strong>的 Hashtable，默认值大小长度是 1009，如果放进 String Pool 的 String 非常多，就会造成<strong>Hash冲突严重</strong>，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降（因为要一个一个找）。  </p><p>在 JDK6 中 StringTable 是固定的，就是 1009 的长度，所以如果常量池中的字符串过多就会导致效率下降很快。在jdk7中，StringTable的长度可以通过一个参数指定：</p><ul><li>-XX:StringTableSize=99991</li></ul></blockquote><ul><li>JDK 自带的 String Pool 固定大小( 即使可配 )，不支持自动扩容，大量使用 <code>String#intern(...)</code> 后，会导致性能大幅度下降。</li><li>Eureka 的应用实例( InstanceInfo ) 的 <code>appName</code>、<code>appGroupName</code>、<code>vipAddress</code>、<code>secureVipAddress</code>、<code>metadata</code> 和应用( Application )的 <code>name</code> 等属性需要使用到 String Pool ，为了在大量的网络通信序列化反序列的过程中，速度更快，更节省内容。</li></ul><p>另外，FastJSON 在 1.124 版本<strong>之前</strong>也使用 <code>String#intern(...)</code> 方法，优化 JSON Key 的速度和空间，但是在大量动态 JSON Key 的场景下，反而会导致性能下降。所以 FastJSON 1.124 修复了该问题。参见如下：</p><blockquote><p>FROM <a href="https://tech.meituan.com/in_depth_understanding_string_intern.html" rel="external nofollow noopener noreferrer" target="_blank">《深入解析String#intern》「 fastjson 不当使用 」</a><br><img src="http://www.iocoder.cn/images/Eureka/2018_08_21/01.png" alt=""></p></blockquote><ul><li>But ，FastJSON 1.124 版本<strong>之前</strong>恰好适合 Eureka ，因为 <code>appName</code>、<code>appGroupName</code> <strong>相对不那么动态</strong>。考虑到可能还是有大量的字符串存在，因而实现自定义的 StringCache 类，以解决 StringPool 的 HashTable 不支持动态扩容的情况。</li></ul><p>OK，下面我们来看看 Eureka 是如何实现自定义的 StringCache 类。</p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-StringCache"><a href="#2-StringCache" class="headerlink" title="2. StringCache"></a>2. StringCache</h1><p><code>com.netflix.discovery.util.StringCache</code> ，字符串缓存。代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringCache</span> </span>&#123;</div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>:     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LENGTH_LIMIT = <span class="number">38</span>;</div><div class="line"> <span class="number">4</span>: </div><div class="line"> <span class="number">5</span>:     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StringCache INSTANCE = <span class="keyword">new</span> StringCache();</div><div class="line"> <span class="number">6</span>: </div><div class="line"> <span class="number">7</span>:     <span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</div><div class="line"> <span class="number">8</span>:     <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, WeakReference&lt;String&gt;&gt; cache = <span class="keyword">new</span> WeakHashMap&lt;String, WeakReference&lt;String&gt;&gt;();</div><div class="line"> <span class="number">9</span>:     <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> lengthLimit;</div><div class="line"><span class="number">10</span>: </div><div class="line"><span class="number">11</span>:     <span class="function"><span class="keyword">public</span> <span class="title">StringCache</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">12</span>:         <span class="keyword">this</span>(LENGTH_LIMIT);</div><div class="line"><span class="number">13</span>:     &#125;</div><div class="line"><span class="number">14</span>: </div><div class="line"><span class="number">15</span>:     <span class="function"><span class="keyword">public</span> <span class="title">StringCache</span><span class="params">(<span class="keyword">int</span> lengthLimit)</span> </span>&#123;</div><div class="line"><span class="number">16</span>:         <span class="keyword">this</span>.lengthLimit = lengthLimit;</div><div class="line"><span class="number">17</span>:     &#125;</div><div class="line"><span class="number">18</span>: </div><div class="line"><span class="number">19</span>:     <span class="function"><span class="keyword">public</span> String <span class="title">cachedValueOf</span><span class="params">(<span class="keyword">final</span> String str)</span> </span>&#123;</div><div class="line"><span class="number">20</span>:         <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; (lengthLimit &lt; <span class="number">0</span> || str.length() &lt;= lengthLimit)) &#123;</div><div class="line"><span class="number">21</span>:             <span class="comment">// Return value from cache if available</span></div><div class="line"><span class="number">22</span>:             <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">23</span>:                 lock.readLock().lock();</div><div class="line"><span class="number">24</span>:                 WeakReference&lt;String&gt; ref = cache.get(str);</div><div class="line"><span class="number">25</span>:                 <span class="keyword">if</span> (ref != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">26</span>:                     <span class="keyword">return</span> ref.get();</div><div class="line"><span class="number">27</span>:                 &#125;</div><div class="line"><span class="number">28</span>:             &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">29</span>:                 lock.readLock().unlock();</div><div class="line"><span class="number">30</span>:             &#125;</div><div class="line"><span class="number">31</span>: </div><div class="line"><span class="number">32</span>:             <span class="comment">// Update cache with new content</span></div><div class="line"><span class="number">33</span>:             <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">34</span>:                 lock.writeLock().lock();</div><div class="line"><span class="number">35</span>:                 WeakReference&lt;String&gt; ref = cache.get(str);</div><div class="line"><span class="number">36</span>:                 <span class="keyword">if</span> (ref != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">37</span>:                     <span class="keyword">return</span> ref.get();</div><div class="line"><span class="number">38</span>:                 &#125;</div><div class="line"><span class="number">39</span>:                 cache.put(str, <span class="keyword">new</span> WeakReference&lt;&gt;(str));</div><div class="line"><span class="number">40</span>:             &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">41</span>:                 lock.writeLock().unlock();</div><div class="line"><span class="number">42</span>:             &#125;</div><div class="line"><span class="number">43</span>:             <span class="keyword">return</span> str;</div><div class="line"><span class="number">44</span>:         &#125;</div><div class="line"><span class="number">45</span>:         <span class="keyword">return</span> str;</div><div class="line"><span class="number">46</span>:     &#125;</div><div class="line"><span class="number">47</span>: </div><div class="line"><span class="number">48</span>:     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">49</span>:         <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">50</span>:             lock.readLock().lock();</div><div class="line"><span class="number">51</span>:             <span class="keyword">return</span> cache.size();</div><div class="line"><span class="number">52</span>:         &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">53</span>:             lock.readLock().unlock();</div><div class="line"><span class="number">54</span>:         &#125;</div><div class="line"><span class="number">55</span>:     &#125;</div><div class="line"><span class="number">56</span>: </div><div class="line"><span class="number">57</span>:     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">intern</span><span class="params">(String original)</span> </span>&#123;</div><div class="line"><span class="number">58</span>:         <span class="keyword">return</span> INSTANCE.cachedValueOf(original);</div><div class="line"><span class="number">59</span>:     &#125;</div><div class="line"><span class="number">60</span>: </div><div class="line"><span class="number">61</span>: &#125;</div></pre></td></tr></table></figure><ul><li><code>INSTANCE</code> 属性，字符串缓存<strong>单例</strong>。</li><li><code>lock</code> 属性，<strong>读写锁</strong>，保证读写互斥。</li><li><code>cache</code> 属性，缓存哈希表。<ul><li>使用 WeakHashMap，当 StringCache 被回收时，其对应的值一起被移除。</li><li><a href="http://blog.csdn.net/yangzl2008/article/details/6980709" rel="external nofollow noopener noreferrer" target="_blank">《WeakHashMap和HashMap的区别》</a></li><li><a href="http://www.cnblogs.com/skywang12345/p/3311092.html" rel="external nofollow noopener noreferrer" target="_blank">《Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例》</a></li></ul></li><li><code>lengthLimit</code> 属性，缓存字符串最大长度。默认值：38 。</li><li><code>#cachedValueOf(...)</code> 方法，获得字符串缓存。若缓存不存在，则进行缓存。和 <code>String#intern()</code> 的逻辑相同，区别在于 <code>cache</code> 支持自动扩容。<ul><li>第 22 至 30 行 ：读锁，读取缓存。</li><li>第 32 至 42 行 ：缓存不存在，写锁，写入缓存。 </li></ul></li><li><code>#size()</code> 方法，缓存大小。</li><li><code>#intern()</code> <strong>静态</strong>方法，使用 <code>INSTANCE</code> 获取缓存字符串。</li></ul><h1 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h1><p>在 InstanceInfo 下的使用，点击 <a href="https://github.com/YunaiV/eureka/blob/7f868f9ca715a8862c0c10cac04e238bbf371db0/eureka-client/src/main/java/com/netflix/appinfo/InstanceInfo.java#L233" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看。</p><p>在 Application 下的使用，点击 <a href="https://github.com/YunaiV/eureka/blob/7f868f9ca715a8862c0c10cac04e238bbf371db0/eureka-client/src/main/java/com/netflix/discovery/shared/Application.java#L95" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>又 Get 新姿势了，好开森。</p><p>胖友，分享个朋友圈，可好？！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/string-cache/&quot;&gt;http://www.iocoder.cn/Eureka/string-cache/&lt;/a&gt; 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;ul&gt;
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 基于令牌桶算法的 RateLimiter</title>
    <link href="http://www.iocoder.cn/Eureka/rate-limiter/"/>
    <id>http://www.iocoder.cn/Eureka/rate-limiter/</id>
    <published>2018-08-13T16:00:00.000Z</published>
    <updated>2017-10-19T05:48:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/rate-limiter/">http://www.iocoder.cn/Eureka/rate-limiter/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Eureka/rate-limiter/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/rate-limiter/">2. RateLimiter</a><ul><li><a href="http://www.iocoder.cn/Eureka/rate-limiter/">2.1 refillToken</a></li><li><a href="http://www.iocoder.cn/Eureka/rate-limiter/">2.2 consumeToken</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/rate-limiter/">3. RateLimitingFilter</a></li><li><a href="http://www.iocoder.cn/Eureka/rate-limiter/">4. InstanceInfoReplicator</a></li><li><a href="http://www.iocoder.cn/Eureka/rate-limiter/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>RateLimiter 的代码实现和 RateLimiter 在 Eureka 中的应用</strong>。</p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-RateLimiter"><a href="#2-RateLimiter" class="headerlink" title="2. RateLimiter"></a>2. RateLimiter</h1><p><code>com.netflix.discovery.util.RateLimiter</code> ，基于<strong>Token Bucket Algorithm ( 令牌桶算法 )</strong>的速率限制器。</p><blockquote><p>FROM <a href="http://www.cnblogs.com/LBSer/p/4083131.html" rel="external nofollow noopener noreferrer" target="_blank">《接口限流实践》</a><br>令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。<br><img src="http://www.iocoder.cn/images/Eureka/2018_08_14/01.png" alt=""></p></blockquote><p>RateLimiter 目前支持<strong>分钟级</strong>和<strong>秒级</strong>两种速率限制。构造方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 速率单位转换成毫秒</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> rateToMsConversion;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RateLimiter</span><span class="params">(TimeUnit averageRateUnit)</span> </span>&#123;</div><div class="line">        <span class="keyword">switch</span> (averageRateUnit) &#123;</div><div class="line">            <span class="keyword">case</span> SECONDS: <span class="comment">// 秒级</span></div><div class="line">                rateToMsConversion = <span class="number">1000</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MINUTES: <span class="comment">// 分钟级</span></div><div class="line">                rateToMsConversion = <span class="number">60</span> * <span class="number">1000</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"TimeUnit of "</span> + averageRateUnit + <span class="string">" is not supported"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>averageRateUnit</code> 参数，速率<strong>单位</strong>。构造方法里将 <code>averageRateUnit</code> 转换成 <code>rateToMsConversion</code> 。</li></ul><p>调用 <code>#acquire(...)</code> 方法，获取令牌，并返回<strong>是否获取成功</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// RateLimiter.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获取令牌( Token )</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> burstSize 令牌桶上限</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> averageRate 令牌再装平均速率</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 是否获取成功</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> burstSize, <span class="keyword">long</span> averageRate)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> acquire(burstSize, averageRate, System.currentTimeMillis());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> burstSize, <span class="keyword">long</span> averageRate, <span class="keyword">long</span> currentTimeMillis)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (burstSize &lt;= <span class="number">0</span> || averageRate &lt;= <span class="number">0</span>) &#123; <span class="comment">// Instead of throwing exception, we just let all the traffic go</span></div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// 填充 令牌</span></div><div class="line">   refillToken(burstSize, averageRate, currentTimeMillis);</div><div class="line">   <span class="comment">// 消费 令牌</span></div><div class="line">   <span class="keyword">return</span> consumeToken(burstSize);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>burstSize</code> 参数 ：令牌桶上限。</li><li><code>averageRate</code> 参数 ：令牌填充<strong>平均</strong>速率。</li><li>我们举个 🌰 来理解这两个参数 + 构造方法里的一个参数：<ul><li><code>averageRateUnit = SECONDS</code></li><li><code>averageRate = 2000</code></li><li><code>burstSize = 10</code></li><li>每<strong>秒</strong>可获取 <code>2000</code> 个令牌。例如，每秒允许请求 <code>2000</code> 次。</li><li>每<strong>毫秒</strong>可填充 <code>2000 / 1000 = 2</code> 个<strong>消耗</strong>的令牌。</li><li>每<strong>毫秒</strong>可获取 <code>10</code> 个令牌。例如，每毫秒允许请求上限为 <code>10</code> 次，并且请求<strong>消耗</strong>掉的令牌，需要逐步填充。这里要注意下，虽然每毫秒允许请求上限为 <code>10</code> 次，这是在没有任何令牌被<strong>消耗</strong>的情况下，实际每秒允许请求依然是 <code>2000</code> 次。</li><li><strong>这就是基于令牌桶算法的限流的特点：让流量平稳，而不是瞬间流量。1000 QPS 相对平均的分摊在这一秒内，而不是第 1 ms 999 请求，后面 999 ms 0 请求</strong>。</li></ul></li><li><p>从代码上看，<code>#acquire(...)</code> 分成两部分，我们分别解析，整体如下图：</p><p>  <img src="http://www.iocoder.cn/images/Eureka/2018_08_14/02.png" alt=""></p></li></ul><h2 id="2-1-refillToken"><a href="#2-1-refillToken" class="headerlink" title="2.1 refillToken"></a>2.1 refillToken</h2><p>调用 <code>#refillToken(...)</code> 方法，填充<strong>已消耗</strong>的令牌。可能很多同学开始和我想的一样，一个后台每毫秒执行填充。<strong>为什么不适合这样呢？</strong>一方面，实际项目里每个接口都会有相应的 RateLimiter ，导致<strong>太多</strong>执行频率<strong>极高</strong>的后台任务；另一方面，获取令牌时才计算，多次令牌填充可以合并成一次，减少冗余和无效的计算。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="comment">/**</span></div><div class="line"><span class="comment"> 2:  * 速率单位转换成毫秒</span></div><div class="line"><span class="comment"> 3:  */</span></div><div class="line"> <span class="number">4</span>: <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> rateToMsConversion;</div><div class="line"> <span class="number">5</span>: </div><div class="line"> <span class="number">6</span>: <span class="comment">/**</span></div><div class="line"><span class="comment"> 7:  * 消耗令牌数</span></div><div class="line"><span class="comment"> 8:  */</span></div><div class="line"> <span class="number">9</span>: <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger consumedTokens = <span class="keyword">new</span> AtomicInteger();</div><div class="line"><span class="number">10</span>: <span class="comment">/**</span></div><div class="line"><span class="comment">11:  * 最后填充令牌的时间</span></div><div class="line"><span class="comment">12:  */</span></div><div class="line"><span class="number">13</span>: <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong lastRefillTime = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</div><div class="line"><span class="number">14</span>: </div><div class="line"><span class="number">15</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refillToken</span><span class="params">(<span class="keyword">int</span> burstSize, <span class="keyword">long</span> averageRate, <span class="keyword">long</span> currentTimeMillis)</span> </span>&#123;</div><div class="line"><span class="number">16</span>:     <span class="comment">// 获得 最后填充令牌的时间</span></div><div class="line"><span class="number">17</span>:     <span class="keyword">long</span> refillTime = lastRefillTime.get();</div><div class="line"><span class="number">18</span>:     <span class="comment">// 获得 过去多少毫秒</span></div><div class="line"><span class="number">19</span>:     <span class="keyword">long</span> timeDelta = currentTimeMillis - refillTime;</div><div class="line"><span class="number">20</span>: </div><div class="line"><span class="number">21</span>:     <span class="comment">// 计算 可填充最大令牌数量</span></div><div class="line"><span class="number">22</span>:     <span class="keyword">long</span> newTokens = timeDelta * averageRate / rateToMsConversion;</div><div class="line"><span class="number">23</span>:     <span class="keyword">if</span> (newTokens &gt; <span class="number">0</span>) &#123;</div><div class="line"><span class="number">24</span>:         <span class="comment">// 计算 新的填充令牌的时间</span></div><div class="line"><span class="number">25</span>:         <span class="keyword">long</span> newRefillTime = refillTime == <span class="number">0</span></div><div class="line"><span class="number">26</span>:                 ? currentTimeMillis</div><div class="line"><span class="number">27</span>:                 : refillTime + newTokens * rateToMsConversion / averageRate;</div><div class="line"><span class="number">28</span>:         <span class="comment">// CAS 保证有且仅有一个线程进入填充</span></div><div class="line"><span class="number">29</span>:         <span class="keyword">if</span> (lastRefillTime.compareAndSet(refillTime, newRefillTime)) &#123;</div><div class="line"><span class="number">30</span>:             <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">// 死循环，直到成功</span></div><div class="line"><span class="number">31</span>:                 <span class="comment">// 计算 填充令牌后的已消耗令牌数量</span></div><div class="line"><span class="number">32</span>:                 <span class="keyword">int</span> currentLevel = consumedTokens.get();</div><div class="line"><span class="number">33</span>:                 <span class="keyword">int</span> adjustedLevel = Math.min(currentLevel, burstSize); <span class="comment">// In case burstSize decreased</span></div><div class="line"><span class="number">34</span>:                 <span class="keyword">int</span> newLevel = (<span class="keyword">int</span>) Math.max(<span class="number">0</span>, adjustedLevel - newTokens);</div><div class="line"><span class="number">35</span>:                 <span class="comment">// CAS 避免和正在消费令牌的线程冲突</span></div><div class="line"><span class="number">36</span>:                 <span class="keyword">if</span> (consumedTokens.compareAndSet(currentLevel, newLevel)) &#123;</div><div class="line"><span class="number">37</span>:                     <span class="keyword">return</span>;</div><div class="line"><span class="number">38</span>:                 &#125;</div><div class="line"><span class="number">39</span>:             &#125;</div><div class="line"><span class="number">40</span>:         &#125;</div><div class="line"><span class="number">41</span>:     &#125;</div><div class="line"><span class="number">42</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 17 行 ：获取最后填充令牌的时间( <code>refillTime</code> ) 。每次填充令牌，会设置 <code>currentTimeMillis</code> 到 <code>refillTime</code> 。</li><li>第 19 行 ：获得距离最后填充令牌的时间差( <code>timeDelta</code> )，用于计算需要填充的令牌数。</li><li>第 22 行 ：计算<strong>可填充的</strong>最大令牌数量( <code>newTokens</code> )。<code>newTokens</code> 可能超过 <code>burstSize</code> ，所以下面会有逻辑调整 <code>newTokens</code> 。</li><li>第 25 至 27 行 ：计算<strong>新的</strong>填充令牌的时间。<strong>为什么不能用 <code>currentTimeMillis</code> 呢</strong>？例如，<code>averageRate = 500 &amp;&amp; averageRateUnit = SECONDS</code> 时， 每 2 毫秒才填充一个令牌，如果设置 <code>currentTimeMillis</code> ，<strong>会导致不足以填充一个令牌的时长被吞了</strong>。</li><li>第 29 行 ：通过 <strong>CAS</strong> 保证有且<strong>仅有一个</strong>线程进入填充逻辑。</li><li>第 30 行 ：<strong>死循环直到成功</strong>。</li><li>第 32 至 34 行 ：计算<strong>新的</strong>填充令牌后的<strong>已消耗</strong>的令牌数量。<ul><li>第 33 行 ：<code>burstSize</code> 可能调小，例如，系统接入分布式配置中心，可以远程调整该数值。如果此时 <code>burstSize</code> 更小，以它作为<strong>已消耗</strong>的令牌数量。</li></ul></li><li>第 36 行 ：通过 <strong>CAS</strong> 保证避免覆盖设置正在消费令牌的线程。</li></ul><h2 id="2-2-consumeToken"><a href="#2-2-consumeToken" class="headerlink" title="2.2 consumeToken"></a>2.2 consumeToken</h2><p>用 <code>#refillToken(...)</code> 方法，填充<strong>消耗( 获取 )</strong>的令牌。</p><p>代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">consumeToken</span><span class="params">(<span class="keyword">int</span> burstSize)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">// 死循环，直到没有令牌，或者获取令牌成功</span></div><div class="line"> <span class="number">3</span>:         <span class="comment">// 没有令牌</span></div><div class="line"> <span class="number">4</span>:         <span class="keyword">int</span> currentLevel = consumedTokens.get();</div><div class="line"> <span class="number">5</span>:         <span class="keyword">if</span> (currentLevel &gt;= burstSize) &#123;</div><div class="line"> <span class="number">6</span>:             <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"> <span class="number">7</span>:         &#125;</div><div class="line"> <span class="number">8</span>:         <span class="comment">// CAS 避免和正在消费令牌或者填充令牌的线程冲突</span></div><div class="line"> <span class="number">9</span>:         <span class="keyword">if</span> (consumedTokens.compareAndSet(currentLevel, currentLevel + <span class="number">1</span>)) &#123;</div><div class="line"><span class="number">10</span>:             <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"><span class="number">11</span>:         &#125;</div><div class="line"><span class="number">12</span>:     &#125;</div><div class="line"><span class="number">13</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 2 行 ：<strong>死循环直到没有令牌或者竞争获取令牌成功</strong>。</li><li>第 4 至 7 行 ：没有令牌。</li><li>第 9 至 11 行 ：通过 <strong>CAS</strong> 避免和正在消费令牌或者填充令牌的线程冲突。</li></ul><h1 id="3-RateLimitingFilter"><a href="#3-RateLimitingFilter" class="headerlink" title="3. RateLimitingFilter"></a>3. RateLimitingFilter</h1><p><code>com.netflix.eureka.RateLimitingFilter</code> ，Eureka-Server 限流过滤器。使用 RateLimiting ，保证 Eureka-Server 稳定性。</p><p><code>#doFilter(...)</code> 方法，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="comment">// 获得 Target</span></div><div class="line"> <span class="number">4</span>:     Target target = getTarget(request);</div><div class="line"> <span class="number">5</span>: </div><div class="line"> <span class="number">6</span>:     <span class="comment">// Other Target ，不做限流</span></div><div class="line"> <span class="number">7</span>:     <span class="keyword">if</span> (target == Target.Other) &#123;</div><div class="line"> <span class="number">8</span>:         chain.doFilter(request, response);</div><div class="line"> <span class="number">9</span>:         <span class="keyword">return</span>;</div><div class="line"><span class="number">10</span>:     &#125;</div><div class="line"><span class="number">11</span>: </div><div class="line"><span class="number">12</span>:     HttpServletRequest httpRequest = (HttpServletRequest) request;</div><div class="line"><span class="number">13</span>:     <span class="comment">// 判断是否被限流</span></div><div class="line"><span class="number">14</span>:     <span class="keyword">if</span> (isRateLimited(httpRequest, target)) &#123;</div><div class="line"><span class="number">15</span>:         <span class="comment">// TODO[0012]：监控相关，跳过</span></div><div class="line"><span class="number">16</span>:         incrementStats(target);</div><div class="line"><span class="number">17</span>:         <span class="comment">// 如果开启限流，返回 503 状态码</span></div><div class="line"><span class="number">18</span>:         <span class="keyword">if</span> (serverConfig.isRateLimiterEnabled()) &#123;</div><div class="line"><span class="number">19</span>:             ((HttpServletResponse) response).setStatus(HttpServletResponse.SC_SERVICE_UNAVAILABLE);</div><div class="line"><span class="number">20</span>:             <span class="keyword">return</span>;</div><div class="line"><span class="number">21</span>:         &#125;</div><div class="line"><span class="number">22</span>:     &#125;</div><div class="line"><span class="number">23</span>:     chain.doFilter(request, response);</div><div class="line"><span class="number">24</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 4 行 ：调用 <code>#getTarget()</code> 方法，获取 Target。RateLimitingFilter 只对符合正在表达式 <code>^.*/apps(/[^/]*)?$</code> 的接口做限流，其中不包含 Eureka-Server 集群批量同步接口。<ul><li>点击 <a href="https://github.com/YunaiV/eureka/blob/7f868f9ca715a8862c0c10cac04e238bbf371db0/eureka-core/src/main/java/com/netflix/eureka/RateLimitingFilter.java#L98" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 Target 枚举类代码。</li><li>点击 <a href="https://github.com/YunaiV/eureka/blob/7f868f9ca715a8862c0c10cac04e238bbf371db0/eureka-core/src/main/java/com/netflix/eureka/RateLimitingFilter.java#L150" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 <code>#getTarget(...)</code> 方法代码。  </li></ul></li><li><p>第 14 行 ：调用 <code>#isRateLimited(...)</code> 方法，判断是否被限流。代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRateLimited</span><span class="params">(HttpServletRequest request, Target target)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// 判断是否特权应用</span></div><div class="line"> <span class="number">3</span>:     <span class="keyword">if</span> (isPrivileged(request)) &#123;</div><div class="line"> <span class="number">4</span>:         logger.debug(<span class="string">"Privileged &#123;&#125; request"</span>, target);</div><div class="line"> <span class="number">5</span>:         <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"> <span class="number">6</span>:     &#125;</div><div class="line"> <span class="number">7</span>:     <span class="comment">// 判断是否被超载( 限流 )</span></div><div class="line"> <span class="number">8</span>:     <span class="keyword">if</span> (isOverloaded(target)) &#123;</div><div class="line"> <span class="number">9</span>:         logger.debug(<span class="string">"Overloaded &#123;&#125; request; discarding it"</span>, target);</div><div class="line"><span class="number">10</span>:         <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"><span class="number">11</span>:     &#125;</div><div class="line"><span class="number">12</span>:     logger.debug(<span class="string">"&#123;&#125; request admitted"</span>, target);</div><div class="line"><span class="number">13</span>:     <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"><span class="number">14</span>: &#125;</div></pre></td></tr></table></figure><ul><li><p>第 3 至 6 行 ：调用 <code>#isPrivileged()</code> 方法，判断是否为特权应用，对特权应用不开启限流逻辑。代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPrivileged</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</div><div class="line">    <span class="comment">// 是否对标准客户端开启限流</span></div><div class="line">    <span class="keyword">if</span> (serverConfig.isRateLimiterThrottleStandardClients()) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 以请求头( "DiscoveryIdentity-Name" ) 判断是否在标准客户端名集合内</span></div><div class="line">    Set&lt;String&gt; privilegedClients = serverConfig.getRateLimiterPrivilegedClients();</div><div class="line">    String clientName = request.getHeader(AbstractEurekaIdentity.AUTH_NAME_HEADER_KEY);</div><div class="line">    <span class="keyword">return</span> privilegedClients.contains(clientName) || DEFAULT_PRIVILEGED_CLIENTS.contains(clientName);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul></li><li><p>第 8 至 11 行 ：调用 <code>#isOverloaded(...)</code> 方法，判断是否超载( 限流 )。代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* Includes both full and delta fetches.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RateLimiter registryFetchRateLimiter = <span class="keyword">new</span> RateLimiter(TimeUnit.SECONDS);</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* Only full registry fetches.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RateLimiter registryFullFetchRateLimiter = <span class="keyword">new</span> RateLimiter(TimeUnit.SECONDS);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isOverloaded</span><span class="params">(Target target)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> maxInWindow = serverConfig.getRateLimiterBurstSize(); <span class="comment">// 10</span></div><div class="line">    <span class="keyword">int</span> fetchWindowSize = serverConfig.getRateLimiterRegistryFetchAverageRate(); <span class="comment">// 500</span></div><div class="line">    <span class="keyword">boolean</span> overloaded = !registryFetchRateLimiter.acquire(maxInWindow, fetchWindowSize);</div><div class="line">    <span class="keyword">if</span> (target == Target.FullFetch) &#123;</div><div class="line">        <span class="keyword">int</span> fullFetchWindowSize = serverConfig.getRateLimiterFullFetchAverageRate(); <span class="comment">// 100</span></div><div class="line">            overloaded |= !registryFullFetchRateLimiter.acquire(maxInWindow, fullFetchWindowSize);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> overloaded;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul></li></ul></li><li><p>第 18 至 21 行 ：若 <code>eureka.rateLimiter.enabled = true</code>( 默认值 ：<code>false</code> ，可配 )，返回 503 状态码。</p></li></ul><h1 id="4-InstanceInfoReplicator"><a href="#4-InstanceInfoReplicator" class="headerlink" title="4. InstanceInfoReplicator"></a>4. InstanceInfoReplicator</h1><p><code>com.netflix.discovery.InstanceInfoReplicator</code> ，Eureka-Client 应用实例复制器。在 <a href="http://www.iocoder.cn/Eureka/instance-registry-register/?self">《Eureka 源码解析 —— 应用实例注册发现（一）之注册》「2.1 应用实例信息复制器」</a> 有详细解析。</p><p>应用实例状态发生变化时，调用 <code>#onDemandUpdate()</code> 方法，向 Eureka-Server 发起注册，同步应用实例信息。InstanceInfoReplicator 使用 RateLimiter ，避免状态<strong>频繁</strong>发生变化，向 Eureka-Server <strong>频繁</strong>同步。代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">InstanceInfoReplicator</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * RateLimiter</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RateLimiter rateLimiter;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 令牌桶上限，默认：2</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> burstSize;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 令牌再装平均速率，默认：60 * 2 / 30 = 4</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> allowedRatePerMinute;</div><div class="line">    </div><div class="line">    InstanceInfoReplicator(DiscoveryClient discoveryClient, InstanceInfo instanceInfo, <span class="keyword">int</span> replicationIntervalSeconds, <span class="keyword">int</span> burstSize) &#123;</div><div class="line">        <span class="comment">// ... 省略其他代码</span></div><div class="line">        </div><div class="line">        <span class="keyword">this</span>.rateLimiter = <span class="keyword">new</span> RateLimiter(TimeUnit.MINUTES);</div><div class="line">        <span class="keyword">this</span>.replicationIntervalSeconds = replicationIntervalSeconds;</div><div class="line">        <span class="keyword">this</span>.burstSize = burstSize;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.allowedRatePerMinute = <span class="number">60</span> * <span class="keyword">this</span>.burstSize / <span class="keyword">this</span>.replicationIntervalSeconds;</div><div class="line">        logger.info(<span class="string">"InstanceInfoReplicator onDemand update allowed rate per min is &#123;&#125;"</span>, allowedRatePerMinute);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDemandUpdate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (rateLimiter.acquire(burstSize, allowedRatePerMinute)) &#123; <span class="comment">// 限流</span></div><div class="line">            scheduler.submit(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    logger.debug(<span class="string">"Executing on-demand update of local InstanceInfo"</span>);</div><div class="line">                    <span class="comment">// 取消任务</span></div><div class="line">                    Future latestPeriodic = scheduledPeriodicRef.get();</div><div class="line">                    <span class="keyword">if</span> (latestPeriodic != <span class="keyword">null</span> &amp;&amp; !latestPeriodic.isDone()) &#123;</div><div class="line">                        logger.debug(<span class="string">"Canceling the latest scheduled update, it will be rescheduled at the end of on demand update"</span>);</div><div class="line">                        latestPeriodic.cancel(<span class="keyword">false</span>);</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 再次调用</span></div><div class="line">                    InstanceInfoReplicator.<span class="keyword">this</span>.run();</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            logger.warn(<span class="string">"Ignoring onDemand update due to rate limiter"</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>在 <code>#onDemandUpdate()</code> 方法，调用 <code>RateLimiter#acquire(...)</code> 方法，获取令牌。<ul><li>若获取成功，向 Eureka-Server 发起注册，同步应用实例信息。</li><li>若获取失败，<strong>不</strong>向 Eureka-Server 发起注册，同步应用实例信息。<strong>这样会不会有问题</strong>？答案是<strong>不会</strong>。<ul><li>InstanceInfoReplicator 会<strong>固定周期</strong>检查本地应用实例是否有没向 Eureka-Server ，若未同步，则发起同步。在 <a href="http://www.iocoder.cn/Eureka/instance-registry-register/?self">《Eureka 源码解析 —— 应用实例注册发现（一）之注册》「2.1 应用实例信息复制器」</a> 有详细解析。</li><li>Eureka-Client 向 Eureka-Server 心跳时，Eureka-Server 会对比应用实例的 <code>lastDirtyTimestamp</code> ，若 Eureka-Client 的更大，则 Eureka-Server 返回 404 状态码。Eureka-Client 接收到 404 状态码后，发起注册同步。在 <a href="http://www.iocoder.cn/Eureka/instance-registry-renew/?self">Eureka 源码解析 —— 应用实例注册发现（二）之续租》「2.2 HeartbeatThread」</a> 有详细解析。</li></ul></li></ul></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>后面找时间研究下 Google Guava RateLimiter 的源码实现，从功能上更加强大，感兴趣的胖友可以瞅瞅呀。</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/rate-limiter/&quot;&gt;http://www.iocoder.cn/Eureka/rate-limiter/&lt;/a&gt; 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— Eureka-Server 集群同步</title>
    <link href="http://www.iocoder.cn/Eureka/server-cluster/"/>
    <id>http://www.iocoder.cn/Eureka/server-cluster/</id>
    <published>2018-08-06T16:00:00.000Z</published>
    <updated>2017-10-19T05:48:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/server-cluster/">http://www.iocoder.cn/Eureka/server-cluster/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">2. 集群节点初始化与更新</a><ul><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">2.1 集群节点启动</a></li><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">2.2 更新集群节点信息</a></li><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">2.3 集群节点</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">3. 获取初始注册信息</a></li><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">4. 同步注册信息</a><ul><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">4.1 同步操作类型</a></li><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">4.2 发起 Eureka-Server 同步操作</a></li><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">4.3 接收 Eureka-Server 同步操作</a></li><li><a href="http://www.iocoder.cn/Eureka/server-cluster/">4.4 处理 Eureka-Server 同步结果</a></li></ul></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Eureka-Server 集群同步注册信息</strong>。</p><p>Eureka-Server 集群如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_08_07/01.png" alt=""></p><ul><li>Eureka-Server 集群不区分<strong>主从节点</strong>或者 <strong>Primary &amp; Secondary 节点</strong>，所有节点<strong>相同角色( 也就是没有角色 )，完全对等</strong>。</li><li>Eureka-Client 可以向<strong>任意</strong> Eureka-Client 发起任意<strong>读写</strong>操作，Eureka-Server 将操作复制到另外的 Eureka-Server 以达到<strong>最终一致性</strong>。注意，Eureka-Server 是选择了 AP 的组件。</li></ul><p>Eureka-Server 可以使用直接配置所有节点的服务地址，或者基于 DNS 配置。推荐阅读：<a href="http://blog.didispace.com/springcloud6/?from=http://www.iocoder.cn" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud构建微服务架构（六）高可用服务注册中心》</a> 。</p><p>本文主要类在 <code>com.netflix.eureka.cluster</code> 包下。</p><p>OK，让我们开始愉快的遨游在代码的海洋。</p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><p>ps ：<strong>注意</strong>，本文提到的<strong>同步</strong>，准确来说是<strong>复制( Replication )</strong>。</p><h1 id="2-集群节点初始化与更新"><a href="#2-集群节点初始化与更新" class="headerlink" title="2. 集群节点初始化与更新"></a>2. 集群节点初始化与更新</h1><p><code>com.netflix.eureka.cluster.PeerEurekaNodes</code> ，Eureka-Server 集群节点集合 。构造方法如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeerEurekaNodes</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(PeerEurekaNodes.class);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用实例注册表</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> PeerAwareInstanceRegistry registry;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Eureka-Server 配置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> EurekaServerConfig serverConfig;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Eureka-Client 配置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> EurekaClientConfig clientConfig;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Eureka-Server 编解码</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> ServerCodecs serverCodecs;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用实例信息管理器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApplicationInfoManager applicationInfoManager;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Eureka-Server 集群节点数组</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;PeerEurekaNode&gt; peerEurekaNodes = Collections.emptyList();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Eureka-Server 服务地址数组</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Set&lt;String&gt; peerEurekaNodeUrls = Collections.emptySet();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 定时任务服务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> ScheduledExecutorService taskExecutor;</div><div class="line"></div><div class="line">    <span class="meta">@Inject</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PeerEurekaNodes</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">            PeerAwareInstanceRegistry registry,</span></span></div><div class="line"><span class="function"><span class="params">            EurekaServerConfig serverConfig,</span></span></div><div class="line"><span class="function"><span class="params">            EurekaClientConfig clientConfig,</span></span></div><div class="line"><span class="function"><span class="params">            ServerCodecs serverCodecs,</span></span></div><div class="line"><span class="function"><span class="params">            ApplicationInfoManager applicationInfoManager)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.registry = registry;</div><div class="line">        <span class="keyword">this</span>.serverConfig = serverConfig;</div><div class="line">        <span class="keyword">this</span>.clientConfig = clientConfig;</div><div class="line">        <span class="keyword">this</span>.serverCodecs = serverCodecs;</div><div class="line">        <span class="keyword">this</span>.applicationInfoManager = applicationInfoManager;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>peerEurekaNodes</code>, <code>peerEurekaNodeUrls</code>, <code>taskExecutor</code> 属性，在构造方法中<strong>未设置和初始化</strong>，而是在 <code>PeerEurekaNodes#start()</code> 方法，设置和初始化，下文我们会解析这个方法。</li><li>Eureka-Server 在初始化时，调用 <code>EurekaBootStrap#getPeerEurekaNodes(...)</code> 方法，创建 PeerEurekaNodes ，点击 <a href="https://github.com/YunaiV/eureka/blob/94a4a1ebd35a3350893369a05757c01b2534b702/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java#L245" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看该方法的实现。</li></ul><h2 id="2-1-集群节点启动"><a href="#2-1-集群节点启动" class="headerlink" title="2.1 集群节点启动"></a>2.1 集群节点启动</h2><p>调用 <code>PeerEurekaNodes#start()</code> 方法，集群节点启动，主要完成两个逻辑：</p><ul><li>初始化集群节点信息</li><li>初始化固定周期( 默认：10 分钟，可配置 )更新集群节点信息的任务</li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// 创建 定时任务服务</span></div><div class="line"> <span class="number">3</span>:     taskExecutor = Executors.newSingleThreadScheduledExecutor(</div><div class="line"> <span class="number">4</span>:             <span class="keyword">new</span> ThreadFactory() &#123;</div><div class="line"> <span class="number">5</span>:                 <span class="meta">@Override</span></div><div class="line"> <span class="number">6</span>:                 <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line"> <span class="number">7</span>:                     Thread thread = <span class="keyword">new</span> Thread(r, <span class="string">"Eureka-PeerNodesUpdater"</span>);</div><div class="line"> <span class="number">8</span>:                     thread.setDaemon(<span class="keyword">true</span>);</div><div class="line"> <span class="number">9</span>:                     <span class="keyword">return</span> thread;</div><div class="line"><span class="number">10</span>:                 &#125;</div><div class="line"><span class="number">11</span>:             &#125;</div><div class="line"><span class="number">12</span>:     );</div><div class="line"><span class="number">13</span>:     <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">14</span>:         <span class="comment">// 初始化 集群节点信息</span></div><div class="line"><span class="number">15</span>:         updatePeerEurekaNodes(resolvePeerUrls());</div><div class="line"><span class="number">16</span>:         <span class="comment">// 初始化 初始化固定周期更新集群节点信息的任务</span></div><div class="line"><span class="number">17</span>:         Runnable peersUpdateTask = <span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="number">18</span>:             <span class="meta">@Override</span></div><div class="line"><span class="number">19</span>:             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">20</span>:                 <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">21</span>:                     updatePeerEurekaNodes(resolvePeerUrls());</div><div class="line"><span class="number">22</span>:                 &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"><span class="number">23</span>:                     logger.error(<span class="string">"Cannot update the replica Nodes"</span>, e);</div><div class="line"><span class="number">24</span>:                 &#125;</div><div class="line"><span class="number">25</span>: </div><div class="line"><span class="number">26</span>:             &#125;</div><div class="line"><span class="number">27</span>:         &#125;;</div><div class="line"><span class="number">28</span>:         taskExecutor.scheduleWithFixedDelay(</div><div class="line"><span class="number">29</span>:                 peersUpdateTask,</div><div class="line"><span class="number">30</span>:                 serverConfig.getPeerEurekaNodesUpdateIntervalMs(),</div><div class="line"><span class="number">31</span>:                 serverConfig.getPeerEurekaNodesUpdateIntervalMs(),</div><div class="line"><span class="number">32</span>:                 TimeUnit.MILLISECONDS</div><div class="line"><span class="number">33</span>:         );</div><div class="line"><span class="number">34</span>:     &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"><span class="number">35</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</div><div class="line"><span class="number">36</span>:     &#125;</div><div class="line"><span class="number">37</span>:     <span class="comment">// 打印 集群节点信息</span></div><div class="line"><span class="number">38</span>:     <span class="keyword">for</span> (PeerEurekaNode node : peerEurekaNodes) &#123;</div><div class="line"><span class="number">39</span>:         logger.info(<span class="string">"Replica node URL:  "</span> + node.getServiceUrl());</div><div class="line"><span class="number">40</span>:     &#125;</div><div class="line"><span class="number">41</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 15 行 &amp;&amp; 第 21 行 ：调用 <code>#updatePeerEurekaNodes()</code> 方法，更新集群节点信息。</li></ul><h2 id="2-2-更新集群节点信息"><a href="#2-2-更新集群节点信息" class="headerlink" title="2.2 更新集群节点信息"></a>2.2 更新集群节点信息</h2><p>调用 <code>#resolvePeerUrls()</code> 方法，获得 Eureka-Server 集群服务地址数组，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">resolvePeerUrls</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// 获得 Eureka-Server 集群服务地址数组</span></div><div class="line"> <span class="number">3</span>:     InstanceInfo myInfo = applicationInfoManager.getInfo();</div><div class="line"> <span class="number">4</span>:     String zone = InstanceInfo.getZone(clientConfig.getAvailabilityZones(clientConfig.getRegion()), myInfo);</div><div class="line"> <span class="number">5</span>:     List&lt;String&gt; replicaUrls = EndpointUtils.getDiscoveryServiceUrls(clientConfig, zone, <span class="keyword">new</span> EndpointUtils.InstanceInfoBasedUrlRandomizer(myInfo));</div><div class="line"> <span class="number">6</span>: </div><div class="line"> <span class="number">7</span>:     <span class="comment">// 移除自己（避免向自己同步）</span></div><div class="line"> <span class="number">8</span>:     <span class="keyword">int</span> idx = <span class="number">0</span>;</div><div class="line"> <span class="number">9</span>:     <span class="keyword">while</span> (idx &lt; replicaUrls.size()) &#123;</div><div class="line"><span class="number">10</span>:         <span class="keyword">if</span> (isThisMyUrl(replicaUrls.get(idx))) &#123;</div><div class="line"><span class="number">11</span>:             replicaUrls.remove(idx);</div><div class="line"><span class="number">12</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">13</span>:             idx++;</div><div class="line"><span class="number">14</span>:         &#125;</div><div class="line"><span class="number">15</span>:     &#125;</div><div class="line"><span class="number">16</span>:     <span class="keyword">return</span> replicaUrls;</div><div class="line"><span class="number">17</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 2 至 5 行 ：获得 Eureka-Server 集群服务地址数组。<code>EndpointUtils#getDiscoveryServiceUrls(...)</code> 方法，逻辑与 <a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/?self">《Eureka 源码解析 —— EndPoint 与 解析器》「3.4 ConfigClusterResolver」</a> 基本类似。EndpointUtils 正在逐步，猜测未来这里会替换。</li><li>第 7 至 15 行 ：移除自身节点，避免向自己同步。</li></ul><hr><p>调用 <code>#updatePeerEurekaNodes()</code> 方法，更新集群节点信息，主要完成两部分逻辑：</p><ul><li>添加新增的集群节点</li><li>关闭删除的集群节点</li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">updatePeerEurekaNodes</span><span class="params">(List&lt;String&gt; newPeerUrls)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="keyword">if</span> (newPeerUrls.isEmpty()) &#123;</div><div class="line"> <span class="number">3</span>:         logger.warn(<span class="string">"The replica size seems to be empty. Check the route 53 DNS Registry"</span>);</div><div class="line"> <span class="number">4</span>:         <span class="keyword">return</span>;</div><div class="line"> <span class="number">5</span>:     &#125;</div><div class="line"> <span class="number">6</span>: </div><div class="line"> <span class="number">7</span>:     <span class="comment">// 计算 新增的集群节点地址</span></div><div class="line"> <span class="number">8</span>:     Set&lt;String&gt; toShutdown = <span class="keyword">new</span> HashSet&lt;&gt;(peerEurekaNodeUrls);</div><div class="line"> <span class="number">9</span>:     toShutdown.removeAll(newPeerUrls);</div><div class="line"><span class="number">10</span>: </div><div class="line"><span class="number">11</span>:     <span class="comment">// 计算 删除的集群节点地址</span></div><div class="line"><span class="number">12</span>:     Set&lt;String&gt; toAdd = <span class="keyword">new</span> HashSet&lt;&gt;(newPeerUrls);</div><div class="line"><span class="number">13</span>:     toAdd.removeAll(peerEurekaNodeUrls);</div><div class="line"><span class="number">14</span>: </div><div class="line"><span class="number">15</span>:     <span class="keyword">if</span> (toShutdown.isEmpty() &amp;&amp; toAdd.isEmpty()) &#123; <span class="comment">// No change</span></div><div class="line"><span class="number">16</span>:         <span class="keyword">return</span>;</div><div class="line"><span class="number">17</span>:     &#125;</div><div class="line"><span class="number">18</span>: </div><div class="line"><span class="number">19</span>:     <span class="comment">// 关闭删除的集群节点</span></div><div class="line"><span class="number">20</span>:     <span class="comment">// Remove peers no long available</span></div><div class="line"><span class="number">21</span>:     List&lt;PeerEurekaNode&gt; newNodeList = <span class="keyword">new</span> ArrayList&lt;&gt;(peerEurekaNodes);</div><div class="line"><span class="number">22</span>:     <span class="keyword">if</span> (!toShutdown.isEmpty()) &#123;</div><div class="line"><span class="number">23</span>:         logger.info(<span class="string">"Removing no longer available peer nodes &#123;&#125;"</span>, toShutdown);</div><div class="line"><span class="number">24</span>:         <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"><span class="number">25</span>:         <span class="keyword">while</span> (i &lt; newNodeList.size()) &#123;</div><div class="line"><span class="number">26</span>:             PeerEurekaNode eurekaNode = newNodeList.get(i);</div><div class="line"><span class="number">27</span>:             <span class="keyword">if</span> (toShutdown.contains(eurekaNode.getServiceUrl())) &#123;</div><div class="line"><span class="number">28</span>:                 newNodeList.remove(i);</div><div class="line"><span class="number">29</span>:                 eurekaNode.shutDown(); <span class="comment">// 关闭</span></div><div class="line"><span class="number">30</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">31</span>:                 i++;</div><div class="line"><span class="number">32</span>:             &#125;</div><div class="line"><span class="number">33</span>:         &#125;</div><div class="line"><span class="number">34</span>:     &#125;</div><div class="line"><span class="number">35</span>: </div><div class="line"><span class="number">36</span>:     <span class="comment">// 添加新增的集群节点</span></div><div class="line"><span class="number">37</span>:     <span class="comment">// Add new peers</span></div><div class="line"><span class="number">38</span>:     <span class="keyword">if</span> (!toAdd.isEmpty()) &#123;</div><div class="line"><span class="number">39</span>:         logger.info(<span class="string">"Adding new peer nodes &#123;&#125;"</span>, toAdd);</div><div class="line"><span class="number">40</span>:         <span class="keyword">for</span> (String peerUrl : toAdd) &#123;</div><div class="line"><span class="number">41</span>:             newNodeList.add(createPeerEurekaNode(peerUrl));</div><div class="line"><span class="number">42</span>:         &#125;</div><div class="line"><span class="number">43</span>:     &#125;</div><div class="line"><span class="number">44</span>: </div><div class="line"><span class="number">45</span>:     <span class="comment">// 赋值</span></div><div class="line"><span class="number">46</span>:     <span class="keyword">this</span>.peerEurekaNodes = newNodeList;</div><div class="line"><span class="number">47</span>:     <span class="keyword">this</span>.peerEurekaNodeUrls = <span class="keyword">new</span> HashSet&lt;&gt;(newPeerUrls);</div><div class="line"><span class="number">48</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 7 至 9 行 ：<strong>计算</strong>新增的集群节点地址。</li><li>第 11 至 13 行 ：<strong>计算</strong>删除的集群节点地址。</li><li>第 19 至 34 行 ：<strong>关闭</strong>删除的集群节点。</li><li><p>第 36 至 43 行 ：<strong>添加</strong>新增的集群节点。调用 <code>#createPeerEurekaNode(peerUrl)</code> 方法，创建集群节点，代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="number">1</span>: <span class="function"><span class="keyword">protected</span> PeerEurekaNode <span class="title">createPeerEurekaNode</span><span class="params">(String peerEurekaNodeUrl)</span> </span>&#123;</div><div class="line"><span class="number">2</span>:     HttpReplicationClient replicationClient = JerseyReplicationClient.createReplicationClient(serverConfig, serverCodecs, peerEurekaNodeUrl);</div><div class="line"><span class="number">3</span>:     String targetHost = hostFromUrl(peerEurekaNodeUrl);</div><div class="line"><span class="number">4</span>:     <span class="keyword">if</span> (targetHost == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">5</span>:         targetHost = <span class="string">"host"</span>;</div><div class="line"><span class="number">6</span>:     &#125;</div><div class="line"><span class="number">7</span>:     <span class="keyword">return</span> <span class="keyword">new</span> PeerEurekaNode(registry, targetHost, peerEurekaNodeUrl, replicationClient, serverConfig);</div><div class="line"><span class="number">8</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 2 行 ：创建 Eureka-Server 集群通信客户端，在 <a href="http://www.iocoder.cn/Eureka/transport/?self">《Eureka 源码解析 —— 网络通信》「4.2 JerseyReplicationClient」</a> 有详细解析。</li><li>第 7 行 ：创建 PeerEurekaNode ，在 <a href="#">「2.3 PeerEurekaNode」</a> 有详细解析。</li></ul></li></ul><h2 id="2-3-集群节点"><a href="#2-3-集群节点" class="headerlink" title="2.3 集群节点"></a>2.3 集群节点</h2><p><code>com.netflix.eureka.cluster.PeerEurekaNode</code> ，单个集群节点。</p><p>点击 <a href="https://github.com/YunaiV/eureka/blob/fcc9027a197783a23e7cb72ad0f617b7dc63d221/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java#L111" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看<strong>构造方法</strong></p><ul><li>第 129 行 ：创建 ReplicationTaskProcessor 。在 <a href="#">「4.1.2 同步操作任务处理器」</a> 详细解析</li><li>第 131 至 140 行 ：创建<strong>批量任务</strong>分发器，在 <a href="http://www.iocoder.cn/Eureka/batch-tasks/?self">《Eureka 源码解析 —— 任务批处理》</a> 有详细解析。</li><li>第 142 至 151 行 ：创建<strong>单任务</strong>分发器，用于 Eureka-Server 向亚马逊 AWS 的 ASG ( <code>Autoscaling Group</code> ) 同步状态。暂时跳过。</li></ul><h1 id="3-获取初始注册信息"><a href="#3-获取初始注册信息" class="headerlink" title="3. 获取初始注册信息"></a>3. 获取初始注册信息</h1><p>Eureka-Server 启动时，调用 <code>PeerAwareInstanceRegistryImpl#syncUp()</code> 方法，从集群的一个 Eureka-Server 节点获取<strong>初始</strong>注册信息，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">syncUp</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="comment">// Copy entire entry from neighboring DS node</span></div><div class="line"> <span class="number">4</span>:     <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"> <span class="number">5</span>: </div><div class="line"> <span class="number">6</span>:     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ((i &lt; serverConfig.getRegistrySyncRetries()) &amp;&amp; (count == <span class="number">0</span>)); i++) &#123;</div><div class="line"> <span class="number">7</span>:         <span class="comment">// 未读取到注册信息，sleep 等待</span></div><div class="line"> <span class="number">8</span>:         <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</div><div class="line"> <span class="number">9</span>:             <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">10</span>:                 Thread.sleep(serverConfig.getRegistrySyncRetryWaitMs());</div><div class="line"><span class="number">11</span>:             &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line"><span class="number">12</span>:                 logger.warn(<span class="string">"Interrupted during registry transfer.."</span>);</div><div class="line"><span class="number">13</span>:                 <span class="keyword">break</span>;</div><div class="line"><span class="number">14</span>:             &#125;</div><div class="line"><span class="number">15</span>:         &#125;</div><div class="line"><span class="number">16</span>: </div><div class="line"><span class="number">17</span>:         <span class="comment">// 获取注册信息</span></div><div class="line"><span class="number">18</span>:         Applications apps = eurekaClient.getApplications();</div><div class="line"><span class="number">19</span>:         <span class="keyword">for</span> (Application app : apps.getRegisteredApplications()) &#123;</div><div class="line"><span class="number">20</span>:             <span class="keyword">for</span> (InstanceInfo instance : app.getInstances()) &#123;</div><div class="line"><span class="number">21</span>:                 <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">22</span>:                     <span class="keyword">if</span> (isRegisterable(instance)) &#123; <span class="comment">// 判断是否能够注册</span></div><div class="line"><span class="number">23</span>:                         register(instance, instance.getLeaseInfo().getDurationInSecs(), <span class="keyword">true</span>); <span class="comment">// 注册</span></div><div class="line"><span class="number">24</span>:                         count++;</div><div class="line"><span class="number">25</span>:                     &#125;</div><div class="line"><span class="number">26</span>:                 &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line"><span class="number">27</span>:                     logger.error(<span class="string">"During DS init copy"</span>, t);</div><div class="line"><span class="number">28</span>:                 &#125;</div><div class="line"><span class="number">29</span>:             &#125;</div><div class="line"><span class="number">30</span>:         &#125;</div><div class="line"><span class="number">31</span>:     &#125;</div><div class="line"><span class="number">32</span>:     <span class="keyword">return</span> count;</div><div class="line"><span class="number">33</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 7 至 15 行 ：未获取到注册信息，<code>sleep</code> 等待再次重试。</li><li>第 17 至 30 行 ：获取注册信息，若获取到，注册到自身节点。<ul><li>第 22 行 ：判断应用实例是否能够注册到自身节点。主要用于亚马逊 AWS 环境下的判断，若非部署在亚马逊里，都返回 <code>true</code> 。点击 <a href="https://github.com/YunaiV/eureka/blob/94a4a1ebd35a3350893369a05757c01b2534b702/eureka-core/src/main/java/com/netflix/eureka/registry/PeerAwareInstanceRegistryImpl.java#L593" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看实现。</li><li>第 23 行 ：调用 <code>#register()</code> 方法，注册应用实例到自身节点。在 <a href="http://www.iocoder.cn/Eureka/instance-registry-register/">《Eureka 源码解析 —— 应用实例注册发现（一）之注册》</a> 有详细解析。</li></ul></li></ul><hr><p>若调用 <code>#syncUp()</code> 方法，未获取到应用实例，则 Eureka-Server 会有一段时间( 默认：5 分钟，可配 )不允许被 Eureka-Client 获取注册信息，避免影响 Eureka-Client 。</p><ul><li><p>标记 Eureka-Server 启动时，未获取到应用实例，代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// PeerAwareInstanceRegistryImpl.java</span></div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> peerInstancesTransferEmptyOnStartup = <span class="keyword">true</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openForTraffic</span><span class="params">(ApplicationInfoManager applicationInfoManager, <span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">    <span class="comment">// ... 省略其他代码</span></div><div class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.peerInstancesTransferEmptyOnStartup = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// ... 省略其他代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><ul><li><p>判断 Eureka-Server 是否允许被 Eureka-Client 获取注册信息，代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// PeerAwareInstanceRegistryImpl.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldAllowAccess</span><span class="params">(<span class="keyword">boolean</span> remoteRegionRequired)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.peerInstancesTransferEmptyOnStartup) &#123;</div><div class="line">       <span class="comment">// 设置启动时间</span></div><div class="line">       <span class="keyword">this</span>.startupTime = System.currentTimeMillis();</div><div class="line">       <span class="keyword">if</span> (!(System.currentTimeMillis() &gt; <span class="keyword">this</span>.startupTime + serverConfig.getWaitTimeInMsWhenSyncEmpty())) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// ... 省略其他代码</span></div><div class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h1 id="4-同步注册信息"><a href="#4-同步注册信息" class="headerlink" title="4. 同步注册信息"></a>4. 同步注册信息</h1><p>Eureka-Server 集群同步注册信息如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_08_07/02.png" alt=""></p><ul><li>Eureka-Server 接收到 Eureka-Client 的 Register、Heartbeat、Cancel、StatusUpdate、DeleteStatusOverride 操作，固定间隔( 默认值 ：500 毫秒，可配 )向 Eureka-Server 集群内其他节点同步( <strong>准实时，非实时</strong> )。</li></ul><h2 id="4-1-同步操作类型"><a href="#4-1-同步操作类型" class="headerlink" title="4.1 同步操作类型"></a>4.1 同步操作类型</h2><p><code>com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl.Action</code> ，同步操作类型，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Action &#123;</div><div class="line">   Heartbeat, Register, Cancel, StatusUpdate, DeleteStatusOverride;</div><div class="line"></div><div class="line">   <span class="comment">// ... 省略监控相关属性</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>Register ，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-register/?self">《Eureka 源码解析 —— 应用实例注册发现（一）之注册》</a> 有详细解析</li><li>Heartbeat ，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-renew/?self">《Eureka 源码解析 —— 应用实例注册发现（二）之续租》</a> 有详细解析</li><li>Cancel ，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-cancel/?self">《Eureka 源码解析 —— 应用实例注册发现（三）之下线》</a> 有详细解析</li><li>StatusUpdate ，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/?self">《Eureka 源码解析 —— 应用实例注册发现（八）之覆盖状态》</a> 有详细解析</li><li>DeleteStatusOverride ，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/?self">《Eureka 源码解析 —— 应用实例注册发现（八）之覆盖状态》</a> 有详细解析</li></ul><h2 id="4-2-发起-Eureka-Server-同步操作"><a href="#4-2-发起-Eureka-Server-同步操作" class="headerlink" title="4.2 发起 Eureka-Server 同步操作"></a>4.2 发起 Eureka-Server 同步操作</h2><p>Eureka-Server 在完成 Eureka-Client 发起的上述操作在<strong>自身节点的执行后</strong>，向集群内其他 Eureka-Server 发起同步操作。以 Register 操作举例子，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// PeerAwareInstanceRegistryImpl.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> InstanceInfo info, <span class="keyword">final</span> <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">   <span class="comment">// 租约过期时间</span></div><div class="line">   <span class="keyword">int</span> leaseDuration = Lease.DEFAULT_DURATION_IN_SECS;</div><div class="line">   <span class="keyword">if</span> (info.getLeaseInfo() != <span class="keyword">null</span> &amp;&amp; info.getLeaseInfo().getDurationInSecs() &gt; <span class="number">0</span>) &#123;</div><div class="line">       leaseDuration = info.getLeaseInfo().getDurationInSecs();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 注册应用实例信息</span></div><div class="line">   <span class="keyword">super</span>.register(info, leaseDuration, isReplication);</div><div class="line">   <span class="comment">// Eureka-Server 复制</span></div><div class="line">   replicateToPeers(Action.Register, info.getAppName(), info.getId(), info, <span class="keyword">null</span>, isReplication);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>最后一行，调用 <code>#replicateToPeers(...)</code> 方法，传递<strong>对应的同步操作类型</strong>，发起同步操作。</li></ul><hr><p><code>#replicateToPeers(...)</code> 方法，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replicateToPeers</span><span class="params">(Action action, String appName, String id,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">2</span>:                               InstanceInfo info <span class="comment">/* optional */</span>,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">3</span>:                               InstanceStatus newStatus <span class="comment">/* optional */</span>, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line"> <span class="number">4</span>:     Stopwatch tracer = action.getTimer().start();</div><div class="line"> <span class="number">5</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">6</span>:         <span class="keyword">if</span> (isReplication) &#123;</div><div class="line"> <span class="number">7</span>:             numberOfReplicationsLastMin.increment();</div><div class="line"> <span class="number">8</span>:         &#125;</div><div class="line"> <span class="number">9</span>: </div><div class="line"><span class="number">10</span>:         <span class="comment">// Eureka-Server 发起的请求 或者 集群为空</span></div><div class="line"><span class="number">11</span>:         <span class="comment">// If it is a replication already, do not replicate again as this will create a poison replication</span></div><div class="line"><span class="number">12</span>:         <span class="keyword">if</span> (peerEurekaNodes == Collections.EMPTY_LIST || isReplication) &#123;</div><div class="line"><span class="number">13</span>:             <span class="keyword">return</span>;</div><div class="line"><span class="number">14</span>:         &#125;</div><div class="line"><span class="number">15</span>: </div><div class="line"><span class="number">16</span>:         <span class="keyword">for</span> (<span class="keyword">final</span> PeerEurekaNode node : peerEurekaNodes.getPeerEurekaNodes()) &#123;</div><div class="line"><span class="number">17</span>:             <span class="comment">// If the url represents this host, do not replicate to yourself.</span></div><div class="line"><span class="number">18</span>:             <span class="keyword">if</span> (peerEurekaNodes.isThisMyUrl(node.getServiceUrl())) &#123;</div><div class="line"><span class="number">19</span>:                 <span class="keyword">continue</span>;</div><div class="line"><span class="number">20</span>:             &#125;</div><div class="line"><span class="number">21</span>:             replicateInstanceActionsToPeers(action, appName, id, info, newStatus, node);</div><div class="line"><span class="number">22</span>:         &#125;</div><div class="line"><span class="number">23</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">24</span>:         tracer.stop();</div><div class="line"><span class="number">25</span>:     &#125;</div><div class="line"><span class="number">26</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 10 至 14 行 ：Eureka-Server 在处理上述操作( Action )，无论来自 Eureka-Client 发起请求，还是 Eureka-Server 发起同步，调用的内部方法相同，通过 <code>isReplication=true</code> 参数，避免死循环同步。</li><li>第 16 至 22 行 ：<strong>循环</strong>集群内<strong>每个</strong>节点，调用 <code>#replicateInstanceActionsToPeers(...)</code> 方法，发起同步操作。</li></ul><hr><p><code>#replicateInstanceActionsToPeers(...)</code> 方法，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replicateInstanceActionsToPeers</span><span class="params">(Action action, String appName,</span></span></div><div class="line"><span class="function"><span class="params">                                            String id, InstanceInfo info, InstanceStatus newStatus,</span></span></div><div class="line"><span class="function"><span class="params">                                            PeerEurekaNode node)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       InstanceInfo infoFromRegistry;</div><div class="line">       CurrentRequestVersion.set(Version.V2);</div><div class="line">       <span class="keyword">switch</span> (action) &#123;</div><div class="line">           <span class="keyword">case</span> Cancel:</div><div class="line">               node.cancel(appName, id);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> Heartbeat:</div><div class="line">               InstanceStatus overriddenStatus = overriddenInstanceStatusMap.get(id);</div><div class="line">               infoFromRegistry = getInstanceByAppAndId(appName, id, <span class="keyword">false</span>);</div><div class="line">               node.heartbeat(appName, id, infoFromRegistry, overriddenStatus, <span class="keyword">false</span>);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> Register:</div><div class="line">               node.register(info);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> StatusUpdate:</div><div class="line">               infoFromRegistry = getInstanceByAppAndId(appName, id, <span class="keyword">false</span>);</div><div class="line">               node.statusUpdate(appName, id, newStatus, infoFromRegistry);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> DeleteStatusOverride:</div><div class="line">               infoFromRegistry = getInstanceByAppAndId(appName, id, <span class="keyword">false</span>);</div><div class="line">               node.deleteStatusOverride(appName, id, infoFromRegistry);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">       logger.error(<span class="string">"Cannot replicate information to &#123;&#125; for action &#123;&#125;"</span>, node.getServiceUrl(), action.name(), t);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>Cancel</strong> ：调用 <code>PeerEurekaNode#cancel(...)</code> 方法，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java#L157" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看实现。</li><li><strong>Heartbeat</strong> ：调用 <code>PeerEurekaNode#heartbeat(...)</code> 方法，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java#L194" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看实现。</li><li><strong>Register</strong> ：调用 <code>PeerEurekaNode#register(...)</code> 方法，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java#L134" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看实现。</li><li><strong>StatusUpdate</strong> ：调用 <code>PeerEurekaNode#statusUpdate(...)</code> 方法，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java#L243" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看实现。</li><li><strong>DeleteStatusOverride</strong> ：调用 <code>PeerEurekaNode#deleteStatusOverride(...)</code> 方法，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java#L294" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看实现。</li><li><p>上面的每个方法实现，我们<strong>都</strong>会看到类似这么一段代码 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line">batchingDispatcher.process(</div><div class="line">    taskId(<span class="string">"$&#123;action&#125;"</span>, appName, id), <span class="comment">// id</span></div><div class="line">    <span class="keyword">new</span> InstanceReplicationTask(targetHost, Action.Cancel, appName, id) &#123;</div><div class="line">        </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> replicationClient.doString(...);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleFailure</span><span class="params">(<span class="keyword">int</span> statusCode, Object responseEntity)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">            <span class="comment">// do Something...</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;, <span class="comment">// ReplicationTask 子类</span></div><div class="line">    expiryTime</div><div class="line">)</div></pre></td></tr></table></figure><ul><li><p><code>#task(...)</code> 方法，生成同步操作任务<strong>编号</strong>。代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">taskId</span><span class="params">(String requestType, String appName, String id)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> requestType + <span class="string">'#'</span> + appName + <span class="string">'/'</span> + id;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>相同应用实例的相同同步操作使用相同任务编号</strong>。在 <a href="http://www.iocoder.cn/Eureka/batch-tasks/?self">《Eureka 源码解析 —— 任务批处理》「2. 整体流程」</a> 中，我们看到” 接收线程( Runner )合并任务，将相同任务编号的任务合并，只执行一次。 “，因此，相同应用实例的相同同步操作就能被合并，减少操作量。例如，Eureka-Server 同步某个应用实例的 Heartbeat 操作，接收同步的 Eureak-Server 挂了，一方面这个应用的这次操作会<strong>重试</strong>，另一方面，这个应用实例会发起<strong>新的</strong> Heartbeat 操作，通过任务编号合并，接收同步的 Eureka-Server 恢复后，减少收到<strong>重复积压</strong>的任务。</li></ul><ul><li>InstanceReplicationTask ，同步操作任务，在 <a href="#">「4.1.1 同步操作任务」</a> 详细解析。</li><li><code>expiryTime</code> ，任务过期时间。</li></ul></li></ul></li></ul><h3 id="4-1-1-同步操作任务"><a href="#4-1-1-同步操作任务" class="headerlink" title="4.1.1 同步操作任务"></a>4.1.1 同步操作任务</h3><p><img src="http://www.iocoder.cn/images/Eureka/2018_08_07/03.png" alt=""></p><ul><li><code>com.netflix.eureka.cluster.ReplicationTask</code> ，同步任务<strong>抽象类</strong><ul><li>点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTask.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 ReplicationTask 代码。</li><li>定义了 <code>#getTaskName()</code> <strong>抽象</strong>方法。</li><li>定义了 <code>#execute()</code> <strong>抽象</strong>方法，执行同步任务。</li><li>实现了 <code>#handleSuccess()</code> 方法，处理成功执行同步结果。</li><li>实现了 <code>#handleFailure(...)</code> 方法，处理失败执行同步结果。</li></ul></li><li><code>com.netflix.eureka.cluster.InstanceReplicationTask</code> ，同步应用实例任务<strong>抽象类</strong><ul><li>点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/InstanceReplicationTask.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 InstanceReplicationTask 代码。</li><li>实现了父类 <code>#getTaskName()</code> <strong>抽象</strong>方法。</li></ul></li><li><code>com.netflix.eureka.cluster.AsgReplicationTask</code> ，亚马逊 AWS 使用，暂时跳过。</li></ul><p>从上面 <code>PeerEurekaNode#同步操作(...)</code> 方法，<strong>全部</strong>实现了 InstanceReplicationTask 类的 <code>#execute()</code> 方法，<strong>部分</strong>重写了 <code>#handleFailure(...)</code> 方法。</p><h3 id="4-1-2-同步操作任务处理器"><a href="#4-1-2-同步操作任务处理器" class="headerlink" title="4.1.2 同步操作任务处理器"></a>4.1.2 同步操作任务处理器</h3><p><code>com.netflix.eureka.cluster.InstanceReplicationTask</code> ，实现 TaskProcessor <strong>接口</strong>，同步操作任务处理器。</p><ul><li>TaskProcessor ，在 <a href="http://www.iocoder.cn/Eureka/batch-tasks/?self">《Eureka 源码解析 —— 任务批处理》「10. 任务执行器【执行任务】」</a> 有详细解析。</li><li>点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 InstanceReplicationTask 代码。</li></ul><p><code>ReplicationTaskProcessor#process(task)</code> ，<strong>处理单任务</strong>，用于 Eureka-Server 向亚马逊 AWS 的 ASG ( <code>Autoscaling Group</code> ) 同步状态，暂时跳过，感兴趣的同学可以点击 <a href="https://github.com/YunaiV/eureka/blob/94a4a1ebd35a3350893369a05757c01b2534b702/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java#L38" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看方法代码。</p><p><code>ReplicationTaskProcessor#process(tasks)</code> ，<strong>处理批量任务</strong>，用于 Eureka-Server 集群注册信息的同步操作任务，通过调用被同步的 Eureka-Server 的 <code>peerreplication/batch/</code> 接口，一次性将批量( 多个 )的同步操作任务发起请求，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> ProcessingResult <span class="title">process</span><span class="params">(List&lt;ReplicationTask&gt; tasks)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="comment">// 创建 批量提交同步操作任务的请求对象</span></div><div class="line"> <span class="number">4</span>:     ReplicationList list = createReplicationListOf(tasks);</div><div class="line"> <span class="number">5</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">6</span>:         <span class="comment">// 发起 批量提交同步操作任务的请求</span></div><div class="line"> <span class="number">7</span>:         EurekaHttpResponse&lt;ReplicationListResponse&gt; response = replicationClient.submitBatchUpdates(list);</div><div class="line"> <span class="number">8</span>:         <span class="comment">// 处理 批量提交同步操作任务的响应</span></div><div class="line"> <span class="number">9</span>:         <span class="keyword">int</span> statusCode = response.getStatusCode();</div><div class="line"><span class="number">10</span>:         <span class="keyword">if</span> (!isSuccess(statusCode)) &#123;</div><div class="line"><span class="number">11</span>:             <span class="keyword">if</span> (statusCode == <span class="number">503</span>) &#123;</div><div class="line"><span class="number">12</span>:                 logger.warn(<span class="string">"Server busy (503) HTTP status code received from the peer &#123;&#125;; rescheduling tasks after delay"</span>, peerId);</div><div class="line"><span class="number">13</span>:                 <span class="keyword">return</span> ProcessingResult.Congestion;</div><div class="line"><span class="number">14</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">15</span>:                 <span class="comment">// Unexpected error returned from the server. This should ideally never happen.</span></div><div class="line"><span class="number">16</span>:                 logger.error(<span class="string">"Batch update failure with HTTP status code &#123;&#125;; discarding &#123;&#125; replication tasks"</span>, statusCode, tasks.size());</div><div class="line"><span class="number">17</span>:                 <span class="keyword">return</span> ProcessingResult.PermanentError;</div><div class="line"><span class="number">18</span>:             &#125;</div><div class="line"><span class="number">19</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">20</span>:             handleBatchResponse(tasks, response.getEntity().getResponseList());</div><div class="line"><span class="number">21</span>:         &#125;</div><div class="line"><span class="number">22</span>:     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"><span class="number">23</span>:         <span class="keyword">if</span> (isNetworkConnectException(e)) &#123;</div><div class="line"><span class="number">24</span>:             logNetworkErrorSample(<span class="keyword">null</span>, e);</div><div class="line"><span class="number">25</span>:             <span class="keyword">return</span> ProcessingResult.TransientError;</div><div class="line"><span class="number">26</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">27</span>:             logger.error(<span class="string">"Not re-trying this exception because it does not seem to be a network exception"</span>, e);</div><div class="line"><span class="number">28</span>:             <span class="keyword">return</span> ProcessingResult.PermanentError;</div><div class="line"><span class="number">29</span>:         &#125;</div><div class="line"><span class="number">30</span>:     &#125;</div><div class="line"><span class="number">31</span>:     <span class="keyword">return</span> ProcessingResult.Success;</div><div class="line"><span class="number">32</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 4 行 ：创建批量提交同步操作任务的请求对象( ReplicationList ) 。比较易懂，咱就不啰嗦贴代码了。<ul><li>ReplicationList ，点击 <a href="https://github.com/YunaiV/eureka/blob/94a4a1ebd35a3350893369a05757c01b2534b702/eureka-core/src/main/java/com/netflix/eureka/cluster/protocol/ReplicationList.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看类。</li><li>ReplicationInstance ，点击 <a href="https://github.com/YunaiV/eureka/blob/94a4a1ebd35a3350893369a05757c01b2534b702/eureka-core/src/main/java/com/netflix/eureka/cluster/protocol/ReplicationInstance.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看类。</li><li><code>#createReplicationListOf(...)</code> ，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java#L142" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看方法。</li><li><code>#createReplicationInstanceOf(...)</code> ，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java#L173" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看方法。</li></ul></li><li>第 7 行 ：调用 <code>JerseyReplicationClient#submitBatchUpdates(...)</code> 方法，请求 <code>peerreplication/batch/</code> 接口，一次性将批量( 多个 )的同步操作任务发起请求。<ul><li><code>JerseyReplicationClient#submitBatchUpdates(...)</code> 方法，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/transport/JerseyReplicationClient.java#L109" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看方法。 </li><li>ReplicationListResponse ，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/protocol/ReplicationListResponse.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看类。</li><li>ReplicationInstanceResponse ，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/protocol/ReplicationInstanceResponse.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看类。</li></ul></li><li>第 9 至 31 行 ：处理批量提交同步操作任务的响应，在 <a href="#">「4.4 处理 Eureka-Server 同步结果」</a> 详细解析。</li></ul><h2 id="4-3-接收-Eureka-Server-同步操作"><a href="#4-3-接收-Eureka-Server-同步操作" class="headerlink" title="4.3 接收 Eureka-Server 同步操作"></a>4.3 接收 Eureka-Server 同步操作</h2><p><code>com.netflix.eureka.resources.PeerReplicationResource</code> ，同步操作任务 Resource ( Controller )。</p><p><code>peerreplication/batch/</code> 接口，映射 <code>PeerReplicationResource#batchReplication(...)</code> 方法，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Path</span>(<span class="string">"batch"</span>)</div><div class="line"> <span class="number">2</span>: <span class="meta">@POST</span></div><div class="line"> <span class="number">3</span>: <span class="function"><span class="keyword">public</span> Response <span class="title">batchReplication</span><span class="params">(ReplicationList replicationList)</span> </span>&#123;</div><div class="line"> <span class="number">4</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">5</span>:         ReplicationListResponse batchResponse = <span class="keyword">new</span> ReplicationListResponse();</div><div class="line"> <span class="number">6</span>:         <span class="comment">// 逐个同步操作任务处理，并将处理结果( ReplicationInstanceResponse ) 合并到 ReplicationListResponse 。</span></div><div class="line"> <span class="number">7</span>:         <span class="keyword">for</span> (ReplicationInstance instanceInfo : replicationList.getReplicationList()) &#123;</div><div class="line"> <span class="number">8</span>:             <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">9</span>:                 batchResponse.addResponse(dispatch(instanceInfo));</div><div class="line"><span class="number">10</span>:             &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"><span class="number">11</span>:                 batchResponse.addResponse(<span class="keyword">new</span> ReplicationInstanceResponse(Status.INTERNAL_SERVER_ERROR.getStatusCode(), <span class="keyword">null</span>));</div><div class="line"><span class="number">12</span>:                 logger.error(instanceInfo.getAction() + <span class="string">" request processing failed for batch item "</span></div><div class="line"><span class="number">13</span>:                         + instanceInfo.getAppName() + <span class="string">'/'</span> + instanceInfo.getId(), e);</div><div class="line"><span class="number">14</span>:             &#125;</div><div class="line"><span class="number">15</span>:         &#125;</div><div class="line"><span class="number">16</span>:         <span class="keyword">return</span> Response.ok(batchResponse).build();</div><div class="line"><span class="number">17</span>:     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"><span class="number">18</span>:         logger.error(<span class="string">"Cannot execute batch Request"</span>, e);</div><div class="line"><span class="number">19</span>:         <span class="keyword">return</span> Response.status(Status.INTERNAL_SERVER_ERROR).build();</div><div class="line"><span class="number">20</span>:     &#125;</div><div class="line"><span class="number">21</span>: &#125;</div><div class="line"><span class="number">22</span>: </div><div class="line"><span class="number">23</span>: <span class="function"><span class="keyword">private</span> ReplicationInstanceResponse <span class="title">dispatch</span><span class="params">(ReplicationInstance instanceInfo)</span> </span>&#123;</div><div class="line"><span class="number">24</span>:     ApplicationResource applicationResource = createApplicationResource(instanceInfo);</div><div class="line"><span class="number">25</span>:     InstanceResource resource = createInstanceResource(instanceInfo, applicationResource);</div><div class="line"><span class="number">26</span>: </div><div class="line"><span class="number">27</span>:     String lastDirtyTimestamp = toString(instanceInfo.getLastDirtyTimestamp());</div><div class="line"><span class="number">28</span>:     String overriddenStatus = toString(instanceInfo.getOverriddenStatus());</div><div class="line"><span class="number">29</span>:     String instanceStatus = toString(instanceInfo.getStatus());</div><div class="line"><span class="number">30</span>: </div><div class="line"><span class="number">31</span>:     Builder singleResponseBuilder = <span class="keyword">new</span> Builder();</div><div class="line"><span class="number">32</span>:     <span class="keyword">switch</span> (instanceInfo.getAction()) &#123;</div><div class="line"><span class="number">33</span>:         <span class="keyword">case</span> Register:</div><div class="line"><span class="number">34</span>:             singleResponseBuilder = handleRegister(instanceInfo, applicationResource);</div><div class="line"><span class="number">35</span>:             <span class="keyword">break</span>;</div><div class="line"><span class="number">36</span>:         <span class="keyword">case</span> Heartbeat:</div><div class="line"><span class="number">37</span>:             singleResponseBuilder = handleHeartbeat(serverConfig, resource, lastDirtyTimestamp, overriddenStatus, instanceStatus);</div><div class="line"><span class="number">38</span>:             <span class="keyword">break</span>;</div><div class="line"><span class="number">39</span>:         <span class="keyword">case</span> Cancel:</div><div class="line"><span class="number">40</span>:             singleResponseBuilder = handleCancel(resource);</div><div class="line"><span class="number">41</span>:             <span class="keyword">break</span>;</div><div class="line"><span class="number">42</span>:         <span class="keyword">case</span> StatusUpdate:</div><div class="line"><span class="number">43</span>:             singleResponseBuilder = handleStatusUpdate(instanceInfo, resource);</div><div class="line"><span class="number">44</span>:             <span class="keyword">break</span>;</div><div class="line"><span class="number">45</span>:         <span class="keyword">case</span> DeleteStatusOverride:</div><div class="line"><span class="number">46</span>:             singleResponseBuilder = handleDeleteStatusOverride(instanceInfo, resource);</div><div class="line"><span class="number">47</span>:             <span class="keyword">break</span>;</div><div class="line"><span class="number">48</span>:     &#125;</div><div class="line"><span class="number">49</span>:     <span class="keyword">return</span> singleResponseBuilder.build();</div><div class="line"><span class="number">50</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 7 至 15 行 ：逐个处理<strong>单个</strong>同步操作任务，并将处理结果( ReplicationInstanceResponse ) 添加到 ReplicationListResponse 。</li><li>第 23 至 50 行 ：处理<strong>单个</strong>同步操作任务，返回处理结果( ReplicationInstanceResponse )。<ul><li>第 24 至 25 行 ：创建 ApplicationResource , InstanceResource 。我们看到，实际该方法是把<strong>单个</strong>同步操作任务提交到其他 Resource ( Controller ) 处理，Eureka-Server 收到 Eureka-Client 请求响应的 Resource ( Controller ) 是<strong>相同的逻辑</strong>。</li><li>Register ：点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java#L137" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 <code>#handleRegister(...)</code> 方法。</li><li>Heartbeat ：点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java#L147" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 <code>#handleHeartbeat(...)</code> 方法。</li><li>Cancel ：点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java#L142" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 <code>#handleCancel(...)</code> 方法。</li><li>StatusUpdate ：点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java#L165" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 <code>#handleStatusUpdate(...)</code> 方法。</li><li>DeleteStatusOverride ：点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java#L170" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看 <code>#handleDeleteStatusOverride(...)</code> 方法。</li></ul></li></ul><h2 id="4-4-处理-Eureka-Server-同步结果"><a href="#4-4-处理-Eureka-Server-同步结果" class="headerlink" title="4.4 处理 Eureka-Server 同步结果"></a>4.4 处理 Eureka-Server 同步结果</h2><p>😈 想想就有小激动，终于写到这里了。</p><p>接 <code>ReplicationTaskProcessor#process(tasks)</code> 方法，处理批量提交同步操作任务的响应，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> ProcessingResult <span class="title">process</span><span class="params">(List&lt;ReplicationTask&gt; tasks)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="comment">// 创建 批量提交同步操作任务的请求对象</span></div><div class="line"> <span class="number">4</span>:     ReplicationList list = createReplicationListOf(tasks);</div><div class="line"> <span class="number">5</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">6</span>:         <span class="comment">// 发起 批量提交同步操作任务的请求</span></div><div class="line"> <span class="number">7</span>:         EurekaHttpResponse&lt;ReplicationListResponse&gt; response = replicationClient.submitBatchUpdates(list);</div><div class="line"> <span class="number">8</span>:         <span class="comment">// 处理 批量提交同步操作任务的响应</span></div><div class="line"> <span class="number">9</span>:         <span class="keyword">int</span> statusCode = response.getStatusCode();</div><div class="line"><span class="number">10</span>:         <span class="keyword">if</span> (!isSuccess(statusCode)) &#123;</div><div class="line"><span class="number">11</span>:             <span class="keyword">if</span> (statusCode == <span class="number">503</span>) &#123;</div><div class="line"><span class="number">12</span>:                 logger.warn(<span class="string">"Server busy (503) HTTP status code received from the peer &#123;&#125;; rescheduling tasks after delay"</span>, peerId);</div><div class="line"><span class="number">13</span>:                 <span class="keyword">return</span> ProcessingResult.Congestion;</div><div class="line"><span class="number">14</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">15</span>:                 <span class="comment">// Unexpected error returned from the server. This should ideally never happen.</span></div><div class="line"><span class="number">16</span>:                 logger.error(<span class="string">"Batch update failure with HTTP status code &#123;&#125;; discarding &#123;&#125; replication tasks"</span>, statusCode, tasks.size());</div><div class="line"><span class="number">17</span>:                 <span class="keyword">return</span> ProcessingResult.PermanentError;</div><div class="line"><span class="number">18</span>:             &#125;</div><div class="line"><span class="number">19</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">20</span>:             handleBatchResponse(tasks, response.getEntity().getResponseList());</div><div class="line"><span class="number">21</span>:         &#125;</div><div class="line"><span class="number">22</span>:     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"><span class="number">23</span>:         <span class="keyword">if</span> (isNetworkConnectException(e)) &#123;</div><div class="line"><span class="number">24</span>:             logNetworkErrorSample(<span class="keyword">null</span>, e);</div><div class="line"><span class="number">25</span>:             <span class="keyword">return</span> ProcessingResult.TransientError;</div><div class="line"><span class="number">26</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">27</span>:             logger.error(<span class="string">"Not re-trying this exception because it does not seem to be a network exception"</span>, e);</div><div class="line"><span class="number">28</span>:             <span class="keyword">return</span> ProcessingResult.PermanentError;</div><div class="line"><span class="number">29</span>:         &#125;</div><div class="line"><span class="number">30</span>:     &#125;</div><div class="line"><span class="number">31</span>:     <span class="keyword">return</span> ProcessingResult.Success;</div><div class="line"><span class="number">32</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 10 行 ，调用 <code>#isSuccess(...)</code> 方法，判断请求是否成功，响应状态码是否在  [200, 300) 范围内。</li><li>第 11 至 13 行 ：状态码 503 ，目前 Eureka-Server 返回 503 的原因是被限流。在 <a href="http://www.iocoder.cn/Eureka/rate-limiter/?self">《Eureka 源码解析 —— 基于令牌桶算法的 RateLimiter》</a> 详细解析。<strong>该情况为瞬时错误，会重试该同步操作任务</strong>，在 <a href="http://www.iocoder.cn/Eureka/batch-tasks/?self">《Eureka 源码解析 —— 任务批处理》「3. 任务处理器」</a> 有详细解析。</li><li>第 14 至 18 行 ：非<strong>预期</strong>状态码，目前 Eureka-Server 在代码上看下来，不会返回这样的状态码。<strong>该情况为永久错误，会重试该同步操作任务</strong>，在 <a href="http://www.iocoder.cn/Eureka/batch-tasks/?self">《Eureka 源码解析 —— 任务批处理》「3. 任务处理器」</a> 有详细解析。</li><li>第 20 行 ：请求成功，调用 <code>#handleBatchResponse(...)</code> 方法，逐个处理<strong>每个</strong> ReplicationTask 和 ReplicationInstanceResponse 。<strong>这里有一点要注意下，请求成功指的是整个请求成功，实际每个 ReplicationInstanceResponse 可能返回的状态码不在 [200, 300) 范围内</strong>。该方法下文详细解析。</li><li><p>第 23 至 25 行 ：请求发生网络异常，例如网络超时，打印网络异常日志。目前日志的打印为部分采样，条件为网络发生异常每间隔 10 秒打印一条，避免网络发生异常打印超级大量的日志。<strong>该情况为永久错误，会重试该同步操作任务</strong>，在 <a href="http://www.iocoder.cn/Eureka/batch-tasks/?self">《Eureka 源码解析 —— 任务批处理》「3. 任务处理器」</a> 有详细解析。</p><ul><li><code>#isNetworkConnectException(...)</code> ，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java#L163" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看方法。</li><li><code>#logNetworkErrorSample(...)</code> ，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java#L103" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看方法。</li></ul></li><li><p>第 26 至 29 行 ：非<strong>预期</strong>异常，目前 Eureka-Server 在代码上看下来，不会抛出这样的异常。<strong>该情况为永久错误，会重试该同步操作任务</strong>，在 <a href="http://www.iocoder.cn/Eureka/batch-tasks/?self">《Eureka 源码解析 —— 任务批处理》「3. 任务处理器」</a> 有详细解析。</p></li></ul><hr><p><code>#handleBatchResponse(...)</code> 方法，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBatchResponse</span><span class="params">(List&lt;ReplicationTask&gt; tasks, List&lt;ReplicationInstanceResponse&gt; responseList)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (tasks.size() != responseList.size()) &#123;</div><div class="line">       <span class="comment">// This should ideally never happen unless there is a bug in the software.</span></div><div class="line">       logger.error(<span class="string">"Batch response size different from submitted task list (&#123;&#125; != &#123;&#125;); skipping response analysis"</span>, responseList.size(), tasks.size());</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tasks.size(); i++) &#123;</div><div class="line">       handleBatchResponse(tasks.get(i), responseList.get(i));</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBatchResponse</span><span class="params">(ReplicationTask task, ReplicationInstanceResponse response)</span> </span>&#123;</div><div class="line">   <span class="comment">// 执行成功</span></div><div class="line">   <span class="keyword">int</span> statusCode = response.getStatusCode();</div><div class="line">   <span class="keyword">if</span> (isSuccess(statusCode)) &#123;</div><div class="line">       task.handleSuccess();</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// 执行失败</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       task.handleFailure(response.getStatusCode(), response.getResponseEntity());</div><div class="line">   &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">       logger.error(<span class="string">"Replication task "</span> + task.getTaskName() + <span class="string">" error handler failure"</span>, e);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p><code>ReplicationTask#handleSuccess()</code> 方法，无任务同步操作任务重写，是个<strong>空方法</strong>，代码如下：</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// ReplicationTask.java</div><div class="line">public void handleSuccess() &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p><code>ReplicationTask#handleFailure()</code> 方法，有<strong>两个</strong>同步操作任务重写：</p><ul><li><p>Cancel ：当 Eureka-Server 不存在下线的应用实例时，返回 404 状态码，此时打印错误日志，代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// PeerEurekaNode#cancel(...)</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleFailure</span><span class="params">(<span class="keyword">int</span> statusCode, Object responseEntity)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">    <span class="keyword">super</span>.handleFailure(statusCode, responseEntity);</div><div class="line">    <span class="keyword">if</span> (statusCode == <span class="number">404</span>) &#123;</div><div class="line">        logger.warn(<span class="string">"&#123;&#125;: missing entry."</span>, getTaskName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul></li><li><p>Heartbeat ：情况较为复杂，我们换一行继续说，避免排版有问题，影响阅读。</p></li></ul></li></ul><p>噔噔噔恰，本文的重要头戏来啦！Last But Very Importment ！！！</p><p>Eureka-Server 是允许<strong>同一时刻</strong>允许在任意节点被 Eureka-Client 发起<strong>写入</strong>相关的操作，网络是不可靠的资源，Eureka-Client 可能向一个 Eureka-Server 注册成功，但是网络波动，导致 Eureka-Client 误以为失败，此时恰好 Eureka-Client 变更了应用实例的状态，重试向另一个 Eureka-Server 注册，那么两个 Eureka-Server 对该应用实例的状态产生冲突。</p><p>再例如…… 我们不要继续举例子，网络波动真的很复杂。我们来看看 Eureka 是怎么处理的。</p><p>应用实例( InstanceInfo ) 的 <code>lastDirtyTimestamp</code> 属性，使用<strong>时间戳</strong>，表示应用实例的<strong>版本号</strong>，当请求方( 不仅仅是 Eureka-Client ，也可能是同步注册操作的 Eureka-Server ) 向 Eureka-Server 发起注册时，若 Eureka-Server 已存在拥有更大 <code>lastDirtyTimestamp</code> 该实例( <strong>相同应用并且相同应用实例编号被认为是相同实例</strong> )，则请求方注册的应用实例( InstanceInfo ) 无法覆盖注册此 Eureka-Server 的该实例( 见 <code>AbstractInstanceRegistry#register(...)</code> 方法 )。例如我们上面举的例子，第一个 Eureka-Server 向 第二个 Eureka-Server 同步注册应用实例时，不会注册覆盖，反倒是第二个 Eureka-Server 同步注册应用到第一个 Eureka-Server ，注册覆盖成功，因为 <code>lastDirtyTimestamp</code> ( 应用实例状态变更时，可以设置 <code>lastDirtyTimestamp</code> 为当前时间，见 <code>ApplicationInfoManager#setInstanceStatus(status)</code> 方法 )。</p><p>但是光靠<strong>注册</strong>请求判断 <code>lastDirtyTimestamp</code> 显然是不够的，因为网络异常情况下时，同步操作任务多次执行失败到达过期时间后，此时在 Eureka-Server 集群同步起到最终一致性<strong>最最最</strong>关键性出现了：Heartbeat 。因为 Heartbeat 会周期性的执行，通过它一方面可以判断 Eureka-Server 是否存在心跳对应的应用实例，另外一方面可以比较应用实例的 <code>lastDirtyTimestamp</code> 。当满足下面任意条件，Eureka-Server 返回 404 状态码：</p><ul><li>1）Eureka-Server 应用实例不存在，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/registry/AbstractInstanceRegistry.java#L438" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看触发条件代码位置。</li><li>2）Eureka-Server 应用实例状态为 <code>UNKNOWN</code>，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/registry/AbstractInstanceRegistry.java#L450" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看触发条件代码位置。为什么会是 <code>UNKNOWN</code> ，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/?self">《Eureka 源码解析 —— 应用实例注册发现（八）之覆盖状态》「 4.3 续租场景」</a> 有详细解析。</li><li><strong>3）</strong>请求的 <code>lastDirtyTimestamp</code> 更大，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java#L306" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看触发条件代码位置。</li></ul><p>请求方接收到 404 状态码返回后，<strong>认为 Eureka-Server 应用实例实际是不存在的</strong>，重新发起应用实例的注册。以本文的 Heartbeat 为例子，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// PeerEurekaNode#heartbeat(...)</span></div><div class="line">  <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line">  <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleFailure</span><span class="params">(<span class="keyword">int</span> statusCode, Object responseEntity)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">  <span class="number">3</span>:     <span class="keyword">super</span>.handleFailure(statusCode, responseEntity);</div><div class="line">  <span class="number">4</span>:     <span class="keyword">if</span> (statusCode == <span class="number">404</span>) &#123;</div><div class="line">  <span class="number">5</span>:         logger.warn(<span class="string">"&#123;&#125;: missing entry."</span>, getTaskName());</div><div class="line">  <span class="number">6</span>:         <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</div><div class="line">  <span class="number">7</span>:             logger.warn(<span class="string">"&#123;&#125;: cannot find instance id &#123;&#125; and hence replicating the instance with status &#123;&#125;"</span>,</div><div class="line">  <span class="number">8</span>:                     getTaskName(), info.getId(), info.getStatus());</div><div class="line">  <span class="number">9</span>:             register(info);</div><div class="line"> <span class="number">10</span>:         &#125;</div><div class="line"> <span class="number">11</span>:     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config.shouldSyncWhenTimestampDiffers()) &#123;</div><div class="line"> <span class="number">12</span>:         InstanceInfo peerInstanceInfo = (InstanceInfo) responseEntity;</div><div class="line"> <span class="number">13</span>:         <span class="keyword">if</span> (peerInstanceInfo != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">14</span>:             syncInstancesIfTimestampDiffers(appName, id, info, peerInstanceInfo);</div><div class="line"> <span class="number">15</span>:         &#125;</div><div class="line"> <span class="number">16</span>:     &#125;</div><div class="line"> <span class="number">17</span>: &#125;</div></pre></td></tr></table></figure><ul><li><p>第 4 至 10 行 ：接收到 404 状态码，调用 <code>#register(...)</code> 方法，向该被心跳同步操作失败的 Eureka-Server 发起注册<strong>本地的应用实例</strong>的请求。</p><ul><li>上述 <strong>3）</strong> ，会使用请求参数 <code>overriddenStatus</code> 存储到 Eureka-Server 的应用实例覆盖状态集合( <code>AbstractInstanceRegistry.overriddenInstanceStatusMap</code> )，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java#L123" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看触发条件代码位置。</li></ul></li><li><p>第 11 至 16 行 ：恰好是 <strong>3）</strong> 反过来的情况，本地的应用实例的 <code>lastDirtyTimestamp</code> 小于 Eureka-Server 该应用实例的，此时 Eureka-Server 返回 409 状态码，点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java#L314" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看触发条件代码位置。调用 <code>#syncInstancesIfTimestampDiffers()</code> 方法，覆盖注册本地应用实例，点击 <a href="https://github.com/YunaiV/eureka/blob/7f868f9ca715a8862c0c10cac04e238bbf371db0/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java#L387" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看方法。</p></li></ul><p>OK，撒花！记住：Eureka 通过 Heartbeat 实现 Eureka-Server 集群同步的最终一致性。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>写的比较嗨皮，所以就送胖友一只胖友</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_08_07/04.png" alt=""></p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p><p>以下是草稿，可以凑合看</p><p>eureka server 集群假定是 s1 s2  </p><p>1）client 向 s1 注册，有一个 lastDirtyTime ，正常情况下成功， s1 会向 s2 同步<br>2）client 向 s1 注册（成功，但是网络波动），然后 client 发生状态的变化，lastDirtyTime 变化，向 s2 注册。<br>这个时候，s1 s2 是冲突的，但是他们会互相同步，实际 s2 =&gt; s1 的注册会真正成功，s1 =&gt; s2 的注册不会返回失败，但是实际 s2 处理的时候，用的是自身的。  </p><p>心跳只是最终去校验。  </p><p>理论来说，心跳不应该带 lastDirtyTime 参数。带的原因就是为了做固定周期的比较。  </p><p>最优解是 注册 就处理掉数据不一致<br>次优解是 心跳 处理掉数据不一致  </p><p>如果在类比，  </p><p>注册，相当于 insertOrUpdate<br>心跳，附加了校验是否要发起【注册】  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/server-cluster/&quot;&gt;http://www.iocoder.cn/Eureka/server-cluster/&lt;/a&gt; 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;

      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 网络通信</title>
    <link href="http://www.iocoder.cn/Eureka/transport/"/>
    <id>http://www.iocoder.cn/Eureka/transport/</id>
    <published>2018-07-30T16:00:00.000Z</published>
    <updated>2017-10-18T15:23:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/transport/">http://www.iocoder.cn/Eureka/transport/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Eureka/transport/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/transport/">2. EurekaHttpClient</a><ul><li><a href="http://www.iocoder.cn/Eureka/transport/">2.1 EurekaJerseyClientImpl</a></li><li><a href="http://www.iocoder.cn/Eureka/transport/">2.2 EurekaJerseyClientBuilder</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/transport/">3. EurekaHttpClient</a><ul><li><a href="http://www.iocoder.cn/Eureka/transport/">3.1 EurekaHttpResponse</a></li><li><a href="http://www.iocoder.cn/Eureka/transport/">3.2 TransportClientFactory</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/transport/">4. AbstractJerseyEurekaHttpClient</a><ul><li><a href="http://www.iocoder.cn/Eureka/transport/">4.1 JerseyApplicationClient</a></li><li><a href="http://www.iocoder.cn/Eureka/transport/">4.2 JerseyReplicationClient</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/transport/">5. EurekaHttpClientDecorator</a><ul><li><a href="http://www.iocoder.cn/Eureka/transport/">5.1 MetricsCollectingEurekaHttpClient</a></li><li><a href="http://www.iocoder.cn/Eureka/transport/">5.2 RedirectingEurekaHttpClient</a></li><li><a href="http://www.iocoder.cn/Eureka/transport/">5.3 RetryableEurekaHttpClient</a></li><li><a href="http://www.iocoder.cn/Eureka/transport/">5.4 SessionedEurekaHttpClient</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/transport/">6. 创建网络通讯客户端</a></li><li><a href="http://www.iocoder.cn/Eureka/transport/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Eureka 的网络通信部分</strong>。在不考虑 Eureka 2.x 的兼容的情况下，Eureka 1.x 主要两部分的网络通信：</p><ul><li>Eureka-Client 请求 Eureka-Server 的网络通信</li><li>Eureka-Server 集群内，Eureka-Server 请求 <strong>其它的Eureka-Server</strong> 的网络通信</li></ul><p>本文涉及类在 <code>com.netflix.discovery.shared.transport</code> 包下，涉及到主体类的类图如下( <a href="http://www.iocoder.cn/images/Eureka/2018_07_31/01.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_07_31/01.png" alt=""></p><ul><li>粉色部分 —— EurekaJerseyClient ，对基于 Jersey Server 的 Eureka-Server 的 Jersey 客户端封装。</li><li>绿色部分 —— EurekaHttpClient ，Eureka-Server HTTP 访问客户端，定义了具体的 Eureka-Server API 调用方法。如果把 DiscoveryClient 类比成 Service ，那么 EurekaHttpClient 可以类比城 Dao 。</li><li>综色部分 —— EurekaHttpClient 实现类，<strong>真正</strong>实现了具体的 Eureka-Server API 调用方法。</li><li>红色部分 —— EurekaHttpClient 委托类，提供了<strong>会话、重试、重定向、监控指标收集</strong>等特性。</li><li>黄色部分 —— EurekaHttpClientFactory，用于创建 EurekaHttpClient 。</li></ul><p>类图看起来很复杂，整体调用关系如下( <a href="http://www.iocoder.cn/images/Eureka/2018_07_31/02.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_07_31/02.png" alt=""></p><p>OK ，我们逐层解析，嗨起来。</p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-EurekaHttpClient"><a href="#2-EurekaHttpClient" class="headerlink" title="2. EurekaHttpClient"></a>2. EurekaHttpClient</h1><p><code>com.netflix.discovery.shared.transport.jersey.EurekaJerseyClient</code> ，EurekaHttpClient <strong>接口</strong>。接口代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EurekaJerseyClient</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function">ApacheHttpClient4 <span class="title">getClient</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroyResources</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>com.sun.jersey.client.apache4.ApacheHttpClient4</code> ，基于 Apache HttpClient4 实现的 Jersey Client 。</li></ul><h2 id="2-1-EurekaJerseyClientImpl"><a href="#2-1-EurekaJerseyClientImpl" class="headerlink" title="2.1 EurekaJerseyClientImpl"></a>2.1 EurekaJerseyClientImpl</h2><p><code>com.netflix.discovery.shared.transport.jersey.EurekaJerseyClientImpl</code> ，EurekaHttpClient <strong>实现类</strong>。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaJerseyClientImpl</span> <span class="keyword">implements</span> <span class="title">EurekaJerseyClient</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 基于 Apache HttpClient4 实现的 Jersey Client</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApacheHttpClient4 apacheHttpClient;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Apache HttpClient 空闲连接清理器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApacheHttpClientConnectionCleaner apacheHttpClientConnectionCleaner;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Jersey Client 配置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    ClientConfig jerseyClientConfig;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EurekaJerseyClientImpl</span><span class="params">(<span class="keyword">int</span> connectionTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">final</span> <span class="keyword">int</span> connectionIdleTimeout,</span></span></div><div class="line"><span class="function"><span class="params">                                  ClientConfig clientConfig)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            jerseyClientConfig = clientConfig;</div><div class="line">            <span class="comment">// 创建  ApacheHttpClient</span></div><div class="line">            apacheHttpClient = ApacheHttpClient4.create(jerseyClientConfig);</div><div class="line"></div><div class="line">            <span class="comment">// 设置 连接参数</span></div><div class="line">            HttpParams params = apacheHttpClient.getClientHandler().getHttpClient().getParams();</div><div class="line">            HttpConnectionParams.setConnectionTimeout(params, connectionTimeout);</div><div class="line">            HttpConnectionParams.setSoTimeout(params, readTimeout);</div><div class="line"></div><div class="line">            <span class="comment">// 创建 ApacheHttpClientConnectionCleaner</span></div><div class="line">            <span class="keyword">this</span>.apacheHttpClientConnectionCleaner = <span class="keyword">new</span> ApacheHttpClientConnectionCleaner(apacheHttpClient, connectionIdleTimeout);</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create Jersey client"</span>, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ApacheHttpClient4 <span class="title">getClient</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> apacheHttpClient;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyResources</span><span class="params">()</span> </span>&#123;</div><div class="line">        apacheHttpClientConnectionCleaner.shutdown();</div><div class="line">        apacheHttpClient.destroy();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>com.netflix.discovery.shared.transport.jersey.ApacheHttpClientConnectionCleaner</code> ，Apache HttpClient 空闲连接清理器，负责<strong>周期性</strong>关闭处于 <code>half-close</code> 状态的空闲连接。点击 <a href="https://github.com/YunaiV/eureka/blob/045686e7461ddac93384161eb342e89c3249dc69/eureka-client/src/main/java/com/netflix/discovery/shared/transport/jersey/ApacheHttpClientConnectionCleaner.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看带中文注释的 ApacheHttpClientConnectionCleaner。推荐阅读：<a href="http://seanhe.iteye.com/blog/234759" rel="external nofollow noopener noreferrer" target="_blank">《HttpClient容易忽视的细节——连接关闭》</a> 。</li></ul><h2 id="2-2-EurekaJerseyClientBuilder"><a href="#2-2-EurekaJerseyClientBuilder" class="headerlink" title="2.2 EurekaJerseyClientBuilder"></a>2.2 EurekaJerseyClientBuilder</h2><p>EurekaJerseyClientBuilder ，EurekaJerseyClientImpl <strong>内部类</strong>，用于创建 EurekaJerseyClientImpl 。</p><p>调用 <code>#build()</code> 方法，创建 EurekaJerseyClientImpl ，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// EurekaJerseyClientBuilder.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> EurekaJerseyClient <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">    MyDefaultApacheHttpClient4Config config = <span class="keyword">new</span> MyDefaultApacheHttpClient4Config();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EurekaJerseyClientImpl(connectionTimeout, readTimeout, connectionIdleTimeout, config);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create Jersey client "</span>, e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>MyDefaultApacheHttpClient4Config ，继承自 <code>com.sun.jersey.client.apache4.config.DefaultApacheHttpClient4Config</code> ，实现<strong>自定义配置</strong>。点击 <a href="https://github.com/YunaiV/eureka/blob/045686e7461ddac93384161eb342e89c3249dc69/eureka-client/src/main/java/com/netflix/discovery/shared/transport/jersey/EurekaJerseyClientImpl.java#L199" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看带中文注释的 MyDefaultApacheHttpClient4Config。例如 ：<ul><li>自定义的<strong>请求、响应的编解码器</strong> <code>com.netflix.discovery.provider.DiscoveryJerseyProvider</code> 。</li><li>禁用<strong>重定向</strong>，使用 RedirectingEurekaHttpClient 实现该特性。</li><li>自定义 UserAgent 。</li><li>自定义 Http Proxy 。</li><li>SSL 功能的增强。ApacheHttpClient4 使用的是 Apache HttpClient 4.1.1 版本，<code>com.netflix.discovery.shared.transport.jersey.SSLSocketFactoryAdapter</code> 将 Apache HttpClient 4.3.4 对 SSL 功能的增强适配到老版本 API 。点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-client/src/main/java/com/netflix/discovery/shared/transport/jersey/SSLSocketFactoryAdapter.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看带中文注释的 SSLSocketFactoryAdapter。</li></ul></li></ul><h1 id="3-EurekaHttpClient"><a href="#3-EurekaHttpClient" class="headerlink" title="3. EurekaHttpClient"></a>3. EurekaHttpClient</h1><p><code>com.netflix.discovery.shared.transport.EurekaHttpClient</code> ，Eureka-Server HTTP 访问客户端，定义了具体的 Eureka-Server API 调用方法 。点击 <a href="https://github.com/YunaiV/eureka/blob/045686e7461ddac93384161eb342e89c3249dc69/eureka-client/src/main/java/com/netflix/discovery/shared/transport/EurekaHttpClient.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看带中文注释的 EurekaHttpClient。</p><h2 id="3-1-EurekaHttpResponse"><a href="#3-1-EurekaHttpResponse" class="headerlink" title="3.1 EurekaHttpResponse"></a>3.1 EurekaHttpResponse</h2><p><code>com.netflix.discovery.shared.transport.EurekaHttpResponse</code> ，请求响应对象，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaHttpResponse</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 返回状态码</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> statusCode;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 返回对象( Entity )</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T entity;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 返回 header</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; headers;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 重定向地址</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URI location;</div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略 setting / getting 和 Builder</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3-2-TransportClientFactory"><a href="#3-2-TransportClientFactory" class="headerlink" title="3.2 TransportClientFactory"></a>3.2 TransportClientFactory</h2><p><code>com.netflix.discovery.shared.transport.TransportClientFactory</code> ，创建 EurekaHttpClient 的工厂<strong>接口</strong>。接口代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransportClientFactory</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 创建 EurekaHttpClient</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> serviceUrl Eureka-Server 地址</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> EurekaHttpClient</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">EurekaHttpClient <span class="title">newClient</span><span class="params">(EurekaEndpoint serviceUrl)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 关闭工厂</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>大多数 EurekaHttpClient 实现类都有其对应的工厂实现类</strong>。</p><h1 id="4-AbstractJerseyEurekaHttpClient"><a href="#4-AbstractJerseyEurekaHttpClient" class="headerlink" title="4. AbstractJerseyEurekaHttpClient"></a>4. AbstractJerseyEurekaHttpClient</h1><p><code>com.netflix.discovery.shared.transport.jersey.AbstractJerseyEurekaHttpClient</code> ，实现 EurekaHttpClient 的<strong>抽象类</strong>，<strong>真正</strong>实现了具体的 Eureka-Server API 调用方法。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractJerseyEurekaHttpClient</span> <span class="keyword">implements</span> <span class="title">EurekaHttpClient</span> </span>&#123;</div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>: <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AbstractJerseyEurekaHttpClient.class);</div><div class="line"> <span class="number">4</span>: </div><div class="line"> <span class="number">5</span>: <span class="comment">/**</span></div><div class="line"><span class="comment"> 6:  * Jersey Client</span></div><div class="line"><span class="comment"> 7:  */</span></div><div class="line"> <span class="number">8</span>: <span class="keyword">protected</span> <span class="keyword">final</span> Client jerseyClient;</div><div class="line"> <span class="number">9</span>: <span class="comment">/**</span></div><div class="line"><span class="comment">10:  * 请求的 Eureka-Server 地址</span></div><div class="line"><span class="comment">11:  */</span></div><div class="line"><span class="number">12</span>: <span class="keyword">protected</span> <span class="keyword">final</span> String serviceUrl;</div><div class="line"><span class="number">13</span>: </div><div class="line"><span class="number">14</span>: <span class="function"><span class="keyword">protected</span> <span class="title">AbstractJerseyEurekaHttpClient</span><span class="params">(Client jerseyClient, String serviceUrl)</span> </span>&#123;</div><div class="line"><span class="number">15</span>:     <span class="keyword">this</span>.jerseyClient = jerseyClient;</div><div class="line"><span class="number">16</span>:     <span class="keyword">this</span>.serviceUrl = serviceUrl;</div><div class="line"><span class="number">17</span>:     logger.debug(<span class="string">"Created client for url: &#123;&#125;"</span>, serviceUrl);</div><div class="line"><span class="number">18</span>: &#125;</div><div class="line"><span class="number">19</span>: </div><div class="line"><span class="number">20</span>: <span class="meta">@Override</span></div><div class="line"><span class="number">21</span>: <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">register</span><span class="params">(InstanceInfo info)</span> </span>&#123;</div><div class="line"><span class="number">22</span>:     <span class="comment">// 设置 请求地址</span></div><div class="line"><span class="number">23</span>:     String urlPath = <span class="string">"apps/"</span> + info.getAppName();</div><div class="line"><span class="number">24</span>:     ClientResponse response = <span class="keyword">null</span>;</div><div class="line"><span class="number">25</span>:     <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">26</span>:         Builder resourceBuilder = jerseyClient.resource(serviceUrl).path(urlPath).getRequestBuilder();</div><div class="line"><span class="number">27</span>:         <span class="comment">// 设置 请求头</span></div><div class="line"><span class="number">28</span>:         addExtraHeaders(resourceBuilder);</div><div class="line"><span class="number">29</span>:         <span class="comment">// 请求 Eureka-Server</span></div><div class="line"><span class="number">30</span>:         response = resourceBuilder</div><div class="line"><span class="number">31</span>:                 .header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>) <span class="comment">// GZIP</span></div><div class="line"><span class="number">32</span>:                 .type(MediaType.APPLICATION_JSON_TYPE) <span class="comment">// 请求参数格式 JSON</span></div><div class="line"><span class="number">33</span>:                 .accept(MediaType.APPLICATION_JSON) <span class="comment">// 响应结果格式 JSON</span></div><div class="line"><span class="number">34</span>:                 .post(ClientResponse.class, info); <span class="comment">// 请求参数</span></div><div class="line"><span class="number">35</span>:         <span class="comment">// 创建 EurekaHttpResponse</span></div><div class="line"><span class="number">36</span>:         <span class="keyword">return</span> anEurekaHttpResponse(response.getStatus()).headers(headersOf(response)).build();</div><div class="line"><span class="number">37</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">38</span>:         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line"><span class="number">39</span>:             logger.debug(<span class="string">"Jersey HTTP POST &#123;&#125;/&#123;&#125; with instance &#123;&#125;; statusCode=&#123;&#125;"</span>, serviceUrl, urlPath, info.getId(),</div><div class="line"><span class="number">40</span>:                     response == <span class="keyword">null</span> ? <span class="string">"N/A"</span> : response.getStatus());</div><div class="line"><span class="number">41</span>:         &#125;</div><div class="line"><span class="number">42</span>:         <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">43</span>:             response.close();</div><div class="line"><span class="number">44</span>:         &#125;</div><div class="line"><span class="number">45</span>:     &#125;</div><div class="line"><span class="number">46</span>: &#125;</div></pre></td></tr></table></figure><ul><li><code>jerseyClient</code> 属性，Jersey Client ，使用上文的 <code>EurekaHttpClient#getClient(...)</code> 方法，获取 ApacheHttpClient4 。</li><li><code>serviceUrl</code> 属性，请求的 Eureka-Server 地址。</li><li><p><code>#register()</code> 方法，实现向 Eureka-Server 注册应用实例。<strong>其他方法代码类似</strong>。</p><ul><li>第 22 至 26 行 ：设置请求地址。</li><li><p>第 28 行 ：调用 <code>#addExtraHeaders(...)</code> 方法，设置请求头( header  )。该方法是<strong>抽象方法</strong>，提供子类实现自定义的请求头。代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addExtraHeaders</span><span class="params">(Builder webResource)</span></span>;</div></pre></td></tr></table></figure><ul><li>x<ul><li>第 29 至 34 行 ：请求 Eureka-Server 。</li><li>第 35 至 36 行 ：解析响应结果，创建 EurekaHttpResponse 。</li></ul></li></ul></li></ul></li></ul><h2 id="4-1-JerseyApplicationClient"><a href="#4-1-JerseyApplicationClient" class="headerlink" title="4.1 JerseyApplicationClient"></a>4.1 JerseyApplicationClient</h2><p><code>com.netflix.discovery.shared.transport.jersey.JerseyApplicationClient</code> ，实现 Eureka-Client 请求 Eureka-Server 的网络通信。点击 <a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-client/src/main/java/com/netflix/discovery/shared/transport/jersey/JerseyApplicationClient.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看带中文注释的 JerseyApplicationClient。</p><h3 id="4-1-1-JerseyEurekaHttpClientFactory"><a href="#4-1-1-JerseyEurekaHttpClientFactory" class="headerlink" title="4.1.1 JerseyEurekaHttpClientFactory"></a>4.1.1 JerseyEurekaHttpClientFactory</h3><p><code>com.netflix.discovery.shared.transport.jersey.JerseyEurekaHttpClientFactory</code> ，创建 JerseyApplicationClient 的<strong>工厂类</strong>。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JerseyEurekaHttpClientFactory</span> <span class="keyword">implements</span> <span class="title">TransportClientFactory</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EurekaJerseyClient jerseyClient;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApacheHttpClient4 apacheClient;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApacheHttpClientConnectionCleaner cleaner;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; additionalHeaders;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JerseyEurekaHttpClientFactory</span><span class="params">(ApacheHttpClient4 apacheClient, <span class="keyword">long</span> connectionIdleTimeout, Map&lt;String, String&gt; additionalHeaders)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, apacheClient, connectionIdleTimeout, additionalHeaders);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JerseyEurekaHttpClientFactory</span><span class="params">(EurekaJerseyClient jerseyClient,</span></span></div><div class="line"><span class="function"><span class="params">                                          ApacheHttpClient4 apacheClient,</span></span></div><div class="line"><span class="function"><span class="params">                                          <span class="keyword">long</span> connectionIdleTimeout,</span></span></div><div class="line"><span class="function"><span class="params">                                          Map&lt;String, String&gt; additionalHeaders)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.jerseyClient = jerseyClient;</div><div class="line">        <span class="keyword">this</span>.apacheClient = jerseyClient != <span class="keyword">null</span> ? jerseyClient.getClient() : apacheClient;</div><div class="line">        <span class="keyword">this</span>.additionalHeaders = additionalHeaders;</div><div class="line">        <span class="keyword">this</span>.cleaner = <span class="keyword">new</span> ApacheHttpClientConnectionCleaner(<span class="keyword">this</span>.apacheClient, connectionIdleTimeout);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> EurekaHttpClient <span class="title">newClient</span><span class="params">(EurekaEndpoint endpoint)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JerseyApplicationClient(apacheClient, endpoint.getServiceUrl(), additionalHeaders);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line">        cleaner.shutdown();</div><div class="line">        <span class="keyword">if</span> (jerseyClient != <span class="keyword">null</span>) &#123;</div><div class="line">            jerseyClient.destroyResources();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            apacheClient.destroy();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="4-1-2-JerseyEurekaHttpClientFactoryBuilder"><a href="#4-1-2-JerseyEurekaHttpClientFactoryBuilder" class="headerlink" title="4.1.2 JerseyEurekaHttpClientFactoryBuilder"></a>4.1.2 JerseyEurekaHttpClientFactoryBuilder</h3><p>JerseyEurekaHttpClientFactoryBuilder ，JerseyEurekaHttpClientFactory <strong>内部类</strong>，用于创建 JerseyEurekaHttpClientFactory 。点击 <a href="https://github.com/YunaiV/eureka/blob/ff48fa728c7085ad8116517ede88398b0fd693c7/eureka-client/src/main/java/com/netflix/discovery/shared/transport/jersey/JerseyEurekaHttpClientFactory.java#L152" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看带中文注释的 JerseyEurekaHttpClientFactory。</p><p>调用 <code>JerseyEurekaHttpClientFactory#create(...)</code> 方法，创建 JerseyEurekaHttpClientFactory ，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JerseyEurekaHttpClientFactory <span class="title">create</span><span class="params">(EurekaClientConfig clientConfig,</span></span></div><div class="line"><span class="function"><span class="params">                                                  Collection&lt;ClientFilter&gt; additionalFilters,</span></span></div><div class="line"><span class="function"><span class="params">                                                  InstanceInfo myInstanceInfo,</span></span></div><div class="line"><span class="function"><span class="params">                                                  AbstractEurekaIdentity clientIdentity)</span> </span>&#123;</div><div class="line">   JerseyEurekaHttpClientFactoryBuilder clientBuilder = newBuilder()</div><div class="line">           .withAdditionalFilters(additionalFilters) <span class="comment">// 客户端附加过滤器</span></div><div class="line">           .withMyInstanceInfo(myInstanceInfo) <span class="comment">// 应用实例</span></div><div class="line">           .withUserAgent(<span class="string">"Java-EurekaClient"</span>) <span class="comment">// UA</span></div><div class="line">           .withClientConfig(clientConfig)</div><div class="line">           .withClientIdentity(clientIdentity);</div><div class="line"></div><div class="line">   <span class="comment">// 设置 Client Name</span></div><div class="line">   <span class="keyword">if</span> (<span class="string">"true"</span>.equals(System.getProperty(<span class="string">"com.netflix.eureka.shouldSSLConnectionsUseSystemSocketFactory"</span>))) &#123;</div><div class="line">       clientBuilder.withClientName(<span class="string">"DiscoveryClient-HTTPClient-System"</span>).withSystemSSLConfiguration();</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clientConfig.getProxyHost() != <span class="keyword">null</span> &amp;&amp; clientConfig.getProxyPort() != <span class="keyword">null</span>) &#123;</div><div class="line">       clientBuilder.withClientName(<span class="string">"Proxy-DiscoveryClient-HTTPClient"</span>)</div><div class="line">               .withProxy(</div><div class="line">                       clientConfig.getProxyHost(), Integer.parseInt(clientConfig.getProxyPort()),</div><div class="line">                       clientConfig.getProxyUserName(), clientConfig.getProxyPassword()</div><div class="line">               ); <span class="comment">// http proxy</span></div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       clientBuilder.withClientName(<span class="string">"DiscoveryClient-HTTPClient"</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">return</span> clientBuilder.build();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JerseyEurekaHttpClientFactoryBuilder <span class="title">newBuilder</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> JerseyEurekaHttpClientFactoryBuilder().withExperimental(<span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="4-2-JerseyReplicationClient"><a href="#4-2-JerseyReplicationClient" class="headerlink" title="4.2 JerseyReplicationClient"></a>4.2 JerseyReplicationClient</h2><p><code>com.netflix.eureka.transport.JerseyReplicationClient</code> ，Eureka-Server 集群内，Eureka-Server 请求 <strong>其它的Eureka-Server</strong> 的网络通信。</p><ul><li><p>实现 <code>AbstractJerseyEurekaHttpClient#addExtraHeaders()</code> 方法，添加自定义头 <code>x-netflix-discovery-replication=true</code> ，代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addExtraHeaders</span><span class="params">(Builder webResource)</span> </span>&#123;</div><div class="line">   webResource.header(PeerEurekaNode.HEADER_REPLICATION, <span class="string">"true"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>重写了 <code>#sendHeartBeat(...)</code> 方法，在 <a href="http://www.iocoder.cn/Eureka/server-cluster/?self">《Eureka 源码解析 —— Eureka-Server 集群同步》</a> 有详细解析。</p></li><li>实现 <code>com.netflix.eureka.cluster.HttpReplicationClient</code> 接口，实现了 <code>#submitBatchUpdates(...)</code> 方法，在 <a href="http://www.iocoder.cn/Eureka/server-cluster/?self">《Eureka 源码解析 —— Eureka-Server 集群同步》</a> 有详细解析。</li></ul><h3 id="4-2-1-没有工厂"><a href="#4-2-1-没有工厂" class="headerlink" title="4.2.1 没有工厂"></a>4.2.1 没有工厂</h3><p>JerseyReplicationClient <strong>没有专属的工厂</strong>。</p><p>调用 <code>JerseyReplicationClient#createReplicationClient(...)</code> <strong>静态方法</strong>，创建 JerseyReplicationClient 。点击 <a href="https://github.com/YunaiV/eureka/blob/94a4a1ebd35a3350893369a05757c01b2534b702/eureka-core/src/main/java/com/netflix/eureka/transport/JerseyReplicationClient.java#L135" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看带中文注释的方法代码。</p><h1 id="5-EurekaHttpClientDecorator"><a href="#5-EurekaHttpClientDecorator" class="headerlink" title="5. EurekaHttpClientDecorator"></a>5. EurekaHttpClientDecorator</h1><p><code>com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator</code>，EurekaHttpClient 委托者<strong>抽象类</strong>。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaHttpClientDecorator</span> <span class="keyword">implements</span> <span class="title">EurekaHttpClient</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 执行请求</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> requestExecutor 请求执行器</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;R&gt; 请求泛型</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 响应</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;R&gt; <span class="function">EurekaHttpResponse&lt;R&gt; <span class="title">execute</span><span class="params">(RequestExecutor&lt;R&gt; requestExecutor)</span></span>;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">register</span><span class="params">(<span class="keyword">final</span> InstanceInfo info)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> execute(<span class="keyword">new</span> RequestExecutor&lt;Void&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="title">execute</span><span class="params">(EurekaHttpClient delegate)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> delegate.register(info);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> RequestType <span class="title">getRequestType</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> RequestType.Register;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>#execute(...)</code> <strong>抽象方法</strong>，子类实现该方法，实现自己的特性。</li><li><code>#register()</code> 方法，实现向 Eureka-Server 注册应用实例。<strong>其他方法代码类似</strong>。<ul><li>调用 <code>#execute(...)</code> 方法，并将原有的注册实现通过 RequestExecutor 传递进去。</li><li>子类在实现的 <code>#execute(...)</code> 方法，可以调用 <code>RequestExecutor#execute(...)</code> 方法，继续执行原有逻辑。</li><li>参考设计模式：<a href="http://blog.csdn.net/hguisu/article/details/7564039" rel="external nofollow noopener noreferrer" target="_blank">《设计模式 ( 十九 ) 模板方法模式Template method（类行为型）》</a> 。</li></ul></li><li><p>RequestType ，请求类型<strong>枚举类</strong>。代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// EurekaHttpClientDecorator.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RequestType &#123;</div><div class="line">   Register,</div><div class="line">   Cancel,</div><div class="line">   SendHeartBeat,</div><div class="line">   StatusUpdate,</div><div class="line">   DeleteStatusOverride,</div><div class="line">   GetApplications,</div><div class="line">   GetDelta,</div><div class="line">   GetVip,</div><div class="line">   GetSecureVip,</div><div class="line">   GetApplication,</div><div class="line">   GetInstance,</div><div class="line">   GetApplicationInstance</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>RequestExecutor ，请求执行器<strong>接口</strong>。接口代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// EurekaHttpClientDecorator.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RequestExecutor</span>&lt;<span class="title">R</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 执行请求</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> delegate 委托的 EurekaHttpClient</span></div><div class="line"><span class="comment">    * <span class="doctag">@return</span> 响应</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="function">EurekaHttpResponse&lt;R&gt; <span class="title">execute</span><span class="params">(EurekaHttpClient delegate)</span></span>;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * <span class="doctag">@return</span> 请求类型</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="function">RequestType <span class="title">getRequestType</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><hr><p>EurekaHttpClientDecorator 的<strong>每个实现类实现一个特性</strong>，代码非常非常非常清晰。</p><blockquote><p>FROM <a href="https://zh.wikipedia.org/wiki/%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F" rel="external nofollow noopener noreferrer" target="_blank">《委托模式》</a><br>委托模式是软件设计模式中的一项基本技巧。在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。委托模式是一项基本技巧，许多其他的模式，如状态模式、策略模式、访问者模式本质上是在更特殊的场合采用了委托模式。委托模式使得我们可以用聚合来替代继承，它还使我们可以模拟mixin。</p></blockquote><p>我们在上图的基础上，<strong>增加委托的关系</strong>，如下图( <a href="http://www.iocoder.cn/images/Eureka/2018_07_31/03.jpeg">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_07_31/03.jpeg" alt=""></p><ul><li>请注意，每个委托着实现类，上面可能有类型为 EurekaHttpClientFactory 的属性，用于创建其委托的 EurekaHttpClient 。<strong>为什么会有 Factory</strong> ？例如，RetryableEurekaHttpClient 重试请求多个 Eureka-Server 地址时，每个 Eureka-Server 地址会创建一个 EurekaHttpClient 。所以，下文涉及到 EurekaHttpClientFactory 和<strong>委托的</strong> EurekaHttpClient 的地方，你都需要仔细理解。</li></ul><h2 id="5-1-MetricsCollectingEurekaHttpClient"><a href="#5-1-MetricsCollectingEurekaHttpClient" class="headerlink" title="5.1 MetricsCollectingEurekaHttpClient"></a>5.1 MetricsCollectingEurekaHttpClient</h2><p><code>com.netflix.discovery.shared.transport.decorator.MetricsCollectingEurekaHttpClient</code> ，监控指标收集 EurekaHttpClient ，配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集。</p><p><code>#execute()</code> 方法，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="keyword">protected</span> &lt;R&gt; <span class="function">EurekaHttpResponse&lt;R&gt; <span class="title">execute</span><span class="params">(RequestExecutor&lt;R&gt; requestExecutor)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="comment">// 获得 请求类型 的 请求指标</span></div><div class="line"> <span class="number">4</span>:     EurekaHttpClientRequestMetrics requestMetrics = metricsByRequestType.get(requestExecutor.getRequestType());</div><div class="line"> <span class="number">5</span>:     Stopwatch stopwatch = requestMetrics.latencyTimer.start();</div><div class="line"> <span class="number">6</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">7</span>:         <span class="comment">// 执行请求</span></div><div class="line"> <span class="number">8</span>:         EurekaHttpResponse&lt;R&gt; httpResponse = requestExecutor.execute(delegate);</div><div class="line"> <span class="number">9</span>:         <span class="comment">// 增加 请求指标</span></div><div class="line"><span class="number">10</span>:         requestMetrics.countersByStatus.get(mappedStatus(httpResponse)).increment();</div><div class="line"><span class="number">11</span>:         <span class="keyword">return</span> httpResponse;</div><div class="line"><span class="number">12</span>:     &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"><span class="number">13</span>:         requestMetrics.connectionErrors.increment();</div><div class="line"><span class="number">14</span>:         exceptionsMetric.count(e);</div><div class="line"><span class="number">15</span>:         <span class="keyword">throw</span> e;</div><div class="line"><span class="number">16</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">17</span>:         stopwatch.stop();</div><div class="line"><span class="number">18</span>:     &#125;</div><div class="line"><span class="number">19</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 10 行 ：调用 <code>RequestExecutor#execute(...)</code> 方法，继续执行请求。<ul><li><code>delegate</code> 属性，对应 JerseyApplicationClient 。</li></ul></li></ul><h2 id="5-2-RedirectingEurekaHttpClient"><a href="#5-2-RedirectingEurekaHttpClient" class="headerlink" title="5.2 RedirectingEurekaHttpClient"></a>5.2 RedirectingEurekaHttpClient</h2><p><code>com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient</code> ，<strong>寻找非 302 重定向</strong>的 Eureka-Server 的 EurekaHttpClient 。</p><p><code>#execute()</code> 方法，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="keyword">protected</span> &lt;R&gt; <span class="function">EurekaHttpResponse&lt;R&gt; <span class="title">execute</span><span class="params">(RequestExecutor&lt;R&gt; requestExecutor)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     EurekaHttpClient currentEurekaClient = delegateRef.get();</div><div class="line"> <span class="number">4</span>:     <span class="keyword">if</span> (currentEurekaClient == <span class="keyword">null</span>) &#123; <span class="comment">// 未找到非 302 的 Eureka-Server</span></div><div class="line"> <span class="number">5</span>:         AtomicReference&lt;EurekaHttpClient&gt; currentEurekaClientRef = <span class="keyword">new</span> AtomicReference&lt;&gt;(factory.newClient(serviceEndpoint));</div><div class="line"> <span class="number">6</span>:         <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">7</span>:             EurekaHttpResponse&lt;R&gt; response = executeOnNewServer(requestExecutor, currentEurekaClientRef);</div><div class="line"> <span class="number">8</span>:             <span class="comment">// 关闭原有的委托 EurekaHttpClient ，并设置当前成功非 302 请求的 EurekaHttpClient</span></div><div class="line"> <span class="number">9</span>:             TransportUtils.shutdown(delegateRef.getAndSet(currentEurekaClientRef.get()));</div><div class="line"><span class="number">10</span>:             <span class="keyword">return</span> response;</div><div class="line"><span class="number">11</span>:         &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"><span class="number">12</span>:             logger.error(<span class="string">"Request execution error"</span>, e);</div><div class="line"><span class="number">13</span>:             TransportUtils.shutdown(currentEurekaClientRef.get());</div><div class="line"><span class="number">14</span>:             <span class="keyword">throw</span> e;</div><div class="line"><span class="number">15</span>:         &#125;</div><div class="line"><span class="number">16</span>:     &#125; <span class="keyword">else</span> &#123; <span class="comment">// 已经找到非 302 的 Eureka-Server</span></div><div class="line"><span class="number">17</span>:         <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">18</span>:             <span class="keyword">return</span> requestExecutor.execute(currentEurekaClient);</div><div class="line"><span class="number">19</span>:         &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"><span class="number">20</span>:             logger.error(<span class="string">"Request execution error"</span>, e);</div><div class="line"><span class="number">21</span>:             delegateRef.compareAndSet(currentEurekaClient, <span class="keyword">null</span>);</div><div class="line"><span class="number">22</span>:             currentEurekaClient.shutdown();</div><div class="line"><span class="number">23</span>:             <span class="keyword">throw</span> e;</div><div class="line"><span class="number">24</span>:         &#125;</div><div class="line"><span class="number">25</span>:     &#125;</div><div class="line"><span class="number">26</span>: &#125;</div></pre></td></tr></table></figure><ul><li><strong>注意</strong>：和我们理解的常规的 302 状态返回处理不同！！！</li><li>整个分成两部分：【第 4 至 15 行】、【第 16 至 24 行】。<ul><li>前者，意味着未找到非返回 302 状态码的 Eureka-Server ，此时通过在原始传递进来的 <code>serviceUrls</code> 执行请求，寻找非 302 状态码返回的 Eureka-Server。<ul><li>当返回非 302 状态码时，找到非返回 302 状态码的 Eureka-Server 。</li><li>当返回 302 状态码时，向新的重定向的 Eureka-Server 执行请求直到成功找到或超过最大次数。<ul><li>后者，意味着当前已经找到非返回 302 状态码的 Eureka-Server ，直接执行请求。<strong>注意</strong> ：此时 Eureka-Server 再返回 302 状态码，不再处理。</li><li>目前 Eureka 1.x 的 Eureka-Server 不存在返回 302 状态码，猜测和 Eureka 2.X TODO[0028]：写入集群和读取集群 有关。</li></ul></li></ul></li></ul></li><li>【前者】第 5 行 ：使用初始的 <code>serviceEndpoint</code> ( 相当于 <code>serviceUrls</code> ) 创建<strong>委托</strong> EurekaHttpClient 。</li><li>【前者】第 7 行 ：调用 <code>#executeOnNewServer(...)</code> 方法，通过执行请求的方式，寻找非 302 状态码返回的 Eureka-Server。实现代码，点击 <a href="https://github.com/YunaiV/eureka/blob/ed9a4241e60e3b558f939754f71188d3063771e2/eureka-client/src/main/java/com/netflix/discovery/shared/transport/decorator/RedirectingEurekaHttpClient.java#L111" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看带中文注释的代码实现。</li><li>【前者】【前者】第 9 行 ：关闭原有的 <code>delegateRef</code> ( 因为此处可能存在并发，多个线程都找到非 302 状态码返回的 Eureka-Server )，并设置当前成功非 302 请求的 EurekaHttpClient 到 <code>delegateRef</code>。</li><li>【前者】第 13 行 ：关闭 <code>currentEurekaClientRef</code> ，当请求发生异常或者超过最大重定向次数。</li><li>【后者】第 18 行 ：意味着当前已经找到非返回 302 状态码的 Eureka-Server ，直接执行请求。</li><li>【后者】第 21 至 22 行 ：执行请求发生异常，关闭 <code>currentEurekaClient</code> ，后面要重新非返回 302 状态码的 Eureka-Server 。</li></ul><h3 id="5-2-1-工厂"><a href="#5-2-1-工厂" class="headerlink" title="5.2.1 工厂"></a>5.2.1 工厂</h3><p>RedirectingEurekaHttpClient 提供 <code>#createFactory(...)</code> <strong>静态方法</strong>获得创建其的工厂，点击 <a href="https://github.com/YunaiV/eureka/blob/ed9a4241e60e3b558f939754f71188d3063771e2/eureka-client/src/main/java/com/netflix/discovery/shared/transport/decorator/RedirectingEurekaHttpClient.java#L96" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看。</p><h2 id="5-3-RetryableEurekaHttpClient"><a href="#5-3-RetryableEurekaHttpClient" class="headerlink" title="5.3 RetryableEurekaHttpClient"></a>5.3 RetryableEurekaHttpClient</h2><p><code>com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient</code> ，支持向多个 Eureka-Server 请求重试的 EurekaHttpClient 。</p><p><code>#execute()</code> 方法，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="keyword">protected</span> &lt;R&gt; <span class="function">EurekaHttpResponse&lt;R&gt; <span class="title">execute</span><span class="params">(RequestExecutor&lt;R&gt; requestExecutor)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     List&lt;EurekaEndpoint&gt; candidateHosts = <span class="keyword">null</span>;</div><div class="line"> <span class="number">4</span>:     <span class="keyword">int</span> endpointIdx = <span class="number">0</span>;</div><div class="line"> <span class="number">5</span>:     <span class="keyword">for</span> (<span class="keyword">int</span> retry = <span class="number">0</span>; retry &lt; numberOfRetries; retry++) &#123;</div><div class="line"> <span class="number">6</span>:         EurekaHttpClient currentHttpClient = delegate.get();</div><div class="line"> <span class="number">7</span>:         EurekaEndpoint currentEndpoint = <span class="keyword">null</span>;</div><div class="line"> <span class="number">8</span>: </div><div class="line"> <span class="number">9</span>:         <span class="comment">// 当前委托的 EurekaHttpClient 不存在</span></div><div class="line"><span class="number">10</span>:         <span class="keyword">if</span> (currentHttpClient == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">11</span>:             <span class="comment">// 获得候选的 Eureka-Server 地址数组</span></div><div class="line"><span class="number">12</span>:             <span class="keyword">if</span> (candidateHosts == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">13</span>:                 candidateHosts = getHostCandidates();</div><div class="line"><span class="number">14</span>:                 <span class="keyword">if</span> (candidateHosts.isEmpty()) &#123;</div><div class="line"><span class="number">15</span>:                     <span class="keyword">throw</span> <span class="keyword">new</span> TransportException(<span class="string">"There is no known eureka server; cluster server list is empty"</span>);</div><div class="line"><span class="number">16</span>:                 &#125;</div><div class="line"><span class="number">17</span>:             &#125;</div><div class="line"><span class="number">18</span>: </div><div class="line"><span class="number">19</span>:             <span class="comment">// 超过候选的 Eureka-Server 地址数组上限</span></div><div class="line"><span class="number">20</span>:             <span class="keyword">if</span> (endpointIdx &gt;= candidateHosts.size()) &#123;</div><div class="line"><span class="number">21</span>:                 <span class="keyword">throw</span> <span class="keyword">new</span> TransportException(<span class="string">"Cannot execute request on any known server"</span>);</div><div class="line"><span class="number">22</span>:             &#125;</div><div class="line"><span class="number">23</span>: </div><div class="line"><span class="number">24</span>:             <span class="comment">// 创建候选的 EurekaHttpClient</span></div><div class="line"><span class="number">25</span>:             currentEndpoint = candidateHosts.get(endpointIdx++);</div><div class="line"><span class="number">26</span>:             currentHttpClient = clientFactory.newClient(currentEndpoint);</div><div class="line"><span class="number">27</span>:         &#125;</div><div class="line"><span class="number">28</span>: </div><div class="line"><span class="number">29</span>:         <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">30</span>:             <span class="comment">// 执行请求</span></div><div class="line"><span class="number">31</span>:             EurekaHttpResponse&lt;R&gt; response = requestExecutor.execute(currentHttpClient);</div><div class="line"><span class="number">32</span>:             <span class="comment">// 判断是否为可接受的相应，若是，返回。</span></div><div class="line"><span class="number">33</span>:             <span class="keyword">if</span> (serverStatusEvaluator.accept(response.getStatusCode(), requestExecutor.getRequestType())) &#123;</div><div class="line"><span class="number">34</span>:                 delegate.set(currentHttpClient);</div><div class="line"><span class="number">35</span>:                 <span class="keyword">if</span> (retry &gt; <span class="number">0</span>) &#123;</div><div class="line"><span class="number">36</span>:                     logger.info(<span class="string">"Request execution succeeded on retry #&#123;&#125;"</span>, retry);</div><div class="line"><span class="number">37</span>:                 &#125;</div><div class="line"><span class="number">38</span>:                 <span class="keyword">return</span> response;</div><div class="line"><span class="number">39</span>:             &#125;</div><div class="line"><span class="number">40</span>:             logger.warn(<span class="string">"Request execution failure with status code &#123;&#125;; retrying on another server if available"</span>, response.getStatusCode());</div><div class="line"><span class="number">41</span>:         &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"><span class="number">42</span>:             logger.warn(<span class="string">"Request execution failed with message: &#123;&#125;"</span>, e.getMessage());  <span class="comment">// just log message as the underlying client should log the stacktrace</span></div><div class="line"><span class="number">43</span>:         &#125;</div><div class="line"><span class="number">44</span>: </div><div class="line"><span class="number">45</span>:         <span class="comment">// 请求失败，若是 currentHttpClient ，清除 delegate</span></div><div class="line"><span class="number">46</span>:         <span class="comment">// Connection error or 5xx from the server that must be retried on another server</span></div><div class="line"><span class="number">47</span>:         delegate.compareAndSet(currentHttpClient, <span class="keyword">null</span>);</div><div class="line"><span class="number">48</span>: </div><div class="line"><span class="number">49</span>:         <span class="comment">// 请求失败，将 currentEndpoint 添加到隔离集合</span></div><div class="line"><span class="number">50</span>:         <span class="keyword">if</span> (currentEndpoint != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">51</span>:             quarantineSet.add(currentEndpoint);</div><div class="line"><span class="number">52</span>:         &#125;</div><div class="line"><span class="number">53</span>:     &#125;</div><div class="line"><span class="number">54</span>:     <span class="keyword">throw</span> <span class="keyword">new</span> TransportException(<span class="string">"Retry limit reached; giving up on completing the request"</span>);</div><div class="line"><span class="number">55</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 10 行 ：当前 <code>currentHttpClient</code> 不存在，意味着原有 <code>delegate</code> 不存在向 Eureka-Server 成功请求的 EurekaHttpClient 。<ul><li>此时需要从配置中的 Eureka-Server 数组重试请求，获得可以请求的 Eureka-Server 。</li><li>如果已经存在请求成功的 <code>delegate</code> ，直接使用它进行执行请求。</li></ul></li><li><p>第 11 至 17 行 ：调用 <code>#getHostCandidates()</code> 方法，获得候选的 Eureka-Server <code>serviceUrls</code> 数组。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> List&lt;EurekaEndpoint&gt; <span class="title">getHostCandidates</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// 获得候选的 Eureka-Server 地址数组</span></div><div class="line"> <span class="number">3</span>:     List&lt;EurekaEndpoint&gt; candidateHosts = clusterResolver.getClusterEndpoints();</div><div class="line"> <span class="number">4</span>: </div><div class="line"> <span class="number">5</span>:     <span class="comment">// 保留交集（移除 quarantineSet 不在 candidateHosts 的元素）</span></div><div class="line"> <span class="number">6</span>:     quarantineSet.retainAll(candidateHosts);</div><div class="line"> <span class="number">7</span>: </div><div class="line"> <span class="number">8</span>:     <span class="comment">// 在保证最小可用的候选的 Eureka-Server 地址数组，移除在隔离集合内的元素</span></div><div class="line"> <span class="number">9</span>:     <span class="comment">// If enough hosts are bad, we have no choice but start over again</span></div><div class="line"><span class="number">10</span>:     <span class="keyword">int</span> threshold = (<span class="keyword">int</span>) (candidateHosts.size() * transportConfig.getRetryableClientQuarantineRefreshPercentage()); <span class="comment">// 0.66</span></div><div class="line"><span class="number">11</span>:     <span class="keyword">if</span> (quarantineSet.isEmpty()) &#123;</div><div class="line"><span class="number">12</span>:         <span class="comment">// no-op</span></div><div class="line"><span class="number">13</span>:     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (quarantineSet.size() &gt;= threshold) &#123;</div><div class="line"><span class="number">14</span>:         logger.debug(<span class="string">"Clearing quarantined list of size &#123;&#125;"</span>, quarantineSet.size());</div><div class="line"><span class="number">15</span>:         quarantineSet.clear();</div><div class="line"><span class="number">16</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">17</span>:         List&lt;EurekaEndpoint&gt; remainingHosts = <span class="keyword">new</span> ArrayList&lt;&gt;(candidateHosts.size());</div><div class="line"><span class="number">18</span>:         <span class="keyword">for</span> (EurekaEndpoint endpoint : candidateHosts) &#123;</div><div class="line"><span class="number">19</span>:             <span class="keyword">if</span> (!quarantineSet.contains(endpoint)) &#123;</div><div class="line"><span class="number">20</span>:                 remainingHosts.add(endpoint);</div><div class="line"><span class="number">21</span>:             &#125;</div><div class="line"><span class="number">22</span>:         &#125;</div><div class="line"><span class="number">23</span>:         candidateHosts = remainingHosts;</div><div class="line"><span class="number">24</span>:     &#125;</div><div class="line"><span class="number">25</span>: </div><div class="line"><span class="number">26</span>:     <span class="keyword">return</span> candidateHosts;</div><div class="line"><span class="number">27</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 3 行 ：调用 <code>ClusterResolver#getClusterEndpoints()</code> 方法，获得候选的 Eureka-Server 地址数组( <code>candidateHosts</code> )。<strong>注意</strong>：该方法返回的 Eureka-Server 地址数组，使用以本机 IP 为<strong>随机种子</strong>，达到不同 IP 的应用实例获得的数组顺序不同，而相同 IP 的应用实例获得的数组顺序一致，<strong>效果类似基于 IP HASH 的负载均衡算法</strong>。实现该功能的代码，在 <a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/?self">《Eureka 源码解析 —— EndPoint 与 解析器》搜索关键字【ResolverUtils#randomize(…)】</a> 详细解析。</li><li>第 6 行 ：调用 <code>Set#retainAll()</code> 方法，移除隔离的故障 Eureka-Server 地址数组( <code>quarantineSet</code> ) 中不在 <code>candidateHosts</code> 的元素。</li><li>第 8 至 24 行 ：在保证最小可用的 <code>candidateHosts</code>，移除在 <code>quarantineSet</code> 的元素。<ul><li>第 10 行 ：最小可用的阀值，配置 <code>eureka.retryableClientQuarantineRefreshPercentage</code> 来设置百分比，默认值：<code>0.66</code> 。</li><li>最 13 至 15 行 ：<code>quarantineSet</code> 数量超过阀值，清空 <code>quarantineSet</code> ，全部 <code>candidateHosts</code> 重试。</li><li>第 17 至 24 行 ：<code>quarantineSet</code> 数量未超过阀值，移除 <code>candidateHosts</code> 中在 <code>quarantineSet</code> 的元素。</li></ul></li></ul></li><li><p>第 19 至 22 行 ：超过 <code>candidateHosts</code> 上限，全部 Eureka-Server 请求失败，抛出异常。</p></li><li>第 24 至 26 行 ：创建委托的 EurekaHttpClient ，用于下面请求执行。</li><li>第 31 行 ：执行请求。</li><li><p>第 33 行 ：调用 <code>ServerStatusEvaluator#accept()</code> 方法，判断响应状态码和请求类型是否能够接受。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ServerStatusEvaluators.java</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ServerStatusEvaluator LEGACY_EVALUATOR = <span class="keyword">new</span> ServerStatusEvaluator() &#123;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> statusCode, RequestType requestType)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (statusCode &gt;= <span class="number">200</span> &amp;&amp; statusCode &lt; <span class="number">300</span> || statusCode == <span class="number">302</span>) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (requestType == RequestType.Register &amp;&amp; statusCode == <span class="number">404</span>) &#123; <span class="comment">// 注册，404 可接受</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (requestType == RequestType.SendHeartBeat &amp;&amp; statusCode == <span class="number">404</span>) &#123; <span class="comment">// 心跳，404 可接受</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (requestType == RequestType.Cancel) &#123;  <span class="comment">// cancel is best effort 下线，接受全部</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (requestType == RequestType.GetDelta &amp;&amp; (statusCode == <span class="number">403</span> || statusCode == <span class="number">404</span>)) &#123; <span class="comment">// 增量获取注册信息，403 404 可接受</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></li><li><p>第 34 行 ：请求成功，设置 <code>delegate</code> 。下次请求，优先使用 <code>delegate</code> ，失败才进行候选的 Eureka-Server 地址数组重试。</p></li><li>第 47 行 ：请求失败，<code>delegate</code> 若等于 <code>currentHttpClient</code> ，进行清除。</li><li>第 50 至 52 行 ：请求失败，将请求的 Eureka-Server 地址添加到 <code>quarantineSet</code> 。</li><li>总结来说：<ul><li>【第一步】若当前有请求成功的 EurekaHttpClient ，继续使用。若请求失败，执行【第二步】。</li><li>【第二步】若当前无请求成功的 EurekaHttpClient ，获取候选的 Eureka-Server 地址数组<strong>顺序</strong>创建新的 EurekaHttpClient，直到成功，或者超过最大重试次数。当请求成功，保存该 EurekaHttpClient ，下次继续使用，直到请求失败。</li></ul></li></ul><h3 id="5-3-1-工厂"><a href="#5-3-1-工厂" class="headerlink" title="5.3.1 工厂"></a>5.3.1 工厂</h3><p>RetryableEurekaHttpClient 提供 <code>#createFactory(...)</code> <strong>静态方法</strong>获得创建其的工厂，点击 <a href="https://github.com/YunaiV/eureka/blob/94a4a1ebd35a3350893369a05757c01b2534b702/eureka-client/src/main/java/com/netflix/discovery/shared/transport/decorator/RetryableEurekaHttpClient.java#L135" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看。</p><h2 id="5-4-SessionedEurekaHttpClient"><a href="#5-4-SessionedEurekaHttpClient" class="headerlink" title="5.4 SessionedEurekaHttpClient"></a>5.4 SessionedEurekaHttpClient</h2><p><code>com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient</code> ，支持会话的 EurekaHttpClient 。执行定期的重建会话，防止一个 Eureka-Client 永远只连接一个特定的 Eureka-Server 。反过来，这也保证了 Eureka-Server 集群变更时，Eureka-Client 对 Eureka-Server 连接的负载均衡。</p><p><code>#execute(...)</code> ，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="keyword">protected</span> &lt;R&gt; <span class="function">EurekaHttpResponse&lt;R&gt; <span class="title">execute</span><span class="params">(RequestExecutor&lt;R&gt; requestExecutor)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line"> <span class="number">4</span>:     <span class="keyword">long</span> delay = now - lastReconnectTimeStamp;</div><div class="line"> <span class="number">5</span>: </div><div class="line"> <span class="number">6</span>:     <span class="comment">// 超过 当前会话时间，关闭当前委托的 EurekaHttpClient 。</span></div><div class="line"> <span class="number">7</span>:     <span class="keyword">if</span> (delay &gt;= currentSessionDurationMs) &#123;</div><div class="line"> <span class="number">8</span>:         logger.debug(<span class="string">"Ending a session and starting anew"</span>);</div><div class="line"> <span class="number">9</span>:         lastReconnectTimeStamp = now;</div><div class="line"><span class="number">10</span>:         currentSessionDurationMs = randomizeSessionDuration(sessionDurationMs);</div><div class="line"><span class="number">11</span>:         TransportUtils.shutdown(eurekaHttpClientRef.getAndSet(<span class="keyword">null</span>));</div><div class="line"><span class="number">12</span>:     &#125;</div><div class="line"><span class="number">13</span>: </div><div class="line"><span class="number">14</span>:     <span class="comment">// 获得委托的 EurekaHttpClient 。若不存在，则创建新的委托的 EurekaHttpClient 。</span></div><div class="line"><span class="number">15</span>:     EurekaHttpClient eurekaHttpClient = eurekaHttpClientRef.get();</div><div class="line"><span class="number">16</span>:     <span class="keyword">if</span> (eurekaHttpClient == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">17</span>:         eurekaHttpClient = TransportUtils.getOrSetAnotherClient(eurekaHttpClientRef, clientFactory.newClient());</div><div class="line"><span class="number">18</span>:     &#125;</div><div class="line"><span class="number">19</span>:     <span class="keyword">return</span> requestExecutor.execute(eurekaHttpClient);</div><div class="line"><span class="number">20</span>: &#125;</div></pre></td></tr></table></figure><ul><li><p>第 7 至 12 行 ：超过当前会话时间，关闭当前委托的 EurekaHttpClient 。</p><ul><li><p>第 10 行 ：调用 <code>#randomizeSessionDuration(...)</code> 方法，计算计算下一次会话超时时长，公式为 <code>sessionDurationMs * (0.5, 1.5)</code> ，代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">randomizeSessionDuration</span><span class="params">(<span class="keyword">long</span> sessionDurationMs)</span> </span>&#123;</div><div class="line">   <span class="keyword">long</span> delta = (<span class="keyword">long</span>) (sessionDurationMs * (random.nextDouble() - <span class="number">0.5</span>));</div><div class="line">   <span class="keyword">return</span> sessionDurationMs + delta;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>增加会话过期的随机性，实现所有 Eureka-Client 的会话过期重连的发生时间更加离散，避免集中时间过期。目前猜测这么做的目的和 TODO[0028]：写入集群和读取集群 有关，即返回 302 。关联 <a href="https://github.com/Netflix/eureka/pull/687" rel="external nofollow noopener noreferrer" target="_blank">1.x new transport enhancements</a> 。</li></ul></li></ul></li><li><p>第 15 至 18 行 ：获得委托的 EurekaHttpClient 。若不存在，创建新的委托的 EurekaHttpClient 。<code>TransportUtils#getOrSetAnotherClient(...)</code> 方法代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EurekaHttpClient <span class="title">getOrSetAnotherClient</span><span class="params">(AtomicReference&lt;EurekaHttpClient&gt; eurekaHttpClientRef, EurekaHttpClient another)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     EurekaHttpClient existing = eurekaHttpClientRef.get();</div><div class="line"> <span class="number">3</span>:     <span class="comment">// 为空才设置</span></div><div class="line"> <span class="number">4</span>:     <span class="keyword">if</span> (eurekaHttpClientRef.compareAndSet(<span class="keyword">null</span>, another)) &#123;</div><div class="line"> <span class="number">5</span>:         <span class="keyword">return</span> another;</div><div class="line"> <span class="number">6</span>:     &#125;</div><div class="line"> <span class="number">7</span>:     <span class="comment">// 设置失败，意味着另外一个线程已经设置</span></div><div class="line"> <span class="number">8</span>:     another.shutdown();</div><div class="line"> <span class="number">9</span>:     <span class="keyword">return</span> existing;</div><div class="line"><span class="number">10</span>: &#125;</div></pre></td></tr></table></figure><ul><li>该方法实现，获得 <code>eurekaHttpClientRef</code> 里的 EurekaHttpClient 。若获取不到，将 <code>another</code> 设置到 <code>eurekaHttpClientRef</code> 。当有多个线程设置时，有且只有一个线程设置成功，另外的设置失败的线程们，意味着当前 <code>eurekaHttpClientRef</code> 有 EurekaHttpClient ，返回 <code>eurekaHttpClientRef</code> 。</li><li><p>目前该方法存在 BUG ，失败的线程直接返回 <code>existing</code> 的是 <code>null</code> ，需要修改成 <code>return eurekaHttpClientRef.get()</code> 。模拟重现该 BUG 代码如下 ：</p><p>  <img src="http://www.iocoder.cn/images/Eureka/2018_07_31/04.png" alt=""></p></li></ul></li><li><p>第 19 行 ：执行请求。</p></li></ul><h3 id="5-4-1-没有工厂"><a href="#5-4-1-没有工厂" class="headerlink" title="5.4.1 没有工厂"></a>5.4.1 没有工厂</h3><p>在 SessionedEurekaHttpClient 类里，没有实现创建其的工厂。在 <a href="#">「6. 创建网络通讯客户端」搜索 <code>canonicalClientFactory</code></a> ，可以看到 <code>EurekaHttpClients#canonicalClientFactory(...)</code> 方法，内部有 SessionedEurekaHttpClient 的创建工厂。</p><h1 id="6-创建网络通讯客户端"><a href="#6-创建网络通讯客户端" class="headerlink" title="6. 创建网络通讯客户端"></a>6. 创建网络通讯客户端</h1><p>对于 Eureka-Server 来说，调用 <code>JerseyReplicationClient#createReplicationClient(...)</code> <strong>静态方法</strong>即可创建用于 Eureka-Server 集群内，Eureka-Server 请求 <strong>其它的Eureka-Server</strong> 的网络通信客户端。</p><p>对于 Eureka-Client 来说，分成用于<strong>注册应用实例( <code>registrationClient</code> )</strong>和<strong>查询注册信息( <code>newQueryClient</code> )</strong>的<strong>两个不同</strong>网络通信客户端。在 DiscoveryClient 初始化时进行创建，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.class</span></div><div class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleServerEndpointTask</span><span class="params">(EurekaTransport eurekaTransport,</span></span></div><div class="line"><span class="function"><span class="params">  <span class="number">2</span>:                                         AbstractDiscoveryClientOptionalArgs args)</span> </span>&#123;</div><div class="line">  <span class="number">3</span>:         </div><div class="line">  <span class="number">4</span>:     Collection&lt;?&gt; additionalFilters = args == <span class="keyword">null</span></div><div class="line">  <span class="number">5</span>:             ? Collections.emptyList()</div><div class="line">  <span class="number">6</span>:             : args.additionalFilters;</div><div class="line">  <span class="number">7</span>: </div><div class="line">  <span class="number">8</span>:     EurekaJerseyClient providedJerseyClient = args == <span class="keyword">null</span></div><div class="line">  <span class="number">9</span>:             ? <span class="keyword">null</span></div><div class="line"> <span class="number">10</span>:             : args.eurekaJerseyClient;</div><div class="line"> <span class="number">11</span>:     </div><div class="line"> <span class="number">12</span>:     TransportClientFactories argsTransportClientFactories = <span class="keyword">null</span>;</div><div class="line"> <span class="number">13</span>:     <span class="keyword">if</span> (args != <span class="keyword">null</span> &amp;&amp; args.getTransportClientFactories() != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">14</span>:         argsTransportClientFactories = args.getTransportClientFactories();</div><div class="line"> <span class="number">15</span>:     &#125;</div><div class="line"> <span class="number">16</span>:     </div><div class="line"> <span class="number">17</span>:     <span class="comment">// Ignore the raw types warnings since the client filter interface changed between jersey 1/2</span></div><div class="line"> <span class="number">18</span>:     <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</div><div class="line"> <span class="number">19</span>:     TransportClientFactories transportClientFactories = argsTransportClientFactories == <span class="keyword">null</span></div><div class="line"> <span class="number">20</span>:             ? <span class="keyword">new</span> Jersey1TransportClientFactories()</div><div class="line"> <span class="number">21</span>:             : argsTransportClientFactories;</div><div class="line"> <span class="number">22</span>: </div><div class="line"> <span class="number">23</span>:     <span class="comment">// If the transport factory was not supplied with args, assume they are using jersey 1 for passivity</span></div><div class="line"> <span class="number">24</span>:     <span class="comment">// noinspection unchecked</span></div><div class="line"> <span class="number">25</span>:     eurekaTransport.transportClientFactory = providedJerseyClient == <span class="keyword">null</span></div><div class="line"> <span class="number">26</span>:             ? transportClientFactories.newTransportClientFactory(clientConfig, additionalFilters, applicationInfoManager.getInfo())</div><div class="line"> <span class="number">27</span>:             : transportClientFactories.newTransportClientFactory(additionalFilters, providedJerseyClient);</div><div class="line"> <span class="number">28</span>: </div><div class="line"> <span class="number">29</span>:     <span class="comment">// （省略代码）初始化 应用解析器的应用实例数据源 TODO[0028]写入集群和读取集群</span></div><div class="line"> <span class="number">30</span>: </div><div class="line"> <span class="number">31</span>:     <span class="comment">// （省略代码）创建 EndPoint 解析器</span></div><div class="line"> <span class="number">32</span>:     eurekaTransport.bootstrapResolver = EurekaHttpClients.newBootstrapResolver(...)</div><div class="line"> <span class="number">33</span>: </div><div class="line"> <span class="number">34</span>:     <span class="keyword">if</span> (clientConfig.shouldRegisterWithEureka()) &#123;</div><div class="line"> <span class="number">35</span>:         EurekaHttpClientFactory newRegistrationClientFactory = <span class="keyword">null</span>;</div><div class="line"> <span class="number">36</span>:         EurekaHttpClient newRegistrationClient = <span class="keyword">null</span>;</div><div class="line"> <span class="number">37</span>:         <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">38</span>:             newRegistrationClientFactory = EurekaHttpClients.registrationClientFactory(</div><div class="line"> <span class="number">39</span>:                     eurekaTransport.bootstrapResolver,</div><div class="line"> <span class="number">40</span>:                     eurekaTransport.transportClientFactory,</div><div class="line"> <span class="number">41</span>:                     transportConfig</div><div class="line"> <span class="number">42</span>:             );</div><div class="line"> <span class="number">43</span>:             newRegistrationClient = newRegistrationClientFactory.newClient();</div><div class="line"> <span class="number">44</span>:         &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"> <span class="number">45</span>:             logger.warn(<span class="string">"Transport initialization failure"</span>, e);</div><div class="line"> <span class="number">46</span>:         &#125;</div><div class="line"> <span class="number">47</span>:         eurekaTransport.registrationClientFactory = newRegistrationClientFactory;</div><div class="line"> <span class="number">48</span>:         eurekaTransport.registrationClient = newRegistrationClient;</div><div class="line"> <span class="number">49</span>:     &#125;</div><div class="line"> <span class="number">50</span>: </div><div class="line"> <span class="number">51</span>:     <span class="comment">// new method (resolve from primary servers for read)</span></div><div class="line"> <span class="number">52</span>:     <span class="comment">// Configure new transport layer (candidate for injecting in the future)</span></div><div class="line"> <span class="number">53</span>:     <span class="keyword">if</span> (clientConfig.shouldFetchRegistry()) &#123;</div><div class="line"> <span class="number">54</span>:         EurekaHttpClientFactory newQueryClientFactory = <span class="keyword">null</span>;</div><div class="line"> <span class="number">55</span>:         EurekaHttpClient newQueryClient = <span class="keyword">null</span>;</div><div class="line"> <span class="number">56</span>:         <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">57</span>:             newQueryClientFactory = EurekaHttpClients.queryClientFactory(</div><div class="line"> <span class="number">58</span>:                     eurekaTransport.bootstrapResolver,</div><div class="line"> <span class="number">59</span>:                     eurekaTransport.transportClientFactory,</div><div class="line"> <span class="number">60</span>:                     clientConfig,</div><div class="line"> <span class="number">61</span>:                     transportConfig,</div><div class="line"> <span class="number">62</span>:                     applicationInfoManager.getInfo(),</div><div class="line"> <span class="number">63</span>:                     applicationsSource</div><div class="line"> <span class="number">64</span>:             );</div><div class="line"> <span class="number">65</span>:             newQueryClient = newQueryClientFactory.newClient();</div><div class="line"> <span class="number">66</span>:         &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"> <span class="number">67</span>:             logger.warn(<span class="string">"Transport initialization failure"</span>, e);</div><div class="line"> <span class="number">68</span>:         &#125;</div><div class="line"> <span class="number">69</span>:         eurekaTransport.queryClientFactory = newQueryClientFactory;</div><div class="line"> <span class="number">70</span>:         eurekaTransport.queryClient = newQueryClient;</div><div class="line"> <span class="number">71</span>:     &#125;</div><div class="line"> <span class="number">72</span>: &#125;</div></pre></td></tr></table></figure><ul><li><p>第 18 至 27 行 ：调用 <code>Jersey1TransportClientFactories#newTransportClientFactory(...)</code> 方法，创建 <code>registrationClient</code> 和 <code>queryClient</code> 公用的委托的 EurekaHttpClientFactory ，代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Jersey1TransportClientFactories.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> TransportClientFactory <span class="title">newTransportClientFactory</span><span class="params">(<span class="keyword">final</span> EurekaClientConfig clientConfig,</span></span></div><div class="line"><span class="function"><span class="params">                                                              <span class="keyword">final</span> Collection&lt;ClientFilter&gt; additionalFilters,</span></span></div><div class="line"><span class="function"><span class="params">                                                              <span class="keyword">final</span> InstanceInfo myInstanceInfo)</span> </span>&#123;</div><div class="line">   <span class="comment">// JerseyEurekaHttpClientFactory</span></div><div class="line">   <span class="keyword">final</span> TransportClientFactory jerseyFactory = JerseyEurekaHttpClientFactory.create(</div><div class="line">           clientConfig,</div><div class="line">           additionalFilters,</div><div class="line">           myInstanceInfo,</div><div class="line">           <span class="keyword">new</span> EurekaClientIdentity(myInstanceInfo.getIPAddr())</div><div class="line">   );</div><div class="line"></div><div class="line">   <span class="comment">// TransportClientFactory</span></div><div class="line">   <span class="keyword">final</span> TransportClientFactory metricsFactory = MetricsCollectingEurekaHttpClient.createFactory(jerseyFactory); <span class="comment">// 委托 TransportClientFactory</span></div><div class="line"></div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> TransportClientFactory() &#123;</div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> EurekaHttpClient <span class="title">newClient</span><span class="params">(EurekaEndpoint serviceUrl)</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> metricsFactory.newClient(serviceUrl);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line">           metricsFactory.shutdown();</div><div class="line">           jerseyFactory.shutdown();</div><div class="line">       &#125;</div><div class="line">   &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>在 TransportClientFactory 里<strong>委托</strong> JerseyEurekaHttpClientFactory 。</li></ul></li><li><p>第 34 至 49 行 ：调用 <code>EurekaHttpClients#registrationClientFactory(...)</code> 方法，创建 <code>registrationClient</code> 的 EurekaHttpClientFactory ，代码如下 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// EurekaHttpClients.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EurekaHttpClientFactory <span class="title">registrationClientFactory</span><span class="params">(ClusterResolver bootstrapResolver,</span></span></div><div class="line"><span class="function"><span class="params">                                                                TransportClientFactory transportClientFactory,</span></span></div><div class="line"><span class="function"><span class="params">                                                                EurekaTransportConfig transportConfig)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> canonicalClientFactory(EurekaClientNames.REGISTRATION, transportConfig, bootstrapResolver, transportClientFactory);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> EurekaHttpClientFactory <span class="title">canonicalClientFactory</span><span class="params">(<span class="keyword">final</span> String name,</span></span></div><div class="line"><span class="function"><span class="params">                                                     <span class="keyword">final</span> EurekaTransportConfig transportConfig,</span></span></div><div class="line"><span class="function"><span class="params">                                                     <span class="keyword">final</span> ClusterResolver&lt;EurekaEndpoint&gt; clusterResolver,</span></span></div><div class="line"><span class="function"><span class="params">                                                     <span class="keyword">final</span> TransportClientFactory transportClientFactory)</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> EurekaHttpClientFactory() &#123; <span class="comment">// SessionedEurekaHttpClientFactory</span></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> EurekaHttpClient <span class="title">newClient</span><span class="params">()</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">new</span> SessionedEurekaHttpClient(</div><div class="line">                   name,</div><div class="line">                   RetryableEurekaHttpClient.createFactory( <span class="comment">// RetryableEurekaHttpClient</span></div><div class="line">                           name,</div><div class="line">                           transportConfig,</div><div class="line">                           clusterResolver,</div><div class="line">                           RedirectingEurekaHttpClient.createFactory(transportClientFactory), <span class="comment">// RedirectingEurekaHttpClient</span></div><div class="line">                           ServerStatusEvaluators.legacyEvaluator()),</div><div class="line">                   transportConfig.getSessionedClientReconnectIntervalSeconds() * <span class="number">1000</span></div><div class="line">           );</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line">           wrapClosable(clusterResolver).shutdown();</div><div class="line">       &#125;</div><div class="line">   &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>第 51 至 71 行 ：调用 <code>EurekaHttpClients#queryClientFactory(...)</code> 方法，创建 <code>queryClient</code> 的 EurekaHttpClientFactory ，代码如下 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// EurekaHttpClients.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EurekaHttpClientFactory <span class="title">queryClientFactory</span><span class="params">(ClusterResolver bootstrapResolver,</span></span></div><div class="line"><span class="function"><span class="params">                                                        TransportClientFactory transportClientFactory,</span></span></div><div class="line"><span class="function"><span class="params">                                                        EurekaClientConfig clientConfig,</span></span></div><div class="line"><span class="function"><span class="params">                                                        EurekaTransportConfig transportConfig,</span></span></div><div class="line"><span class="function"><span class="params">                                                        InstanceInfo myInstanceInfo,</span></span></div><div class="line"><span class="function"><span class="params">                                                        ApplicationsResolver.ApplicationsSource applicationsSource)</span> </span>&#123;</div><div class="line"></div><div class="line">   ClosableResolver queryResolver = transportConfig.useBootstrapResolverForQuery()</div><div class="line">           ? wrapClosable(bootstrapResolver)</div><div class="line">           : queryClientResolver(bootstrapResolver, transportClientFactory,</div><div class="line">           clientConfig, transportConfig, myInstanceInfo, applicationsSource);</div><div class="line">   <span class="keyword">return</span> canonicalClientFactory(EurekaClientNames.QUERY, transportConfig, queryResolver, transportClientFactory); <span class="comment">// 该方法上面有</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>这次真的是彩蛋，我们将整体调用关系调整如下如下( <a href="http://www.iocoder.cn/images/Eureka/2018_07_31/05.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_07_31/05.png" alt=""></p><p>胖友，你学会了么？</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/transport/&quot;&gt;http://www.iocoder.cn/Eureka/transport/&lt;/a&gt; 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;strong
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— EndPoint 与 解析器</title>
    <link href="http://www.iocoder.cn/Eureka/end-point-and-resolver/"/>
    <id>http://www.iocoder.cn/Eureka/end-point-and-resolver/</id>
    <published>2018-07-23T16:00:00.000Z</published>
    <updated>2017-10-16T11:13:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">http://www.iocoder.cn/Eureka/end-point-and-resolver/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">2. EndPoint</a><ul><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">2.1 EurekaEndpoint</a></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">2.2 DefaultEndpoint</a></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">2.3 AwsEndpoint</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">3. 解析器</a><ul><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">3.1 ClusterResolver</a></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">3.2 ClosableResolver</a></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">3.3 DnsTxtRecordClusterResolver</a></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">3.4 ConfigClusterResolver</a></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">3.5 ZoneAffinityClusterResolver</a></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">3.6 AsyncResolver</a><ul><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">3.6.1 定时任务</a></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">3.6.2 解析 EndPoint 集群</a></li></ul></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">4. 初始化解析器</a></li><li><a href="http://www.iocoder.cn/Eureka/end-point-and-resolver/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>EndPoint 与 解析器</strong>。</p><ul><li>EndPoint ，服务端点。例如，Eureka-Server 的访问地址。</li><li>EndPoint 解析器，将配置的 Eureka-Server 的访问地址解析成 EndPoint 。</li></ul><p>目前有多种 Eureka-Server 访问地址的配置方式，<strong>本文只分享 Eureka 1.x 的配置</strong>，不包含 Eureka 1.x 对 Eureka 2.x 的兼容配置：</p><ul><li>第一种，直接配置实际访问地址。例如，<code>eureka.serviceUrl.defaultZone=http://127.0.0.1:8080/v2</code> 。</li><li>第二种，基于 DNS 解析出访问地址。例如，<code>eureka.shouldUseDns=true</code> 并且  <code>eureka.eurekaServer.domainName=eureka.iocoder.cn</code> 。</li></ul><p>本文涉及类在 <code>com.netflix.discovery.shared.resolver</code> 包下，涉及到主体类的类图如下( <a href="http://www.iocoder.cn/images/Eureka/2018_07_24/01.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_07_24/01.png" alt=""></p><ul><li>红色部分 —— EndPoint</li><li>黄色部分 —— EndPoint 解析器</li></ul><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-EndPoint"><a href="#2-EndPoint" class="headerlink" title="2. EndPoint"></a>2. EndPoint</h1><h2 id="2-1-EurekaEndpoint"><a href="#2-1-EurekaEndpoint" class="headerlink" title="2.1 EurekaEndpoint"></a>2.1 EurekaEndpoint</h2><p><code>com.netflix.discovery.shared.resolver.EurekaEndpoint</code> ，Eureka 服务端点<strong>接口</strong>，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EurekaEndpoint</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 完整的服务 URL</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">String <span class="title">getServiceUrl</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@deprecated</span> use &#123;<span class="doctag">@link</span> #getNetworkAddress()&#125;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Deprecated</span></div><div class="line">    <span class="function">String <span class="title">getHostName</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 网络地址</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">String <span class="title">getNetworkAddress</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 端口</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 是否安全( https )</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSecure</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 相对路径</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">String <span class="title">getRelativeUri</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="2-2-DefaultEndpoint"><a href="#2-2-DefaultEndpoint" class="headerlink" title="2.2 DefaultEndpoint"></a>2.2 DefaultEndpoint</h2><p><code>com.netflix.discovery.shared.resolver.DefaultEndpoint</code> ，默认 Eureka 服务端点<strong>实现类</strong>。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultEndpoint</span> <span class="keyword">implements</span> <span class="title">EurekaEndpoint</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 网络地址</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String networkAddress;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 端口</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 是否安全( https )</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isSecure;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 相对地址</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String relativeUri;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 完整的服务 URL</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String serviceUrl;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultEndpoint</span><span class="params">(String serviceUrl)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.serviceUrl = serviceUrl;</div><div class="line"></div><div class="line">        <span class="comment">// 将 serviceUrl 分解成 几个属性</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            URL url = <span class="keyword">new</span> URL(serviceUrl);</div><div class="line">            <span class="keyword">this</span>.networkAddress = url.getHost();</div><div class="line">            <span class="keyword">this</span>.port = url.getPort();</div><div class="line">            <span class="keyword">this</span>.isSecure = <span class="string">"https"</span>.equals(url.getProtocol());</div><div class="line">            <span class="keyword">this</span>.relativeUri = url.getPath();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Malformed serviceUrl: "</span> + serviceUrl);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultEndpoint</span><span class="params">(String networkAddress, <span class="keyword">int</span> port, <span class="keyword">boolean</span> isSecure, String relativeUri)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.networkAddress = networkAddress;</div><div class="line">        <span class="keyword">this</span>.port = port;</div><div class="line">        <span class="keyword">this</span>.isSecure = isSecure;</div><div class="line">        <span class="keyword">this</span>.relativeUri = relativeUri;</div><div class="line"></div><div class="line">        <span class="comment">// 几个属性 拼接成 serviceUrl</span></div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder().append(isSecure ? <span class="string">"https"</span> : <span class="string">"http"</span>).append(<span class="string">"://"</span>).append(networkAddress);</div><div class="line"><span class="keyword">if</span> (port &gt;= <span class="number">0</span>) &#123;</div><div class="line">sb.append(<span class="string">':'</span>).append(port);</div><div class="line">&#125;</div><div class="line">        <span class="keyword">if</span> (relativeUri != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (!relativeUri.startsWith(<span class="string">"/"</span>)) &#123;</div><div class="line">                sb.append(<span class="string">'/'</span>);</div><div class="line">            &#125;</div><div class="line">            sb.append(relativeUri);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.serviceUrl = sb.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>重写了 <code>#equals(...)</code> 和 <code>#hashCode(...)</code> 方法，标准实现方式，这里就不贴代码了。</li><li>重写了 <code>#compareTo(...)</code> 方法，基于 <code>serviceUrl</code> 属性做比较。</li></ul><h2 id="2-3-AwsEndpoint"><a href="#2-3-AwsEndpoint" class="headerlink" title="2.3 AwsEndpoint"></a>2.3 AwsEndpoint</h2><p><code>com.netflix.discovery.shared.resolver.aws.AwsEndpoint</code> ，基于 <code>region</code>、<code>zone</code> 的 Eureka 服务端点<strong>实现类</strong> ( 请不要在意 AWS 开头 )。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AwsEndpoint</span> <span class="keyword">extends</span> <span class="title">DefaultEndpoint</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 区域</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String region;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 可用区</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String zone;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>重写了 <code>#equals(...)</code> 和 <code>#hashCode(...)</code> 方法，标准实现方式，这里就不贴代码了。</li></ul><h1 id="3-解析器"><a href="#3-解析器" class="headerlink" title="3. 解析器"></a>3. 解析器</h1><p>EndPoint 解析器使用<strong>委托设计模式</strong>实现。所以，上文图片中我们看到好多个解析器，<strong>实际代码非常非常非常清晰</strong>。</p><blockquote><p>FROM <a href="https://zh.wikipedia.org/wiki/%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F" rel="external nofollow noopener noreferrer" target="_blank">《委托模式》</a><br>委托模式是软件设计模式中的一项基本技巧。在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。委托模式是一项基本技巧，许多其他的模式，如状态模式、策略模式、访问者模式本质上是在更特殊的场合采用了委托模式。委托模式使得我们可以用聚合来替代继承，它还使我们可以模拟mixin。</p></blockquote><p>我们在上图的基础上，<strong>增加委托的关系</strong>，如下图：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_07_24/02.png" alt=""></p><h2 id="3-1-ClusterResolver"><a href="#3-1-ClusterResolver" class="headerlink" title="3.1 ClusterResolver"></a>3.1 ClusterResolver</h2><p><code>com.netflix.discovery.shared.resolver.ClusterResolver</code> ，集群解析器<strong>接口</strong>。接口代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClusterResolver</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">EurekaEndpoint</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 地区</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">String <span class="title">getRegion</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> EndPoint 集群( 数组 )</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">List&lt;T&gt; <span class="title">getClusterEndpoints</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3-2-ClosableResolver"><a href="#3-2-ClosableResolver" class="headerlink" title="3.2 ClosableResolver"></a>3.2 ClosableResolver</h2><p><code>com.netflix.discovery.shared.resolver.ClosableResolver</code> ，<strong>可关闭</strong>的解析器<strong>接口</strong>，继承自 ClusterResolver <strong>接口</strong>。接口代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClosableResolver</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">EurekaEndpoint</span>&gt; <span class="keyword">extends</span> <span class="title">ClusterResolver</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 关闭</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3-3-DnsTxtRecordClusterResolver"><a href="#3-3-DnsTxtRecordClusterResolver" class="headerlink" title="3.3 DnsTxtRecordClusterResolver"></a>3.3 DnsTxtRecordClusterResolver</h2><p><code>com.netflix.discovery.shared.resolver.aws.DnsTxtRecordClusterResolver</code> ，基于 DNS <strong>TXT</strong> 记录类型的集群解析器。<strong>类属性</strong>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DnsTxtRecordClusterResolver</span> <span class="keyword">implements</span> <span class="title">ClusterResolver</span>&lt;<span class="title">AwsEndpoint</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 地区</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String region;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 集群根地址，例如 txt.default.eureka.iocoder.cn</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String rootClusterDNS;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 是否解析可用区( zone )</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> extractZoneFromDNS;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 端口</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 是否安全</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isSecure;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 相对地址</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String relativeUri;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>DnsTxtRecordClusterResolver 通过集群根地址( <code>rootClusterDNS</code> ) 解析出 EndPoint 集群。需要在 DNS 配置<strong>两层</strong>解析记录：</p><ul><li>第一层 ：<ul><li>主机记录 ：格式为 <code>TXT.${REGION}.${自定义二级域名}</code> 。</li><li>记录类型 ：<strong>TXT 记录类型</strong>。</li><li>记录值 ：第二层的<strong>主机记录</strong>。如有多个第二层级，使用<strong>空格</strong>分隔。</li></ul></li><li>第二层：<ul><li>主机记录 ：格式为 <code>TXT.${ZONE}.${自定义二级域名}</code> 或者 <code>${ZONE}.${自定义二级域名}</code>。</li><li>记录类型 ：<strong>TXT 记录类型</strong>。</li><li>记录值 ：EndPoint 的网络地址。如有多个 EndPoint，使用<strong>空格</strong>分隔。<ul><li>举个例子：<br><img src="http://www.iocoder.cn/images/Eureka/2018_07_24/03.png" alt=""></li></ul></li></ul></li></ul></li><li><p><code>rootClusterDNS</code> ，集群根地址。例如：<code>txt.default.eureka.iocoder.cn</code>，其· <code>txt.default.eureka</code> 为 DNS 解析记录的第一层的<strong>主机记录</strong>。</p></li><li><code>region</code> ：地区。需要和 <code>rootClusterDNS</code> 的 <code>${REGION}</code> 一致。</li><li><code>extractZoneFromDNS</code> ：是否解析 DNS 解析记录的第二层级的<strong>主机记录</strong>的 <code>${ZONE}</code> 可用区。</li></ul><hr><p><code>#getClusterEndpoints(...)</code> 方法，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> List&lt;AwsEndpoint&gt; <span class="title">getClusterEndpoints</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     List&lt;AwsEndpoint&gt; eurekaEndpoints = resolve(region, rootClusterDNS, extractZoneFromDNS, port, isSecure, relativeUri);</div><div class="line"> <span class="number">4</span>:     <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line"> <span class="number">5</span>:         logger.debug(<span class="string">"Resolved &#123;&#125; to &#123;&#125;"</span>, rootClusterDNS, eurekaEndpoints);</div><div class="line"> <span class="number">6</span>:     &#125;</div><div class="line"> <span class="number">7</span>:     <span class="keyword">return</span> eurekaEndpoints;</div><div class="line"> <span class="number">8</span>: &#125;</div><div class="line"> <span class="number">9</span>: </div><div class="line"><span class="number">10</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;AwsEndpoint&gt; <span class="title">resolve</span><span class="params">(String region, String rootClusterDNS, <span class="keyword">boolean</span> extractZone, <span class="keyword">int</span> port, <span class="keyword">boolean</span> isSecure, String relativeUri)</span> </span>&#123;</div><div class="line"><span class="number">11</span>:     <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">12</span>:         <span class="comment">// 解析 第一层 DNS 记录</span></div><div class="line"><span class="number">13</span>:         Set&lt;String&gt; zoneDomainNames = resolve(rootClusterDNS);</div><div class="line"><span class="number">14</span>:         <span class="keyword">if</span> (zoneDomainNames.isEmpty()) &#123;</div><div class="line"><span class="number">15</span>:             <span class="keyword">throw</span> <span class="keyword">new</span> ClusterResolverException(<span class="string">"Cannot resolve Eureka cluster addresses; there are no data in TXT record for DN "</span> + rootClusterDNS);</div><div class="line"><span class="number">16</span>:         &#125;</div><div class="line"><span class="number">17</span>:         <span class="comment">// 记录 第二层 DNS 记录</span></div><div class="line"><span class="number">18</span>:         List&lt;AwsEndpoint&gt; endpoints = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="number">19</span>:         <span class="keyword">for</span> (String zoneDomain : zoneDomainNames) &#123;</div><div class="line"><span class="number">20</span>:             String zone = extractZone ? ResolverUtils.extractZoneFromHostName(zoneDomain) : <span class="keyword">null</span>; <span class="comment">// </span></div><div class="line"><span class="number">21</span>:             Set&lt;String&gt; zoneAddresses = resolve(zoneDomain);</div><div class="line"><span class="number">22</span>:             <span class="keyword">for</span> (String address : zoneAddresses) &#123;</div><div class="line"><span class="number">23</span>:                 endpoints.add(<span class="keyword">new</span> AwsEndpoint(address, port, isSecure, relativeUri, region, zone));</div><div class="line"><span class="number">24</span>:             &#125;</div><div class="line"><span class="number">25</span>:         &#125;</div><div class="line"><span class="number">26</span>:         <span class="keyword">return</span> endpoints;</div><div class="line"><span class="number">27</span>:     &#125; <span class="keyword">catch</span> (NamingException e) &#123;</div><div class="line"><span class="number">28</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> ClusterResolverException(<span class="string">"Cannot resolve Eureka cluster addresses for root: "</span> + rootClusterDNS, e);</div><div class="line"><span class="number">29</span>:     &#125;</div><div class="line"><span class="number">30</span>: &#125;</div></pre></td></tr></table></figure><ul><li><p>第 12 至 16 行 ：调用 <code>#resolve(rootClusterDNS)</code> 解析<strong>第一层</strong> DNS 记录。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Set&lt;String&gt; <span class="title">resolve</span><span class="params">(String rootClusterDNS)</span> <span class="keyword">throws</span> NamingException </span>&#123;</div><div class="line"> <span class="number">2</span>:     Set&lt;String&gt; result;</div><div class="line"> <span class="number">3</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">4</span>:         result = DnsResolver.getCNamesFromTxtRecord(rootClusterDNS);</div><div class="line"> <span class="number">5</span>:         <span class="comment">// TODO 芋艿：这块是bug，不需要这一段</span></div><div class="line"> <span class="number">6</span>:         <span class="keyword">if</span> (!rootClusterDNS.startsWith(<span class="string">"txt."</span>)) &#123;</div><div class="line"> <span class="number">7</span>:             result = DnsResolver.getCNamesFromTxtRecord(<span class="string">"txt."</span> + rootClusterDNS);</div><div class="line"> <span class="number">8</span>:         &#125;</div><div class="line"> <span class="number">9</span>:     &#125; <span class="keyword">catch</span> (NamingException e) &#123;</div><div class="line"><span class="number">10</span>:         <span class="keyword">if</span> (!rootClusterDNS.startsWith(<span class="string">"txt."</span>)) &#123;</div><div class="line"><span class="number">11</span>:             result = DnsResolver.getCNamesFromTxtRecord(<span class="string">"txt."</span> + rootClusterDNS);</div><div class="line"><span class="number">12</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">13</span>:             <span class="keyword">throw</span> e;</div><div class="line"><span class="number">14</span>:         &#125;</div><div class="line"><span class="number">15</span>:     &#125;</div><div class="line"><span class="number">16</span>:     <span class="keyword">return</span> result;</div><div class="line"><span class="number">17</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 4 行 ： 调用 <code>DnsResolver#getCNamesFromTxtRecord(...)</code> 方法，解析 TXT 主机记录。点击<a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-client/src/main/java/com/netflix/discovery/endpoint/DnsResolver.java#L126" rel="external nofollow noopener noreferrer" target="_blank">链接</a>查看带中文注释的 DnsResolver 的代码，比较解析，笔者就不啰嗦了。</li><li>第 5 至 8 行 ：当传递参数 <code>rootClusterDNS</code> 不以 <code>txt.</code> 开头时，即使第 4 行解析成功，也会报错，此时是个 Eureka 的 BUG 。因此，配置 DNS 解析记录时，主机记录暂时必须以 <code>txt.</code> 开头。</li></ul></li><li><p>第 17 至 25 行 ：循环第一层 DNS 记录的解析结果，进一步解析第二层 DNS 记录。</p><ul><li>第 20 行 ：解析可用区( <code>zone</code> )。</li><li>第 21 行 ：调用 <code>#resolve(rootClusterDNS)</code> 解析<strong>第二层</strong> DNS 记录。 </li></ul></li></ul><h2 id="3-4-ConfigClusterResolver"><a href="#3-4-ConfigClusterResolver" class="headerlink" title="3.4 ConfigClusterResolver"></a>3.4 ConfigClusterResolver</h2><p><code>com.netflix.discovery.shared.resolver.aws.ConfigClusterResolver</code> ，基于<strong>配置文件</strong>的集群解析器。<strong>类属性</strong>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClusterResolver</span> <span class="keyword">implements</span> <span class="title">ClusterResolver</span>&lt;<span class="title">AwsEndpoint</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EurekaClientConfig clientConfig;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InstanceInfo myInstanceInfo;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConfigClusterResolver</span><span class="params">(EurekaClientConfig clientConfig, InstanceInfo myInstanceInfo)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.clientConfig = clientConfig;</div><div class="line">        <span class="keyword">this</span>.myInstanceInfo = myInstanceInfo;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><p><code>#getClusterEndpoints(...)</code> 方法，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> List&lt;AwsEndpoint&gt; <span class="title">getClusterEndpoints</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="comment">// 使用 DNS 获取 EndPoint</span></div><div class="line"> <span class="number">4</span>:     <span class="keyword">if</span> (clientConfig.shouldUseDnsForFetchingServiceUrls()) &#123;</div><div class="line"> <span class="number">5</span>:         <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</div><div class="line"> <span class="number">6</span>:             logger.info(<span class="string">"Resolving eureka endpoints via DNS: &#123;&#125;"</span>, getDNSName());</div><div class="line"> <span class="number">7</span>:         &#125;</div><div class="line"> <span class="number">8</span>:         <span class="keyword">return</span> getClusterEndpointsFromDns();</div><div class="line"> <span class="number">9</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">10</span>:     <span class="comment">// 直接配置实际访问地址</span></div><div class="line"><span class="number">11</span>:         logger.info(<span class="string">"Resolving eureka endpoints via configuration"</span>);</div><div class="line"><span class="number">12</span>:         <span class="keyword">return</span> getClusterEndpointsFromConfig();</div><div class="line"><span class="number">13</span>:     &#125;</div><div class="line"><span class="number">14</span>: &#125;</div></pre></td></tr></table></figure><ul><li><p>第 3 至 8 行 ：基于 DNS 获取 EndPoint 集群，调用 <code>#getClusterEndpointsFromDns()</code> 方法，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> List&lt;AwsEndpoint&gt; <span class="title">getClusterEndpointsFromDns</span><span class="params">()</span> </span>&#123;</div><div class="line">   String discoveryDnsName = getDNSName(); <span class="comment">// 获取 集群根地址</span></div><div class="line">   <span class="keyword">int</span> port = Integer.parseInt(clientConfig.getEurekaServerPort()); <span class="comment">// 端口</span></div><div class="line"></div><div class="line">   <span class="comment">// cheap enough so just re-use</span></div><div class="line">   DnsTxtRecordClusterResolver dnsResolver = <span class="keyword">new</span> DnsTxtRecordClusterResolver(</div><div class="line">           getRegion(),</div><div class="line">           discoveryDnsName,</div><div class="line">           <span class="keyword">true</span>, <span class="comment">// 解析 zone</span></div><div class="line">           port,</div><div class="line">           <span class="keyword">false</span>,</div><div class="line">           clientConfig.getEurekaServerURLContext()</div><div class="line">   );</div><div class="line"></div><div class="line">   <span class="comment">// 调用 DnsTxtRecordClusterResolver 解析 EndPoint</span></div><div class="line">   List&lt;AwsEndpoint&gt; endpoints = dnsResolver.getClusterEndpoints();</div><div class="line"></div><div class="line">   <span class="keyword">if</span> (endpoints.isEmpty()) &#123;</div><div class="line">       logger.error(<span class="string">"Cannot resolve to any endpoints for the given dnsName: &#123;&#125;"</span>, discoveryDnsName);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">return</span> endpoints;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getDNSName</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="string">"txt."</span> + getRegion() + <span class="string">'.'</span> + clientConfig.getEurekaServerDNSName();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>必须配置 <code>eureka.shouldUseDns=true</code> ，开启基于 DNS 获取 EndPoint 集群。</li><li>必须配置 <code>eureka.eurekaServer.domainName=${xxxxx}</code> ，配置集群根地址。</li><li>选填配 <code>eureka.eurekaServer.port</code> ，<code>eureka.eurekaServer.context</code> 。</li><li>从代码中我们可以看出，使用 DnsTxtRecordClusterResolver 解析出 EndPoint 集群。</li></ul></li><li><p>第 9 至 13 行 ：直接<strong>配置文件</strong>填写实际 EndPoint 集群，调用 <code>#getClusterEndpointsFromConfig()</code> 方法，实现代码如下：</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> List&lt;AwsEndpoint&gt; <span class="title">getClusterEndpointsFromConfig</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// 获得 可用区</span></div><div class="line"> <span class="number">3</span>:     String[] availZones = clientConfig.getAvailabilityZones(clientConfig.getRegion());</div><div class="line"> <span class="number">4</span>:     <span class="comment">// 获取 应用实例自己 的 可用区</span></div><div class="line"> <span class="number">5</span>:     String myZone = InstanceInfo.getZone(availZones, myInstanceInfo);</div><div class="line"> <span class="number">6</span>:     <span class="comment">// 获得 可用区与 serviceUrls 的映射</span></div><div class="line"> <span class="number">7</span>:     Map&lt;String, List&lt;String&gt;&gt; serviceUrls = EndpointUtils.getServiceUrlsMapFromConfig(clientConfig, myZone, clientConfig.shouldPreferSameZoneEureka());</div><div class="line"> <span class="number">8</span>:     <span class="comment">// 拼装 EndPoint 集群结果</span></div><div class="line"> <span class="number">9</span>:     List&lt;AwsEndpoint&gt; endpoints = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="number">10</span>:     <span class="keyword">for</span> (String zone : serviceUrls.keySet()) &#123;</div><div class="line"><span class="number">11</span>:         <span class="keyword">for</span> (String url : serviceUrls.get(zone)) &#123;</div><div class="line"><span class="number">12</span>:             <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">13</span>:                 endpoints.add(<span class="keyword">new</span> AwsEndpoint(url, getRegion(), zone));</div><div class="line"><span class="number">14</span>:             &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</div><div class="line"><span class="number">15</span>:                 logger.warn(<span class="string">"Invalid eureka server URI: &#123;&#125;; removing from the server pool"</span>, url);</div><div class="line"><span class="number">16</span>:             &#125;</div><div class="line"><span class="number">17</span>:         &#125;</div><div class="line"><span class="number">18</span>:     &#125;</div><div class="line"><span class="number">19</span>: </div><div class="line"><span class="number">20</span>:     <span class="comment">// 打印日志，EndPoint 集群</span></div><div class="line"><span class="number">21</span>:     <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line"><span class="number">22</span>:         logger.debug(<span class="string">"Config resolved to &#123;&#125;"</span>, endpoints);</div><div class="line"><span class="number">23</span>:     &#125;</div><div class="line"><span class="number">24</span>:     <span class="comment">// 打印日志，解析结果为空</span></div><div class="line"><span class="number">25</span>:     <span class="keyword">if</span> (endpoints.isEmpty()) &#123;</div><div class="line"><span class="number">26</span>:         logger.error(<span class="string">"Cannot resolve to any endpoints from provided configuration: &#123;&#125;"</span>, serviceUrls);</div><div class="line"><span class="number">27</span>:     &#125;</div><div class="line"><span class="number">28</span>: </div><div class="line"><span class="number">29</span>:     <span class="keyword">return</span> endpoints;</div><div class="line"><span class="number">30</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 3 行 ：获得可用区数组。通过 <code>eureka.${REGION}.availabilityZones</code> 配置。</li><li>第 5 行 ：调用 <code>InstanceInfo#getZone(...)</code> 方法，获得<strong>应用实例自己所在的可用区</strong>( <code>zone</code> )。非亚马逊 AWS 环境下，可用区数组的第一个元素就是<strong>应用实例自己所在的可用区</strong>。</li><li><p>第 7 行 ：调用 <code>EndpointUtils#getServiceUrlsMapFromConfig(...)</code> 方法，获得可用区与 <code>serviceUrls</code> 的映射。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// EndpointUtils.java</span></div><div class="line">  <span class="number">1</span>: <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; getServiceUrlsMapFromConfig(EurekaClientConfig clientConfig, String instanceZone, <span class="keyword">boolean</span> preferSameZone) &#123;</div><div class="line">  <span class="number">2</span>:     Map&lt;String, List&lt;String&gt;&gt; orderedUrls = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(); <span class="comment">// key：zone；value：serviceUrls</span></div><div class="line">  <span class="number">3</span>:     <span class="comment">// 获得 应用实例的 地区( region )</span></div><div class="line">  <span class="number">4</span>:     String region = getRegion(clientConfig);</div><div class="line">  <span class="number">5</span>:     <span class="comment">// 获得 应用实例的 可用区</span></div><div class="line">  <span class="number">6</span>:     String[] availZones = clientConfig.getAvailabilityZones(clientConfig.getRegion());</div><div class="line">  <span class="number">7</span>:     <span class="keyword">if</span> (availZones == <span class="keyword">null</span> || availZones.length == <span class="number">0</span>) &#123;</div><div class="line">  <span class="number">8</span>:         availZones = <span class="keyword">new</span> String[<span class="number">1</span>];</div><div class="line">  <span class="number">9</span>:         availZones[<span class="number">0</span>] = DEFAULT_ZONE;</div><div class="line"> <span class="number">10</span>:     &#125;</div><div class="line"> <span class="number">11</span>:     logger.debug(<span class="string">"The availability zone for the given region &#123;&#125; are &#123;&#125;"</span>, region, Arrays.toString(availZones));</div><div class="line"> <span class="number">12</span>:     <span class="comment">// 获得 开始位置</span></div><div class="line"> <span class="number">13</span>:     <span class="keyword">int</span> myZoneOffset = getZoneOffset(instanceZone, preferSameZone, availZones);</div><div class="line"> <span class="number">14</span>:     <span class="comment">// 将 开始位置 的 serviceUrls 添加到结果</span></div><div class="line"> <span class="number">15</span>:     String zone = availZones[myZoneOffset];</div><div class="line"> <span class="number">16</span>:     List&lt;String&gt; serviceUrls = clientConfig.getEurekaServerServiceUrls(zone);</div><div class="line"> <span class="number">17</span>:     <span class="keyword">if</span> (serviceUrls != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">18</span>:         orderedUrls.put(zone, serviceUrls);</div><div class="line"> <span class="number">19</span>:     &#125;</div><div class="line"> <span class="number">20</span>:     <span class="comment">// 从开始位置顺序遍历剩余的 serviceUrls 添加到结果</span></div><div class="line"> <span class="number">21</span>:     <span class="keyword">int</span> currentOffset = myZoneOffset == (availZones.length - <span class="number">1</span>) ? <span class="number">0</span> : (myZoneOffset + <span class="number">1</span>);</div><div class="line"> <span class="number">22</span>:     <span class="keyword">while</span> (currentOffset != myZoneOffset) &#123;</div><div class="line"> <span class="number">23</span>:         zone = availZones[currentOffset];</div><div class="line"> <span class="number">24</span>:         serviceUrls = clientConfig.getEurekaServerServiceUrls(zone);</div><div class="line"> <span class="number">25</span>:         <span class="keyword">if</span> (serviceUrls != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">26</span>:             orderedUrls.put(zone, serviceUrls);</div><div class="line"> <span class="number">27</span>:         &#125;</div><div class="line"> <span class="number">28</span>:         <span class="keyword">if</span> (currentOffset == (availZones.length - <span class="number">1</span>)) &#123;</div><div class="line"> <span class="number">29</span>:             currentOffset = <span class="number">0</span>;</div><div class="line"> <span class="number">30</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">31</span>:             currentOffset++;</div><div class="line"> <span class="number">32</span>:         &#125;</div><div class="line"> <span class="number">33</span>:     &#125;</div><div class="line"> <span class="number">34</span>: </div><div class="line"> <span class="number">35</span>:     <span class="comment">// 为空，报错</span></div><div class="line"> <span class="number">36</span>:     <span class="keyword">if</span> (orderedUrls.size() &lt; <span class="number">1</span>) &#123;</div><div class="line"> <span class="number">37</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"DiscoveryClient: invalid serviceUrl specified!"</span>);</div><div class="line"> <span class="number">38</span>:     &#125;</div><div class="line"> <span class="number">39</span>:     <span class="keyword">return</span> orderedUrls;</div><div class="line"> <span class="number">40</span>: &#125;</div></pre></td></tr></table></figure><ul><li><p>第 13 行 ：获得<strong>开始位置</strong>。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getZoneOffset</span><span class="params">(String myZone, <span class="keyword">boolean</span> preferSameZone, String[] availZones)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; availZones.length; i++) &#123;</div><div class="line">       <span class="keyword">if</span> (myZone != <span class="keyword">null</span> &amp;&amp; (availZones[i].equalsIgnoreCase(myZone.trim()) == preferSameZone)) &#123;</div><div class="line">           <span class="keyword">return</span> i;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   logger.warn(<span class="string">"DISCOVERY: Could not pick a zone based on preferred zone settings. My zone - &#123;&#125;,"</span> +</div><div class="line">           <span class="string">" preferSameZone- &#123;&#125;. Defaulting to "</span> + availZones[<span class="number">0</span>], myZone, preferSameZone);</div><div class="line"></div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>当方法参数 <code>preferSameZone=true</code> ，即 <code>eureka.preferSameZone=true</code>( 默认值 ：<code>true</code> ) 时，<strong>开始位置</strong>为可用区数组( <code>availZones</code> )的<strong>第一个</strong>和应用实例所在的可用区( <code>myZone</code> )【<strong>相等</strong>】元素的位置。</li><li>当方法参数 <code>preferSameZone=false</code> ，即 <code>eureka.preferSameZone=false</code>( 默认值 ：<code>true</code> ) 时，<strong>开始位置</strong>为可用区数组( <code>availZones</code> )的<strong>第一个</strong>和应用实例所在的可用区( <code>myZone</code> )【<strong>不相等</strong>】元素的位置。</li></ul></li><li><p>第 20 至 33 行 ：从开始位置<strong>顺序</strong>将剩余的可用区的 <code>serviceUrls</code> 添加到结果。<strong>顺序</strong>理解如下图：<br>  <img src="http://www.iocoder.cn/images/Eureka/2018_07_24/04.png" alt=""></p></li></ul></li><li><p>第 9 至 18 行 ：拼装 EndPoint 集群结果。</p></li></ul><h2 id="3-5-ZoneAffinityClusterResolver"><a href="#3-5-ZoneAffinityClusterResolver" class="headerlink" title="3.5 ZoneAffinityClusterResolver"></a>3.5 ZoneAffinityClusterResolver</h2><p><code>com.netflix.discovery.shared.resolver.aws.ZoneAffinityClusterResolver</code> ，使用可用区亲和的集群解析器。<strong>类属性</strong>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZoneAffinityClusterResolver</span> <span class="keyword">implements</span> <span class="title">ClusterResolver</span>&lt;<span class="title">AwsEndpoint</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ZoneAffinityClusterResolver.class);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 委托的解析器</span></div><div class="line"><span class="comment">     * 目前代码里为 &#123;<span class="doctag">@link</span> ConfigClusterResolver&#125;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClusterResolver&lt;AwsEndpoint&gt; delegate;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用实例的可用区</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String myZone;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 是否可用区亲和</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> zoneAffinity;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZoneAffinityClusterResolver</span><span class="params">(ClusterResolver&lt;AwsEndpoint&gt; delegate, String myZone, <span class="keyword">boolean</span> zoneAffinity)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.delegate = delegate;</div><div class="line">        <span class="keyword">this</span>.myZone = myZone;</div><div class="line">        <span class="keyword">this</span>.zoneAffinity = zoneAffinity;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>属性 <code>delegate</code> ，委托的解析器。目前代码里使用的是 ConfigClusterResolver 。</li><li>属性 <code>zoneAffinity</code> ，是否可用区亲和。<ul><li><code>true</code> ：EndPoint 可用区为<strong>本地</strong>的优先被放在前面。</li><li><code>false</code> ：EndPoint 可用区<strong>非本地</strong>的优先被放在前面。 </li></ul></li></ul><p><code>#getClusterEndpoints(...)</code> 方法，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> List&lt;AwsEndpoint&gt; <span class="title">getClusterEndpoints</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="comment">// 拆分成 本地的可用区和非本地的可用区的 EndPoint 集群</span></div><div class="line"> <span class="number">4</span>:     List&lt;AwsEndpoint&gt;[] parts = ResolverUtils.splitByZone(delegate.getClusterEndpoints(), myZone);</div><div class="line"> <span class="number">5</span>:     List&lt;AwsEndpoint&gt; myZoneEndpoints = parts[<span class="number">0</span>];</div><div class="line"> <span class="number">6</span>:     List&lt;AwsEndpoint&gt; remainingEndpoints = parts[<span class="number">1</span>];</div><div class="line"> <span class="number">7</span>:     <span class="comment">// 随机打乱 EndPoint 集群并进行合并</span></div><div class="line"> <span class="number">8</span>:     List&lt;AwsEndpoint&gt; randomizedList = randomizeAndMerge(myZoneEndpoints, remainingEndpoints);</div><div class="line"> <span class="number">9</span>:     <span class="comment">// 非可用区亲和，将非本地的可用区的 EndPoint 集群放在前面</span></div><div class="line"><span class="number">10</span>:     <span class="keyword">if</span> (!zoneAffinity) &#123;</div><div class="line"><span class="number">11</span>:         Collections.reverse(randomizedList);</div><div class="line"><span class="number">12</span>:     &#125;</div><div class="line"><span class="number">13</span>: </div><div class="line"><span class="number">14</span>:     <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line"><span class="number">15</span>:         logger.debug(<span class="string">"Local zone=&#123;&#125;; resolved to: &#123;&#125;"</span>, myZone, randomizedList);</div><div class="line"><span class="number">16</span>:     &#125;</div><div class="line"><span class="number">17</span>: </div><div class="line"><span class="number">18</span>:     <span class="keyword">return</span> randomizedList;</div><div class="line"><span class="number">19</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 2 行 ：调用 <code>ClusterResolver#getClusterEndpoints()</code> 方法，获得 EndPoint 集群。再调用 <code>ResolverUtils#splitByZone(...)</code> 方法，拆分成<strong>本地</strong>和<strong>非本地</strong>的可用区的 EndPoint 集群，点击<a href="https://github.com/YunaiV/eureka/blob/69993ad1e80d45c43ac8585921eca4efb88b09b9/eureka-client/src/main/java/com/netflix/discovery/shared/resolver/ResolverUtils.java#L55" rel="external nofollow noopener noreferrer" target="_blank">链接</a>查看实现。</li><li><p>第 8 行 ：调用 <code>#randomizeAndMerge(...)</code> 方法，<strong>分别</strong>随机打乱<strong>每个</strong> EndPoint 集群，并进行<strong>合并</strong>数组，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ZoneAffinityClusterResolver.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;AwsEndpoint&gt; <span class="title">randomizeAndMerge</span><span class="params">(List&lt;AwsEndpoint&gt; myZoneEndpoints, List&lt;AwsEndpoint&gt; remainingEndpoints)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (myZoneEndpoints.isEmpty()) &#123;</div><div class="line">       <span class="keyword">return</span> ResolverUtils.randomize(remainingEndpoints); <span class="comment">// 打乱</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (remainingEndpoints.isEmpty()) &#123;</div><div class="line">       <span class="keyword">return</span> ResolverUtils.randomize(myZoneEndpoints); <span class="comment">// 打乱</span></div><div class="line">   &#125;</div><div class="line">   List&lt;AwsEndpoint&gt; mergedList = ResolverUtils.randomize(myZoneEndpoints); <span class="comment">// 打乱</span></div><div class="line">   mergedList.addAll(ResolverUtils.randomize(remainingEndpoints)); <span class="comment">// 打乱</span></div><div class="line">   <span class="keyword">return</span> mergedList;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ResolverUtils.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends EurekaEndpoint&gt; <span class="function">List&lt;T&gt; <span class="title">randomize</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</div><div class="line">   <span class="comment">// 数组大小为 0 或者 1 ，不进行打乱</span></div><div class="line">   List&lt;T&gt; randomList = <span class="keyword">new</span> ArrayList&lt;&gt;(list);</div><div class="line">   <span class="keyword">if</span> (randomList.size() &lt; <span class="number">2</span>) &#123;</div><div class="line">       <span class="keyword">return</span> randomList;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 以本地IP为随机种子，有如下好处：</span></div><div class="line">   <span class="comment">// 多个主机，实现对同一个 EndPoint 集群负载均衡的效果。</span></div><div class="line">   <span class="comment">// 单个主机，同一个 EndPoint 集群按照固定顺序访问。Eureka-Server 不是强一致性的注册中心，Eureka-Client 对同一个 Eureka-Server 拉取注册信息，保证两者之间增量同步的一致性。</span></div><div class="line">   Random random = <span class="keyword">new</span> Random(LOCAL_IPV4_ADDRESS.hashCode());</div><div class="line">   <span class="keyword">int</span> last = randomList.size() - <span class="number">1</span>;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; last; i++) &#123;</div><div class="line">       <span class="keyword">int</span> pos = random.nextInt(randomList.size() - i);</div><div class="line">       <span class="keyword">if</span> (pos != i) &#123;</div><div class="line">           Collections.swap(randomList, i, pos);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> randomList;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>注意，<code>ResolverUtils#randomize(...)</code> 使用以本机IP为随机种子</strong>，有如下好处：<ul><li>多个主机，实现对同一个 EndPoint 集群负载均衡的效果。</li><li>单个主机，同一个 EndPoint 集群按照固定顺序访问。Eureka-Server 不是强一致性的注册中心，Eureka-Client 对同一个 Eureka-Server 拉取注册信息，保证两者之间增量同步的一致性。</li></ul></li></ul></li><li><p>第 10 至 12 行 ：非可用区亲和，将非本地的可用区的 EndPoint 集群放在前面。</p></li></ul><h2 id="3-6-AsyncResolver"><a href="#3-6-AsyncResolver" class="headerlink" title="3.6 AsyncResolver"></a>3.6 AsyncResolver</h2><p><code>com.netflix.discovery.shared.resolver.AsyncResolver</code> ，<strong>异步执行</strong>解析的集群解析器。AsyncResolver 属性较多，而且复杂的多，我们拆分到具体方法里分享。</p><h3 id="3-6-1-定时任务"><a href="#3-6-1-定时任务" class="headerlink" title="3.6.1 定时任务"></a>3.6.1 定时任务</h3><p>AsyncResolver 内置定时任务，<strong>定时</strong>刷新 EndPoint 集群解析结果。</p><p><strong>为什么要刷新</strong>？例如，Eureka-Server 的 <code>serviceUrls</code> 基于 DNS 配置。</p><p><strong>定时任务代码如下</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 是否已经调度定时任务 &#123;<span class="doctag">@link</span> #updateTask&#125;</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean scheduled = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 委托的解析器</span></div><div class="line"><span class="comment">* 目前代码为 &#123;<span class="doctag">@link</span> com.netflix.discovery.shared.resolver.aws.ZoneAffinityClusterResolver&#125;</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClusterResolver&lt;T&gt; delegate;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 定时服务</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService executorService;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 线程池执行器</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor threadPoolExecutor;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 后台任务</span></div><div class="line"><span class="comment">* 定时解析 EndPoint 集群</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> TimedSupervisorTask backgroundTask;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 解析 EndPoint 集群结果</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;List&lt;T&gt;&gt; resultsRef;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 定时解析 EndPoint 集群的频率</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> refreshIntervalMs;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 预热超时时间，单位：毫秒</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> warmUpTimeoutMs;</div><div class="line"></div><div class="line"><span class="comment">// Metric timestamp, tracking last time when data were effectively changed.</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastLoadTimestamp = -<span class="number">1</span>;</div><div class="line"></div><div class="line">AsyncResolver(String name,</div><div class="line">             ClusterResolver&lt;T&gt; delegate,</div><div class="line">             List&lt;T&gt; initialValue,</div><div class="line">             <span class="keyword">int</span> executorThreadPoolSize,</div><div class="line">             <span class="keyword">int</span> refreshIntervalMs,</div><div class="line">             <span class="keyword">int</span> warmUpTimeoutMs) &#123;</div><div class="line">   <span class="keyword">this</span>.name = name;</div><div class="line">   <span class="keyword">this</span>.delegate = delegate;</div><div class="line">   <span class="keyword">this</span>.refreshIntervalMs = refreshIntervalMs;</div><div class="line">   <span class="keyword">this</span>.warmUpTimeoutMs = warmUpTimeoutMs;</div><div class="line"></div><div class="line">   <span class="comment">// 初始化 定时服务</span></div><div class="line">   <span class="keyword">this</span>.executorService = Executors.newScheduledThreadPool(<span class="number">1</span>, <span class="comment">// 线程大小=1</span></div><div class="line">           <span class="keyword">new</span> ThreadFactoryBuilder()</div><div class="line">                   .setNameFormat(<span class="string">"AsyncResolver-"</span> + name + <span class="string">"-%d"</span>)</div><div class="line">                   .setDaemon(<span class="keyword">true</span>)</div><div class="line">                   .build());</div><div class="line"></div><div class="line">   <span class="comment">// 初始化 线程池执行器</span></div><div class="line">   <span class="keyword">this</span>.threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</div><div class="line">           <span class="number">1</span>, <span class="comment">// 线程大小=1</span></div><div class="line">           executorThreadPoolSize, <span class="number">0</span>, TimeUnit.SECONDS,</div><div class="line">           <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),  <span class="comment">// use direct handoff</span></div><div class="line">           <span class="keyword">new</span> ThreadFactoryBuilder()</div><div class="line">                   .setNameFormat(<span class="string">"AsyncResolver-"</span> + name + <span class="string">"-executor-%d"</span>)</div><div class="line">                   .setDaemon(<span class="keyword">true</span>)</div><div class="line">                   .build()</div><div class="line">   );</div><div class="line"></div><div class="line">   <span class="comment">// 初始化 后台任务</span></div><div class="line">   <span class="keyword">this</span>.backgroundTask = <span class="keyword">new</span> TimedSupervisorTask(</div><div class="line">           <span class="keyword">this</span>.getClass().getSimpleName(),</div><div class="line">           executorService,</div><div class="line">           threadPoolExecutor,</div><div class="line">           refreshIntervalMs,</div><div class="line">           TimeUnit.MILLISECONDS,</div><div class="line">           <span class="number">5</span>,</div><div class="line">           updateTask</div><div class="line">   );</div><div class="line"></div><div class="line">   <span class="keyword">this</span>.resultsRef = <span class="keyword">new</span> AtomicReference&lt;&gt;(initialValue);</div><div class="line">   Monitors.registerObject(name, <span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p><code>backgroundTask</code> ，后台任务，定时解析 EndPoint 集群。</p><ul><li>TimedSupervisorTask ，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-renew/?self">《Eureka 源码解析 —— 应用实例注册发现（二）之续租》「2.3 TimedSupervisorTask」</a> 有详细解析。</li><li><p><code>updateTask</code> 实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable updateTask = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            List&lt;T&gt; newList = delegate.getClusterEndpoints(); <span class="comment">// 调用 委托的解析器 解析 EndPoint 集群</span></div><div class="line">            <span class="keyword">if</span> (newList != <span class="keyword">null</span>) &#123;</div><div class="line">                resultsRef.getAndSet(newList);</div><div class="line">                lastLoadTimestamp = System.currentTimeMillis();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                logger.warn(<span class="string">"Delegate returned null list of cluster endpoints"</span>);</div><div class="line">            &#125;</div><div class="line">            logger.debug(<span class="string">"Resolved to &#123;&#125;"</span>, newList);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            logger.warn(<span class="string">"Failed to retrieve cluster endpoints from the delegate"</span>, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><ul><li><code>delegate</code> ，委托的解析器，目前代码为 ZoneAffinityClusterResolver。</li></ul></li><li><p>后台任务的<strong>发起</strong>在 <code>#getClusterEndpoints()</code> 方法，在 <a href="#">「3.6.2 解析 EndPoint 集群」</a> 详细解析。</p></li></ul></li></ul><h3 id="3-6-2-解析-EndPoint-集群"><a href="#3-6-2-解析-EndPoint-集群" class="headerlink" title="3.6.2 解析 EndPoint 集群"></a>3.6.2 解析 EndPoint 集群</h3><p>调用 <code>#getClusterEndpoints()</code> 方法，解析 EndPoint 集群，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getClusterEndpoints</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="keyword">long</span> delay = refreshIntervalMs;</div><div class="line"> <span class="number">4</span>:     <span class="comment">// 若未预热解析 EndPoint 集群结果，进行预热</span></div><div class="line"> <span class="number">5</span>:     <span class="keyword">if</span> (warmedUp.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</div><div class="line"> <span class="number">6</span>:         <span class="keyword">if</span> (!doWarmUp()) &#123;</div><div class="line"> <span class="number">7</span>:             delay = <span class="number">0</span>; <span class="comment">// 预热失败，取消定时任务的第一次延迟</span></div><div class="line"> <span class="number">8</span>:         &#125;</div><div class="line"> <span class="number">9</span>:     &#125;</div><div class="line"><span class="number">10</span>:     <span class="comment">// 若未调度定时任务，进行调度</span></div><div class="line"><span class="number">11</span>:     <span class="keyword">if</span> (scheduled.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</div><div class="line"><span class="number">12</span>:         scheduleTask(delay);</div><div class="line"><span class="number">13</span>:     &#125;</div><div class="line"><span class="number">14</span>:     <span class="comment">// 返回 EndPoint 集群</span></div><div class="line"><span class="number">15</span>:     <span class="keyword">return</span> resultsRef.get();</div><div class="line"><span class="number">16</span>: &#125;</div></pre></td></tr></table></figure><ul><li><p>第 5 至 9 行 ：<strong>若未预热解析 EndPoint 集群结果</strong>，调用 <code>#doWarmUp()</code> 方法，进行预热。若预热失败，取消定时任务的第一次延迟。<code>#doWarmUp()</code> 方法实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">doWarmUp</span><span class="params">()</span> </span>&#123;</div><div class="line">   Future future = <span class="keyword">null</span>;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       future = threadPoolExecutor.submit(updateTask);</div><div class="line">       future.get(warmUpTimeoutMs, TimeUnit.MILLISECONDS);  <span class="comment">// block until done or timeout</span></div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">       logger.warn(<span class="string">"Best effort warm up failed"</span>, e);</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       <span class="keyword">if</span> (future != <span class="keyword">null</span>) &#123;</div><div class="line">           future.cancel(<span class="keyword">true</span>);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>updateTask</code> ，解析 EndPoint 集群。</li></ul></li><li><p>第 10 至 13 行 ： <strong>若未调度定时任务，进行调度</strong>，调用 <code>#scheduleTask()</code> 方法，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTask</span><span class="params">(<span class="keyword">long</span> delay)</span> </span>&#123;</div><div class="line">   executorService.schedule(backgroundTask, delay, TimeUnit.MILLISECONDS);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul></li><li><p>第 15 行 ：返回 EndPoint 集群。<strong>当第一次预热失败，会返回空，直到定时任务获得到结果</strong>。</p></li></ul><h1 id="4-初始化解析器"><a href="#4-初始化解析器" class="headerlink" title="4. 初始化解析器"></a>4. 初始化解析器</h1><p>Eureka-Client 在初始化时，调用 <code>DiscoveryClient#scheduleServerEndpointTask()</code> 方法，初始化 AsyncResolver 解析器。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleServerEndpointTask</span><span class="params">(EurekaTransport eurekaTransport,</span></span></div><div class="line"><span class="function"><span class="params">                                            AbstractDiscoveryClientOptionalArgs args)</span> </span>&#123;</div><div class="line">                                            </div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line"></div><div class="line">   <span class="comment">// 创建 EndPoint 解析器</span></div><div class="line">   eurekaTransport.bootstrapResolver = EurekaHttpClients.newBootstrapResolver(</div><div class="line">           clientConfig,</div><div class="line">           transportConfig,</div><div class="line">           eurekaTransport.transportClientFactory,</div><div class="line">           applicationInfoManager.getInfo(),</div><div class="line">           applicationsSource</div><div class="line">   );</div><div class="line">   </div><div class="line">   <span class="comment">// ... 省略无关代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>EurekaHttpClients#newBootstrapResolver(...)</code> 方法，创建 EndPoint 解析器，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String COMPOSITE_BOOTSTRAP_STRATEGY = <span class="string">"composite"</span>;</div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClosableResolver&lt;AwsEndpoint&gt; <span class="title">newBootstrapResolver</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">4</span>:         <span class="keyword">final</span> EurekaClientConfig clientConfig,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">5</span>:         <span class="keyword">final</span> EurekaTransportConfig transportConfig,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">6</span>:         <span class="keyword">final</span> TransportClientFactory transportClientFactory,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">7</span>:         <span class="keyword">final</span> InstanceInfo myInstanceInfo,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">8</span>:         <span class="keyword">final</span> ApplicationsResolver.ApplicationsSource applicationsSource)</span></span></div><div class="line"><span class="function"> 9: </span>&#123;</div><div class="line"><span class="number">10</span>:     <span class="keyword">if</span> (COMPOSITE_BOOTSTRAP_STRATEGY.equals(transportConfig.getBootstrapResolverStrategy())) &#123;</div><div class="line"><span class="number">11</span>:         <span class="keyword">if</span> (clientConfig.shouldFetchRegistry()) &#123;</div><div class="line"><span class="number">12</span>:             <span class="keyword">return</span> compositeBootstrapResolver(</div><div class="line"><span class="number">13</span>:                     clientConfig,</div><div class="line"><span class="number">14</span>:                     transportConfig,</div><div class="line"><span class="number">15</span>:                     transportClientFactory,</div><div class="line"><span class="number">16</span>:                     myInstanceInfo,</div><div class="line"><span class="number">17</span>:                     applicationsSource</div><div class="line"><span class="number">18</span>:             );</div><div class="line"><span class="number">19</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">20</span>:             logger.warn(<span class="string">"Cannot create a composite bootstrap resolver if registry fetch is disabled."</span> +</div><div class="line"><span class="number">21</span>:                     <span class="string">" Falling back to using a default bootstrap resolver."</span>);</div><div class="line"><span class="number">22</span>:         &#125;</div><div class="line"><span class="number">23</span>:     &#125;</div><div class="line"><span class="number">24</span>: </div><div class="line"><span class="number">25</span>:     <span class="comment">// if all else fails, return the default</span></div><div class="line"><span class="number">26</span>:     <span class="keyword">return</span> defaultBootstrapResolver(clientConfig, myInstanceInfo);</div><div class="line"><span class="number">27</span>: &#125;</div><div class="line"><span class="number">28</span>: </div><div class="line"><span class="number">29</span>: <span class="comment">/**</span></div><div class="line"><span class="comment">30:  * <span class="doctag">@return</span> a bootstrap resolver that resolves eureka server endpoints based on either DNS or static config,</span></div><div class="line"><span class="comment">31:  *         depending on configuration for one or the other. This resolver will warm up at the start.</span></div><div class="line"><span class="comment">32:  */</span></div><div class="line"><span class="number">33</span>: <span class="function"><span class="keyword">static</span> ClosableResolver&lt;AwsEndpoint&gt; <span class="title">defaultBootstrapResolver</span><span class="params">(<span class="keyword">final</span> EurekaClientConfig clientConfig,</span></span></div><div class="line"><span class="function"><span class="params"><span class="number">34</span>:                                                               <span class="keyword">final</span> InstanceInfo myInstanceInfo)</span> </span>&#123;</div><div class="line"><span class="number">35</span>:     <span class="comment">// 获得 可用区集合</span></div><div class="line"><span class="number">36</span>:     String[] availZones = clientConfig.getAvailabilityZones(clientConfig.getRegion());</div><div class="line"><span class="number">37</span>:     <span class="comment">// 获得 应用实例的 可用区</span></div><div class="line"><span class="number">38</span>:     String myZone = InstanceInfo.getZone(availZones, myInstanceInfo);</div><div class="line"><span class="number">39</span>: </div><div class="line"><span class="number">40</span>:     <span class="comment">// 创建 ZoneAffinityClusterResolver</span></div><div class="line"><span class="number">41</span>:     ClusterResolver&lt;AwsEndpoint&gt; delegateResolver = <span class="keyword">new</span> ZoneAffinityClusterResolver(</div><div class="line"><span class="number">42</span>:             <span class="keyword">new</span> ConfigClusterResolver(clientConfig, myInstanceInfo),</div><div class="line"><span class="number">43</span>:             myZone,</div><div class="line"><span class="number">44</span>:             <span class="keyword">true</span></div><div class="line"><span class="number">45</span>:     );</div><div class="line"><span class="number">46</span>: </div><div class="line"><span class="number">47</span>:     <span class="comment">// 第一次 EndPoint 解析</span></div><div class="line"><span class="number">48</span>:     List&lt;AwsEndpoint&gt; initialValue = delegateResolver.getClusterEndpoints();</div><div class="line"><span class="number">49</span>: </div><div class="line"><span class="number">50</span>:     <span class="comment">// 解析不到 Eureka-Server EndPoint ，快速失败</span></div><div class="line"><span class="number">51</span>:     <span class="keyword">if</span> (initialValue.isEmpty()) &#123;</div><div class="line"><span class="number">52</span>:         String msg = <span class="string">"Initial resolution of Eureka server endpoints failed. Check ConfigClusterResolver logs for more info"</span>;</div><div class="line"><span class="number">53</span>:         logger.error(msg);</div><div class="line"><span class="number">54</span>:         failFastOnInitCheck(clientConfig, msg);</div><div class="line"><span class="number">55</span>:     &#125;</div><div class="line"><span class="number">56</span>: </div><div class="line"><span class="number">57</span>:     <span class="comment">// 创建 AsyncResolver</span></div><div class="line"><span class="number">58</span>:     <span class="keyword">return</span> <span class="keyword">new</span> AsyncResolver&lt;&gt;(</div><div class="line"><span class="number">59</span>:             EurekaClientNames.BOOTSTRAP,</div><div class="line"><span class="number">60</span>:             delegateResolver,</div><div class="line"><span class="number">61</span>:             initialValue,</div><div class="line"><span class="number">62</span>:             <span class="number">1</span>,</div><div class="line"><span class="number">63</span>:             clientConfig.getEurekaServiceUrlPollIntervalSeconds() * <span class="number">1000</span></div><div class="line"><span class="number">64</span>:     );</div><div class="line"><span class="number">65</span>: &#125;</div></pre></td></tr></table></figure></li></ul><pre><code>* 第 10 至 23 行 ：组合解析器，用于 Eureka 1.x 对 Eureka 2.x 的兼容配置，暂时不需要了解。TODO[0028]写入集群和读取集群* 第 26 行 ：调用 `#defaultBootstrapResolver()` 方法，创建默认的解析器 AsyncResolver 。* 第 40 至 45 行 ：创建 ZoneAffinityClusterResolver 。在 ZoneAffinityClusterResolver 构造方法的参数，我们看到创建 ConfigClusterResolver 作为 `delegate` 参数。* 第 48 行 ：调用 `ZoneAffinityClusterResolver#getClusterEndpoints()` 方法，**第一次 Eureka-Server EndPoint 集群解析**。* 第 51 至 55 行 ：解析不到 Eureka-Server EndPoint 集群时，可以通过配置( `eureka.experimental.clientTransportFailFastOnInit=true` )，使 Eureka-Client 初始化失败。`#failFastOnInitCheck(...)` 方法，实现代码如下：    <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// potential future feature, guarding with experimental flag for now</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">failFastOnInitCheck</span><span class="params">(EurekaClientConfig clientConfig, String msg)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (<span class="string">"true"</span>.equals(clientConfig.getExperimental(<span class="string">"clientTransportFailFastOnInit"</span>))) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(msg);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>    * x</code></pre><ul><li><p>第 58 至 64 行 ：创建 AsyncResolver 。从代码上，我们可以看到，<code>AsyncResolver.resultsRef</code> 属性一开始已经用 <code>initialValue</code> 传递给 AsyncResolver 构造方法。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsyncResolver</span><span class="params">(String name,</span></span></div><div class="line"><span class="function"><span class="params">                      ClusterResolver&lt;T&gt; delegate,</span></span></div><div class="line"><span class="function"><span class="params">                      List&lt;T&gt; initialValues,</span></span></div><div class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> executorThreadPoolSize,</span></span></div><div class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> refreshIntervalMs)</span> </span>&#123;</div><div class="line">     <span class="keyword">this</span>(</div><div class="line">             name,</div><div class="line">             delegate,</div><div class="line">             initialValues,</div><div class="line">             executorThreadPoolSize,</div><div class="line">             refreshIntervalMs,</div><div class="line">             <span class="number">0</span></div><div class="line">     );</div><div class="line">    </div><div class="line">     <span class="comment">// 设置已经预热</span></div><div class="line">     warmedUp.set(<span class="keyword">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>T T  一开始看解析器，没反应过来是委托设计模式，一脸懵逼+一脸懵逼+一脸懵逼。后面理顺了，发现超级奈斯( Nice ) 啊 ！！！！</p><p>胖友，你学会了么？</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/end-point-and-resolver/&quot;&gt;http://www.iocoder.cn/Eureka/end-point-and-resolver/&lt;/a&gt; 「芋道源码」欢迎
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 任务批处理</title>
    <link href="http://www.iocoder.cn/Eureka/batch-tasks/"/>
    <id>http://www.iocoder.cn/Eureka/batch-tasks/</id>
    <published>2018-07-16T16:00:00.000Z</published>
    <updated>2017-10-17T14:06:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/batch-tasks/">http://www.iocoder.cn/Eureka/batch-tasks/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">2. 整体流程</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">3. 任务处理器</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">4. 创建任务分发器</a><ul><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">4.1 批量任务执行分发器</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">4.2 单任务执行分发器</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">5. 创建任务接收执行器</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">6. 创建任务执行器</a><ul><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">6.1 创建批量任务执行器</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">6.2 创建单任务执行器</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">6.3 工作线程抽象类</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">7. 网络通信整形器</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">8. 任务接收执行器【处理任务】</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">9. 任务接收线程【调度任务】</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">10. 任务执行器【执行任务】</a><ul><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">10.1 批量任务工作线程</a></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">10.2 单任务工作线程</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/batch-tasks/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>任务批处理</strong>。Eureka-Server 集群通过任务批处理同步应用实例注册实例，所以本文也是为 Eureka-Server 集群同步的分享做铺垫。</p><p>本文涉及类在 <code>com.netflix.eureka.util.batcher</code> 包下，涉及到主体类的类图如下( <a href="http://www.iocoder.cn/images/Eureka/2018_07_17/02.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_07_17/02.png" alt=""></p><ul><li>紫色部分 —— 任务分发器</li><li>蓝色部分 —— 任务接收器</li><li>红色部分 —— 任务执行器</li><li>绿色部分 —— 任务处理器</li><li>黄色部分 —— 任务持有者( 任务 )</li></ul><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-整体流程"><a href="#2-整体流程" class="headerlink" title="2. 整体流程"></a>2. 整体流程</h1><p>任务执行的整体流程如下( <a href="http://www.iocoder.cn/images/Eureka/2018_07_17/01.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_07_17/01.png" alt=""></p><ul><li>细箭头 —— 任务执行经历的操作</li><li>粗箭头 —— 任务队列流转的方向</li><li><p><strong>不同于</strong>一般情况下，任务提交了<strong>立即</strong>同步或异步执行，任务的执行拆分了<strong>三层队列</strong>：</p><ul><li><p>第一层，接收队列( <code>acceptorQueue</code> )，重新处理队列( <code>reprocessQueue</code> )。</p><ul><li>蓝线：分发器在收到任务执行请求后，提交到接收队列，<strong>任务实际未执行</strong>。</li><li>黄线：执行器的工作线程处理任务失败，将符合条件( 见 <a href="#">「3. 任务处理器」</a> )的失败任务提交到重新执行队列。</li></ul><ul><li><p>第二层，待执行队列( <code>processingOrder</code> )</p><ul><li>粉线：接收线程( Runner )将重新执行队列，接收队列提交到待执行队列。</li></ul></li><li><p>第三层，工作队列( <code>workQueue</code> )</p><ul><li>粉线：接收线程( Runner )将待执行队列的任务根据参数( <code>maxBatchingSize</code> )将任务合并成<strong>批量任务</strong>，调度( 提交 )到工作队列。</li><li>黄线：执行器的工作线程<strong>池</strong>，一个工作线程可以拉取一个<strong>批量任务</strong>进行执行。</li></ul></li></ul></li></ul></li><li><p><strong>三层队列的好处</strong>：</p><ul><li>接收队列，避免处理任务的阻塞等待。</li><li>接收线程( Runner )合并任务，将相同任务编号( <strong>是的，任务是带有编号的</strong> )的任务合并，只执行一次。</li><li>Eureka-Server 为集群同步提供批量操作<strong>多个</strong>应用实例的<strong>接口</strong>，一个<strong>批量任务</strong>可以一次调度接口完成，避免多次调用的开销。当然，这样做的前提是合并任务，这也导致 Eureka-Server 集群之间对应用实例的注册和下线带来更大的延迟。<strong>毕竟，Eureka 是在 CAP 之间，选择了 AP</strong>。</li></ul></li></ul><h1 id="3-任务处理器"><a href="#3-任务处理器" class="headerlink" title="3. 任务处理器"></a>3. 任务处理器</h1><p><code>com.netflix.eureka.util.batcher.TaskProcessor</code> ，任务处理器<strong>接口</strong>。接口代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TaskProcessor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * A processed task/task list ends up in one of the following states:</span></div><div class="line"><span class="comment">     * &lt;ul&gt;</span></div><div class="line"><span class="comment">     *     &lt;li&gt;&#123;<span class="doctag">@code</span> Success&#125; processing finished successfully&lt;/li&gt;</span></div><div class="line"><span class="comment">     *     &lt;li&gt;&#123;<span class="doctag">@code</span> TransientError&#125; processing failed, but shall be retried later&lt;/li&gt;</span></div><div class="line"><span class="comment">     *     &lt;li&gt;&#123;<span class="doctag">@code</span> PermanentError&#125; processing failed, and is non recoverable&lt;/li&gt;</span></div><div class="line"><span class="comment">     * &lt;/ul&gt;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">enum</span> ProcessingResult &#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 成功</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        Success,</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 拥挤错误</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        Congestion,</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 瞬时错误</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        TransientError,</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 永久错误</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        PermanentError</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 处理单任务</span></div><div class="line"><span class="comment">     * In non-batched mode a single task is processed at a time.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">ProcessingResult <span class="title">process</span><span class="params">(T task)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 处理批量任务</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * For batched mode a collection of tasks is run at a time. The result is provided for the aggregated result,</span></div><div class="line"><span class="comment">     * and all tasks are handled in the same way according to what is returned (for example are rescheduled, if the</span></div><div class="line"><span class="comment">     * error is transient).</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">ProcessingResult <span class="title">process</span><span class="params">(List&lt;T&gt; tasks)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>ProcessingResult ，处理任务结果。<ul><li><code>Success</code> ，成功。</li><li><code>Congestion</code> ，拥挤错误，<strong>任务将会被重试</strong>。例如，请求被限流。</li><li><code>TransientError</code> ，瞬时错误，<strong>任务将会被重试</strong>。例如，网络请求超时。</li><li><code>PermanentError</code> ，永久错误，<strong>任务将会被丢弃</strong>。例如，执行时发生程序异常。</li></ul></li><li><code>#process(task)</code> 方法，处理单任务。</li><li><code>#process(tasks)</code> 方法，处理批量任务。</li></ul><h1 id="4-创建任务分发器"><a href="#4-创建任务分发器" class="headerlink" title="4. 创建任务分发器"></a>4. 创建任务分发器</h1><p><code>com.netflix.eureka.util.batcher.TaskDispatcher</code> ，任务分发器<strong>接口</strong>。接口代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TaskDispatcher</span>&lt;<span class="title">ID</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(ID id, T task, <span class="keyword">long</span> expiryTime)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>#process(...)</code> 方法，提交任务编号，任务，任务过期时间给任务分发器处理。</li></ul><p><code>com.netflix.eureka.util.batcher.TaskDispatchers</code> ，任务分发器<strong>工厂类</strong>，用于创建任务分发器。其内部提供两种任务分发器的实现：</p><ul><li><strong>批量任务</strong>执行的分发器，用于 Eureka-Server 集群注册信息的同步任务。</li><li><strong>单任务</strong>执行的分发器，用于 Eureka-Server 向亚马逊 AWS 的 ASG ( Autoscaling Group ) 同步状态。虽然本系列暂时对 AWS 相关的不做解析，从工具类的角度来说，本文会对该分发器进行分享。</li></ul><p><code>com.netflix.eureka.cluster.ReplicationTaskProcessor</code> ，实现 TaskDispatcher ，Eureka-Server 集群任务处理器。感兴趣的同学，可以点击<a href="https://github.com/YunaiV/eureka/blob/6e1b694898aa2f4c155936420c2ce5850f142742/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a>自己研究，我们将在 <a href="http://www.iocoder.cn/Eureka/server-cluster/?self">《Eureka 源码解析 —— Eureka-Server 集群同步》</a> 有详细解析。</p><h2 id="4-1-批量任务执行分发器"><a href="#4-1-批量任务执行分发器" class="headerlink" title="4.1 批量任务执行分发器"></a>4.1 批量任务执行分发器</h2><p>调用 <code>TaskDispatchers#createBatchingTaskDispatcher(...)</code> 方法，创建<strong>批量任务</strong>执行的分发器，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TaskDispatchers.java</span></div><div class="line">  <span class="number">1</span>: <span class="comment">/**</span></div><div class="line"><span class="comment">  2:  * 创建批量任务执行的分发器</span></div><div class="line"><span class="comment">  3:  *</span></div><div class="line"><span class="comment">  4:  * <span class="doctag">@param</span> id 任务执行器编号</span></div><div class="line"><span class="comment">  5:  * <span class="doctag">@param</span> maxBufferSize 待执行队列最大数量</span></div><div class="line"><span class="comment">  6:  * <span class="doctag">@param</span> workloadSize 单个批量任务包含任务最大数量</span></div><div class="line"><span class="comment">  7:  * <span class="doctag">@param</span> workerCount 任务执行器工作线程数</span></div><div class="line"><span class="comment">  8:  * <span class="doctag">@param</span> maxBatchingDelay 批量任务等待最大延迟时长，单位：毫秒</span></div><div class="line"><span class="comment">  9:  * <span class="doctag">@param</span> congestionRetryDelayMs 请求限流延迟重试时间，单位：毫秒</span></div><div class="line"><span class="comment"> 10:  * <span class="doctag">@param</span> networkFailureRetryMs 网络失败延迟重试时长，单位：毫秒</span></div><div class="line"><span class="comment"> 11:  * <span class="doctag">@param</span> taskProcessor 任务处理器</span></div><div class="line"><span class="comment"> 12:  * <span class="doctag">@param</span> &lt;ID&gt; 任务编号泛型</span></div><div class="line"><span class="comment"> 13:  * <span class="doctag">@param</span> &lt;T&gt; 任务泛型</span></div><div class="line"><span class="comment"> 14:  * <span class="doctag">@return</span> 批量任务执行的分发器</span></div><div class="line"><span class="comment"> 15:  */</span></div><div class="line"> <span class="number">16</span>: <span class="keyword">public</span> <span class="keyword">static</span> &lt;ID, T&gt; <span class="function">TaskDispatcher&lt;ID, T&gt; <span class="title">createBatchingTaskDispatcher</span><span class="params">(String id,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">17</span>:                                                                          <span class="keyword">int</span> maxBufferSize,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">18</span>:                                                                          <span class="keyword">int</span> workloadSize,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">19</span>:                                                                          <span class="keyword">int</span> workerCount,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">20</span>:                                                                          <span class="keyword">long</span> maxBatchingDelay,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">21</span>:                                                                          <span class="keyword">long</span> congestionRetryDelayMs,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">22</span>:                                                                          <span class="keyword">long</span> networkFailureRetryMs,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">23</span>:                                                                          TaskProcessor&lt;T&gt; taskProcessor)</span> </span>&#123;</div><div class="line"> <span class="number">24</span>:     <span class="comment">// 创建 任务接收执行器</span></div><div class="line"> <span class="number">25</span>:     <span class="keyword">final</span> AcceptorExecutor&lt;ID, T&gt; acceptorExecutor = <span class="keyword">new</span> AcceptorExecutor&lt;&gt;(</div><div class="line"> <span class="number">26</span>:             id, maxBufferSize, workloadSize, maxBatchingDelay, congestionRetryDelayMs, networkFailureRetryMs</div><div class="line"> <span class="number">27</span>:     );</div><div class="line"> <span class="number">28</span>:     <span class="comment">// 创建 批量任务执行器</span></div><div class="line"> <span class="number">29</span>:     <span class="keyword">final</span> TaskExecutors&lt;ID, T&gt; taskExecutor = TaskExecutors.batchExecutors(id, workerCount, taskProcessor, acceptorExecutor);</div><div class="line"> <span class="number">30</span>:     <span class="comment">// 创建 批量任务分发器</span></div><div class="line"> <span class="number">31</span>:     <span class="keyword">return</span> <span class="keyword">new</span> TaskDispatcher&lt;ID, T&gt;() &#123;</div><div class="line"> <span class="number">32</span>:         <span class="meta">@Override</span></div><div class="line"> <span class="number">33</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(ID id, T task, <span class="keyword">long</span> expiryTime)</span> </span>&#123;</div><div class="line"> <span class="number">34</span>:             acceptorExecutor.process(id, task, expiryTime);</div><div class="line"> <span class="number">35</span>:         &#125;</div><div class="line"> <span class="number">36</span>: </div><div class="line"> <span class="number">37</span>:         <span class="meta">@Override</span></div><div class="line"> <span class="number">38</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">39</span>:             acceptorExecutor.shutdown();</div><div class="line"> <span class="number">40</span>:             taskExecutor.shutdown();</div><div class="line"> <span class="number">41</span>:         &#125;</div><div class="line"> <span class="number">42</span>:     &#125;;</div><div class="line"> <span class="number">43</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 1 至 23 行 ：方法参数。比较多哈，请耐心理解。<ul><li><code>workloadSize</code> 参数，单个批量任务包含任务最大数量。</li><li><code>taskProcessor</code> 参数，<strong>自定义任务执行器实现</strong>。</li></ul></li><li>第 24 至 27 行 ：创建任务<strong>接收</strong>执行器。在 <a href="#">「5. 创建任务接收器」</a> 详细解析。</li><li>第 28 至 29 行 ：创建<strong>批量</strong>任务执行器。在 <a href="#">「6.1 创建批量任务执行器」</a> 详细解析。</li><li>第 30 至 42 行 ：创建<strong>批量</strong>任务分发器。<ul><li>第 32 至 35 行 ：<code>#process()</code> 方法的实现，调用 <code>AcceptorExecutor#process(...)</code> 方法，提交 [ 任务编号 , 任务 , 任务过期时间 ] 给任务分发器处理。</li></ul></li></ul><h2 id="4-2-单任务执行分发器"><a href="#4-2-单任务执行分发器" class="headerlink" title="4.2 单任务执行分发器"></a>4.2 单任务执行分发器</h2><p>调用 <code>TaskDispatchers#createNonBatchingTaskDispatcher(...)</code> 方法，创建<strong>单任务</strong>执行的分发器，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="comment">/**</span></div><div class="line"><span class="comment"> 2:  * 创建单任务执行的分发器</span></div><div class="line"><span class="comment"> 3:  *</span></div><div class="line"><span class="comment"> 4:  * <span class="doctag">@param</span> id 任务执行器编号</span></div><div class="line"><span class="comment"> 5:  * <span class="doctag">@param</span> maxBufferSize 待执行队列最大数量</span></div><div class="line"><span class="comment"> 6:  * <span class="doctag">@param</span> workerCount 任务执行器工作线程数</span></div><div class="line"><span class="comment"> 7:  * <span class="doctag">@param</span> maxBatchingDelay 批量任务等待最大延迟时长，单位：毫秒</span></div><div class="line"><span class="comment"> 8:  * <span class="doctag">@param</span> congestionRetryDelayMs 请求限流延迟重试时间，单位：毫秒</span></div><div class="line"><span class="comment"> 9:  * <span class="doctag">@param</span> networkFailureRetryMs 网络失败延迟重试时长，单位：毫秒</span></div><div class="line"><span class="comment">10:  * <span class="doctag">@param</span> taskProcessor 任务处理器</span></div><div class="line"><span class="comment">11:  * <span class="doctag">@param</span> &lt;ID&gt; 任务编号泛型</span></div><div class="line"><span class="comment">12:  * <span class="doctag">@param</span> &lt;T&gt; 任务泛型</span></div><div class="line"><span class="comment">13:  * <span class="doctag">@return</span> 单任务执行的分发器</span></div><div class="line"><span class="comment">14:  */</span></div><div class="line"><span class="number">15</span>: <span class="keyword">public</span> <span class="keyword">static</span> &lt;ID, T&gt; <span class="function">TaskDispatcher&lt;ID, T&gt; <span class="title">createNonBatchingTaskDispatcher</span><span class="params">(String id,</span></span></div><div class="line"><span class="function"><span class="params"><span class="number">16</span>:                                                                             <span class="keyword">int</span> maxBufferSize,</span></span></div><div class="line"><span class="function"><span class="params"><span class="number">17</span>:                                                                             <span class="keyword">int</span> workerCount,</span></span></div><div class="line"><span class="function"><span class="params"><span class="number">18</span>:                                                                             <span class="keyword">long</span> maxBatchingDelay,</span></span></div><div class="line"><span class="function"><span class="params"><span class="number">19</span>:                                                                             <span class="keyword">long</span> congestionRetryDelayMs,</span></span></div><div class="line"><span class="function"><span class="params"><span class="number">20</span>:                                                                             <span class="keyword">long</span> networkFailureRetryMs,</span></span></div><div class="line"><span class="function"><span class="params"><span class="number">21</span>:                                                                             TaskProcessor&lt;T&gt; taskProcessor)</span> </span>&#123;</div><div class="line"><span class="number">22</span>:     <span class="comment">// 创建 任务接收执行器</span></div><div class="line"><span class="number">23</span>:     <span class="keyword">final</span> AcceptorExecutor&lt;ID, T&gt; acceptorExecutor = <span class="keyword">new</span> AcceptorExecutor&lt;&gt;(</div><div class="line"><span class="number">24</span>:             id, maxBufferSize, <span class="comment">/* workloadSize = 1 */</span><span class="number">1</span>, maxBatchingDelay, congestionRetryDelayMs, networkFailureRetryMs</div><div class="line"><span class="number">25</span>:     );</div><div class="line"><span class="number">26</span>:     <span class="keyword">final</span> TaskExecutors&lt;ID, T&gt; taskExecutor = TaskExecutors.singleItemExecutors(id, workerCount, taskProcessor, acceptorExecutor);</div><div class="line"><span class="number">27</span>:     <span class="keyword">return</span> <span class="keyword">new</span> TaskDispatcher&lt;ID, T&gt;() &#123;</div><div class="line"><span class="number">28</span>:         <span class="meta">@Override</span></div><div class="line"><span class="number">29</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(ID id, T task, <span class="keyword">long</span> expiryTime)</span> </span>&#123;</div><div class="line"><span class="number">30</span>:             acceptorExecutor.process(id, task, expiryTime);</div><div class="line"><span class="number">31</span>:         &#125;</div><div class="line"><span class="number">32</span>: </div><div class="line"><span class="number">33</span>:         <span class="meta">@Override</span></div><div class="line"><span class="number">34</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">35</span>:             acceptorExecutor.shutdown();</div><div class="line"><span class="number">36</span>:             taskExecutor.shutdown();</div><div class="line"><span class="number">37</span>:         &#125;</div><div class="line"><span class="number">38</span>:     &#125;;</div><div class="line"><span class="number">39</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 1 至 21 行 ：方法参数。比较多哈，请耐心理解。<ul><li><del><code>workloadSize</code> 参数</del>，相比 <code>#createBatchingTaskDispatcher(...)</code> 少这个参数。<strong>在第 24 行，你会发现该参数传递给 AcceptorExecutor 使用 1 噢</strong>。</li><li><code>taskProcessor</code> 参数，<strong>自定义任务执行器实现</strong>。</li></ul></li><li>第 21 至 25 行 ：创建任务<strong>接收</strong>执行器。和 <code>#createBatchingTaskDispatcher(...)</code> 只差 <code>workloadSize = 1</code> 参数。在 <a href="#">「5. 创建任务接收器」</a> 详细解析。</li><li>第 28 至 29 行 ：创建<strong>单</strong>任务执行器。<strong>和 <code>#createBatchingTaskDispatcher(...)</code> 差别很大</strong>。<a href="#">「6.2 创建单任务执行器」</a> 详细解析。</li><li>第 30 至 42 行 ：创建<strong>单</strong>任务分发器。和 <code>#createBatchingTaskDispatcher(...)</code> 一样。</li></ul><h1 id="5-创建任务接收执行器"><a href="#5-创建任务接收执行器" class="headerlink" title="5. 创建任务接收执行器"></a>5. 创建任务接收执行器</h1><p><code>com.netflix.eureka.util.batcher.AcceptorExecutor</code> ，任务接收执行器。创建构造方法代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="class"><span class="keyword">class</span> <span class="title">AcceptorExecutor</span>&lt;<span class="title">ID</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>:     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AcceptorExecutor.class);</div><div class="line"> <span class="number">4</span>: </div><div class="line"> <span class="number">5</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment"> 6:      * 待执行队列最大数量</span></div><div class="line"><span class="comment"> 7:      * &#123;<span class="doctag">@link</span> #processingOrder&#125;</span></div><div class="line"><span class="comment"> 8:      */</span></div><div class="line"> <span class="number">9</span>:     <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxBufferSize;</div><div class="line"><span class="number">10</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">11:      * 单个批量任务包含任务最大数量</span></div><div class="line"><span class="comment">12:      */</span></div><div class="line"><span class="number">13</span>:     <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxBatchingSize;</div><div class="line"><span class="number">14</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">15:      * 批量任务等待最大延迟时长，单位：毫秒</span></div><div class="line"><span class="comment">16:      */</span></div><div class="line"><span class="number">17</span>:     <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxBatchingDelay;</div><div class="line"><span class="number">18</span>: </div><div class="line"><span class="number">19</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">20:      * 是否关闭</span></div><div class="line"><span class="comment">21:      */</span></div><div class="line"><span class="number">22</span>:     <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean isShutdown = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</div><div class="line"><span class="number">23</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">24:      * 接收任务队列</span></div><div class="line"><span class="comment">25:      */</span></div><div class="line"><span class="number">26</span>:     <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;TaskHolder&lt;ID, T&gt;&gt; acceptorQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class="line"><span class="number">27</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">28:      * 重新执行任务队列</span></div><div class="line"><span class="comment">29:      */</span></div><div class="line"><span class="number">30</span>:     <span class="keyword">private</span> <span class="keyword">final</span> BlockingDeque&lt;TaskHolder&lt;ID, T&gt;&gt; reprocessQueue = <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;();</div><div class="line"><span class="number">31</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">32:      * 接收任务线程</span></div><div class="line"><span class="comment">33:      */</span></div><div class="line"><span class="number">34</span>:     <span class="keyword">private</span> <span class="keyword">final</span> Thread acceptorThread;</div><div class="line"><span class="number">35</span>: </div><div class="line"><span class="number">36</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">37:      * 待执行任务映射</span></div><div class="line"><span class="comment">38:      */</span></div><div class="line"><span class="number">39</span>:     <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ID, TaskHolder&lt;ID, T&gt;&gt; pendingTasks = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"><span class="number">40</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">41:      * 待执行队列</span></div><div class="line"><span class="comment">42:      */</span></div><div class="line"><span class="number">43</span>:     <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;ID&gt; processingOrder = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line"><span class="number">44</span>: </div><div class="line"><span class="number">45</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">46:      * 单任务工作请求信号量</span></div><div class="line"><span class="comment">47:      */</span></div><div class="line"><span class="number">48</span>:     <span class="keyword">private</span> <span class="keyword">final</span> Semaphore singleItemWorkRequests = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</div><div class="line"><span class="number">49</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">50:      * 单任务工作队列</span></div><div class="line"><span class="comment">51:      */</span></div><div class="line"><span class="number">52</span>:     <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;TaskHolder&lt;ID, T&gt;&gt; singleItemWorkQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class="line"><span class="number">53</span>: </div><div class="line"><span class="number">54</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">55:      * 批量任务工作请求信号量</span></div><div class="line"><span class="comment">56:      */</span></div><div class="line"><span class="number">57</span>:     <span class="keyword">private</span> <span class="keyword">final</span> Semaphore batchWorkRequests = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</div><div class="line"><span class="number">58</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">59:      * 批量任务工作队列</span></div><div class="line"><span class="comment">60:      */</span></div><div class="line"><span class="number">61</span>:     <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;List&lt;TaskHolder&lt;ID, T&gt;&gt;&gt; batchWorkQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class="line"><span class="number">62</span>: </div><div class="line"><span class="number">63</span>:     <span class="comment">/**</span></div><div class="line"><span class="comment">64:      * 网络通信整形器</span></div><div class="line"><span class="comment">65:      */</span></div><div class="line"><span class="number">66</span>:     <span class="keyword">private</span> <span class="keyword">final</span> TrafficShaper trafficShaper;</div><div class="line"><span class="number">67</span>: </div><div class="line"><span class="number">68</span>:     AcceptorExecutor(String id,</div><div class="line"><span class="number">69</span>:                      <span class="keyword">int</span> maxBufferSize,</div><div class="line"><span class="number">70</span>:                      <span class="keyword">int</span> maxBatchingSize,</div><div class="line"><span class="number">71</span>:                      <span class="keyword">long</span> maxBatchingDelay,</div><div class="line"><span class="number">72</span>:                      <span class="keyword">long</span> congestionRetryDelayMs,</div><div class="line"><span class="number">73</span>:                      <span class="keyword">long</span> networkFailureRetryMs) &#123;</div><div class="line"><span class="number">74</span>:         <span class="keyword">this</span>.maxBufferSize = maxBufferSize;</div><div class="line"><span class="number">75</span>:         <span class="keyword">this</span>.maxBatchingSize = maxBatchingSize;</div><div class="line"><span class="number">76</span>:         <span class="keyword">this</span>.maxBatchingDelay = maxBatchingDelay;</div><div class="line"><span class="number">77</span>: </div><div class="line"><span class="number">78</span>:         <span class="comment">// 创建 网络通信整形器</span></div><div class="line"><span class="number">79</span>:         <span class="keyword">this</span>.trafficShaper = <span class="keyword">new</span> TrafficShaper(congestionRetryDelayMs, networkFailureRetryMs);</div><div class="line"><span class="number">80</span>: </div><div class="line"><span class="number">81</span>:         <span class="comment">// 创建 接收任务线程</span></div><div class="line"><span class="number">82</span>:         ThreadGroup threadGroup = <span class="keyword">new</span> ThreadGroup(<span class="string">"eurekaTaskExecutors"</span>);</div><div class="line"><span class="number">83</span>:         <span class="keyword">this</span>.acceptorThread = <span class="keyword">new</span> Thread(threadGroup, <span class="keyword">new</span> AcceptorRunner(), <span class="string">"TaskAcceptor-"</span> + id);</div><div class="line"><span class="number">84</span>:         <span class="keyword">this</span>.acceptorThread.setDaemon(<span class="keyword">true</span>);</div><div class="line"><span class="number">85</span>:         <span class="keyword">this</span>.acceptorThread.start();</div><div class="line"><span class="number">86</span>: </div><div class="line"><span class="number">87</span>:         <span class="comment">// TODO （省略代码）芋艿：监控相关，暂时无视</span></div><div class="line"><span class="number">88</span>:     &#125;</div><div class="line"><span class="number">89</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 5 至 61 行 ：属性。比较多哈，请耐心理解。<ul><li>眼尖如你，会发现 AcceptorExecutor 即存在单任务工作队列( <code>singleItemWorkQueue</code> )，又存在批量任务工作队列( <code>batchWorkQueue</code> ) ，在 <a href="#">「9. 任务接收线程【调度任务】」</a> 会解答这个疑惑。</li></ul></li><li>第 78 至 79 行 ：创建网络通信整形器。在 <a href="#">「7. 网络通信整形器」</a> 详细解析。</li><li>第 81 至 85 行 ：<strong>创建接收任务线程</strong>。</li></ul><h1 id="6-创建任务执行器"><a href="#6-创建任务执行器" class="headerlink" title="6. 创建任务执行器"></a>6. 创建任务执行器</h1><p><code>com.netflix.eureka.util.batcher.TaskExecutors</code> ，任务执行器。<strong>其内部提供创建单任务和批量任务执行器的两种方法</strong>。TaskExecutors 构造方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskExecutors</span>&lt;<span class="title">ID</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(TaskExecutors.class);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 是否关闭</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean isShutdown;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 工作线程池</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Thread&gt; workerThreads;</div><div class="line"></div><div class="line">    TaskExecutors(WorkerRunnableFactory&lt;ID, T&gt; workerRunnableFactory, <span class="keyword">int</span> workerCount, AtomicBoolean isShutdown) &#123;</div><div class="line">        <span class="keyword">this</span>.isShutdown = isShutdown;</div><div class="line">        <span class="keyword">this</span>.workerThreads = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="comment">// 创建 工作线程池</span></div><div class="line">        ThreadGroup threadGroup = <span class="keyword">new</span> ThreadGroup(<span class="string">"eurekaTaskExecutors"</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; workerCount; i++) &#123;</div><div class="line">            WorkerRunnable&lt;ID, T&gt; runnable = workerRunnableFactory.create(i);</div><div class="line">            Thread workerThread = <span class="keyword">new</span> Thread(threadGroup, runnable, runnable.getWorkerName());</div><div class="line">            workerThreads.add(workerThread);</div><div class="line">            workerThread.setDaemon(<span class="keyword">true</span>);</div><div class="line">            workerThread.start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 创建工作线程工厂</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;ID&gt; 任务编号泛型</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 批量任务执行器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">WorkerRunnableFactory</span>&lt;<span class="title">ID</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line">        <span class="function">WorkerRunnable&lt;ID, T&gt; <span class="title">create</span><span class="params">(<span class="keyword">int</span> idx)</span></span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>workerThreads</code> 属性，工作线程<strong>池</strong>。<strong>工作任务队列会被工作线程池并发拉取，并发执行</strong>。</li><li><code>com.netflix.eureka.util.batcher.TaskExecutors.WorkerRunnableFactory</code> ，创建工作线程工厂<strong>接口</strong>。单任务和批量任务执行器的工作线程实现不同，通过自定义工厂实现类创建。</li></ul><h2 id="6-1-创建批量任务执行器"><a href="#6-1-创建批量任务执行器" class="headerlink" title="6.1 创建批量任务执行器"></a>6.1 创建批量任务执行器</h2><p>调用 <code>TaskExecutors#batchExecutors(...)</code> 方法，创建批量任务执行器。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 创建批量任务执行器</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> name 任务执行器名</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> workerCount 任务执行器工作线程数</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> processor 任务处理器</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> acceptorExecutor 接收任务执行器</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> &lt;ID&gt; 任务编号泛型</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> &lt;T&gt; 任务泛型</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 批量任务执行器</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">static</span> &lt;ID, T&gt; <span class="function">TaskExecutors&lt;ID, T&gt; <span class="title">batchExecutors</span><span class="params">(<span class="keyword">final</span> String name,</span></span></div><div class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> workerCount,</span></span></div><div class="line"><span class="function"><span class="params">                                                  <span class="keyword">final</span> TaskProcessor&lt;T&gt; processor,</span></span></div><div class="line"><span class="function"><span class="params">                                                  <span class="keyword">final</span> AcceptorExecutor&lt;ID, T&gt; acceptorExecutor)</span> </span>&#123;</div><div class="line">   <span class="keyword">final</span> AtomicBoolean isShutdown = <span class="keyword">new</span> AtomicBoolean();</div><div class="line">   <span class="keyword">final</span> TaskExecutorMetrics metrics = <span class="keyword">new</span> TaskExecutorMetrics(name);</div><div class="line">   <span class="comment">// 创建批量任务执行器</span></div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> TaskExecutors&lt;&gt;(<span class="keyword">new</span> WorkerRunnableFactory&lt;ID, T&gt;() &#123; <span class="comment">// 批量任务工作线程工厂</span></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> WorkerRunnable&lt;ID, T&gt; <span class="title">create</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">new</span> BatchWorkerRunnable&lt;&gt;(<span class="string">"TaskBatchingWorker-"</span> + name + <span class="string">'-'</span> + idx <span class="comment">/* 线程名 */</span>, isShutdown, metrics, processor, acceptorExecutor);</div><div class="line">       &#125;</div><div class="line">   &#125;, workerCount, isShutdown);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>com.netflix.eureka.util.batcher.TaskExecutors.WorkerRunnable.BatchWorkerRunnable</code> ，批量任务工作线程。</li></ul><h2 id="6-2-创建单任务执行器"><a href="#6-2-创建单任务执行器" class="headerlink" title="6.2 创建单任务执行器"></a>6.2 创建单任务执行器</h2><p>调用 <code>TaskExecutors#singleItemExecutors(...)</code> 方法，创建批量任务执行器。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 创建单任务执行器</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> name 任务执行器名</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> workerCount 任务执行器工作线程数</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> processor 任务处理器</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> acceptorExecutor 接收任务执行器</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> &lt;ID&gt; 任务编号泛型</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> &lt;T&gt; 任务泛型</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 单任务执行器</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">static</span> &lt;ID, T&gt; <span class="function">TaskExecutors&lt;ID, T&gt; <span class="title">singleItemExecutors</span><span class="params">(<span class="keyword">final</span> String name,</span></span></div><div class="line"><span class="function"><span class="params">                                                       <span class="keyword">int</span> workerCount,</span></span></div><div class="line"><span class="function"><span class="params">                                                       <span class="keyword">final</span> TaskProcessor&lt;T&gt; processor,</span></span></div><div class="line"><span class="function"><span class="params">                                                       <span class="keyword">final</span> AcceptorExecutor&lt;ID, T&gt; acceptorExecutor)</span> </span>&#123;</div><div class="line">   <span class="keyword">final</span> AtomicBoolean isShutdown = <span class="keyword">new</span> AtomicBoolean();</div><div class="line">   <span class="keyword">final</span> TaskExecutorMetrics metrics = <span class="keyword">new</span> TaskExecutorMetrics(name);</div><div class="line">   <span class="comment">// 创建单任务执行器</span></div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> TaskExecutors&lt;&gt;(<span class="keyword">new</span> WorkerRunnableFactory&lt;ID, T&gt;() &#123; <span class="comment">// 单任务工作线程工厂</span></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> WorkerRunnable&lt;ID, T&gt; <span class="title">create</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">new</span> SingleTaskWorkerRunnable&lt;&gt;(<span class="string">"TaskNonBatchingWorker-"</span> + name + <span class="string">'-'</span> + idx <span class="comment">/* 线程名 */</span>, isShutdown, metrics, processor, acceptorExecutor);</div><div class="line">       &#125;</div><div class="line">   &#125;, workerCount, isShutdown);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>com.netflix.eureka.util.batcher.TaskExecutors.WorkerRunnable.SingleTaskWorkerRunnable</code> ，单任务工作线程。</li></ul><h2 id="6-3-工作线程抽象类"><a href="#6-3-工作线程抽象类" class="headerlink" title="6.3 工作线程抽象类"></a>6.3 工作线程抽象类</h2><p><code>com.netflix.eureka.util.batcher.TaskExecutors.WorkerRunnable</code> ，任务工作线程抽象类。BatchWorkerRunnable 和 SingleTaskWorkerRunnable 都实现该类，差异在 <code>#run()</code> 的自定义实现。WorkerRunnable 实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerRunnable</span>&lt;<span class="title">ID</span>, <span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 线程名</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">final</span> String workerName;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 是否关闭</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">final</span> AtomicBoolean isShutdown;</div><div class="line">   <span class="keyword">final</span> TaskExecutorMetrics metrics;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 任务处理器</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">final</span> TaskProcessor&lt;T&gt; processor;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 任务接收执行器</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">final</span> AcceptorExecutor&lt;ID, T&gt; taskDispatcher;</div><div class="line">   </div><div class="line">   <span class="comment">// ... 省略构造方法和 getting 方法。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="7-网络通信整形器"><a href="#7-网络通信整形器" class="headerlink" title="7. 网络通信整形器"></a>7. 网络通信整形器</h1><p><code>com.netflix.eureka.util.batcher.TrafficShaper</code> ，网络通信整形器。当任务执行发生请求限流，或是请求网络失败的情况，则延时 AcceptorRunner 将任务提交到工作任务队列，从而避免任务很快去执行，再次发生上述情况。TrafficShaper 实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrafficShaper</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Upper bound on delay provided by configuration.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MAX_DELAY = <span class="number">30</span> * <span class="number">1000</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 请求限流延迟重试时间，单位：毫秒</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> congestionRetryDelayMs;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 网络失败延迟重试时长，单位：毫秒</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> networkFailureRetryMs;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 最后请求限流时间戳，单位：毫秒</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastCongestionError;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 最后网络失败时间戳，单位：毫秒</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastNetworkFailure;</div><div class="line"></div><div class="line">    TrafficShaper(<span class="keyword">long</span> congestionRetryDelayMs, <span class="keyword">long</span> networkFailureRetryMs) &#123;</div><div class="line">        <span class="keyword">this</span>.congestionRetryDelayMs = Math.min(MAX_DELAY, congestionRetryDelayMs);</div><div class="line">        <span class="keyword">this</span>.networkFailureRetryMs = Math.min(MAX_DELAY, networkFailureRetryMs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerFailure</span><span class="params">(ProcessingResult processingResult)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (processingResult == ProcessingResult.Congestion) &#123;</div><div class="line">            lastCongestionError = System.currentTimeMillis();</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (processingResult == ProcessingResult.TransientError) &#123;</div><div class="line">            lastNetworkFailure = System.currentTimeMillis();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 计算提交延迟，单位：毫秒</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 延迟</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">long</span> <span class="title">transmissionDelay</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 无延迟</span></div><div class="line">        <span class="keyword">if</span> (lastCongestionError == -<span class="number">1</span> &amp;&amp; lastNetworkFailure == -<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line"></div><div class="line">        <span class="comment">// 计算最后请求限流带来的延迟</span></div><div class="line">        <span class="keyword">if</span> (lastCongestionError != -<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">long</span> congestionDelay = now - lastCongestionError;</div><div class="line">            <span class="keyword">if</span> (congestionDelay &gt;= <span class="number">0</span> &amp;&amp; congestionDelay &lt; congestionRetryDelayMs) &#123; <span class="comment">// 范围内</span></div><div class="line">                <span class="keyword">return</span> congestionRetryDelayMs - congestionDelay; <span class="comment">// 补充延迟</span></div><div class="line">            &#125;</div><div class="line">            lastCongestionError = -<span class="number">1</span>; <span class="comment">// 重置时间戳</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 计算最后网络失败带来的延迟</span></div><div class="line">        <span class="keyword">if</span> (lastNetworkFailure != -<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">long</span> failureDelay = now - lastNetworkFailure;</div><div class="line">            <span class="keyword">if</span> (failureDelay &gt;= <span class="number">0</span> &amp;&amp; failureDelay &lt; networkFailureRetryMs) &#123; <span class="comment">// 范围内</span></div><div class="line">                <span class="keyword">return</span> networkFailureRetryMs - failureDelay; <span class="comment">// 补充延迟</span></div><div class="line">            &#125;</div><div class="line">            lastNetworkFailure = -<span class="number">1</span>; <span class="comment">// 重置时间戳</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 无延迟</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>#registerFailure(...)</code> ，在任务执行失败时，提交任务结果给 TrafficShaper ，记录发生时间。在 <a href="#">「10. 任务执行器【执行任务】」</a> 会看到调用该方法。</li><li><code>#transmissionDelay(...)</code> ，计算提交延迟，单位：毫秒。<a href="#">「9. 任务接收线程【调度任务】」</a> 会看到调用该方法。</li></ul><h1 id="8-任务接收执行器【处理任务】"><a href="#8-任务接收执行器【处理任务】" class="headerlink" title="8. 任务接收执行器【处理任务】"></a>8. 任务接收执行器【处理任务】</h1><p>调用 <code>AcceptorExecutor#process(...)</code> 方法，添加任务到接收任务队列。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AcceptorExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(ID id, T task, <span class="keyword">long</span> expiryTime)</span> </span>&#123;</div><div class="line">   acceptorQueue.add(<span class="keyword">new</span> TaskHolder&lt;ID, T&gt;(id, task, expiryTime));</div><div class="line">   acceptedTasks++;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p><code>com.netflix.eureka.util.batcher.TaskHolder</code> ，任务持有者，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskHolder</span>&lt;<span class="title">ID</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 任务编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ID id;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 任务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T task;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 任务过期时间戳</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> expiryTime;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 任务提交时间戳</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> submitTimestamp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h1 id="9-任务接收线程【调度任务】"><a href="#9-任务接收线程【调度任务】" class="headerlink" title="9. 任务接收线程【调度任务】"></a>9. 任务接收线程【调度任务】</h1><p>后台线程执行 <code>AcceptorRunner#run(...)</code> 方法，调度任务。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">3</span>:     <span class="keyword">long</span> scheduleTime = <span class="number">0</span>;</div><div class="line"> <span class="number">4</span>:     <span class="keyword">while</span> (!isShutdown.get()) &#123;</div><div class="line"> <span class="number">5</span>:         <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">6</span>:             <span class="comment">// 处理完输入队列( 接收队列 + 重新执行队列 )</span></div><div class="line"> <span class="number">7</span>:             drainInputQueues();</div><div class="line"> <span class="number">8</span>: </div><div class="line"> <span class="number">9</span>:             <span class="comment">// 待执行任务数量</span></div><div class="line"><span class="number">10</span>:             <span class="keyword">int</span> totalItems = processingOrder.size();</div><div class="line"><span class="number">11</span>: </div><div class="line"><span class="number">12</span>:             <span class="comment">// 计算调度时间</span></div><div class="line"><span class="number">13</span>:             <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line"><span class="number">14</span>:             <span class="keyword">if</span> (scheduleTime &lt; now) &#123;</div><div class="line"><span class="number">15</span>:                 scheduleTime = now + trafficShaper.transmissionDelay();</div><div class="line"><span class="number">16</span>:             &#125;</div><div class="line"><span class="number">17</span>: </div><div class="line"><span class="number">18</span>:             <span class="comment">// 调度</span></div><div class="line"><span class="number">19</span>:             <span class="keyword">if</span> (scheduleTime &lt;= now) &#123;</div><div class="line"><span class="number">20</span>:                 <span class="comment">// 调度批量任务</span></div><div class="line"><span class="number">21</span>:                 assignBatchWork();</div><div class="line"><span class="number">22</span>:                 <span class="comment">// 调度单任务</span></div><div class="line"><span class="number">23</span>:                 assignSingleItemWork();</div><div class="line"><span class="number">24</span>:             &#125;</div><div class="line"><span class="number">25</span>: </div><div class="line"><span class="number">26</span>:             <span class="comment">// 1）任务执行器无任务请求，正在忙碌处理之前的任务；或者 2）任务延迟调度。睡眠 10 秒，避免资源浪费。</span></div><div class="line"><span class="number">27</span>:             <span class="comment">// If no worker is requesting data or there is a delay injected by the traffic shaper,</span></div><div class="line"><span class="number">28</span>:             <span class="comment">// sleep for some time to avoid tight loop.</span></div><div class="line"><span class="number">29</span>:             <span class="keyword">if</span> (totalItems == processingOrder.size()) &#123;</div><div class="line"><span class="number">30</span>:                 Thread.sleep(<span class="number">10</span>);</div><div class="line"><span class="number">31</span>:             &#125;</div><div class="line"><span class="number">32</span>:         &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</div><div class="line"><span class="number">33</span>:             <span class="comment">// Ignore</span></div><div class="line"><span class="number">34</span>:         &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"><span class="number">35</span>:             <span class="comment">// Safe-guard, so we never exit this loop in an uncontrolled way.</span></div><div class="line"><span class="number">36</span>:             logger.warn(<span class="string">"Discovery AcceptorThread error"</span>, e);</div><div class="line"><span class="number">37</span>:         &#125;</div><div class="line"><span class="number">38</span>:     &#125;</div><div class="line"><span class="number">39</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 4 行 ：无限循环执行调度，直到关闭。</li><li><p>第 6 至 7 行 ：调用 <code>#drainInputQueues()</code> 方法，<strong>循环</strong>处理完输入队列( 接收队列 + 重新执行队列 )，<strong>直到</strong>有待执行的任务。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drainInputQueues</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="keyword">do</span> &#123;</div><div class="line"> <span class="number">3</span>:         <span class="comment">// 处理完重新执行队列</span></div><div class="line"> <span class="number">4</span>:         drainReprocessQueue();</div><div class="line"> <span class="number">5</span>:         <span class="comment">// 处理完接收队列</span></div><div class="line"> <span class="number">6</span>:         drainAcceptorQueue();</div><div class="line"> <span class="number">7</span>: </div><div class="line"> <span class="number">8</span>:         <span class="comment">// 所有队列为空，等待 10 ms，看接收队列是否有新任务</span></div><div class="line"> <span class="number">9</span>:         <span class="keyword">if</span> (!isShutdown.get()) &#123;</div><div class="line"><span class="number">10</span>:             <span class="comment">// If all queues are empty, block for a while on the acceptor queue</span></div><div class="line"><span class="number">11</span>:             <span class="keyword">if</span> (reprocessQueue.isEmpty() &amp;&amp; acceptorQueue.isEmpty() &amp;&amp; pendingTasks.isEmpty()) &#123;</div><div class="line"><span class="number">12</span>:                 TaskHolder&lt;ID, T&gt; taskHolder = acceptorQueue.poll(<span class="number">10</span>, TimeUnit.MILLISECONDS);</div><div class="line"><span class="number">13</span>:                 <span class="keyword">if</span> (taskHolder != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">14</span>:                     appendTaskHolder(taskHolder);</div><div class="line"><span class="number">15</span>:                 &#125;</div><div class="line"><span class="number">16</span>:             &#125;</div><div class="line"><span class="number">17</span>:         &#125;</div><div class="line"><span class="number">18</span>:     &#125; <span class="keyword">while</span> (!reprocessQueue.isEmpty() || !acceptorQueue.isEmpty() || pendingTasks.isEmpty()); <span class="comment">// 处理完输入队列( 接收队列 + 重新执行队列 )</span></div><div class="line"><span class="number">19</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 2 行 &amp;&amp; 第 18 行 ：<strong>循环</strong>，直到<strong>同时</strong>满足如下全部条件：<ul><li>重新执行队列( <code>reprocessQueue</code> ) 和接收队列( <code>acceptorQueue</code> )为空</li><li>待执行任务映射( <code>pendingTasks</code> )<strong>不为空</strong></li></ul></li><li><p>第 3 至 4 行 ：处理完重新执行队列( <code>reprocessQueue</code> )。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drainReprocessQueue</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line"> <span class="number">3</span>:     <span class="keyword">while</span> (!reprocessQueue.isEmpty() &amp;&amp; !isFull()) &#123;</div><div class="line"> <span class="number">4</span>:         TaskHolder&lt;ID, T&gt; taskHolder = reprocessQueue.pollLast(); <span class="comment">// 优先拿较新的任务</span></div><div class="line"> <span class="number">5</span>:         ID id = taskHolder.getId();</div><div class="line"> <span class="number">6</span>:         <span class="keyword">if</span> (taskHolder.getExpiryTime() &lt;= now) &#123; <span class="comment">// 过期</span></div><div class="line"> <span class="number">7</span>:             expiredTasks++;</div><div class="line"> <span class="number">8</span>:         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pendingTasks.containsKey(id)) &#123; <span class="comment">// 已存在</span></div><div class="line"> <span class="number">9</span>:             overriddenTasks++;</div><div class="line"><span class="number">10</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">11</span>:             pendingTasks.put(id, taskHolder);</div><div class="line"><span class="number">12</span>:             processingOrder.addFirst(id); <span class="comment">// 提交到队头</span></div><div class="line"><span class="number">13</span>:         &#125;</div><div class="line"><span class="number">14</span>:     &#125;</div><div class="line"><span class="number">15</span>:     <span class="comment">// 如果待执行队列已满，清空重新执行队列，放弃较早的任务</span></div><div class="line"><span class="number">16</span>:     <span class="keyword">if</span> (isFull()) &#123;</div><div class="line"><span class="number">17</span>:         queueOverflows += reprocessQueue.size();</div><div class="line"><span class="number">18</span>:         reprocessQueue.clear();</div><div class="line"><span class="number">19</span>:     &#125;</div><div class="line"><span class="number">20</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 4 行 ：优先从重新执行任务的队尾拿较新的任务，从而实现保留更新的任务在待执行任务映射( <code>pendingTasks</code> ) 里。</li><li>第 12 行 ：添加任务编号到待执行队列( <code>processingOrder</code> ) 的头部。效果如下图：<img src="http://www.iocoder.cn/images/Eureka/2018_07_17/03.png" alt=""></li><li>第 15 至 18 行 ：如果待执行队列( <code>pendingTasks</code> )已满，清空重新执行队列( <code>processingOrder</code> )，放弃较早的任务。</li></ul></li><li><p>第 5 至 6 行 ：处理完接收队列( <code>acceptorQueue</code> )，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drainAcceptorQueue</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">while</span> (!acceptorQueue.isEmpty()) &#123; <span class="comment">// 循环，直到接收队列为空</span></div><div class="line">      appendTaskHolder(acceptorQueue.poll());</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendTaskHolder</span><span class="params">(TaskHolder&lt;ID, T&gt; taskHolder)</span> </span>&#123;</div><div class="line">  <span class="comment">// 如果待执行队列已满，移除待处理队列，放弃较早的任务</span></div><div class="line">  <span class="keyword">if</span> (isFull()) &#123;</div><div class="line">      pendingTasks.remove(processingOrder.poll());</div><div class="line">      queueOverflows++;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 添加到待执行队列</span></div><div class="line">  TaskHolder&lt;ID, T&gt; previousTask = pendingTasks.put(taskHolder.getId(), taskHolder);</div><div class="line">  <span class="keyword">if</span> (previousTask == <span class="keyword">null</span>) &#123;</div><div class="line">      processingOrder.add(taskHolder.getId());</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">      overriddenTasks++;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>第 8 至 17 行 ：当所有队列为空，阻塞从接收队列( <code>acceptorQueue</code> ) 拉取任务 10 ms。若拉取到，添加到待执行队列( <code>processingOrder</code> )。</p></li></ul></li><li><p>第 12 至 16 行 ：计算可调度任务的最小时间( <code>scheduleTime</code> )。</p><ul><li>当 <code>scheduleTime</code> 小于当前时间，不重新计算，即此时需要延迟等待调度。</li><li>当 <code>scheduleTime</code> 大于等于当前时间，配合 <code>TrafficShaper#transmissionDelay(...)</code> 重新计算。</li></ul></li><li>第 19 行 ：当 <code>scheduleTime</code> 小于当前时间，执行任务的调度。</li><li><p>第 21 行 ：调用 <code>#assignBatchWork()</code> 方法，调度批量任务。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">void</span> <span class="title">assignBatchWork</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="keyword">if</span> (hasEnoughTasksForNextBatch()) &#123;</div><div class="line"> <span class="number">3</span>:         <span class="comment">// 获取 批量任务工作请求信号量</span></div><div class="line"> <span class="number">4</span>:         <span class="keyword">if</span> (batchWorkRequests.tryAcquire(<span class="number">1</span>)) &#123;</div><div class="line"> <span class="number">5</span>:             <span class="comment">// 获取批量任务</span></div><div class="line"> <span class="number">6</span>:             <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line"> <span class="number">7</span>:             <span class="keyword">int</span> len = Math.min(maxBatchingSize, processingOrder.size());</div><div class="line"> <span class="number">8</span>:             List&lt;TaskHolder&lt;ID, T&gt;&gt; holders = <span class="keyword">new</span> ArrayList&lt;&gt;(len);</div><div class="line"> <span class="number">9</span>:             <span class="keyword">while</span> (holders.size() &lt; len &amp;&amp; !processingOrder.isEmpty()) &#123;</div><div class="line"><span class="number">10</span>:                 ID id = processingOrder.poll();</div><div class="line"><span class="number">11</span>:                 TaskHolder&lt;ID, T&gt; holder = pendingTasks.remove(id);</div><div class="line"><span class="number">12</span>:                 <span class="keyword">if</span> (holder.getExpiryTime() &gt; now) &#123; <span class="comment">// 过期</span></div><div class="line"><span class="number">13</span>:                     holders.add(holder);</div><div class="line"><span class="number">14</span>:                 &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">15</span>:                     expiredTasks++;</div><div class="line"><span class="number">16</span>:                 &#125;</div><div class="line"><span class="number">17</span>:             &#125;</div><div class="line"><span class="number">18</span>:             <span class="comment">//</span></div><div class="line"><span class="number">19</span>:             <span class="keyword">if</span> (holders.isEmpty()) &#123; <span class="comment">// 未调度到批量任务，释放请求信号量</span></div><div class="line"><span class="number">20</span>:                 batchWorkRequests.release();</div><div class="line"><span class="number">21</span>:             &#125; <span class="keyword">else</span> &#123; <span class="comment">// 添加批量任务到批量任务工作队列</span></div><div class="line"><span class="number">22</span>:                 batchSizeMetric.record(holders.size(), TimeUnit.MILLISECONDS);</div><div class="line"><span class="number">23</span>:                 batchWorkQueue.add(holders);</div><div class="line"><span class="number">24</span>:             &#125;</div><div class="line"><span class="number">25</span>:         &#125;</div><div class="line"><span class="number">26</span>:     &#125;</div><div class="line"><span class="number">27</span>: &#125;</div></pre></td></tr></table></figure><ul><li><p>第 2 行 ：调用 <code>#hasEnoughTasksForNextBatch()</code> 方法，判断是否有足够任务进行下一次批量任务调度：1）待执行任务( <code>processingOrder</code> )映射已满；或者 2）到达批量任务处理最大等待延迟。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasEnoughTasksForNextBatch</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 待执行队列为空</span></div><div class="line">    <span class="keyword">if</span> (processingOrder.isEmpty()) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 待执行任务映射已满</span></div><div class="line">    <span class="keyword">if</span> (pendingTasks.size() &gt;= maxBufferSize) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 到达批量任务处理最大等待延迟( 通过待处理队列的头部任务判断 )</span></div><div class="line">    TaskHolder&lt;ID, T&gt; nextHolder = pendingTasks.get(processingOrder.peek());</div><div class="line">    <span class="keyword">long</span> delay = System.currentTimeMillis() - nextHolder.getSubmitTimestamp();</div><div class="line">    <span class="keyword">return</span> delay &gt;= maxBatchingDelay;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul></li><li><p>第 5 至 17 行 ：获取批量任务( <code>holders</code> )。😈 你会发现，本文说了半天的批量任务，实际是 <code>List&lt;TaskHolder&lt;ID, T&gt;&gt;</code> 哈。</p></li><li>第 4 行 ：获取批量任务工作请求信号量( <code>batchWorkRequests</code> ) 。在任务执行器的批量任务执行器，每次执行时，发出 <code>batchWorkRequests</code> 。<strong>每一个信号量需要保证获取到一个批量任务</strong>。</li><li>第 19 至 20 行 ：未调度到批量任务，释放请求信号量，<strong>代表请求实际未完成，每一个信号量需要保证获取到一个批量任务</strong>。</li><li>第 21 至 24 行 ：添加批量任务到批量任务工作队列。</li><li>第 23 行 ：调用 <code>#assignSingleItemWork()</code> 方法，调度单任务。</li></ul></li><li><p>第 23 行 ：调用 <code>#assignSingleItemWork()</code> 方法，调度单任务，和 <code>#assignBatchWork()</code> 方法<strong>类似</strong>。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">assignSingleItemWork</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!processingOrder.isEmpty()) &#123; <span class="comment">// 待执行任队列不为空</span></div><div class="line">      <span class="comment">// 获取 单任务工作请求信号量</span></div><div class="line">      <span class="keyword">if</span> (singleItemWorkRequests.tryAcquire(<span class="number">1</span>)) &#123;</div><div class="line">          <span class="comment">// 【循环】获取单任务</span></div><div class="line">          <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line">          <span class="keyword">while</span> (!processingOrder.isEmpty()) &#123;</div><div class="line">              ID id = processingOrder.poll(); <span class="comment">// 一定不为空</span></div><div class="line">              TaskHolder&lt;ID, T&gt; holder = pendingTasks.remove(id);</div><div class="line">              <span class="keyword">if</span> (holder.getExpiryTime() &gt; now) &#123;</div><div class="line">                  singleItemWorkQueue.add(holder);</div><div class="line">                  <span class="keyword">return</span>;</div><div class="line">              &#125;</div><div class="line">              expiredTasks++;</div><div class="line">          &#125;</div><div class="line">          <span class="comment">// 获取不到单任务，释放请求信号量</span></div><div class="line">          singleItemWorkRequests.release();</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul></li><li><p>第 26 至 31 行 ：当调度任务前的待执行任务数( <code>totalItems</code> )等于当前待执行队列( <code>processingOrder</code> )的任务数，意味着：1）任务执行器无任务请求，正在忙碌处理之前的任务；或者 2）任务延迟调度。睡眠 10 秒，避免资源浪费。</p></li></ul><h1 id="10-任务执行器【执行任务】"><a href="#10-任务执行器【执行任务】" class="headerlink" title="10. 任务执行器【执行任务】"></a>10. 任务执行器【执行任务】</h1><h2 id="10-1-批量任务工作线程"><a href="#10-1-批量任务工作线程" class="headerlink" title="10.1 批量任务工作线程"></a>10.1 批量任务工作线程</h2><p>批量任务工作后台线程( BatchWorkerRunnable )执行 <code>#run(...)</code> 方法，调度任务。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// </span></div><div class="line">  <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line">  <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="number">3</span>:     <span class="keyword">try</span> &#123;</div><div class="line">  <span class="number">4</span>:         <span class="keyword">while</span> (!isShutdown.get()) &#123;</div><div class="line">  <span class="number">5</span>:             <span class="comment">// 获取批量任务</span></div><div class="line">  <span class="number">6</span>:             List&lt;TaskHolder&lt;ID, T&gt;&gt; holders = getWork();</div><div class="line">  <span class="number">7</span>: </div><div class="line">  <span class="number">8</span>:             <span class="comment">// TODO 芋艿：监控相关，暂时无视</span></div><div class="line">  <span class="number">9</span>:             metrics.registerExpiryTimes(holders);</div><div class="line"> <span class="number">10</span>: </div><div class="line"> <span class="number">11</span>:             <span class="comment">// 获得实际批量任务</span></div><div class="line"> <span class="number">12</span>:             List&lt;T&gt; tasks = getTasksOf(holders);</div><div class="line"> <span class="number">13</span>:             <span class="comment">// 调用处理器执行任务</span></div><div class="line"> <span class="number">14</span>:             ProcessingResult result = processor.process(tasks);</div><div class="line"> <span class="number">15</span>:             <span class="keyword">switch</span> (result) &#123;</div><div class="line"> <span class="number">16</span>:                 <span class="keyword">case</span> Success:</div><div class="line"> <span class="number">17</span>:                     <span class="keyword">break</span>;</div><div class="line"> <span class="number">18</span>:                 <span class="keyword">case</span> Congestion:</div><div class="line"> <span class="number">19</span>:                 <span class="keyword">case</span> TransientError:</div><div class="line"> <span class="number">20</span>:                     taskDispatcher.reprocess(holders, result); <span class="comment">// 提交重新处理</span></div><div class="line"> <span class="number">21</span>:                     <span class="keyword">break</span>;</div><div class="line"> <span class="number">22</span>:                 <span class="keyword">case</span> PermanentError:</div><div class="line"> <span class="number">23</span>:                     logger.warn(<span class="string">"Discarding &#123;&#125; tasks of &#123;&#125; due to permanent error"</span>, holders.size(), workerName);</div><div class="line"> <span class="number">24</span>:             &#125;</div><div class="line"> <span class="number">25</span>: </div><div class="line"> <span class="number">26</span>:             <span class="comment">// TODO 芋艿：监控相关，暂时无视</span></div><div class="line"> <span class="number">27</span>:             metrics.registerTaskResult(result, tasks.size());</div><div class="line"> <span class="number">28</span>:         &#125;</div><div class="line"> <span class="number">29</span>:     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line"> <span class="number">30</span>:         <span class="comment">// Ignore</span></div><div class="line"> <span class="number">31</span>:     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"> <span class="number">32</span>:         <span class="comment">// Safe-guard, so we never exit this loop in an uncontrolled way.</span></div><div class="line"> <span class="number">33</span>:         logger.warn(<span class="string">"Discovery WorkerThread error"</span>, e);</div><div class="line"> <span class="number">34</span>:     &#125;</div><div class="line"> <span class="number">35</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 4 行 ：无限循环执行调度，直到关闭。</li><li><p>第 6 行 ：调用 <code>getWork()</code> 方法，获取<strong>一个</strong>批量任务直到成功。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">private</span> List&lt;TaskHolder&lt;ID, T&gt;&gt; getWork() <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// 发起请求信号量，并获得批量任务的工作队列</span></div><div class="line"> <span class="number">3</span>:     BlockingQueue&lt;List&lt;TaskHolder&lt;ID, T&gt;&gt;&gt; workQueue = taskDispatcher.requestWorkItems();</div><div class="line"> <span class="number">4</span>:     <span class="comment">// 【循环】获取批量任务，直到成功</span></div><div class="line"> <span class="number">5</span>:     List&lt;TaskHolder&lt;ID, T&gt;&gt; result;</div><div class="line"> <span class="number">6</span>:     <span class="keyword">do</span> &#123;</div><div class="line"> <span class="number">7</span>:         result = workQueue.poll(<span class="number">1</span>, TimeUnit.SECONDS);</div><div class="line"> <span class="number">8</span>:     &#125; <span class="keyword">while</span> (!isShutdown.get() &amp;&amp; result == <span class="keyword">null</span>);</div><div class="line"> <span class="number">9</span>:     <span class="keyword">return</span> result;</div><div class="line"><span class="number">10</span>: &#125;</div></pre></td></tr></table></figure><ul><li><p>第 3 行 ：调用 <code>TaskDispatcher#requestWorkItems()</code> 方法，发起请求信号量，并获得批量任务的工作队列。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TaskDispatcher.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 批量任务工作请求信号量</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Semaphore batchWorkRequests = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 批量任务工作队列</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;List&lt;TaskHolder&lt;ID, T&gt;&gt;&gt; batchWorkQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class="line"></div><div class="line">BlockingQueue&lt;List&lt;TaskHolder&lt;ID, T&gt;&gt;&gt; requestWorkItems() &#123;</div><div class="line">   batchWorkRequests.release();</div><div class="line">   <span class="keyword">return</span> batchWorkQueue;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>注意</strong>，批量任务工作队列( <code>batchWorkQueue</code> ) 和单任务工作队列( <code>singleItemWorkQueue</code> ) 是<strong>不同的队列</strong>。</li></ul></li><li><p>第 5 至 8 行 ：<strong>循环</strong>获取<strong>一个</strong>批量任务，直到成功。</p></li></ul></li><li><p>第 12 行 ：调用 <code>#getTasksOf(...)</code> 方法，获得<strong>实际</strong>批量任务。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> List&lt;T&gt; <span class="title">getTasksOf</span><span class="params">(List&lt;TaskHolder&lt;ID, T&gt;&gt; holders)</span> </span>&#123;</div><div class="line">    List&lt;T&gt; tasks = <span class="keyword">new</span> ArrayList&lt;&gt;(holders.size());</div><div class="line">    <span class="keyword">for</span> (TaskHolder&lt;ID, T&gt; holder : holders) &#123;</div><div class="line">        tasks.add(holder.getTask());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> tasks;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul></li><li><p>第 14 至 24 行 ：调用处理器( TaskProcessor ) 执行任务。当任务执行结果为 <code>Congestion</code> 或 <code>TransientError</code> ，调用 <code>AcceptorExecutor#reprocess(...)</code> 提交<strong>整个批量任务</strong>重新处理，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AcceptorExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">reprocess</span><span class="params">(List&lt;TaskHolder&lt;ID, T&gt;&gt; holders, ProcessingResult processingResult)</span> </span>&#123;</div><div class="line">   <span class="comment">// 添加到 重新执行队列</span></div><div class="line">   reprocessQueue.addAll(holders);</div><div class="line"></div><div class="line">   <span class="comment">// TODO 芋艿：监控相关，暂时无视</span></div><div class="line">   replayedTasks += holders.size();</div><div class="line">   </div><div class="line">   <span class="comment">// 提交任务结果给 TrafficShaper</span></div><div class="line">   trafficShaper.registerFailure(processingResult);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h2 id="10-2-单任务工作线程"><a href="#10-2-单任务工作线程" class="headerlink" title="10.2 单任务工作线程"></a>10.2 单任务工作线程</h2><p>单任务工作后台线程( SingleTaskWorkerRunnable )执行 <code>#run(...)</code> 方法，调度任务，和 <code>BatchWorkerRunnable#run(...)</code> 基本类似，就不啰嗦了。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="comment">// SingleTaskWorkerRunnable.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">while</span> (!isShutdown.get()) &#123;</div><div class="line">          <span class="comment">// 发起请求信号量，并获得单任务的工作队列</span></div><div class="line">          BlockingQueue&lt;TaskHolder&lt;ID, T&gt;&gt; workQueue = taskDispatcher.requestWorkItem();</div><div class="line">          TaskHolder&lt;ID, T&gt; taskHolder;</div><div class="line">          <span class="comment">// 【循环】获取单任务，直到成功</span></div><div class="line">          <span class="keyword">while</span> ((taskHolder = workQueue.poll(<span class="number">1</span>, TimeUnit.SECONDS)) == <span class="keyword">null</span>) &#123;</div><div class="line">              <span class="keyword">if</span> (isShutdown.get()) &#123;</div><div class="line">                  <span class="keyword">return</span>;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">          <span class="comment">// TODO 芋艿：监控相关，暂时无视</span></div><div class="line">          metrics.registerExpiryTime(taskHolder);</div><div class="line">          <span class="keyword">if</span> (taskHolder != <span class="keyword">null</span>) &#123;</div><div class="line">              <span class="comment">// 调用处理器执行任务</span></div><div class="line">              ProcessingResult result = processor.process(taskHolder.getTask());</div><div class="line">              <span class="keyword">switch</span> (result) &#123;</div><div class="line">                  <span class="keyword">case</span> Success:</div><div class="line">                      <span class="keyword">break</span>;</div><div class="line">                  <span class="keyword">case</span> Congestion:</div><div class="line">                  <span class="keyword">case</span> TransientError:</div><div class="line">                      taskDispatcher.reprocess(taskHolder, result); <span class="comment">// 提交重新处理</span></div><div class="line">                      <span class="keyword">break</span>;</div><div class="line">                  <span class="keyword">case</span> PermanentError:</div><div class="line">                      logger.warn(<span class="string">"Discarding a task of &#123;&#125; due to permanent error"</span>, workerName);</div><div class="line">              &#125;</div><div class="line">              <span class="comment">// TODO 芋艿：监控相关，暂时无视</span></div><div class="line">              metrics.registerTaskResult(result, <span class="number">1</span>);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">      <span class="comment">// Ignore</span></div><div class="line">  &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">      <span class="comment">// Safe-guard, so we never exit this loop in an uncontrolled way.</span></div><div class="line">      logger.warn(<span class="string">"Discovery WorkerThread error"</span>, e);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>😈 又是一篇长文。建议边看代码，边对照着整体流程图，理解实际不难。</p><p>当然，欢迎你有任何疑问，在我的公众号( <strong>芋道源码</strong> ) 留言。</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/batch-tasks/&quot;&gt;http://www.iocoder.cn/Eureka/batch-tasks/&lt;/a&gt; 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;st
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— Eureka源码解析 —— 应用实例注册发现 （九）之岁月是把萌萌的读写锁</title>
    <link href="http://www.iocoder.cn/Eureka/instance-registry-read-write-lock/"/>
    <id>http://www.iocoder.cn/Eureka/instance-registry-read-write-lock/</id>
    <published>2018-07-13T16:00:00.000Z</published>
    <updated>2017-10-20T01:19:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/instance-registry-read-write-lock/">http://www.iocoder.cn/Eureka/instance-registry-read-write-lock/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-read-write-lock/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-read-write-lock/">2. 读写锁</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-read-write-lock/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Eureka 注册中心的那把读写锁</strong>，让我瘙痒难耐，却不得其解。在某次意外的抠脚的一刻( 笔者不抽烟，如果抽烟的话，此处应该就不是抠脚了 )，突然顿悟，爽，这好比… 比喻有点猥琐，笔者就省略 100 字。</p><p>不瞎比比，上代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractInstanceRegistry</span> <span class="keyword">implements</span> <span class="title">InstanceRegistry</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock read = readWriteLock.readLock();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock write = readWriteLock.writeLock();</div><div class="line"></div><div class="line">    <span class="comment">// ... 省略其他代码</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-读写锁"><a href="#2-读写锁" class="headerlink" title="2. 读写锁"></a>2. 读写锁</h1><p>我们把设计到读写锁的方法整理如下：</p><table><thead><tr><th>方法</th><th>读锁</th><th>写锁</th><th>不使用</th></tr></thead><tbody><tr><td><code>#register(...)</code></td><td>√</td><td></td><td></td></tr><tr><td><code>#cancel(...)</code></td><td>√</td><td></td><td></td></tr><tr><td><code>#evict(...)</code></td><td>√</td><td></td><td></td></tr><tr><td><code>#renew(...)</code></td><td></td><td></td><td>√</td></tr><tr><td><code>#statusUpdate(...)</code></td><td>√</td><td></td><td></td></tr><tr><td><code>#deleteStatusOverride(...)</code></td><td>√</td><td></td><td></td></tr><tr><td><code>#getApplicationDeltasFromMultipleRegions(...)</code></td><td></td><td>√</td><td></td></tr><tr><td><code>#getApplicationsFromMultipleRegions(...)</code></td><td></td><td></td><td>√</td></tr></tbody></table><p>是否看到这读写感到几丝诡异的味道？OK，我们把问题梳理如下：</p><ul><li>A. 为什么 <code>#register(...)</code> / <code>#cancel(...)</code> / <code>#evict(...)</code> / <code>#statusUpdate(...)</code> / <code>#deleteStatusOverride(...)</code> 等<strong>写操作</strong>使用<strong>读锁</strong></li><li>B. 为什么 <code>#renew(...)</code> <strong>写操作</strong>不使用<strong>锁</strong></li><li>C. 为什么 <code>#getApplicationDeltasFromMultipleRegions(...)</code> <strong>读操作</strong>使用<strong>写锁</strong></li><li>D. 为什么 <code>getApplicationsFromMultipleRegions(...)</code> <strong>读操作</strong>不使用<strong>锁</strong></li></ul><hr><p><strong>先解释 A + C</strong> ：</p><p>我们来回想下，在 Eureka 应用集合一致性哈希码的公式：<code>appsHashCode = ${status}_${count}_</code> 。( 不了解的同学可以加载下 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">《Eureka 源码解析 —— 应用实例注册发现（七）之增量获取》「 2. 应用集合一致性哈希码 」</a> )</p><p><del>应用实例的数量和状态都会影响<strong>哈希码</strong>的计算结果。也就是说，上述<strong>前六个</strong>( 包括不使用锁的 <code>#renew(...)</code> 方法 )方法的调用都会影响哈希码。</del></p><p>我们把目光移向唯一使用<strong>写锁</strong>的 <code>#getApplicationDeltasFromMultipleRegions(...)</code> 方法，该方法执行过程中，需要保证 <code>recentlyChangedQueue</code> 和 <code>registry</code> 共享变量的<strong>应用实例的状态一致</strong>，不然返回的增量应用实例集合的状态是不准确的。此时能够达到该效果，必须让 <code>#getApplicationDeltasFromMultipleRegions(...)</code> 和前六个方法<strong>互斥</strong>。方案如下：</p><ul><li>a. 全部 <code>synchronized</code></li><li>b. <code>#getApplicationDeltasFromMultipleRegions(...)</code> 使用<strong>读锁</strong>，前六个方法使用<strong>写锁</strong></li><li>c. <code>#getApplicationDeltasFromMultipleRegions(...)</code> 使用<strong>写锁</strong>，前六个方法使用<strong>读锁</strong></li></ul><p>Eureka 选择了<strong>方案c</strong>，原因如下：</p><ul><li>a. 性能太差</li><li>b. 前六个方法使用<strong>写锁</strong>，势必冲突太大，虽然读肯定比写多。</li><li>c. <code>#getApplicationDeltasFromMultipleRegions(...)</code> 使用<strong>写锁</strong>，配合 ResponseCache ，即减少了<strong>写锁</strong>使用的频率，每次缓存过期才使用，又避免了前六个方法因为<strong>方案b</strong>中的<strong>写锁</strong>导致互斥。( 不了解 ResponseCache 的同学可以加载下 <a href="hhttp://www.iocoder.cn/Eureka/instance-registry-fetch-all/">《Eureka 源码解析 —— 应用实例注册发现（六）之全量获取》「 3.2 响应缓存 ResponseCache 」</a> )</li></ul><hr><p><strong>再解释 D</strong></p><p><code>#getApplicationsFromMultipleRegions(...)</code> 方法的逻辑，只依赖 <code>registry</code> 共享变量，不存在应用实例的状态一致的困扰，所以不使用锁。</p><hr><p><strong>最后解释 B</strong></p><p><code>#renew(...)</code> 方法的逻辑，虽然会影响应用实例的状态，但是是极小概率，考虑到它调用的比较频繁，比起因为锁给这个方法带来的性能降低，不如返回的结果暂时不够准确。( 想了解极小概率发生原因的同学可以加载 <a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/?self">《Eureka 源码解析 —— 应用实例注册发现（八）之覆盖状态》「 4.3 续租场景 」</a> )</p><hr><p>TODO [0029] 读写锁</p><p>笔者路上突然又想了问题，可能不是上述原因，可能和 ResponseCache 有关系，参见 <code>#invalidateCache(...)</code> 方法的每次调用。也就是说，这个读写锁是针对 ResponseCache 的读写锁。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>开森 ！</p><p>本来以为需要跟 Eureka 官方提交 issue 提问，并且做好了获得不到答案的准备，结果无意中的抠脚( 请允许我热爱抠脚给我带来的灵感 )解答了自己的疑惑。</p><p>岁月是把纠结而又萌萌哒的锁，你不知道你的困扰，哪天不经意的被打开。</p><p>愿大喜大悲，不枉仅知的这一生。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/instance-registry-read-write-lock/&quot;&gt;http://www.iocoder.cn/Eureka/instance-registry-read-wr
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 应用实例注册发现（八）之覆盖状态</title>
    <link href="http://www.iocoder.cn/Eureka/instance-registry-override-status/"/>
    <id>http://www.iocoder.cn/Eureka/instance-registry-override-status/</id>
    <published>2018-07-07T16:00:00.000Z</published>
    <updated>2017-10-18T18:03:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">http://www.iocoder.cn/Eureka/instance-registry-override-status/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong> </p><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">2. 应用实例覆盖状态变更接口</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">2.1 更新应用实例覆盖状态</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">3. 应用实例覆盖状态删除接口</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">3.1 删除应用实例覆盖状态</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">4. 应用实例覆盖状态映射</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">4.1 应用实例状态覆盖规则</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">4.2 注册场景</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">4.3 续租场景</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">4.4 下线场景</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">4.5 过期场景</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">5. 客户端调用接口</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>应用实例的覆盖状态属性</strong>。</p><p>这里要注意下，不是应用实例的状态( <code>status</code> )，而是覆盖状态( <code>overridestatus</code> ) 。代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceInfo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> InstanceStatus overriddenstatus = InstanceStatus.UNKNOWN;</div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略属性和方法</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>调用 Eureka-Server HTTP Restful 接口 <code>apps/${APP_NAME}/${INSTANCE_ID}/status</code> 对应用实例覆盖状态的变更，从而达到<strong>主动</strong>的、<strong>强制</strong>的变更应用实例状态。注意，<strong>实际不会真的修改 Eureka-Client 应用实例的状态，而是修改在 Eureka-Server 注册的应用实例的状态</strong>。</p><p>通过这样的方式，Eureka-Client 在获取到注册信息时，并且配置 <code>eureka.shouldFilterOnlyUpInstances = true</code>，过滤掉非 <code>InstanceStatus.UP</code> 的应用实例，从而避免调动该实例，以达到应用实例的<strong>暂停服务( <code>InstanceStatus.OUT_OF_SERVICE</code> )，而无需关闭应用实例</strong>。</p><p>因此，大多数情况下，调用该接口的目的，将应用实例状态在 ( <code>InstanceStatus.UP</code> ) 和  ( <code>InstanceStatus.OUT_OF_SERVICE</code> ) 之间切换。引用官方代码上的注释如下：</p><blockquote><p><code>AbstractInstanceRegistry#statusUpdate</code> 方法注释<br>Updates the status of an instance.<br>Normally happens to put an instance between {@link InstanceStatus#OUT_OF_SERVICE} and {@link InstanceStatus#UP} to put the instance in and out of traffic.</p></blockquote><hr><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><hr><p>接口 <code>apps/${APP_NAME}/${INSTANCE_ID}/status</code> 实际是两个：</p><ul><li>PUT <code>apps/${APP_NAME}/${INSTANCE_ID}/status</code></li><li>DELETE <code>apps/${APP_NAME}/${INSTANCE_ID}/status</code></li></ul><p>下面，我们逐节分享这两接口的代码实现。</p><h1 id="2-应用实例覆盖状态变更接口"><a href="#2-应用实例覆盖状态变更接口" class="headerlink" title="2. 应用实例覆盖状态变更接口"></a>2. 应用实例覆盖状态变更接口</h1><p>应用实例覆盖状态变更接口，映射 <code>InstanceResource#statusUpdate()</code> 方法，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@PUT</span></div><div class="line"><span class="meta">@Path</span>(<span class="string">"status"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">statusUpdate</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">       @QueryParam(<span class="string">"value"</span>)</span> String newStatus,</span></div><div class="line"><span class="function">       @<span class="title">HeaderParam</span><span class="params">(PeerEurekaNode.HEADER_REPLICATION)</span> String isReplication,</span></div><div class="line"><span class="function">       @<span class="title">QueryParam</span><span class="params">(<span class="string">"lastDirtyTimestamp"</span>)</span> String lastDirtyTimestamp) </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 应用实例不存在</span></div><div class="line">       <span class="keyword">if</span> (registry.getInstanceByAppAndId(app.getName(), id) == <span class="keyword">null</span>) &#123;</div><div class="line">           logger.warn(<span class="string">"Instance not found: &#123;&#125;/&#123;&#125;"</span>, app.getName(), id);</div><div class="line">           <span class="keyword">return</span> Response.status(Status.NOT_FOUND).build();</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// 覆盖状态更新</span></div><div class="line">       <span class="keyword">boolean</span> isSuccess = registry.statusUpdate(app.getName(), id,</div><div class="line">               InstanceStatus.valueOf(newStatus), lastDirtyTimestamp,</div><div class="line">               <span class="string">"true"</span>.equals(isReplication));</div><div class="line"></div><div class="line">       <span class="comment">// 返回结果</span></div><div class="line">       <span class="keyword">if</span> (isSuccess) &#123;</div><div class="line">           logger.info(<span class="string">"Status updated: "</span> + app.getName() + <span class="string">" - "</span> + id</div><div class="line">                   + <span class="string">" - "</span> + newStatus);</div><div class="line">           <span class="keyword">return</span> Response.ok().build();</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           logger.warn(<span class="string">"Unable to update status: "</span> + app.getName() + <span class="string">" - "</span></div><div class="line">                   + id + <span class="string">" - "</span> + newStatus);</div><div class="line">           <span class="keyword">return</span> Response.serverError().build();</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">       logger.error(<span class="string">"Error updating instance &#123;&#125; for status &#123;&#125;"</span>, id,</div><div class="line">               newStatus);</div><div class="line">       <span class="keyword">return</span> Response.serverError().build();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>PeerAwareInstanceRegistryImpl#statusUpdate(...)</code> 方法，更新应用实例覆盖状态。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">statusUpdate</span><span class="params">(<span class="keyword">final</span> String appName, <span class="keyword">final</span> String id,</span></span></div><div class="line"><span class="function"><span class="params">                           <span class="keyword">final</span> InstanceStatus newStatus, String lastDirtyTimestamp,</span></span></div><div class="line"><span class="function"><span class="params">                           <span class="keyword">final</span> <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">super</span>.statusUpdate(appName, id, newStatus, lastDirtyTimestamp, isReplication)) &#123;</div><div class="line">       <span class="comment">// Eureka-Server 集群同步</span></div><div class="line">       replicateToPeers(Action.StatusUpdate, appName, id, <span class="keyword">null</span>, newStatus, isReplication);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用父类 <code>AbstractInstanceRegistry#statusUpdate(...)</code> 方法，更新应用实例覆盖状态。</li></ul></li></ul><h2 id="2-1-更新应用实例覆盖状态"><a href="#2-1-更新应用实例覆盖状态" class="headerlink" title="2.1 更新应用实例覆盖状态"></a>2.1 更新应用实例覆盖状态</h2><p>调用 <code>AbstractInstanceRegistry#statusUpdate(...)</code> 方法，更新应用实例覆盖状态，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">statusUpdate</span><span class="params">(String appName, String id,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">3</span>:                             InstanceStatus newStatus, String lastDirtyTimestamp,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">4</span>:                             <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line"> <span class="number">5</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">6</span>:         <span class="comment">// 获取读锁</span></div><div class="line"> <span class="number">7</span>:         read.lock();</div><div class="line"> <span class="number">8</span>:         <span class="comment">// 添加 覆盖状态变更次数 到 监控</span></div><div class="line"> <span class="number">9</span>:         STATUS_UPDATE.increment(isReplication);</div><div class="line"><span class="number">10</span>:         <span class="comment">// 获得 租约</span></div><div class="line"><span class="number">11</span>:         Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(appName);</div><div class="line"><span class="number">12</span>:         Lease&lt;InstanceInfo&gt; lease = <span class="keyword">null</span>;</div><div class="line"><span class="number">13</span>:         <span class="keyword">if</span> (gMap != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">14</span>:             lease = gMap.get(id);</div><div class="line"><span class="number">15</span>:         &#125;</div><div class="line"><span class="number">16</span>:         <span class="comment">// 租约不存在</span></div><div class="line"><span class="number">17</span>:         <span class="keyword">if</span> (lease == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">18</span>:             <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"><span class="number">19</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">20</span>:             <span class="comment">// 设置 租约最后更新时间（续租）</span></div><div class="line"><span class="number">21</span>:             lease.renew();</div><div class="line"><span class="number">22</span>: </div><div class="line"><span class="number">23</span>:             <span class="comment">// 应用实例信息不存在( 防御型编程 )</span></div><div class="line"><span class="number">24</span>:             InstanceInfo info = lease.getHolder();</div><div class="line"><span class="number">25</span>:             <span class="comment">// Lease is always created with its instance info object.</span></div><div class="line"><span class="number">26</span>:             <span class="comment">// This log statement is provided as a safeguard, in case this invariant is violated.</span></div><div class="line"><span class="number">27</span>:             <span class="keyword">if</span> (info == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">28</span>:                 logger.error(<span class="string">"Found Lease without a holder for instance id &#123;&#125;"</span>, id);</div><div class="line"><span class="number">29</span>:             &#125;</div><div class="line"><span class="number">30</span>:             <span class="comment">//</span></div><div class="line"><span class="number">31</span>:             <span class="keyword">if</span> ((info != <span class="keyword">null</span>) &amp;&amp; !(info.getStatus().equals(newStatus))) &#123;</div><div class="line"><span class="number">32</span>:                 <span class="comment">// 设置 租约的开始服务的时间戳（只有第一次有效）</span></div><div class="line"><span class="number">33</span>:                 <span class="comment">// Mark service as UP if needed</span></div><div class="line"><span class="number">34</span>:                 <span class="keyword">if</span> (InstanceStatus.UP.equals(newStatus)) &#123;</div><div class="line"><span class="number">35</span>:                     lease.serviceUp();</div><div class="line"><span class="number">36</span>:                 &#125;</div><div class="line"><span class="number">37</span>:                 <span class="comment">// 添加到 应用实例覆盖状态映射</span></div><div class="line"><span class="number">38</span>:                 <span class="comment">// This is NAC overridden status</span></div><div class="line"><span class="number">39</span>:                 overriddenInstanceStatusMap.put(id, newStatus);</div><div class="line"><span class="number">40</span>:                 <span class="comment">// 设置 应用实例覆盖状态</span></div><div class="line"><span class="number">41</span>:                 <span class="comment">// Set it for transfer of overridden status to replica on</span></div><div class="line"><span class="number">42</span>:                 <span class="comment">// replica start up</span></div><div class="line"><span class="number">43</span>:                 info.setOverriddenStatus(newStatus);</div><div class="line"><span class="number">44</span>:                 <span class="comment">// 设置 应用实例信息 数据不一致时间</span></div><div class="line"><span class="number">45</span>:                 <span class="keyword">long</span> replicaDirtyTimestamp = <span class="number">0</span>;</div><div class="line"><span class="number">46</span>:                 <span class="comment">// 设置 应用实例状态</span></div><div class="line"><span class="number">47</span>:                 info.setStatusWithoutDirty(newStatus);</div><div class="line"><span class="number">48</span>:                 <span class="keyword">if</span> (lastDirtyTimestamp != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">49</span>:                     replicaDirtyTimestamp = Long.valueOf(lastDirtyTimestamp);</div><div class="line"><span class="number">50</span>:                 &#125;</div><div class="line"><span class="number">51</span>:                 <span class="comment">// If the replication's dirty timestamp is more than the existing one, just update</span></div><div class="line"><span class="number">52</span>:                 <span class="comment">// it to the replica's.</span></div><div class="line"><span class="number">53</span>:                 <span class="keyword">if</span> (replicaDirtyTimestamp &gt; info.getLastDirtyTimestamp()) &#123;</div><div class="line"><span class="number">54</span>:                     info.setLastDirtyTimestamp(replicaDirtyTimestamp);</div><div class="line"><span class="number">55</span>:                 &#125;</div><div class="line"><span class="number">56</span>:                 <span class="comment">// 添加到 最近租约变更记录队列</span></div><div class="line"><span class="number">57</span>:                 info.setActionType(ActionType.MODIFIED);</div><div class="line"><span class="number">58</span>:                 recentlyChangedQueue.add(<span class="keyword">new</span> RecentlyChangedItem(lease));</div><div class="line"><span class="number">59</span>:                 <span class="comment">// 设置 最后更新时间</span></div><div class="line"><span class="number">60</span>:                 info.setLastUpdatedTimestamp();</div><div class="line"><span class="number">61</span>:                 <span class="comment">// 设置 响应缓存 过期</span></div><div class="line"><span class="number">62</span>:                 invalidateCache(appName, info.getVIPAddress(), info.getSecureVipAddress());</div><div class="line"><span class="number">63</span>:             &#125;</div><div class="line"><span class="number">64</span>:             <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"><span class="number">65</span>:         &#125;</div><div class="line"><span class="number">66</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">67</span>:         <span class="comment">// 释放锁</span></div><div class="line"><span class="number">68</span>:         read.unlock();</div><div class="line"><span class="number">69</span>:     &#125;</div><div class="line"><span class="number">70</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 6 至 7 行 ：获取读锁。在 <a href="http://www.iocoder.cn/Eureka/instance-registry-read-write-lock/?self">《Eureka源码解析 —— 应用实例注册发现 （九）之岁月是把萌萌的读写锁》</a> 详细解析。</li><li>第 8 至 9 行 ：添加覆盖状态变更次数到监控。配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集。</li><li>第 10 至 15 行 ：获得租约。</li><li>第 16 至 18 行 ：租约不存在，返回更新失败。</li><li>第 20 至 21 行 ：设置租约最后更新时间( 续租 )。</li><li>第 23 至 29 行 ：持有租约的应用实例不存在，理论来说不会出现，防御性编程。</li><li>第 31 行 ：<strong>应用实例当前状态和覆该状态不一致时才更新覆盖状态</strong>。</li><li>第 32 至 36 行 ：当覆盖状态是 <code>InstanceStatus.UP</code>，设置租约的开始服务的时间戳（只有第一次有效）。</li><li><p>第 37 至 39 行 ：添加到应用实例覆盖状态映射( <code>overriddenInstanceStatusMap</code> )。此处英文 <code>&quot;NAC&quot;</code> 可能是 <code>&quot;Network Access Control&quot;</code> 的缩写，感兴趣的可以看看 <a href="https://en.wikipedia.org/wiki/Network_Access_Control" rel="external nofollow noopener noreferrer" target="_blank">《Network Access Control》</a> 。<code>overriddenInstanceStatusMap</code> 属性代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 应用实例覆盖状态映射</span></div><div class="line"><span class="comment">* key：应用实例编号</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ConcurrentMap&lt;String, InstanceStatus&gt; overriddenInstanceStatusMap = CacheBuilder</div><div class="line">      .newBuilder().initialCapacity(<span class="number">500</span>)</div><div class="line">      .expireAfterAccess(<span class="number">1</span>, TimeUnit.HOURS)</div><div class="line">      .&lt;String, InstanceStatus&gt;build().asMap();</div></pre></td></tr></table></figure><ul><li>有效期 1 小时。每次访问后会刷新有效期，在后文你会看到对其的访问。</li></ul></li><li><p>第 40 至 43 行 ：设置应用实例的覆盖状态。用于 Eureka-Server 集群同步。</p></li><li>第 46 至 47 行 ：<strong>设置应用实例状态</strong>。设置后，Eureka-Client 拉取注册信息，被更新覆盖状态的应用实例就是设置的状态。</li><li>第 48 至 55 行 ：设置应用实例的数据不一致时间。用于 Eureka-Server 集群同步。</li><li>第 56 至 58 行 ：添加应用实例到最近租约变更记录队列。</li><li>第 59 至 60 行 ：设置应用实例的最后更新时间( <code>lastUpdatedTimestamp</code> )。<code>lastUpdatedTimestamp</code> 主要用于记录最后更新时间，无实际业务用途。</li><li>第 61 至 62 行 ：设置响应缓存过期。</li><li>第 64 行 ：返回更新成功。</li><li>第 68 行 ：释放读锁。</li></ul><h1 id="3-应用实例覆盖状态删除接口"><a href="#3-应用实例覆盖状态删除接口" class="headerlink" title="3. 应用实例覆盖状态删除接口"></a>3. 应用实例覆盖状态删除接口</h1><p>当我们不需要应用实例的覆盖状态时，调度接口接口进行删除。关联官方 <code>issue#89</code> ：<a href="https://github.com/Netflix/eureka/issues/89" rel="external nofollow noopener noreferrer" target="_blank">Provide an API to remove all overridden status</a>。</p><p>应用实例覆盖状态删除接口，映射 <code>InstanceResource#deleteStatusUpdate()</code> 方法，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@DELETE</span></div><div class="line"><span class="meta">@Path</span>(<span class="string">"status"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">deleteStatusUpdate</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">       @HeaderParam(PeerEurekaNode.HEADER_REPLICATION)</span> String isReplication,</span></div><div class="line"><span class="function">       @<span class="title">QueryParam</span><span class="params">(<span class="string">"value"</span>)</span> String newStatusValue,</span></div><div class="line"><span class="function">       @<span class="title">QueryParam</span><span class="params">(<span class="string">"lastDirtyTimestamp"</span>)</span> String lastDirtyTimestamp) </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 应用实例不存在</span></div><div class="line">       <span class="keyword">if</span> (registry.getInstanceByAppAndId(app.getName(), id) == <span class="keyword">null</span>) &#123;</div><div class="line">           logger.warn(<span class="string">"Instance not found: &#123;&#125;/&#123;&#125;"</span>, app.getName(), id);</div><div class="line">           <span class="keyword">return</span> Response.status(Status.NOT_FOUND).build();</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// 覆盖状态删除</span></div><div class="line">       InstanceStatus newStatus = newStatusValue == <span class="keyword">null</span> ? InstanceStatus.UNKNOWN : InstanceStatus.valueOf(newStatusValue);</div><div class="line">       <span class="keyword">boolean</span> isSuccess = registry.deleteStatusOverride(app.getName(), id,</div><div class="line">               newStatus, lastDirtyTimestamp, <span class="string">"true"</span>.equals(isReplication));</div><div class="line"></div><div class="line">       <span class="comment">// 返回结果</span></div><div class="line">       <span class="keyword">if</span> (isSuccess) &#123;</div><div class="line">           logger.info(<span class="string">"Status override removed: "</span> + app.getName() + <span class="string">" - "</span> + id);</div><div class="line">           <span class="keyword">return</span> Response.ok().build();</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           logger.warn(<span class="string">"Unable to remove status override: "</span> + app.getName() + <span class="string">" - "</span> + id);</div><div class="line">           <span class="keyword">return</span> Response.serverError().build();</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">       logger.error(<span class="string">"Error removing instance's &#123;&#125; status override"</span>, id);</div><div class="line">       <span class="keyword">return</span> Response.serverError().build();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>请求参数 <code>newStatusValue</code> ，设置应用实例的状态。大多数情况下，<code>newStatusValue</code> 要和应用实例实际的状态一致，因为该应用实例的 Eureka-Client 不会从 Eureka-Server 拉取到该应用状态 <code>newStatusValue</code> 。另外一种方式，不传递该参数，相当于 <code>UNKNOWN</code> 状态，这样，Eureka-Client 会主动向 Eureka-Server 再次发起注册，具体原因在 [「4.3 续租场景」] 详细解析，更加推荐的方式。</li><li><p>调用父类 <code>AbstractInstanceRegistry#deleteStatusOverride(...)</code> 方法，删除应用实例覆盖状态。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteStatusOverride</span><span class="params">(String appName, String id,</span></span></div><div class="line"><span class="function"><span class="params">                                   InstanceStatus newStatus,</span></span></div><div class="line"><span class="function"><span class="params">                                   String lastDirtyTimestamp,</span></span></div><div class="line"><span class="function"><span class="params">                                   <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">super</span>.deleteStatusOverride(appName, id, newStatus, lastDirtyTimestamp, isReplication)) &#123;</div><div class="line">       <span class="comment">// Eureka-Server 集群同步</span></div><div class="line">       replicateToPeers(Action.DeleteStatusOverride, appName, id, <span class="keyword">null</span>, <span class="keyword">null</span>, isReplication);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用父类 <code>AbstractInstanceRegistry#deleteStatusOverride(...)</code> 方法，删除应用实例覆盖状态。</li></ul></li></ul><h2 id="3-1-删除应用实例覆盖状态"><a href="#3-1-删除应用实例覆盖状态" class="headerlink" title="3.1 删除应用实例覆盖状态"></a>3.1 删除应用实例覆盖状态</h2><p>调用父类 <code>AbstractInstanceRegistry#deleteStatusOverride(...)</code> 方法，删除应用实例覆盖状态。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteStatusOverride</span><span class="params">(String appName, String id,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">3</span>:                                     InstanceStatus newStatus,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">4</span>:                                     String lastDirtyTimestamp,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">5</span>:                                     <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line"> <span class="number">6</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">7</span>:         <span class="comment">// 获取读锁</span></div><div class="line"> <span class="number">8</span>:         read.lock();</div><div class="line"> <span class="number">9</span>:         <span class="comment">// 添加 覆盖状态删除次数 到 监控</span></div><div class="line"><span class="number">10</span>:         STATUS_OVERRIDE_DELETE.increment(isReplication);</div><div class="line"><span class="number">11</span>:         <span class="comment">// 获得 租约</span></div><div class="line"><span class="number">12</span>:         Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(appName);</div><div class="line"><span class="number">13</span>:         Lease&lt;InstanceInfo&gt; lease = <span class="keyword">null</span>;</div><div class="line"><span class="number">14</span>:         <span class="keyword">if</span> (gMap != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">15</span>:             lease = gMap.get(id);</div><div class="line"><span class="number">16</span>:         &#125;</div><div class="line"><span class="number">17</span>:         <span class="comment">// 租约不存在</span></div><div class="line"><span class="number">18</span>:         <span class="keyword">if</span> (lease == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">19</span>:             <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"><span class="number">20</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">21</span>:             <span class="comment">// 设置 租约最后更新时间（续租）</span></div><div class="line"><span class="number">22</span>:             lease.renew();</div><div class="line"><span class="number">23</span>: </div><div class="line"><span class="number">24</span>:             <span class="comment">// 应用实例信息不存在( 防御型编程 )</span></div><div class="line"><span class="number">25</span>:             InstanceInfo info = lease.getHolder();</div><div class="line"><span class="number">26</span>:             <span class="comment">// Lease is always created with its instance info object.</span></div><div class="line"><span class="number">27</span>:             <span class="comment">// This log statement is provided as a safeguard, in case this invariant is violated.</span></div><div class="line"><span class="number">28</span>:             <span class="keyword">if</span> (info == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">29</span>:                 logger.error(<span class="string">"Found Lease without a holder for instance id &#123;&#125;"</span>, id);</div><div class="line"><span class="number">30</span>:             &#125;</div><div class="line"><span class="number">31</span>: </div><div class="line"><span class="number">32</span>:             <span class="comment">// 移除 应用实例覆盖状态</span></div><div class="line"><span class="number">33</span>:             InstanceStatus currentOverride = overriddenInstanceStatusMap.remove(id);</div><div class="line"><span class="number">34</span>:             <span class="keyword">if</span> (currentOverride != <span class="keyword">null</span> &amp;&amp; info != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">35</span>:                 <span class="comment">// 设置 应用实例覆盖状态</span></div><div class="line"><span class="number">36</span>:                 info.setOverriddenStatus(InstanceStatus.UNKNOWN);</div><div class="line"><span class="number">37</span>:                 <span class="comment">// 设置 应用实例状态</span></div><div class="line"><span class="number">38</span>:                 info.setStatusWithoutDirty(newStatus);</div><div class="line"><span class="number">39</span>:                 <span class="comment">// 设置 应用实例信息 数据不一致时间</span></div><div class="line"><span class="number">40</span>:                 <span class="keyword">long</span> replicaDirtyTimestamp = <span class="number">0</span>;</div><div class="line"><span class="number">41</span>:                 <span class="keyword">if</span> (lastDirtyTimestamp != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">42</span>:                     replicaDirtyTimestamp = Long.valueOf(lastDirtyTimestamp);</div><div class="line"><span class="number">43</span>:                 &#125;</div><div class="line"><span class="number">44</span>:                 <span class="comment">// If the replication's dirty timestamp is more than the existing one, just update</span></div><div class="line"><span class="number">45</span>:                 <span class="comment">// it to the replica's.</span></div><div class="line"><span class="number">46</span>:                 <span class="keyword">if</span> (replicaDirtyTimestamp &gt; info.getLastDirtyTimestamp()) &#123;</div><div class="line"><span class="number">47</span>:                     info.setLastDirtyTimestamp(replicaDirtyTimestamp);</div><div class="line"><span class="number">48</span>:                 &#125;</div><div class="line"><span class="number">49</span>:                 <span class="comment">// 添加到 最近租约变更记录队列</span></div><div class="line"><span class="number">50</span>:                 info.setActionType(ActionType.MODIFIED);</div><div class="line"><span class="number">51</span>:                 recentlyChangedQueue.add(<span class="keyword">new</span> RecentlyChangedItem(lease));</div><div class="line"><span class="number">52</span>:                 <span class="comment">// 设置 最后更新时间</span></div><div class="line"><span class="number">53</span>:                 info.setLastUpdatedTimestamp();</div><div class="line"><span class="number">54</span>:                 <span class="comment">// 设置 响应缓存 过期</span></div><div class="line"><span class="number">55</span>:                 invalidateCache(appName, info.getVIPAddress(), info.getSecureVipAddress());</div><div class="line"><span class="number">56</span>:             &#125;</div><div class="line"><span class="number">57</span>:             <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"><span class="number">58</span>:         &#125;</div><div class="line"><span class="number">59</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">60</span>:         <span class="comment">// 释放锁</span></div><div class="line"><span class="number">61</span>:         read.unlock();</div><div class="line"><span class="number">62</span>:     &#125;</div><div class="line"><span class="number">63</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 7 至 8 行 ：获取读锁。在 <a href="http://www.iocoder.cn/Eureka/instance-registry-read-write-lock/?self">《Eureka源码解析 —— 应用实例注册发现 （九）之岁月是把萌萌的读写锁》</a> 详细解析。</li><li>第 9 至 10 行 ：添加覆盖状态删除次数到监控。配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集。</li><li>第 11 至 16 行 ：获得租约。</li><li>第 17 至 19 行 ：租约不存在，返回更新失败。</li><li>第 21 至 22 行 ：设置租约最后更新时间( 续租 )。</li><li>第 24 至 30 行 ：持有租约的应用实例不存在，理论来说不会出现，防御性编程。</li><li>第 32 至 33 行 ：移除出应用实例覆盖状态映射( <code>overriddenInstanceStatusMap</code> )。</li><li>第 34 行 ：<strong>应用实例的覆盖状态存在才设置状态</strong>。</li><li>第 35 至 36 行 ：设置应用实例的覆盖状态为 InstanceStatus.UNKNOWN。用于 Eureka-Server 集群同步。</li><li>第 37 至 38 行 ：设置应用实例的状态为 <code>newStatus</code>。设置后，Eureka-Client 拉取注册信息，被更新覆盖状态的应用实例就是设置的状态。</li><li>第 39 至 48 行 ：设置应用实例的数据不一致时间。用于 Eureka-Server 集群同步。</li><li>第 49 至 51 行 ：添加应用实例到最近租约变更记录队列。</li><li>第 52 至 53 行 ：设置应用实例的最后更新时间( <code>lastUpdatedTimestamp</code> )。<code>lastUpdatedTimestamp</code> 主要用于记录最后更新时间，无实际业务用途。</li><li>第 54 至 55 行 ：设置响应缓存过期。</li><li>第 57 行 ：返回更新成功。</li><li>第 61 行 ：释放读锁。</li></ul><h1 id="4-应用实例覆盖状态映射"><a href="#4-应用实例覆盖状态映射" class="headerlink" title="4. 应用实例覆盖状态映射"></a>4. 应用实例覆盖状态映射</h1><p>虽然我们在上面代码，使用覆盖状态( <code>overridestatus</code> )设置到应用实例的状态( <code>status</code> )，<strong>实际调用 <code>AbstractInstanceRegistry#getOverriddenInstanceStatus(...)</code> 方法，根据应用实例状态覆盖规则( InstanceStatusOverrideRule )进行计算最终应用实例的状态</strong>。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line"><span class="keyword">protected</span> InstanceInfo.<span class="function">InstanceStatus <span class="title">getOverriddenInstanceStatus</span><span class="params">(InstanceInfo r,</span></span></div><div class="line"><span class="function"><span class="params">                                                               Lease&lt;InstanceInfo&gt; existingLease,</span></span></div><div class="line"><span class="function"><span class="params">                                                               <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">   InstanceStatusOverrideRule rule = getInstanceInfoOverrideRule();</div><div class="line">   logger.debug(<span class="string">"Processing override status using rule: &#123;&#125;"</span>, rule);</div><div class="line">   <span class="keyword">return</span> rule.apply(r, existingLease, isReplication).status();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> InstanceStatusOverrideRule <span class="title">getInstanceInfoOverrideRule</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>#getInstanceInfoOverrideRule()</code> 方法，获取应用实例状态覆盖规则( InstanceStatusOverrideRule )。在 PeerAwareInstanceRegistryImpl 里该方法实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> InstanceStatusOverrideRule instanceStatusOverrideRule;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">PeerAwareInstanceRegistryImpl</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">            EurekaServerConfig serverConfig,</span></span></div><div class="line"><span class="function"><span class="params">            EurekaClientConfig clientConfig,</span></span></div><div class="line"><span class="function"><span class="params">            ServerCodecs serverCodecs,</span></span></div><div class="line"><span class="function"><span class="params">            EurekaClient eurekaClient</span></span></div><div class="line"><span class="function"><span class="params">    )</span> </span>&#123;</div><div class="line">    <span class="comment">// ... 省略其它方法</span></div><div class="line">    </div><div class="line">    <span class="keyword">this</span>.instanceStatusOverrideRule = <span class="keyword">new</span> FirstMatchWinsCompositeRule(</div><div class="line">        <span class="keyword">new</span> DownOrStartingRule(),</div><div class="line">        <span class="keyword">new</span> OverrideExistsRule(overriddenInstanceStatusMap), </div><div class="line">        <span class="keyword">new</span> LeaseExistsRule());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> InstanceStatusOverrideRule <span class="title">getInstanceInfoOverrideRule</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.instanceStatusOverrideRule;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h2 id="4-1-应用实例状态覆盖规则"><a href="#4-1-应用实例状态覆盖规则" class="headerlink" title="4.1 应用实例状态覆盖规则"></a>4.1 应用实例状态覆盖规则</h2><p><code>com.netflix.eureka.registry.rule.InstanceStatusOverrideRule</code> ，应用实例状态覆盖规则<strong>接口</strong>。接口代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// InstanceStatusOverrideRule.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InstanceStatusOverrideRule</span> </span>&#123;</div><div class="line"></div><div class="line">     <span class="comment">/**</span></div><div class="line"><span class="comment">     * Match this rule.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> instanceInfo The instance info whose status we care about. 关注状态的应用实例对象</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> existingLease Does the instance have an existing lease already? If so let's consider that. 已存在的租约</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> isReplication When overriding consider if we are under a replication mode from other servers. 是否是 Eureka-Server 发起的请求</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> A result with whether we matched and what we propose the status to be overriden to.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">     <span class="function">StatusOverrideResult <span class="title">apply</span><span class="params">(<span class="keyword">final</span> InstanceInfo instanceInfo,</span></span></div><div class="line"><span class="function"><span class="params">                               <span class="keyword">final</span> Lease&lt;InstanceInfo&gt; existingLease,</span></span></div><div class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> isReplication)</span></span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// StatusOverrideResult.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatusOverrideResult</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StatusOverrideResult NO_MATCH = <span class="keyword">new</span> StatusOverrideResult(<span class="keyword">false</span>, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StatusOverrideResult <span class="title">matchingStatus</span><span class="params">(InstanceInfo.InstanceStatus status)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StatusOverrideResult(<span class="keyword">true</span>, status);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Does the rule match?</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> matches;</div><div class="line"></div><div class="line">    <span class="comment">// The status computed by the rule.</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InstanceInfo.InstanceStatus status;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StatusOverrideResult</span><span class="params">(<span class="keyword">boolean</span> matches, InstanceInfo.InstanceStatus status)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.matches = matches;</div><div class="line">        <span class="keyword">this</span>.status = status;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> matches;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> InstanceInfo.<span class="function">InstanceStatus <span class="title">status</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> status;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>#apply(...)</code> 方法参数 <code>instanceInfo</code> 代表的是<strong>关注状态</strong>的应用实例，和方法参数 <code>existingLease</code> 里的应用实例不一定是同一个，在 <a href="#">「4.1.6 总结」</a> 详细解析。</li><li><code>com.netflix.eureka.registry.rule.StatusOverrideResult</code> ，状态覆盖结果。当匹配成功，返回 <code>matches = true</code> ；否则，返回 <code>matches = false</code> 。</li></ul><p><strong>实现类关系如下</strong>：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_07_10/01.png" alt=""></p><ul><li>AsgEnabledRule ，亚马逊 AWS 专用，跳过。</li></ul><h3 id="4-1-1-FirstMatchWinsCompositeRule"><a href="#4-1-1-FirstMatchWinsCompositeRule" class="headerlink" title="4.1.1 FirstMatchWinsCompositeRule"></a>4.1.1 FirstMatchWinsCompositeRule</h3><p><code>com.netflix.eureka.registry.rule.FirstMatchWinsCompositeRule</code> ，<strong>复合</strong>规则，以第一个匹配成功为准。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstMatchWinsCompositeRule</span> <span class="keyword">implements</span> <span class="title">InstanceStatusOverrideRule</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 复合规则集合</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InstanceStatusOverrideRule[] rules;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 默认规则</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InstanceStatusOverrideRule defaultRule;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String compositeRuleName;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FirstMatchWinsCompositeRule</span><span class="params">(InstanceStatusOverrideRule... rules)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.rules = rules;</div><div class="line">        <span class="keyword">this</span>.defaultRule = <span class="keyword">new</span> AlwaysMatchInstanceStatusRule();</div><div class="line">        <span class="comment">// Let's build up and "cache" the rule name to be used by toString();</span></div><div class="line">        List&lt;String&gt; ruleNames = <span class="keyword">new</span> ArrayList&lt;&gt;(rules.length+<span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rules.length; ++i) &#123;</div><div class="line">            ruleNames.add(rules[i].toString());</div><div class="line">        &#125;</div><div class="line">        ruleNames.add(defaultRule.toString());</div><div class="line">        compositeRuleName = ruleNames.toString();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> StatusOverrideResult <span class="title">apply</span><span class="params">(InstanceInfo instanceInfo,</span></span></div><div class="line"><span class="function"><span class="params">                                      Lease&lt;InstanceInfo&gt; existingLease,</span></span></div><div class="line"><span class="function"><span class="params">                                      <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">        <span class="comment">// 使用复合规则，顺序匹配，直到匹配成功</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.rules.length; ++i) &#123;</div><div class="line">            StatusOverrideResult result = <span class="keyword">this</span>.rules[i].apply(instanceInfo, existingLease, isReplication);</div><div class="line">            <span class="keyword">if</span> (result.matches()) &#123;</div><div class="line">                <span class="keyword">return</span> result;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 使用默认规则</span></div><div class="line">        <span class="keyword">return</span> defaultRule.apply(instanceInfo, existingLease, isReplication);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.compositeRuleName;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>rules</code> 属性，<strong>复合</strong>规则集合。在 PeerAwareInstanceRegistryImpl 里，我们可以看到该属性为 [ DownOrStartingRule , OverrideExistsRule , LeaseExistsRule ] 。</li><li><code>defaultRule</code> 属性，默认规则，值为 AlwaysMatchInstanceStatusRule 。</li><li><code>#apply()</code> 方法，优先使用<strong>复合</strong>规则( <code>rules</code> )，顺序匹配，直到匹配成功 。当未匹配成功，使用默认规则( <code>defaultRule</code> ) 。</li></ul><h3 id="4-1-2-DownOrStartingRule"><a href="#4-1-2-DownOrStartingRule" class="headerlink" title="4.1.2 DownOrStartingRule"></a>4.1.2 DownOrStartingRule</h3><p><code>com.netflix.eureka.registry.rule.DownOrStartingRule</code> ，匹配 <code>InstanceInfo.InstanceStatus.DOWN</code> 或者 <code>InstanceInfo.InstanceStatus.STARTING</code> 状态。实现 <code>#apply(...)</code> 代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> StatusOverrideResult <span class="title">apply</span><span class="params">(InstanceInfo instanceInfo,</span></span></div><div class="line"><span class="function"><span class="params">                                 Lease&lt;InstanceInfo&gt; existingLease,</span></span></div><div class="line"><span class="function"><span class="params">                                 <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">   <span class="comment">// ReplicationInstance is DOWN or STARTING - believe that, but when the instance says UP, question that</span></div><div class="line">   <span class="comment">// The client instance sends STARTING or DOWN (because of heartbeat failures), then we accept what</span></div><div class="line">   <span class="comment">// the client says. The same is the case with replica as well.</span></div><div class="line">   <span class="comment">// The OUT_OF_SERVICE from the client or replica needs to be confirmed as well since the service may be</span></div><div class="line">   <span class="comment">// currently in SERVICE</span></div><div class="line">   <span class="keyword">if</span> ((!InstanceInfo.InstanceStatus.UP.equals(instanceInfo.getStatus()))</div><div class="line">           &amp;&amp; (!InstanceInfo.InstanceStatus.OUT_OF_SERVICE.equals(instanceInfo.getStatus()))) &#123;</div><div class="line">       logger.debug(<span class="string">"Trusting the instance status &#123;&#125; from replica or instance for instance &#123;&#125;"</span>,</div><div class="line">               instanceInfo.getStatus(), instanceInfo.getId());</div><div class="line">       <span class="keyword">return</span> StatusOverrideResult.matchingStatus(instanceInfo.getStatus());</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> StatusOverrideResult.NO_MATCH;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>注意</strong>，使用的是 <code>instanceInfo</code> 。</li></ul><h3 id="4-1-3-OverrideExistsRule"><a href="#4-1-3-OverrideExistsRule" class="headerlink" title="4.1.3 OverrideExistsRule"></a>4.1.3 OverrideExistsRule</h3><p><code>com.netflix.eureka.registry.rule.OverrideExistsRule</code> ，匹配应用实例覆盖状态映射( <code>statusOverrides</code> ) 。实现 <code>#apply(...)</code> 代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverrideExistsRule</span> <span class="keyword">implements</span> <span class="title">InstanceStatusOverrideRule</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="keyword">private</span> Map&lt;String, InstanceInfo.InstanceStatus&gt; statusOverrides;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> StatusOverrideResult <span class="title">apply</span><span class="params">(InstanceInfo instanceInfo, Lease&lt;InstanceInfo&gt; existingLease, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">        InstanceInfo.InstanceStatus overridden = statusOverrides.get(instanceInfo.getId());</div><div class="line">        <span class="comment">// If there are instance specific overrides, then they win - otherwise the ASG status</span></div><div class="line">        <span class="keyword">if</span> (overridden != <span class="keyword">null</span>) &#123;</div><div class="line">            logger.debug(<span class="string">"The instance specific override for instance &#123;&#125; and the value is &#123;&#125;"</span>,</div><div class="line">                    instanceInfo.getId(), overridden.name());</div><div class="line">            <span class="keyword">return</span> StatusOverrideResult.matchingStatus(overridden);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> StatusOverrideResult.NO_MATCH;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>statusOverrides</code> 属性，应用实例覆盖状态映射。在 PeerAwareInstanceRegistryImpl 里，使用 <code>AbstractInstanceRegistry.overriddenInstanceStatusMap</code> 属性赋值。</li><li>上文我们提到 <code>AbstractInstanceRegistry.overriddenInstanceStatusMap</code>  每次访问刷新有效期，如果调用到 OverrideExistsRule ，则会不断刷新。从 DownOrStartingRule 看到，<code>instanceInfo</code> 处于 <code>InstanceInfo.InstanceStatus.DOWN</code> 或者 <code>InstanceInfo.InstanceStatus.STARTING</code> 才不会继续调用 OverrideExistsRule 匹配，<code>AbstractInstanceRegistry.overriddenInstanceStatusMap</code> 才有可能过期。</li></ul><h3 id="4-1-4-LeaseExistsRule"><a href="#4-1-4-LeaseExistsRule" class="headerlink" title="4.1.4 LeaseExistsRule"></a>4.1.4 LeaseExistsRule</h3><p><code>com.netflix.eureka.registry.rule.LeaseExistsRule</code> ，匹配已存在租约的应用实例的 <code>nstanceStatus.OUT_OF_SERVICE</code> 或者 <code>InstanceInfo.InstanceStatus.UP</code> 状态。实现 <code>#apply(...)</code> 代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> StatusOverrideResult <span class="title">apply</span><span class="params">(InstanceInfo instanceInfo,</span></span></div><div class="line"><span class="function"><span class="params">                                 Lease&lt;InstanceInfo&gt; existingLease,</span></span></div><div class="line"><span class="function"><span class="params">                                 <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">   <span class="comment">// This is for backward compatibility until all applications have ASG</span></div><div class="line">   <span class="comment">// names, otherwise while starting up</span></div><div class="line">   <span class="comment">// the client status may override status replicated from other servers</span></div><div class="line">   <span class="keyword">if</span> (!isReplication) &#123; <span class="comment">// 非 Eureka-Server 请求</span></div><div class="line">       InstanceInfo.InstanceStatus existingStatus = <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">if</span> (existingLease != <span class="keyword">null</span>) &#123;</div><div class="line">           existingStatus = existingLease.getHolder().getStatus();</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// Allow server to have its way when the status is UP or OUT_OF_SERVICE</span></div><div class="line">       <span class="keyword">if</span> ((existingStatus != <span class="keyword">null</span>)</div><div class="line">               &amp;&amp; (InstanceInfo.InstanceStatus.OUT_OF_SERVICE.equals(existingStatus)</div><div class="line">               || InstanceInfo.InstanceStatus.UP.equals(existingStatus))) &#123;</div><div class="line">           logger.debug(<span class="string">"There is already an existing lease with status &#123;&#125;  for instance &#123;&#125;"</span>,</div><div class="line">                   existingLease.getHolder().getStatus().name(),</div><div class="line">                   existingLease.getHolder().getId());</div><div class="line">           <span class="keyword">return</span> StatusOverrideResult.matchingStatus(existingLease.getHolder().getStatus());</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> StatusOverrideResult.NO_MATCH;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>注意</strong>，使用的是 <code>existingLease</code> ，并且非 Eureka-Server 请求。</li></ul><h3 id="4-1-5-AlwaysMatchInstanceStatusRule"><a href="#4-1-5-AlwaysMatchInstanceStatusRule" class="headerlink" title="4.1.5 AlwaysMatchInstanceStatusRule"></a>4.1.5 AlwaysMatchInstanceStatusRule</h3><p><code>com.netflix.eureka.registry.rule.AlwaysMatchInstanceStatusRule</code> ，总是匹配<strong>关注状态的实例对象</strong>( <code>instanceInfo</code> )的状态。实现 <code>#apply(...)</code> 代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> StatusOverrideResult <span class="title">apply</span><span class="params">(InstanceInfo instanceInfo,</span></span></div><div class="line"><span class="function"><span class="params">                                 Lease&lt;InstanceInfo&gt; existingLease,</span></span></div><div class="line"><span class="function"><span class="params">                                 <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">   logger.debug(<span class="string">"Returning the default instance status &#123;&#125; for instance &#123;&#125;"</span>, instanceInfo.getStatus(),</div><div class="line">           instanceInfo.getId());</div><div class="line">   <span class="keyword">return</span> StatusOverrideResult.matchingStatus(instanceInfo.getStatus());</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>注意</strong>，使用的是 <code>instanceInfo</code> 。</li></ul><h3 id="4-1-6-总结"><a href="#4-1-6-总结" class="headerlink" title="4.1.6 总结"></a>4.1.6 总结</h3><p>我们将 PeerAwareInstanceRegistryImpl 的应用实例覆盖状态规则梳理如下：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_07_10/02.png" alt=""></p><ul><li>应用实例状态是<strong>最重要</strong>的属性，没有之一，因而在最终实例状态的计算，以<strong>可信赖</strong>为主。</li><li>DownOrStartingRule ，<code>instanceInfo</code> 处于 <code>STARTING</code> 或者 <code>DOWN</code> 状态，应用实例可能不适合提供服务( 被请求 )，考虑<strong>可信赖</strong>，返回 <code>instanceInfo</code> 的状态。</li><li>OverrideExistsRule ，当存在覆盖状态( <code>statusoverrides</code> ) ，使用该状态，比较好理解。</li><li>LeaseExistsRule ，来自 Eureka-Client 的请求( 非 Eureka-Server 集群请求)，当 Eureka-Server 的实例状态<strong>存在</strong>，并且处于 <code>UP</code> 或则 <code>OUT_OF_SERVICE</code> ，保留当前状态。原因，<strong>禁止 Eureka-Client 主动在这两个状态之间切换。如果要切换，使用应用实例覆盖状态变更与删除接口</strong>。</li><li>AlwaysMatchInstanceStatusRule ，使用 <code>instanceInfo</code> 的状态返回，以保证能匹配到状态。</li><li>在下文中，你会看到，<code>#getOverriddenInstanceStatus()</code> 方法会在<strong>注册</strong>和<strong>续租</strong>使用到。结合上图，我们在 <a href="#">「4.2 注册场景」</a> 和 <a href="#">「4.3 续租场景」</a> 也会详细解析。</li></ul><ul><li>在下文中，你会看到，<code>#getOverriddenInstanceStatus()</code> 方法会在<strong>注册</strong>和<strong>续租</strong>使用到，方法参数 <code>instanceInfo</code> 情况如下：<ul><li><strong>注册时</strong> ：请求参数 <code>instanceInfo</code> ，和 <code>existingLease</code> 的应用实例属性不相等( 如果考虑 Eureka-Server 的 <code>LastDirtyTimestamp</code> 更大的情况，则类似 <strong>续租时的情况</strong> ) 。</li><li><strong>续租时</strong> ：使用 Eureka-Server 的 <code>existingLease</code> 的应用实例，两者相等。</li><li><strong>总的来说，可以将 <code>instanceInfo</code> 理解成请求方的状态</strong>。</li></ul></li><li>DownOrStartingRule ，</li></ul><h2 id="4-2-注册场景"><a href="#4-2-注册场景" class="headerlink" title="4.2 注册场景"></a>4.2 注册场景</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(InstanceInfo registrant, <span class="keyword">int</span> leaseDuration, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">  <span class="number">2</span>:     <span class="keyword">try</span> &#123;</div><div class="line">  <span class="number">3</span>:         <span class="comment">// （(省略代码) ）获取锁</span></div><div class="line">  <span class="number">4</span>:         Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(registrant.getAppName());</div><div class="line">  <span class="number">5</span>:         <span class="comment">// (省略代码) 增加 注册次数 到 监控</span></div><div class="line">  <span class="number">6</span>:         <span class="comment">// (省略代码) 获得 应用实例信息 对应的 租约</span></div><div class="line">  <span class="number">7</span>:         Lease&lt;InstanceInfo&gt; existingLease = gMap.get(registrant.getId());</div><div class="line">  <span class="number">8</span>:         <span class="comment">// Retain the last dirty timestamp without overwriting it, if there is already a lease</span></div><div class="line">  <span class="number">9</span>:         <span class="keyword">if</span> (existingLease != <span class="keyword">null</span> &amp;&amp; (existingLease.getHolder() != <span class="keyword">null</span>)) &#123; <span class="comment">// (省略代码) 已存在时，使用数据不一致的时间大的应用注册信息为有效的</span></div><div class="line"> <span class="number">10</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">11</span>:             <span class="comment">// The lease does not exist and hence it is a new registration</span></div><div class="line"> <span class="number">12</span>:             <span class="comment">// (省略代码) 【自我保护机制】增加 `numberOfRenewsPerMinThreshold` 、`expectedNumberOfRenewsPerMin`</span></div><div class="line"> <span class="number">13</span>:         &#125;</div><div class="line"> <span class="number">14</span>:         <span class="comment">// 创建 租约</span></div><div class="line"> <span class="number">15</span>:         Lease&lt;InstanceInfo&gt; lease = <span class="keyword">new</span> Lease&lt;InstanceInfo&gt;(registrant, leaseDuration);</div><div class="line"> <span class="number">16</span>:         <span class="keyword">if</span> (existingLease != <span class="keyword">null</span>) &#123; <span class="comment">// 若租约已存在，设置 租约的开始服务的时间戳</span></div><div class="line"> <span class="number">17</span>:             lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp());</div><div class="line"> <span class="number">18</span>:         &#125;</div><div class="line"> <span class="number">19</span>:         <span class="comment">// 添加到 租约映射</span></div><div class="line"> <span class="number">20</span>:         gMap.put(registrant.getId(), lease);</div><div class="line"> <span class="number">21</span>:         <span class="comment">// (省略代码) 添加到 最近注册的调试队列</span></div><div class="line"> <span class="number">22</span>:         <span class="comment">// (省略代码) 添加到 应用实例覆盖状态映射（Eureka-Server 初始化使用）</span></div><div class="line"> <span class="number">23</span>:         <span class="comment">// 设置 应用实例覆盖状态</span></div><div class="line"> <span class="number">24</span>:         InstanceStatus overriddenStatusFromMap = overriddenInstanceStatusMap.get(registrant.getId());</div><div class="line"> <span class="number">25</span>:         <span class="keyword">if</span> (overriddenStatusFromMap != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">26</span>:             logger.info(<span class="string">"Storing overridden status &#123;&#125; from map"</span>, overriddenStatusFromMap);</div><div class="line"> <span class="number">27</span>:             registrant.setOverriddenStatus(overriddenStatusFromMap);</div><div class="line"> <span class="number">28</span>:         &#125;</div><div class="line"> <span class="number">29</span>: </div><div class="line"> <span class="number">30</span>:         <span class="comment">// 获得 应用实例状态</span></div><div class="line"> <span class="number">31</span>:         <span class="comment">// Set the status based on the overridden status rules</span></div><div class="line"> <span class="number">32</span>:         InstanceStatus overriddenInstanceStatus = getOverriddenInstanceStatus(registrant, existingLease, isReplication);</div><div class="line"> <span class="number">33</span>:         <span class="comment">// 设置 应用实例状态</span></div><div class="line"> <span class="number">34</span>:         registrant.setStatusWithoutDirty(overriddenInstanceStatus);</div><div class="line"> <span class="number">35</span>: </div><div class="line"> <span class="number">36</span>:         <span class="comment">// (省略代码) 设置 租约的开始服务的时间戳（只有第一次有效）</span></div><div class="line"> <span class="number">37</span>:         <span class="comment">// (省略代码) 设置 应用实例信息的操作类型 为 添加</span></div><div class="line"> <span class="number">38</span>:         <span class="comment">// (省略代码) 添加到 最近租约变更记录队列</span></div><div class="line"> <span class="number">39</span>:         <span class="comment">// (省略代码) 设置 租约的最后更新时间戳</span></div><div class="line"> <span class="number">40</span>:         <span class="comment">// (省略代码) 设置 响应缓存 过期</span></div><div class="line"> <span class="number">41</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"> <span class="number">42</span>:         <span class="comment">// (省略代码) 释放锁</span></div><div class="line"> <span class="number">43</span>:     &#125;</div><div class="line"> <span class="number">44</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 7 行 ：获得<strong>已存在</strong>的租约( <code>existingLease</code> ) 。</li><li>第 15 行 ：创建<strong>新的</strong>租约( <code>lease</code> )。</li><li>第 24 至 28 行 ：设置应用实例的覆盖状态( <code>overridestatus</code> )，避免注册应用实例后，丢失覆盖状态。</li><li>第 30 至 32 行 ：<strong>获得应用实例最终状态</strong>。注意下，不考虑第 9 行代码的情况，<code>registrant</code> 和 <code>existingLease</code> 的应用实例不是同一个对象。</li><li>第 33 只 34 行 ：设置应用实例的状态。</li></ul><h2 id="4-3-续租场景"><a href="#4-3-续租场景" class="headerlink" title="4.3 续租场景"></a>4.3 续租场景</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">renew</span><span class="params">(String appName, String id, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">  <span class="number">2</span>:     <span class="comment">// （省略代码）增加 续租次数 到 监控</span></div><div class="line">  <span class="number">3</span>:     <span class="comment">// 获得 租约</span></div><div class="line">  <span class="number">4</span>:     Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(appName);</div><div class="line">  <span class="number">5</span>:     Lease&lt;InstanceInfo&gt; leaseToRenew = <span class="keyword">null</span>;</div><div class="line">  <span class="number">6</span>:     <span class="keyword">if</span> (gMap != <span class="keyword">null</span>) &#123;</div><div class="line">  <span class="number">7</span>:         leaseToRenew = gMap.get(id);</div><div class="line">  <span class="number">8</span>:     &#125;</div><div class="line">  <span class="number">9</span>:     <span class="comment">// （省略代码）租约不存在</span></div><div class="line"> <span class="number">10</span>:     <span class="keyword">if</span> (leaseToRenew == <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">11</span>:         <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"> <span class="number">12</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">13</span>:         InstanceInfo instanceInfo = leaseToRenew.getHolder();</div><div class="line"> <span class="number">14</span>:         <span class="keyword">if</span> (instanceInfo != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">15</span>:             <span class="comment">// 获得 应用实例状态</span></div><div class="line"> <span class="number">16</span>:             InstanceStatus overriddenInstanceStatus = <span class="keyword">this</span>.getOverriddenInstanceStatus(</div><div class="line"> <span class="number">17</span>:                     instanceInfo, leaseToRenew, isReplication);</div><div class="line"> <span class="number">18</span>:             <span class="comment">// 应用实例状态未知，无法续约</span></div><div class="line"> <span class="number">19</span>:             <span class="keyword">if</span> (overriddenInstanceStatus == InstanceStatus.UNKNOWN) &#123;</div><div class="line"> <span class="number">20</span>:                 logger.info(<span class="string">"Instance status UNKNOWN possibly due to deleted override for instance &#123;&#125;"</span></div><div class="line"> <span class="number">21</span>:                         + <span class="string">"; re-register required"</span>, instanceInfo.getId());</div><div class="line"> <span class="number">22</span>:                 RENEW_NOT_FOUND.increment(isReplication);</div><div class="line"> <span class="number">23</span>:                 <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"> <span class="number">24</span>:             &#125;</div><div class="line"> <span class="number">25</span>:             <span class="comment">// 设置 应用实例状态</span></div><div class="line"> <span class="number">26</span>:             <span class="keyword">if</span> (!instanceInfo.getStatus().equals(overriddenInstanceStatus)) &#123;</div><div class="line"> <span class="number">27</span>:                 Object[] args = &#123;</div><div class="line"> <span class="number">28</span>:                         instanceInfo.getStatus().name(),</div><div class="line"> <span class="number">29</span>:                         instanceInfo.getOverriddenStatus().name(),</div><div class="line"> <span class="number">30</span>:                         instanceInfo.getId()</div><div class="line"> <span class="number">31</span>:                 &#125;;</div><div class="line"> <span class="number">32</span>:                 logger.info(</div><div class="line"> <span class="number">33</span>:                         <span class="string">"The instance status &#123;&#125; is different from overridden instance status &#123;&#125; for instance &#123;&#125;. "</span></div><div class="line"> <span class="number">34</span>:                                 + <span class="string">"Hence setting the status to overridden status"</span>, args);</div><div class="line"> <span class="number">35</span>:                 instanceInfo.setStatusWithoutDirty(overriddenInstanceStatus);</div><div class="line"> <span class="number">36</span>:             &#125;</div><div class="line"> <span class="number">37</span>:         &#125;</div><div class="line"> <span class="number">38</span>:         <span class="comment">// （省略代码）新增 续租每分钟次数</span></div><div class="line"> <span class="number">39</span>:         <span class="comment">// （省略代码）设置 租约最后更新时间（续租）</span></div><div class="line"> <span class="number">40</span>:         <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"> <span class="number">41</span>:     &#125;</div><div class="line"> <span class="number">42</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 15 至 17 行 ：获得应用实例的<strong>最终状态</strong>。</li><li>第 18 至 24 行 ：应用实例的<strong>最终状态</strong>为 <code>UNKNOWN</code>，无法续约 。返回 <code>false</code> 后，请求方( Eureka-Client 或者 Eureka-Server 集群其他节点 )会发起注册，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-renew/">《Eureka 源码解析 —— 应用实例注册发现（二）之续租》</a> 有详细解析。<strong>为什么会是 <code>UNKNOWN</code> 呢</strong>？在 <a href="#">「3. 应用实例覆盖状态删除接口」</a> 传递应用实例状态为 <code>UNKNOWN</code> 。</li><li>第 25 至 36 行 ：应用实例的状态与<strong>最终状态</strong>不相等，使用<strong>最终状态</strong>覆盖应用实例的状态。<strong>为什么会不相等</strong>呢？<code>#renew(...)</code> 和 <code>#statusUpdate(...)</code> 可以无锁，并行执行，如果 <ul><li><code>#renew(...)</code> 执行完第 16 行代码，获取到 <code>overriddenInstanceStatus</code> 后，恰巧 <code>#statusUpdate(...)</code> 执行完更新应用实例状态 <code>newStatus</code>，又恰好两者不相等，使用 <code>overriddenInstanceStatus</code> 覆盖掉应用实例的 <code>newStatus</code> 状态。</li><li><strong>那岂不是覆盖状态( <code>overriddenstatus</code> )反倒被覆盖</strong>？？？不会，在下一次心跳，应用实例的状态会被修正回来。当然，如果应用实例状态如果为 <code>UP</code> 或者 <code>STARTING</code> 不会被修正，也不应该被修正。</li></ul></li></ul><h2 id="4-4-下线场景"><a href="#4-4-下线场景" class="headerlink" title="4.4 下线场景"></a>4.4 下线场景</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">internalCancel</span><span class="params">(String appName, String id, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line">    </div><div class="line">    <span class="comment">// 移除 应用实例覆盖状态映射</span></div><div class="line">    InstanceStatus instanceStatus = overriddenInstanceStatusMap.remove(id);</div><div class="line">    <span class="keyword">if</span> (instanceStatus != <span class="keyword">null</span>) &#123;</div><div class="line">        logger.debug(<span class="string">"Removed instance id &#123;&#125; from the overridden map which has value &#123;&#125;"</span>, id, instanceStatus.name());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="4-5-过期场景"><a href="#4-5-过期场景" class="headerlink" title="4.5 过期场景"></a>4.5 过期场景</h2><p>同 <a href="#">「4.4 下线场景」</a> 相同。</p><h1 id="5-客户端调用接口"><a href="#5-客户端调用接口" class="headerlink" title="5. 客户端调用接口"></a>5. 客户端调用接口</h1><p>对应用实例覆盖状态的变更和删除接口调用，点击如下方法查看，非常易懂，本文就不啰嗦了：</p><ul><li><a href="https://github.com/Netflix/eureka/blob/d2dbee8a79b3c6dd9b553eb3f702f7721797bcd6/eureka-client/src/main/java/com/netflix/discovery/shared/transport/jersey/AbstractJerseyEurekaHttpClient.java#L119" rel="external nofollow noopener noreferrer" target="_blank"><code>AbstractJerseyEurekaHttpClient#statusUpdate(...)</code></a></li><li><a href="https://github.com/Netflix/eureka/blob/d2dbee8a79b3c6dd9b553eb3f702f7721797bcd6/eureka-client/src/main/java/com/netflix/discovery/shared/transport/jersey/AbstractJerseyEurekaHttpClient.java#L142" rel="external nofollow noopener noreferrer" target="_blank"><code>AbstractJerseyEurekaHttpClient#deleteStatusOverride(...)</code></a></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>猜测覆盖状态的花费了较长时间，梳理应用实例覆盖规则耗费大量脑细胞。</p><p>下一篇，让我鸡鸡动动的，Eureka-Server 集群同步走起！</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/instance-registry-override-status/&quot;&gt;http://www.iocoder.cn/Eureka/instance-registry-overrid
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 应用实例注册发现（七）之增量获取</title>
    <link href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/"/>
    <id>http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/</id>
    <published>2018-07-02T16:00:00.000Z</published>
    <updated>2017-10-18T18:03:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong> </p><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">2. 应用集合一致性哈希码</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">2.1 计算公式</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">2.2 合理性</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">3. Eureka-Client 发起增量获取</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">3.1 合并应用集合</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">4. Eureka-Server 接收全量获取</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">3.1 接收全量获取请求</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">3.2 最近租约变更记录队列</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">3.3 缓存读取</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Eureka-Client 向 Eureka-Server 获取增量注册信息的过程</strong>。</p><p>前置阅读：<a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/?self">《Eureka 源码解析 —— 应用实例注册发现（六）之全量获取》</a></p><blockquote><p>FROM <a href="《http://techshow.ctrip.com/archives/1699.html》">《深度剖析服务发现组件Netflix Eureka》</a><br><img src="http://www.iocoder.cn/images/Eureka/2018_06_29/01.png" alt=""></p></blockquote><p>Eureka-Client 获取注册信息，分成<strong>全量获取</strong>和<strong>增量获取</strong>。默认配置下，Eureka-Client 启动时，首先执行一次<strong>全量</strong>获取进行<strong>本地缓存</strong>注册信息，而后每 <strong>30</strong> 秒<strong>增量</strong>获取刷新<strong>本地缓存</strong>( 非“<strong>正常</strong>”情况下会是全量获取 )。</p><p>本文重点在于<strong>增量获取</strong>。</p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-应用集合一致性哈希码"><a href="#2-应用集合一致性哈希码" class="headerlink" title="2. 应用集合一致性哈希码"></a>2. 应用集合一致性哈希码</h1><p><code>Applications.appsHashCode</code> ，应用集合<strong>一致性哈希码</strong>。</p><p><strong>增量</strong>获取注册的应用集合( Applications ) 时，Eureka-Client 会获取到：</p><ol><li>Eureka-Server 近期变化( 注册、下线 )的应用集合</li><li>Eureka-Server 应用集合一致性哈希码</li></ol><p>Eureka-Client 将<strong>变化</strong>的应用集合和<strong>本地缓存</strong>的应用集合进行合并后进行计算本地的应用集合一致性哈希码。若两个<strong>哈希码</strong>相等，意味着增量获取成功；若不相等，意味着增量获取失败，Eureka-Client 重新和 Eureka-Server <strong>全量</strong>获取应用集合。</p><p>Eureka 比较应用集合一致性哈希码，和日常我们通过哈希码比较两个对象是否相等类似。</p><h2 id="2-1-计算公式"><a href="#2-1-计算公式" class="headerlink" title="2.1 计算公式"></a>2.1 计算公式</h2><p><code>appsHashCode = ${status}_${count}_</code></p><ul><li>使用每个应用实例状态( <code>status</code> ) + 数量( <code>count</code> )拼接出一致性哈希码。若数量为 0 ，该应用实例状态不进行拼接。<strong>状态以字符串大小排序</strong>。</li><li>举个例子，8 个 UP ，0 个 DOWN ，则 <code>appsHashCode = UP_8_</code> 。8 个 UP ，2 个 DOWN ，则 <code>appsHashCode = DOWN_2_UP_8_</code> 。</li><li><p>实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Applications.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getReconcileHashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 计数集合 key：应用实例状态</span></div><div class="line">   TreeMap&lt;String, AtomicInteger&gt; instanceCountMap = <span class="keyword">new</span> TreeMap&lt;String, AtomicInteger&gt;();</div><div class="line">   populateInstanceCountMap(instanceCountMap);</div><div class="line">   <span class="comment">// 计算 hashcode</span></div><div class="line">   <span class="keyword">return</span> getReconcileHashCode(instanceCountMap);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>#populateInstanceCountMap()</code> 方法，计算每个应用实例状态的数量。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Applications.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">populateInstanceCountMap</span><span class="params">(Map&lt;String, AtomicInteger&gt; instanceCountMap)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (Application app : <span class="keyword">this</span>.getRegisteredApplications()) &#123;</div><div class="line">       <span class="keyword">for</span> (InstanceInfo info : app.getInstancesAsIsFromEureka()) &#123;</div><div class="line">           <span class="comment">// 计数</span></div><div class="line">           AtomicInteger instanceCount = instanceCountMap.computeIfAbsent(info.getStatus().name(),</div><div class="line">                   k -&gt; <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>));</div><div class="line">           instanceCount.incrementAndGet();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Application&gt; <span class="title">getRegisteredApplications</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Application&gt;(<span class="keyword">this</span>.applications);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Applications.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;InstanceInfo&gt; <span class="title">getInstancesAsIsFromEureka</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">synchronized</span> (instances) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;InstanceInfo&gt;(<span class="keyword">this</span>.instances);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>计数那块代码，使用 Integer 即可，无需使用 AtomicInteger 。</li></ul></li></ul></li><li><p>调用 <code>#getReconcileHashCode()</code> 方法，计算 <code>hashcode</code> 。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getReconcileHashCode</span><span class="params">(Map&lt;String, AtomicInteger&gt; instanceCountMap)</span> </span>&#123;</div><div class="line">   StringBuilder reconcileHashCode = <span class="keyword">new</span> StringBuilder(<span class="number">75</span>);</div><div class="line">   <span class="keyword">for</span> (Map.Entry&lt;String, AtomicInteger&gt; mapEntry : instanceCountMap.entrySet()) &#123;</div><div class="line">       reconcileHashCode.append(mapEntry.getKey()).append(STATUS_DELIMITER) <span class="comment">// status</span></div><div class="line">               .append(mapEntry.getValue().get()).append(STATUS_DELIMITER); <span class="comment">// count</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> reconcileHashCode.toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h2 id="2-2-合理性"><a href="#2-2-合理性" class="headerlink" title="2.2 合理性"></a>2.2 合理性</h2><p><strong>本小节，建议你理解完全文后，再回到此处</strong><br><strong>本小节，建议你理解完全文后，再回到此处</strong><br><strong>本小节，建议你理解完全文后，再回到此处</strong>  </p><p>笔者刚看完应用集合一致性哈希算法的计算公式，处于一脸懵逼的状态。这么精简的方式真的能够校验出数据的一致性么？不晓得有多少读者跟笔者有一样的疑惑。下面我们来论证该算法的合理性( 一本正经的胡说八道 )。</p><p>一致性哈希值通过<strong>状态 + 数量</strong>来计算，那么是不是可能状态总数是一样多，实际分布在不同的应用？那么我们列举模型如下：</p><table><thead><tr><th></th><th>UP</th></tr></thead><tbody><tr><td>应用A</td><td>m</td></tr><tr><td>应用B</td><td>n</td></tr></tbody></table><p>如果此时应用A 下线了 c 个原应用实例，应用B 注册了 c 个信应用实例，那么处于 UP 状态的数量仍然是 m + n 个。</p><ul><li>正常情况下，Eureka-Client 从 Eureka-Server 获取到<strong>完整的增量变化</strong>并合并，此时应用情况如下表格所示，两者是一致的，一致性哈希算法<strong>合理</strong>。</li></ul><table><thead><tr><th></th><th>UP (server)</th><th>UP (client)</th></tr></thead><tbody><tr><td>应用A</td><td>m - c</td><td>m - c</td></tr><tr><td>应用B</td><td>n + c</td><td>n + c</td></tr></tbody></table><ul><li>异常情况下【1】，变更记录队列全部过期。那 Eureka-Client 从 Eureka-Server 获取到<strong>空的增量变化</strong>并合并，此时应用情况如下表格所示，两者应用是不相同的， 一致性哈希值却是相等的，一致性哈希算法<strong>不合理</strong>。</li></ul><table><thead><tr><th></th><th>UP (server)</th><th>UP (client)</th></tr></thead><tbody><tr><td>应用A</td><td>m - c</td><td>m</td></tr><tr><td>应用B</td><td>n + c</td><td>n</td></tr></tbody></table><ul><li>异常情况下【2】，变更记录队列部分过期，例如应用A 和 应用B 都剩余 w 条变更记录。那 Eureka-Client 从 Eureka-Server 获取到<strong>部分的增量变化</strong>并合并，两者应用是不相同的，此时应用情况如下表格所示，一致性哈希值却是相等的，一致性哈希算法<strong>不合理</strong>。</li></ul><table><thead><tr><th></th><th>UP (server)</th><th>UP (client)</th></tr></thead><tbody><tr><td>应用A</td><td>m - c</td><td>m - w</td></tr><tr><td>应用B</td><td>n + c</td><td>n + w</td></tr></tbody></table><p>What ？ 从异常情况【1】【2】可以看到，一致性哈希算法竟然是<strong>不合理</strong>的，那么我们手动来做一次最精简的实验。实验如下：</p><ul><li>模拟场景：异常情况【1】，m = n = c = 1 。简单粗暴。</li><li>特别配置<ul><li><code>eureka.retentionTimeInMSInDeltaQueue = 1</code> ，变更记录队列每条记录存活时长 1 ms。用以实现 Eureka-Client 请求不到完整的增量变化。</li><li><code>eureka.deltaRetentionTimerIntervalInMs = 1</code> ，变更记录队列每条记录过期定时任务执行频率 1 ms。用以实现 Eureka-Client 请求不到完整的增量变化。</li><li><code>eureka.shouldUseReadOnlyResponseCache = false</code> ，禁用响应缓存的只读缓存。用以避免等待缓存刷新。</li><li><code>eureka.waitTimeInMsWhenSyncEmpty = 1</code> ，</li></ul></li><li>实验过程<ol><li>00:00 启动 Eureka-Server</li><li>00:30 启动应用A ，向 Eureka-Server 注册</li><li>01:00 启动 Eureka-Client ，向 Eureka-Server 获取注册信息，等待获取到应用A</li><li>01:30 关闭应用A 。立即启动应用B ，向 Eureka-Server 注册</li><li>等待 5 分钟，Eureka-Client 无法获取到应用B </li><li>此时应用情况如下表格所示，两者应用是不相同的，一致性哈希值却是相等的，一致性哈希算法<strong>不合理。</strong></li></ol></li></ul><table><thead><tr><th></th><th>UP (server)</th><th>UP (client)</th></tr></thead><tbody><tr><td>应用A</td><td>0</td><td>1</td></tr><tr><td>应用B</td><td>1</td><td>0</td></tr></tbody></table><p>🙂<strong>结论</strong>🙂</p><p>当然排除掉特别极端的场景，Eureka-Client 从 Eureka-Server 因为网络异常导致一直同步不到增量变化，又恰好应用关闭和开启满足状态统计数量。另外，变更记录队列记录过期时长为 300 秒，增量获取频率为 30 秒，获取的次数有 10 次左右。<strong>所以，应用集合一致性哈希码在绝大多数场景是合理的</strong>。<strong>笔者的YY</strong>，解决这个极小场景有如下方式：</p><ul><li>第一种，修改计算公式 <code>appsHashCode = MD5(${app_name}_${instance_id}_${status}_${count}_)</code> ，增加对应用名和应用实例编号敏感。</li><li>第二种，每 N 分钟进行一次全量获取注册信息。</li></ul><p>ps ：笔者怀着忐忑的心写完了这个小节，如果有不合理的地方，又或者有不同观点的胖友，欢迎一起探讨。谢谢。</p><p>TODO[0027][反思]：应用集合一致性哈希算法。</p><h1 id="3-Eureka-Client-发起增量获取"><a href="#3-Eureka-Client-发起增量获取" class="headerlink" title="3. Eureka-Client 发起增量获取"></a>3. Eureka-Client 发起增量获取</h1><p>在 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/?self">《Eureka 源码解析 —— 应用实例注册发现（六）之全量获取》「2.4 发起获取注册信息」</a> 里，调用 <code>DiscoveryClient#getAndUpdateDelta(...)</code> 方法，<strong>增量</strong>获取注册信息，并<strong>刷新</strong>本地缓存，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getAndUpdateDelta</span><span class="params">(Applications applications)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="keyword">long</span> currentUpdateGeneration = fetchRegistryGeneration.get();</div><div class="line"> <span class="number">3</span>: </div><div class="line"> <span class="number">4</span>:     <span class="comment">// 增量获取注册信息</span></div><div class="line"> <span class="number">5</span>:     Applications delta = <span class="keyword">null</span>;</div><div class="line"> <span class="number">6</span>:     EurekaHttpResponse&lt;Applications&gt; httpResponse = eurekaTransport.queryClient.getDelta(remoteRegionsRef.get());</div><div class="line"> <span class="number">7</span>:     <span class="keyword">if</span> (httpResponse.getStatusCode() == Status.OK.getStatusCode()) &#123;</div><div class="line"> <span class="number">8</span>:         delta = httpResponse.getEntity();</div><div class="line"> <span class="number">9</span>:     &#125;</div><div class="line"><span class="number">10</span>: </div><div class="line"><span class="number">11</span>:     <span class="keyword">if</span> (delta == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">12</span>:         <span class="comment">// 增量获取为空，全量获取</span></div><div class="line"><span class="number">13</span>:         logger.warn(<span class="string">"The server does not allow the delta revision to be applied because it is not safe. "</span></div><div class="line"><span class="number">14</span>:                 + <span class="string">"Hence got the full registry."</span>);</div><div class="line"><span class="number">15</span>:         getAndStoreFullRegistry();</div><div class="line"><span class="number">16</span>:     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fetchRegistryGeneration.compareAndSet(currentUpdateGeneration, currentUpdateGeneration + <span class="number">1</span>)) &#123;</div><div class="line"><span class="number">17</span>:         logger.debug(<span class="string">"Got delta update with apps hashcode &#123;&#125;"</span>, delta.getAppsHashCode());</div><div class="line"><span class="number">18</span>:         String reconcileHashCode = <span class="string">""</span>;</div><div class="line"><span class="number">19</span>:         <span class="keyword">if</span> (fetchRegistryUpdateLock.tryLock()) &#123;</div><div class="line"><span class="number">20</span>:             <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">21</span>:                 <span class="comment">// 将变化的应用集合和本地缓存的应用集合进行合并</span></div><div class="line"><span class="number">22</span>:                 updateDelta(delta);</div><div class="line"><span class="number">23</span>:                 <span class="comment">// 计算本地的应用集合一致性哈希码</span></div><div class="line"><span class="number">24</span>:                 reconcileHashCode = getReconcileHashCode(applications);</div><div class="line"><span class="number">25</span>:             &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">26</span>:                 fetchRegistryUpdateLock.unlock();</div><div class="line"><span class="number">27</span>:             &#125;</div><div class="line"><span class="number">28</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">29</span>:             logger.warn(<span class="string">"Cannot acquire update lock, aborting getAndUpdateDelta"</span>);</div><div class="line"><span class="number">30</span>:         &#125;</div><div class="line"><span class="number">31</span>:         <span class="comment">// There is a diff in number of instances for some reason</span></div><div class="line"><span class="number">32</span>:         <span class="keyword">if</span> (!reconcileHashCode.equals(delta.getAppsHashCode()) <span class="comment">// 一致性哈希值不相等</span></div><div class="line"><span class="number">33</span>:                 || clientConfig.shouldLogDeltaDiff()) &#123; <span class="comment">//</span></div><div class="line"><span class="number">34</span>:             reconcileAndLogDifference(delta, reconcileHashCode);  <span class="comment">// this makes a remoteCall</span></div><div class="line"><span class="number">35</span>:         &#125;</div><div class="line"><span class="number">36</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">37</span>:         logger.warn(<span class="string">"Not updating application delta as another thread is updating it already"</span>);</div><div class="line"><span class="number">38</span>:         logger.debug(<span class="string">"Ignoring delta update with apps hashcode &#123;&#125;, as another thread is updating it already"</span>, delta.getAppsHashCode());</div><div class="line"><span class="number">39</span>:     &#125;</div><div class="line"><span class="number">40</span>: &#125;</div></pre></td></tr></table></figure><ul><li><p>第 4 至 9 行 ：请求<strong>增量</strong>获取注册信息，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractJerseyEurekaHttpClient.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Applications&gt; <span class="title">getDelta</span><span class="params">(String... regions)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> getApplicationsInternal(<span class="string">"apps/delta"</span>, regions);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>AbstractJerseyEurekaHttpClient#getApplicationsInternal(...)</code> 方法，GET 请求 Eureka-Server 的 <code>apps/detla</code> 接口，参数为 <code>regions</code> ，返回格式为 JSON ，实现增量获取注册信息。</li></ul></li><li><p>第 11 至 15 行 ：<strong>增量</strong>获取失败，调用 <code>#getAndStoreFullRegistry()</code> 方法，<strong>全量</strong>获取注册信息，并设置到本地缓存。该方法在 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/?self">《Eureka 源码解析 —— 应用实例注册发现（六）之全量获取》「2.4.1 全量获取注册信息，并设置到本地缓存」</a> 有详细解析。</p></li><li>第 16 至 35 行 ：处理<strong>增量</strong>获取的结果。<ul><li>第 16 行 ：TODO[0025] ：并发更新的情况？？？</li><li>第 19 行 ：TODO[0025] ：并发更新的情况？？？</li><li>第 21 行 ：调用 <code>#updateDelta(...)</code> 方法，将<strong>变化</strong>的应用集合和<strong>本地缓存</strong>的应用集合进行合并。</li><li>第 31 至 35 行 ：一致性哈希值不相等，调用 <code>#reconcileAndLogDifference()</code> 方法，<strong>全量</strong>获取注册信息，并设置到本地缓存，和 <code>#getAndStoreFullRegistry()</code> 基本类似。<ul><li>第 33 行 ：配置 <code>eureka.printDeltaFullDiff</code> ，是否打印增量和全量差异。默认值 ：<code>false</code> 。从目前代码实现上来看，暂时没有生效。<strong>注意</strong> ：开启该参数会导致每次<strong>增量</strong>获取后又发起<strong>全量</strong>获取，不要开启。</li></ul></li></ul></li></ul><h2 id="3-1-合并应用集合"><a href="#3-1-合并应用集合" class="headerlink" title="3.1 合并应用集合"></a>3.1 合并应用集合</h2><p>调用 <code>#updateDelta(...)</code> 方法，将<strong>变化</strong>的应用集合和<strong>本地缓存</strong>的应用集合进行合并。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateDelta</span><span class="params">(Applications delta)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="keyword">int</span> deltaCount = <span class="number">0</span>;</div><div class="line"> <span class="number">3</span>:     <span class="keyword">for</span> (Application app : delta.getRegisteredApplications()) &#123; <span class="comment">// 循环增量（变化）应用集合</span></div><div class="line"> <span class="number">4</span>:         <span class="keyword">for</span> (InstanceInfo instance : app.getInstances()) &#123;</div><div class="line"> <span class="number">5</span>:             Applications applications = getApplications();</div><div class="line"> <span class="number">6</span>:             <span class="comment">// TODO[0009]：RemoteRegionRegistry</span></div><div class="line"> <span class="number">7</span>:             String instanceRegion = instanceRegionChecker.getInstanceRegion(instance);</div><div class="line"> <span class="number">8</span>:             <span class="keyword">if</span> (!instanceRegionChecker.isLocalRegion(instanceRegion)) &#123;</div><div class="line"> <span class="number">9</span>:                 Applications remoteApps = remoteRegionVsApps.get(instanceRegion);</div><div class="line"><span class="number">10</span>:                 <span class="keyword">if</span> (<span class="keyword">null</span> == remoteApps) &#123;</div><div class="line"><span class="number">11</span>:                     remoteApps = <span class="keyword">new</span> Applications();</div><div class="line"><span class="number">12</span>:                     remoteRegionVsApps.put(instanceRegion, remoteApps);</div><div class="line"><span class="number">13</span>:                 &#125;</div><div class="line"><span class="number">14</span>:                 applications = remoteApps;</div><div class="line"><span class="number">15</span>:             &#125;</div><div class="line"><span class="number">16</span>: </div><div class="line"><span class="number">17</span>:             ++deltaCount;</div><div class="line"><span class="number">18</span>:             <span class="keyword">if</span> (ActionType.ADDED.equals(instance.getActionType())) &#123; <span class="comment">// 添加</span></div><div class="line"><span class="number">19</span>:                 Application existingApp = applications.getRegisteredApplications(instance.getAppName());</div><div class="line"><span class="number">20</span>:                 <span class="keyword">if</span> (existingApp == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">21</span>:                     applications.addApplication(app);</div><div class="line"><span class="number">22</span>:                 &#125;</div><div class="line"><span class="number">23</span>:                 logger.debug(<span class="string">"Added instance &#123;&#125; to the existing apps in region &#123;&#125;"</span>, instance.getId(), instanceRegion);</div><div class="line"><span class="number">24</span>:                 applications.getRegisteredApplications(instance.getAppName()).addInstance(instance);</div><div class="line"><span class="number">25</span>:             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ActionType.MODIFIED.equals(instance.getActionType())) &#123; <span class="comment">// 修改</span></div><div class="line"><span class="number">26</span>:                 Application existingApp = applications.getRegisteredApplications(instance.getAppName());</div><div class="line"><span class="number">27</span>:                 <span class="keyword">if</span> (existingApp == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">28</span>:                     applications.addApplication(app);</div><div class="line"><span class="number">29</span>:                 &#125;</div><div class="line"><span class="number">30</span>:                 logger.debug(<span class="string">"Modified instance &#123;&#125; to the existing apps "</span>, instance.getId());</div><div class="line"><span class="number">31</span>: </div><div class="line"><span class="number">32</span>:                 applications.getRegisteredApplications(instance.getAppName()).addInstance(instance);</div><div class="line"><span class="number">33</span>:             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ActionType.DELETED.equals(instance.getActionType())) &#123; <span class="comment">// 删除</span></div><div class="line"><span class="number">34</span>:                 Application existingApp = applications.getRegisteredApplications(instance.getAppName());</div><div class="line"><span class="number">35</span>:                 <span class="keyword">if</span> (existingApp == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">36</span>:                     applications.addApplication(app);</div><div class="line"><span class="number">37</span>:                 &#125;</div><div class="line"><span class="number">38</span>:                 logger.debug(<span class="string">"Deleted instance &#123;&#125; to the existing apps "</span>, instance.getId());</div><div class="line"><span class="number">39</span>:                 applications.getRegisteredApplications(instance.getAppName()).removeInstance(instance);</div><div class="line"><span class="number">40</span>:             &#125;</div><div class="line"><span class="number">41</span>:         &#125;</div><div class="line"><span class="number">42</span>:     &#125;</div><div class="line"><span class="number">43</span>:     logger.debug(<span class="string">"The total number of instances fetched by the delta processor : &#123;&#125;"</span>, deltaCount);</div><div class="line"><span class="number">44</span>: </div><div class="line"><span class="number">45</span>:     getApplications().setVersion(delta.getVersion());</div><div class="line"><span class="number">46</span>:     <span class="comment">// 过滤、打乱应用集合</span></div><div class="line"><span class="number">47</span>:     getApplications().shuffleInstances(clientConfig.shouldFilterOnlyUpInstances());</div><div class="line"><span class="number">48</span>: </div><div class="line"><span class="number">49</span>:     <span class="comment">// TODO[0009]：RemoteRegionRegistry</span></div><div class="line"><span class="number">50</span>:     <span class="keyword">for</span> (Applications applications : remoteRegionVsApps.values()) &#123;</div><div class="line"><span class="number">51</span>:         applications.setVersion(delta.getVersion());</div><div class="line"><span class="number">52</span>:         applications.shuffleInstances(clientConfig.shouldFilterOnlyUpInstances());</div><div class="line"><span class="number">53</span>:     &#125;</div><div class="line"><span class="number">54</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 6 至 15 行 ：TODO[0009]：RemoteRegionRegistry</li><li><p>第 18 至 24 行 ：添加( ADDED )应用实例时，调用 <code>Application#addInstance(...)</code> 方法，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Application.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInstance</span><span class="params">(InstanceInfo i)</span> </span>&#123;</div><div class="line">   <span class="comment">// 添加到 应用实例映射</span></div><div class="line">   instancesMap.put(i.getId(), i);</div><div class="line">   <span class="keyword">synchronized</span> (instances) &#123;</div><div class="line">       <span class="comment">// 移除原有实例</span></div><div class="line">       instances.remove(i);</div><div class="line">       <span class="comment">// 添加新实例</span></div><div class="line">       instances.add(i);</div><div class="line">       <span class="comment">// 设置 isDirty ，目前只用于 `#toString()` 方法打印，无业务逻辑</span></div><div class="line">       isDirty = <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// InstanceInfo.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; <span class="comment">// 只使用 ID 计算 hashcode</span></div><div class="line">   String id = getId();</div><div class="line">   <span class="keyword">return</span> (id == <span class="keyword">null</span>) ? <span class="number">31</span> : (id.hashCode() + <span class="number">31</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123; <span class="comment">// 只对比 ID</span></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">this</span> == obj) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (getClass() != obj.getClass()) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">   InstanceInfo other = (InstanceInfo) obj;</div><div class="line">   String id = getId();</div><div class="line">   <span class="keyword">if</span> (id == <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="keyword">if</span> (other.getId() != <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!id.equals(other.getId())) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>第 25 至 32 行 ：修改( MODIFIED )应用实例时，<strong>同样</strong>调用 <code>Application#addInstance(...)</code> 方法。</p></li><li><p>第 33 至 40 行 ：删除( DELETED )应用实例时，调用 <code>Application#removeInstance(...)</code> 方法，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeInstance</span><span class="params">(InstanceInfo i)</span> </span>&#123;</div><div class="line">    removeInstance(i, <span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeInstance</span><span class="params">(InstanceInfo i, <span class="keyword">boolean</span> markAsDirty)</span> </span>&#123;</div><div class="line">    <span class="comment">// 移除 应用实例映射</span></div><div class="line">    instancesMap.remove(i.getId());</div><div class="line">    <span class="keyword">synchronized</span> (instances) &#123;</div><div class="line">        <span class="comment">// 移除 应用实例</span></div><div class="line">        instances.remove(i);</div><div class="line">        <span class="keyword">if</span> (markAsDirty) &#123;</div><div class="line">            <span class="comment">// 设置 isDirty ，目前只用于 `#toString()` 方法打印，无业务逻辑</span></div><div class="line">            isDirty = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>第 47 行 ：调用 <code>Applications#shuffleInstances(...)</code> 方法，根据配置 <code>eureka.shouldFilterOnlyUpInstances = true</code> ( 默认值 ：<code>true</code> ) 过滤只保留状态为开启( UP )的应用实例，并<strong>随机打乱</strong>应用实例顺序。打乱后，实现调用应用服务的随机性。代码比较易懂，点击<a href="https://github.com/YunaiV/eureka/blob/512697015ef081233c5cb7c472250bca6b779ab4/eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java#L286" rel="external nofollow noopener noreferrer" target="_blank">链接</a>查看方法实现。</p></li><li>第 49 至 53 行 ：TODO[0009]：RemoteRegionRegistry</li></ul><h1 id="4-Eureka-Server-接收全量获取"><a href="#4-Eureka-Server-接收全量获取" class="headerlink" title="4. Eureka-Server 接收全量获取"></a>4. Eureka-Server 接收全量获取</h1><h2 id="3-1-接收全量获取请求"><a href="#3-1-接收全量获取请求" class="headerlink" title="3.1 接收全量获取请求"></a>3.1 接收全量获取请求</h2><p><code>com.netflix.eureka.resources.ApplicationsResource</code>，处理<strong>所有</strong>应用的请求操作的 Resource ( Controller )。</p><p>接收增量获取请求，映射 <code>ApplicationsResource#getContainers()</code> 方法。</p><ul><li>和 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/?self">《Eureka 源码解析 —— 应用实例注册发现（六）之全量获取》「3.1 接收全量获取请求」</a> 类似，就不重复啰嗦啦。</li><li>点击 <a href="https://github.com/YunaiV/eureka/blob/225a81d9818d355503ad802363448eb29c374b6f/eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationsResource.java#L190" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看该方法的<strong>带中文注释</strong>代码。</li></ul><h2 id="3-2-最近租约变更记录队列"><a href="#3-2-最近租约变更记录队列" class="headerlink" title="3.2 最近租约变更记录队列"></a>3.2 最近租约变更记录队列</h2><p><code>AbstractInstanceRegistry.recentlyChangedQueue</code>，最近租约变更记录队列。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 最近租约变更记录队列</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> ConcurrentLinkedQueue&lt;RecentlyChangedItem&gt; recentlyChangedQueue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;RecentlyChangedItem&gt;();</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 最近租约变更记录</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RecentlyChangedItem</span> </span>&#123;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 最后更新时间戳</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">long</span> lastUpdateTime;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 租约</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">private</span> Lease&lt;InstanceInfo&gt; leaseInfo;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">RecentlyChangedItem</span><span class="params">(Lease&lt;InstanceInfo&gt; lease)</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>.leaseInfo = lease;</div><div class="line">       lastUpdateTime = System.currentTimeMillis();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLastUpdateTime</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.lastUpdateTime;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> Lease&lt;InstanceInfo&gt; <span class="title">getLeaseInfo</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.leaseInfo;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>当应用实例注册、下线、状态变更时，创建最近租约变更记录( RecentlyChangedItem ) 到队列。</li><li><p>后台任务定时<strong>顺序</strong>扫描队列，当 <code>lastUpdateTime</code> 超过一定时长后进行移除。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line"><span class="keyword">this</span>.deltaRetentionTimer.schedule(getDeltaRetentionTask(),</div><div class="line">                serverConfig.getDeltaRetentionTimerIntervalInMs(),</div><div class="line">                serverConfig.getDeltaRetentionTimerIntervalInMs());</div><div class="line">                </div><div class="line"><span class="function"><span class="keyword">private</span> TimerTask <span class="title">getDeltaRetentionTask</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> TimerTask() &#123;</div><div class="line"></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">           Iterator&lt;RecentlyChangedItem&gt; it = recentlyChangedQueue.iterator();</div><div class="line">           <span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">               <span class="keyword">if</span> (it.next().getLastUpdateTime() &lt; System.currentTimeMillis() - serverConfig.getRetentionTimeInMSInDeltaQueue()) &#123;</div><div class="line">                   it.remove();</div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">   &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>配置 <code>eureka.deltaRetentionTimerIntervalInMs</code>， 移除队列里过期的租约变更记录的定时任务执行频率，单位：毫秒。默认值 ：30 * 1000 毫秒。</li><li>配置 <code>eureka.retentionTimeInMSInDeltaQueue</code>，租约变更记录过期时长，单位：毫秒。默认值 ： 3 <em> 60 </em> 1000 毫秒。</li></ul></li></ul><h2 id="3-3-缓存读取"><a href="#3-3-缓存读取" class="headerlink" title="3.3 缓存读取"></a>3.3 缓存读取</h2><p>在 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/?self">《Eureka 源码解析 —— 应用实例注册发现（六）之全量获取》「3.3 缓存读取」</a> 里，在 <code>#generatePayload()</code> 方法里，调用 <code>AbstractInstanceRegistry#getApplicationDeltas(...)</code> 方法，获取近期变化的应用集合，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">public</span> Applications <span class="title">getApplicationDeltas</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="number">2</span>:     <span class="comment">// 添加 增量获取次数 到 监控</span></div><div class="line">  <span class="number">3</span>:     GET_ALL_CACHE_MISS_DELTA.increment();</div><div class="line">  <span class="number">4</span>:     <span class="comment">// 初始化 变化的应用集合</span></div><div class="line">  <span class="number">5</span>:     Applications apps = <span class="keyword">new</span> Applications();</div><div class="line">  <span class="number">6</span>:     apps.setVersion(responseCache.getVersionDelta().get());</div><div class="line">  <span class="number">7</span>:     Map&lt;String, Application&gt; applicationInstancesMap = <span class="keyword">new</span> HashMap&lt;String, Application&gt;();</div><div class="line">  <span class="number">8</span>:     <span class="keyword">try</span> &#123;</div><div class="line">  <span class="number">9</span>:         <span class="comment">// 获取写锁</span></div><div class="line"> <span class="number">10</span>:         write.lock();</div><div class="line"> <span class="number">11</span>:         <span class="comment">// 获取 最近租约变更记录队列</span></div><div class="line"> <span class="number">12</span>:         Iterator&lt;RecentlyChangedItem&gt; iter = <span class="keyword">this</span>.recentlyChangedQueue.iterator();</div><div class="line"> <span class="number">13</span>:         logger.debug(<span class="string">"The number of elements in the delta queue is :"</span> + <span class="keyword">this</span>.recentlyChangedQueue.size());</div><div class="line"> <span class="number">14</span>:         <span class="comment">// 拼装 变化的应用集合</span></div><div class="line"> <span class="number">15</span>:         <span class="keyword">while</span> (iter.hasNext()) &#123;</div><div class="line"> <span class="number">16</span>:             Lease&lt;InstanceInfo&gt; lease = iter.next().getLeaseInfo();</div><div class="line"> <span class="number">17</span>:             InstanceInfo instanceInfo = lease.getHolder();</div><div class="line"> <span class="number">18</span>:             Object[] args = &#123;instanceInfo.getId(), instanceInfo.getStatus().name(), instanceInfo.getActionType().name()&#125;;</div><div class="line"> <span class="number">19</span>:             logger.debug(<span class="string">"The instance id %s is found with status %s and actiontype %s"</span>, args);</div><div class="line"> <span class="number">20</span>:             Application app = applicationInstancesMap.get(instanceInfo.getAppName());</div><div class="line"> <span class="number">21</span>:             <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">22</span>:                 app = <span class="keyword">new</span> Application(instanceInfo.getAppName());</div><div class="line"> <span class="number">23</span>:                 applicationInstancesMap.put(instanceInfo.getAppName(), app);</div><div class="line"> <span class="number">24</span>:                 apps.addApplication(app);</div><div class="line"> <span class="number">25</span>:             &#125;</div><div class="line"> <span class="number">26</span>:             app.addInstance(decorateInstanceInfo(lease));</div><div class="line"> <span class="number">27</span>:         &#125;</div><div class="line"> <span class="number">28</span>: </div><div class="line"> <span class="number">29</span>:         <span class="comment">// TODO[0009]：RemoteRegionRegistry</span></div><div class="line"> <span class="number">30</span>:         <span class="keyword">boolean</span> disableTransparentFallback = serverConfig.disableTransparentFallbackToOtherRegion();</div><div class="line"> <span class="number">31</span>:         <span class="keyword">if</span> (!disableTransparentFallback) &#123;</div><div class="line"> <span class="number">32</span>:             Applications allAppsInLocalRegion = getApplications(<span class="keyword">false</span>);</div><div class="line"> <span class="number">33</span>: </div><div class="line"> <span class="number">34</span>:             <span class="keyword">for</span> (RemoteRegionRegistry remoteRegistry : <span class="keyword">this</span>.regionNameVSRemoteRegistry.values()) &#123;</div><div class="line"> <span class="number">35</span>:                 Applications applications = remoteRegistry.getApplicationDeltas();</div><div class="line"> <span class="number">36</span>:                 <span class="keyword">for</span> (Application application : applications.getRegisteredApplications()) &#123;</div><div class="line"> <span class="number">37</span>:                     Application appInLocalRegistry =</div><div class="line"> <span class="number">38</span>:                             allAppsInLocalRegion.getRegisteredApplications(application.getName());</div><div class="line"> <span class="number">39</span>:                     <span class="keyword">if</span> (appInLocalRegistry == <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">40</span>:                         apps.addApplication(application);</div><div class="line"> <span class="number">41</span>:                     &#125;</div><div class="line"> <span class="number">42</span>:                 &#125;</div><div class="line"> <span class="number">43</span>:             &#125;</div><div class="line"> <span class="number">44</span>:         &#125;</div><div class="line"> <span class="number">45</span>: </div><div class="line"> <span class="number">46</span>:         <span class="comment">// 获取全量应用集合，通过它计算一致性哈希值</span></div><div class="line"> <span class="number">47</span>:         Applications allApps = getApplications(!disableTransparentFallback);</div><div class="line"> <span class="number">48</span>:         apps.setAppsHashCode(allApps.getReconcileHashCode());</div><div class="line"> <span class="number">49</span>:         <span class="keyword">return</span> apps;</div><div class="line"> <span class="number">50</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"> <span class="number">51</span>:         write.unlock();</div><div class="line"> <span class="number">52</span>:     &#125;</div><div class="line"> <span class="number">53</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 2 至 3 行 ：添加增量获取次数到监控。配合 <a href="https://github.com/Netflix/servo" rel="external nofollow noopener noreferrer" target="_blank">Netflix Servo</a> 实现监控信息采集。</li><li>第 4 行 ：初始化变化( 增量 )的应用集合( <code>apps</code> )。</li><li>第 9 行 ：获取写锁。在 <a href="http://www.iocoder.cn/Eureka/instance-registry-read-write-lock/?self">《Eureka源码解析 —— 应用实例注册发现 （九）之岁月是把萌萌的读写锁》</a> 详细解析。</li><li>第 11 至 13 行 ：获取最近租约变更记录队列( <code>最近租约变更记录队列</code> )。</li><li>第 14 至 27 行 ：拼装变化的应用集合( <code>apps</code> )。</li><li>第 29 至 44 行 ：TODO[0009]：RemoteRegionRegistry</li><li>第 46 至 48 行 ：调用 <code>#getApplications(...)</code> 方法，获取<strong>全量</strong>应用集合( <code>allApps</code> )，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/?self">《Eureka 源码解析 —— 应用实例注册发现（六）之全量获取》「3.3.1 获得注册的应用集合」</a> 有详细解析。后通过 <code>allApps</code> 计算一致性哈希值。通过这个全量应用集合的哈希值，Eureka-Client 获取到增量应用集合并合并后，就可以比对啦。</li><li>第 51 行 ：释放写锁。</li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>在汉堡王写完这篇热情的博客。为什么用“热情”这个字眼呢？大夏天的，竟然不开空调的！对的，没有开空调，简直是个小火炉。恩，不过静心写完这篇文章，让我还是挺嗨皮的。</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/&quot;&gt;http://www.iocoder.cn/Eureka/instance-registry-fetch-delta
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 应用实例注册发现（六）之全量获取</title>
    <link href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/"/>
    <id>http://www.iocoder.cn/Eureka/instance-registry-fetch-all/</id>
    <published>2018-06-28T16:00:00.000Z</published>
    <updated>2017-10-18T14:48:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">http://www.iocoder.cn/Eureka/instance-registry-fetch-all/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong> </p><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">2. Eureka-Client 发起全量获取</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">2.1 初始化全量获取</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">2.2 定时获取</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">2.3 刷新注册信息缓存</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">2.4 发起获取注册信息</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">3. Eureka-Server 接收全量获取</a><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">3.1 接收全量获取请求</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">3.2 响应缓存 ResponseCache</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">3.3 缓存读取</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">3.4 主动过期读写缓存</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">3.5 被动过期读写缓存</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">3.6 定时刷新只读缓存</a></li></ul></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-all/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Eureka-Client 向 Eureka-Server 获取全量注册信息的过程</strong>。</p><blockquote><p>FROM <a href="《http://techshow.ctrip.com/archives/1699.html》">《深度剖析服务发现组件Netflix Eureka》</a><br><img src="http://www.iocoder.cn/images/Eureka/2018_06_29/01.png" alt=""></p></blockquote><p>Eureka-Client 获取注册信息，分成<strong>全量获取</strong>和<strong>增量获取</strong>。默认配置下，Eureka-Client 启动时，首先执行一次<strong>全量</strong>获取进行<strong>本地缓存</strong>注册信息，而后每 <strong>30</strong> 秒<strong>增量</strong>获取刷新<strong>本地缓存</strong>( 非“<strong>正常</strong>”情况下会是全量获取 )。</p><p>本文重点在于<strong>全量获取</strong>。</p><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-Eureka-Client-发起全量获取"><a href="#2-Eureka-Client-发起全量获取" class="headerlink" title="2. Eureka-Client 发起全量获取"></a>2. Eureka-Client 发起全量获取</h1><p>本小节调用关系如下：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_06_29/03.png" alt=""></p><h2 id="2-1-初始化全量获取"><a href="#2-1-初始化全量获取" class="headerlink" title="2.1 初始化全量获取"></a>2.1 初始化全量获取</h2><p>Eureka-Client 启动时，首先执行一次<strong>全量</strong>获取进行<strong>本地缓存</strong>注册信息，首先代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* Applications 在本地的缓存</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;Applications&gt; localRegionApps = <span class="keyword">new</span> AtomicReference&lt;Applications&gt;();</div><div class="line"></div><div class="line">DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,</div><div class="line">                    Provider&lt;BackupRegistry&gt; backupRegistryProvider) &#123;</div><div class="line">                    </div><div class="line">     <span class="comment">// ... 省略无关代码</span></div><div class="line">     </div><div class="line">    <span class="comment">// 【3.2.5】初始化应用集合在本地的缓存</span></div><div class="line">    localRegionApps.set(<span class="keyword">new</span> Applications());</div><div class="line">     </div><div class="line">    <span class="comment">// ... 省略无关代码     </span></div><div class="line">     </div><div class="line">    <span class="comment">// 【3.2.12】从 Eureka-Server 拉取注册信息</span></div><div class="line">    <span class="keyword">if</span> (clientConfig.shouldFetchRegistry() &amp;&amp; !fetchRegistry(<span class="keyword">false</span>)) &#123;</div><div class="line">        fetchRegistryFromBackup();</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">     <span class="comment">// ... 省略无关代码       </span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p><code>com.netflix.discovery.shared.Applications</code>，注册的应用集合。较为容易理解，点击 <a href="https://github.com/YunaiV/eureka/blob/512697015ef081233c5cb7c472250bca6b779ab4/eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 链接查看带中文注释的类，这里就不啰嗦了。Applications 与 InstanceInfo 类关系如下：</p><p>  <img src="http://www.iocoder.cn/images/Eureka/2018_06_29/02.png" alt=""></p></li><li><p>配置 <code>eureka.shouldFetchRegistry = true</code>，开启从 Eureka-Server 获取注册信息。默认值：<code>true</code> 。</p></li><li>调用 <code>#fetchRegistry(false)</code> 方法，从 Eureka-Server <strong>全量</strong>获取注册信息，在 <a href="#">「2.4 发起获取注册信息」</a> 详细解析。</li></ul><h2 id="2-2-定时获取"><a href="#2-2-定时获取" class="headerlink" title="2.2 定时获取"></a>2.2 定时获取</h2><p>Eureka-Client 在<a href="http://www.iocoder.cn/Eureka/eureka-client-init-third/?self">初始化</a>过程中，创建<strong>获取注册信息</strong>线程，<strong>固定间隔</strong>向 Eureka-Server 发起<strong>获取注册信息</strong>( fetch )，<strong>刷新</strong>本地注册信息<strong>缓存</strong>。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java</span></div><div class="line">DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,</div><div class="line">               Provider&lt;BackupRegistry&gt; backupRegistryProvider) &#123;</div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line">               </div><div class="line">    <span class="comment">// 【3.2.9】初始化线程池</span></div><div class="line">    <span class="comment">// default size of 2 - 1 each for heartbeat and cacheRefresh</span></div><div class="line">    scheduler = Executors.newScheduledThreadPool(<span class="number">2</span>,</div><div class="line">         <span class="keyword">new</span> ThreadFactoryBuilder()</div><div class="line">                 .setNameFormat(<span class="string">"DiscoveryClient-%d"</span>)</div><div class="line">                 .setDaemon(<span class="keyword">true</span>)</div><div class="line">                 .build());</div><div class="line">    </div><div class="line">    cacheRefreshExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</div><div class="line">         <span class="number">1</span>, clientConfig.getCacheRefreshExecutorThreadPoolSize(), <span class="number">0</span>, TimeUnit.SECONDS,</div><div class="line">         <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</div><div class="line">         <span class="keyword">new</span> ThreadFactoryBuilder()</div><div class="line">                 .setNameFormat(<span class="string">"DiscoveryClient-CacheRefreshExecutor-%d"</span>)</div><div class="line">                 .setDaemon(<span class="keyword">true</span>)</div><div class="line">                 .build()</div><div class="line">     );  <span class="comment">// use direct handoff</span></div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line">    </div><div class="line">    <span class="comment">// 【3.2.14】初始化定时任务</span></div><div class="line">    initScheduledTasks();</div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略无关代码</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initScheduledTasks</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 向 Eureka-Server 心跳（续租）执行器</span></div><div class="line">    <span class="keyword">if</span> (clientConfig.shouldFetchRegistry()) &#123;</div><div class="line">       <span class="comment">// registry cache refresh timer</span></div><div class="line">       <span class="keyword">int</span> registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds();</div><div class="line">       <span class="keyword">int</span> expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound();</div><div class="line">       scheduler.schedule(</div><div class="line">               <span class="keyword">new</span> TimedSupervisorTask(</div><div class="line">                       <span class="string">"cacheRefresh"</span>,</div><div class="line">                       scheduler,</div><div class="line">                       cacheRefreshExecutor,</div><div class="line">                       registryFetchIntervalSeconds,</div><div class="line">                       TimeUnit.SECONDS,</div><div class="line">                       expBackOffBound,</div><div class="line">                       <span class="keyword">new</span> CacheRefreshThread()</div><div class="line">               ),</div><div class="line">               registryFetchIntervalSeconds, TimeUnit.SECONDS);</div><div class="line">     &#125;</div><div class="line">     <span class="comment">// ... 省略无关代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>初始化定时任务代码，和<strong>续租</strong>的定时任务代码类似，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-renew/?self">《Eureka 源码解析 —— 应用实例注册发现（二）之续租<br>》</a> 有详细解析，这里不重复分享。</li><li><p><code>com.netflix.discovery.DiscoveryClient.CacheRefreshThread</code>，注册信息缓存刷新任务，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CacheRefreshThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        refreshRegistry();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>#refreshRegistry(false)</code> 方法，刷新注册信息缓存，在 <a href="#">「2.3 刷新注册信息缓存」</a> 详细解析。</li></ul></li></ul><h2 id="2-3-刷新注册信息缓存"><a href="#2-3-刷新注册信息缓存" class="headerlink" title="2.3 刷新注册信息缓存"></a>2.3 刷新注册信息缓存</h2><p>调用 <code>#refreshRegistry(false)</code> 方法，刷新注册信息缓存，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DiscoveryClient.java</span></div><div class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">void</span> <span class="title">refreshRegistry</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="number">2</span>:     <span class="keyword">try</span> &#123;</div><div class="line">  <span class="number">3</span>:         <span class="comment">// TODO 芋艿：TODO[0009]：RemoteRegionRegistry</span></div><div class="line">  <span class="number">4</span>:         <span class="keyword">boolean</span> isFetchingRemoteRegionRegistries = isFetchingRemoteRegionRegistries();</div><div class="line">  <span class="number">5</span>: </div><div class="line">  <span class="number">6</span>:         <span class="keyword">boolean</span> remoteRegionsModified = <span class="keyword">false</span>;</div><div class="line">  <span class="number">7</span>:         <span class="comment">// This makes sure that a dynamic change to remote regions to fetch is honored.</span></div><div class="line">  <span class="number">8</span>:         String latestRemoteRegions = clientConfig.fetchRegistryForRemoteRegions();</div><div class="line">  <span class="number">9</span>:         <span class="keyword">if</span> (<span class="keyword">null</span> != latestRemoteRegions) &#123;</div><div class="line"> <span class="number">10</span>:             String currentRemoteRegions = remoteRegionsToFetch.get();</div><div class="line"> <span class="number">11</span>:             <span class="keyword">if</span> (!latestRemoteRegions.equals(currentRemoteRegions)) &#123;</div><div class="line"> <span class="number">12</span>:                 <span class="comment">// Both remoteRegionsToFetch and AzToRegionMapper.regionsToFetch need to be in sync</span></div><div class="line"> <span class="number">13</span>:                 <span class="keyword">synchronized</span> (instanceRegionChecker.getAzToRegionMapper()) &#123;</div><div class="line"> <span class="number">14</span>:                     <span class="keyword">if</span> (remoteRegionsToFetch.compareAndSet(currentRemoteRegions, latestRemoteRegions)) &#123;</div><div class="line"> <span class="number">15</span>:                         String[] remoteRegions = latestRemoteRegions.split(<span class="string">","</span>);</div><div class="line"> <span class="number">16</span>:                         remoteRegionsRef.set(remoteRegions);</div><div class="line"> <span class="number">17</span>:                         instanceRegionChecker.getAzToRegionMapper().setRegionsToFetch(remoteRegions);</div><div class="line"> <span class="number">18</span>:                         remoteRegionsModified = <span class="keyword">true</span>;</div><div class="line"> <span class="number">19</span>:                     &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">20</span>:                         logger.info(<span class="string">"Remote regions to fetch modified concurrently,"</span> +</div><div class="line"> <span class="number">21</span>:                                 <span class="string">" ignoring change from &#123;&#125; to &#123;&#125;"</span>, currentRemoteRegions, latestRemoteRegions);</div><div class="line"> <span class="number">22</span>:                     &#125;</div><div class="line"> <span class="number">23</span>:                 &#125;</div><div class="line"> <span class="number">24</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">25</span>:                 <span class="comment">// Just refresh mapping to reflect any DNS/Property change</span></div><div class="line"> <span class="number">26</span>:                 instanceRegionChecker.getAzToRegionMapper().refreshMapping();</div><div class="line"> <span class="number">27</span>:             &#125;</div><div class="line"> <span class="number">28</span>:         &#125;</div><div class="line"> <span class="number">29</span>: </div><div class="line"> <span class="number">30</span>:         <span class="keyword">boolean</span> success = fetchRegistry(remoteRegionsModified);</div><div class="line"> <span class="number">31</span>:         <span class="keyword">if</span> (success) &#123;</div><div class="line"> <span class="number">32</span>:             <span class="comment">// 设置 注册信息的应用实例数</span></div><div class="line"> <span class="number">33</span>:             registrySize = localRegionApps.get().size();</div><div class="line"> <span class="number">34</span>:             <span class="comment">// 设置 最后获取注册信息时间</span></div><div class="line"> <span class="number">35</span>:             lastSuccessfulRegistryFetchTimestamp = System.currentTimeMillis();</div><div class="line"> <span class="number">36</span>:         &#125;</div><div class="line"> <span class="number">37</span>: </div><div class="line"> <span class="number">38</span>:         <span class="comment">// 打印日志</span></div><div class="line"> <span class="number">39</span>:         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line"> <span class="number">40</span>:             StringBuilder allAppsHashCodes = <span class="keyword">new</span> StringBuilder();</div><div class="line"> <span class="number">41</span>:             allAppsHashCodes.append(<span class="string">"Local region apps hashcode: "</span>);</div><div class="line"> <span class="number">42</span>:             allAppsHashCodes.append(localRegionApps.get().getAppsHashCode());</div><div class="line"> <span class="number">43</span>:             allAppsHashCodes.append(<span class="string">", is fetching remote regions? "</span>);</div><div class="line"> <span class="number">44</span>:             allAppsHashCodes.append(isFetchingRemoteRegionRegistries);</div><div class="line"> <span class="number">45</span>:             <span class="keyword">for</span> (Map.Entry&lt;String, Applications&gt; entry : remoteRegionVsApps.entrySet()) &#123;</div><div class="line"> <span class="number">46</span>:                 allAppsHashCodes.append(<span class="string">", Remote region: "</span>);</div><div class="line"> <span class="number">47</span>:                 allAppsHashCodes.append(entry.getKey());</div><div class="line"> <span class="number">48</span>:                 allAppsHashCodes.append(<span class="string">" , apps hashcode: "</span>);</div><div class="line"> <span class="number">49</span>:                 allAppsHashCodes.append(entry.getValue().getAppsHashCode());</div><div class="line"> <span class="number">50</span>:             &#125;</div><div class="line"> <span class="number">51</span>:             logger.debug(<span class="string">"Completed cache refresh task for discovery. All Apps hash code is &#123;&#125; "</span>,</div><div class="line"> <span class="number">52</span>:                     allAppsHashCodes.toString());</div><div class="line"> <span class="number">53</span>:         &#125;</div><div class="line"> <span class="number">54</span>:     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"> <span class="number">55</span>:         logger.error(<span class="string">"Cannot fetch registry from server"</span>, e);</div><div class="line"> <span class="number">56</span>:     &#125;        </div><div class="line"> <span class="number">57</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 3 至 28 行 ：TODO[0009]：RemoteRegionRegistry</li><li>第 30 行 ：调用 <code>#fetchRegistry(false)</code> 方法，从 Eureka-Server 获取注册信息，在 <a href="#">「2.4 发起获取注册信息」</a> 详细解析。</li><li><p>第 31 至 36 行 ：获取注册信息成功，设置注册信息的应用实例数，最后获取注册信息时间。变量代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 注册信息的应用实例数</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> registrySize = <span class="number">0</span>;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 最后成功从 Eureka-Server 拉取注册信息时间戳</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastSuccessfulRegistryFetchTimestamp = -<span class="number">1</span>;</div></pre></td></tr></table></figure></li><li><p>第 38 至 53 行 ：打印调试日志。</p></li><li>第 54 至 56 行 ：打印<strong>异常</strong>日志。</li></ul><h2 id="2-4-发起获取注册信息"><a href="#2-4-发起获取注册信息" class="headerlink" title="2.4 发起获取注册信息"></a>2.4 发起获取注册信息</h2><p>调用 <code>#fetchRegistry(false)</code> 方法，从 Eureka-Server 获取注册信息( 根据条件判断，可能是<strong>全量</strong>，也可能是<strong>增量</strong> )，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">fetchRegistry</span><span class="params">(<span class="keyword">boolean</span> forceFullRegistryFetch)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     Stopwatch tracer = FETCH_REGISTRY_TIMER.start();</div><div class="line"> <span class="number">3</span>: </div><div class="line"> <span class="number">4</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">5</span>:         <span class="comment">// 获取 本地缓存的注册的应用实例集合</span></div><div class="line"> <span class="number">6</span>:         <span class="comment">// If the delta is disabled or if it is the first time, get all</span></div><div class="line"> <span class="number">7</span>:         <span class="comment">// applications</span></div><div class="line"> <span class="number">8</span>:         Applications applications = getApplications();</div><div class="line"> <span class="number">9</span>: </div><div class="line"><span class="number">10</span>:         <span class="comment">// 全量获取</span></div><div class="line"><span class="number">11</span>:         <span class="keyword">if</span> (clientConfig.shouldDisableDelta() <span class="comment">// 禁用增量获取</span></div><div class="line"><span class="number">12</span>:                 || (!Strings.isNullOrEmpty(clientConfig.getRegistryRefreshSingleVipAddress()))</div><div class="line"><span class="number">13</span>:                 || forceFullRegistryFetch</div><div class="line"><span class="number">14</span>:                 || (applications == <span class="keyword">null</span>) <span class="comment">// 空</span></div><div class="line"><span class="number">15</span>:                 || (applications.getRegisteredApplications().size() == <span class="number">0</span>) <span class="comment">// 空</span></div><div class="line"><span class="number">16</span>:                 || (applications.getVersion() == -<span class="number">1</span>)) <span class="comment">//Client application does not have latest library supporting delta</span></div><div class="line"><span class="number">17</span>:         &#123;</div><div class="line"><span class="number">18</span>:             logger.info(<span class="string">"Disable delta property : &#123;&#125;"</span>, clientConfig.shouldDisableDelta());</div><div class="line"><span class="number">19</span>:             logger.info(<span class="string">"Single vip registry refresh property : &#123;&#125;"</span>, clientConfig.getRegistryRefreshSingleVipAddress());</div><div class="line"><span class="number">20</span>:             logger.info(<span class="string">"Force full registry fetch : &#123;&#125;"</span>, forceFullRegistryFetch);</div><div class="line"><span class="number">21</span>:             logger.info(<span class="string">"Application is null : &#123;&#125;"</span>, (applications == <span class="keyword">null</span>));</div><div class="line"><span class="number">22</span>:             logger.info(<span class="string">"Registered Applications size is zero : &#123;&#125;"</span>,</div><div class="line"><span class="number">23</span>:                     (applications.getRegisteredApplications().size() == <span class="number">0</span>));</div><div class="line"><span class="number">24</span>:             logger.info(<span class="string">"Application version is -1: &#123;&#125;"</span>, (applications.getVersion() == -<span class="number">1</span>));</div><div class="line"><span class="number">25</span>:             <span class="comment">// 执行 全量获取</span></div><div class="line"><span class="number">26</span>:             getAndStoreFullRegistry();</div><div class="line"><span class="number">27</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">28</span>:             <span class="comment">// 执行 增量获取</span></div><div class="line"><span class="number">29</span>:             getAndUpdateDelta(applications);</div><div class="line"><span class="number">30</span>:         &#125;</div><div class="line"><span class="number">31</span>:         <span class="comment">// 设置 应用集合 hashcode</span></div><div class="line"><span class="number">32</span>:         applications.setAppsHashCode(applications.getReconcileHashCode());</div><div class="line"><span class="number">33</span>:         <span class="comment">// 打印 本地缓存的注册的应用实例数量</span></div><div class="line"><span class="number">34</span>:         logTotalInstances();</div><div class="line"><span class="number">35</span>:     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"><span class="number">36</span>:         logger.error(PREFIX + appPathIdentifier + <span class="string">" - was unable to refresh its cache! status = "</span> + e.getMessage(), e);</div><div class="line"><span class="number">37</span>:         <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"><span class="number">38</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">39</span>:         <span class="keyword">if</span> (tracer != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">40</span>:             tracer.stop();</div><div class="line"><span class="number">41</span>:         &#125;</div><div class="line"><span class="number">42</span>:     &#125;</div><div class="line"><span class="number">43</span>: </div><div class="line"><span class="number">44</span>:     <span class="comment">// Notify about cache refresh before updating the instance remote status</span></div><div class="line"><span class="number">45</span>:     onCacheRefreshed();</div><div class="line"><span class="number">46</span>: </div><div class="line"><span class="number">47</span>:     <span class="comment">// Update remote status based on refreshed data held in the cache</span></div><div class="line"><span class="number">48</span>:     updateInstanceRemoteStatus();</div><div class="line"><span class="number">49</span>: </div><div class="line"><span class="number">50</span>:     <span class="comment">// registry was fetched successfully, so return true</span></div><div class="line"><span class="number">51</span>:     <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"><span class="number">52</span>: &#125;</div></pre></td></tr></table></figure><ul><li><p>第 5 至 8 行 ：获取本地缓存的注册的应用实例集合，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Applications <span class="title">getApplications</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> localRegionApps.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>第 10 至 26 行 ：<strong>全量</strong>获取注册信息。</p><ul><li>第 11 行 ：配置 <code>eureka.disableDelta = true</code> ，禁用<strong>增量</strong>获取注册信息。默认值：<code>false</code> 。</li><li>第 12 行 ：只获得一个 <code>vipAddress</code> 对应的应用实例们的注册信息。</li><li>第 13 行 ：方法参数 <code>forceFullRegistryFetch</code> 强制<strong>全量</strong>获取注册信息。</li><li>第 14 至 15 行 ：本地缓存为空。</li><li>第 25 至 26 行 ：调用 <code>#getAndStoreFullRegistry()</code> 方法，<strong>全量</strong>获取注册信息，并设置到本地缓存。下文详细解析。</li></ul></li><li>第 27 至 30 行 ：<strong>增量</strong>获取注册信息，并刷新本地缓存，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">《Eureka 源码解析 —— 应用实例注册发现 （七）之增量获取》</a> 详细解析。</li><li>第 31 至 32 行 ：计算应用集合 <code>hashcode</code> 。该变量用于校验<strong>增量</strong>获取的注册信息和 Eureka-Server <strong>全量</strong>的注册信息是否一致( 完整 )，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">《Eureka 源码解析 —— 应用实例注册发现 （七）之增量获取》</a> 详细解析。</li><li><p>第 33 至 34 行 ：打印调试日志，输出本地缓存的注册的应用实例数量。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">logTotalInstances</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">       <span class="keyword">int</span> totInstances = <span class="number">0</span>;</div><div class="line">       <span class="keyword">for</span> (Application application : getApplications().getRegisteredApplications()) &#123;</div><div class="line">           totInstances += application.getInstancesAsIsFromEureka().size();</div><div class="line">       &#125;</div><div class="line">       logger.debug(<span class="string">"The total number of all instances in the client now is &#123;&#125;"</span>, totInstances);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>第 44 至 45 行 ：触发 CacheRefreshedEvent 事件，事件监听器执行。目前 Eureka 未提供默认的该事件监听器。</p><ul><li><p><code>#onCacheRefreshed()</code> 方法，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Eureka 事件监听器</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArraySet&lt;EurekaEventListener&gt; eventListeners = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCacheRefreshed</span><span class="params">()</span> </span>&#123;</div><div class="line">    fireEvent(<span class="keyword">new</span> CacheRefreshedEvent());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">fireEvent</span><span class="params">(<span class="keyword">final</span> EurekaEvent event)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (EurekaEventListener listener : eventListeners) &#123;</div><div class="line">        listener.onEvent(event);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul></li><li><p><strong>笔者的YY</strong> ：你可以实现自定义的事件监听器监听 CacheRefreshedEvent 事件，以达到<strong>持久化</strong>最新的注册信息到存储器( 例如，本地文件 )，通过这样的方式，配合实现 BackupRegistry 接口读取存储器。BackupRegistry 接口调用如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 【3.2.12】从 Eureka-Server 拉取注册信息</span></div><div class="line"><span class="keyword">if</span> (clientConfig.shouldFetchRegistry() &amp;&amp; !fetchRegistry(<span class="keyword">false</span>)) &#123;</div><div class="line">    fetchRegistryFromBackup();</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul></li><li><p>第47 至 48 行 ：更新<strong>本地缓存</strong>的当前应用实例在 Eureka-Server 的状态。</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">private</span> <span class="keyword">volatile</span> InstanceInfo.InstanceStatus lastRemoteInstanceStatus = InstanceInfo.InstanceStatus.UNKNOWN; </div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">updateInstanceRemoteStatus</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">4</span>:     <span class="comment">// Determine this instance's status for this app and set to UNKNOWN if not found</span></div><div class="line"> <span class="number">5</span>:     InstanceInfo.InstanceStatus currentRemoteInstanceStatus = <span class="keyword">null</span>;</div><div class="line"> <span class="number">6</span>:     <span class="keyword">if</span> (instanceInfo.getAppName() != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">7</span>:         Application app = getApplication(instanceInfo.getAppName());</div><div class="line"> <span class="number">8</span>:         <span class="keyword">if</span> (app != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">9</span>:             InstanceInfo remoteInstanceInfo = app.getByInstanceId(instanceInfo.getId());</div><div class="line"><span class="number">10</span>:             <span class="keyword">if</span> (remoteInstanceInfo != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">11</span>:                 currentRemoteInstanceStatus = remoteInstanceInfo.getStatus();</div><div class="line"><span class="number">12</span>:             &#125;</div><div class="line"><span class="number">13</span>:         &#125;</div><div class="line"><span class="number">14</span>:     &#125;</div><div class="line"><span class="number">15</span>:     <span class="keyword">if</span> (currentRemoteInstanceStatus == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">16</span>:         currentRemoteInstanceStatus = InstanceInfo.InstanceStatus.UNKNOWN;</div><div class="line"><span class="number">17</span>:     &#125;</div><div class="line"><span class="number">18</span>: </div><div class="line"><span class="number">19</span>:     <span class="comment">// Notify if status changed</span></div><div class="line"><span class="number">20</span>:     <span class="keyword">if</span> (lastRemoteInstanceStatus != currentRemoteInstanceStatus) &#123;</div><div class="line"><span class="number">21</span>:         onRemoteStatusChanged(lastRemoteInstanceStatus, currentRemoteInstanceStatus);</div><div class="line"><span class="number">22</span>:         lastRemoteInstanceStatus = currentRemoteInstanceStatus;</div><div class="line"><span class="number">23</span>:     &#125;</div><div class="line"><span class="number">24</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 4 至 14 行 ：从注册信息中获取当前应用在 Eureka-Server 的状态。</li><li><p>第 19 至 23 行 ：对比<strong>本地缓存</strong>和<strong>最新的</strong>的当前应用实例在 Eureka-Server 的状态，若不同，更新<strong>本地缓存</strong>( <strong>注意，只更新该缓存变量，不更新本地当前应用实例的状态( <code>instanceInfo.status</code> )</strong> )，触发 StatusChangeEvent 事件，事件监听器执行。目前 Eureka 未提供默认的该事件监听器。<code>#onRemoteStatusChanged(...)</code> 实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRemoteStatusChanged</span><span class="params">(InstanceInfo.InstanceStatus oldStatus, InstanceInfo.InstanceStatus newStatus)</span> </span>&#123;</div><div class="line">   fireEvent(<span class="keyword">new</span> StatusChangeEvent(oldStatus, newStatus));</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>Eureka-Client 本地应用实例与 Eureka-Server 的该应用实例状态不同的原因，因为应用实例的覆盖状态，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-override-status/?self">《Eureka 源码解析 —— 应用实例注册发现 （八）之覆盖状态》</a> 有详细解析。</li></ul></li></ul></li></ul><h3 id="2-4-1-全量获取注册信息，并设置到本地缓存"><a href="#2-4-1-全量获取注册信息，并设置到本地缓存" class="headerlink" title="2.4.1 全量获取注册信息，并设置到本地缓存"></a>2.4.1 全量获取注册信息，并设置到本地缓存</h3><p>调用 <code>#getAndStoreFullRegistry()</code> 方法，<strong>全量</strong>获取注册信息，并设置到本地缓存。下实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getAndStoreFullRegistry</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="keyword">long</span> currentUpdateGeneration = fetchRegistryGeneration.get();</div><div class="line"> <span class="number">3</span>: </div><div class="line"> <span class="number">4</span>:     logger.info(<span class="string">"Getting all instance registry info from the eureka server"</span>);</div><div class="line"> <span class="number">5</span>: </div><div class="line"> <span class="number">6</span>:     <span class="comment">// 全量获取注册信息</span></div><div class="line"> <span class="number">7</span>:     Applications apps = <span class="keyword">null</span>;</div><div class="line"> <span class="number">8</span>:     EurekaHttpResponse&lt;Applications&gt; httpResponse = clientConfig.getRegistryRefreshSingleVipAddress() == <span class="keyword">null</span></div><div class="line"> <span class="number">9</span>:             ? eurekaTransport.queryClient.getApplications(remoteRegionsRef.get())</div><div class="line"><span class="number">10</span>:             : eurekaTransport.queryClient.getVip(clientConfig.getRegistryRefreshSingleVipAddress(), remoteRegionsRef.get());</div><div class="line"><span class="number">11</span>:     <span class="keyword">if</span> (httpResponse.getStatusCode() == Status.OK.getStatusCode()) &#123;</div><div class="line"><span class="number">12</span>:         apps = httpResponse.getEntity();</div><div class="line"><span class="number">13</span>:     &#125;</div><div class="line"><span class="number">14</span>:     logger.info(<span class="string">"The response status is &#123;&#125;"</span>, httpResponse.getStatusCode());</div><div class="line"><span class="number">15</span>: </div><div class="line"><span class="number">16</span>:     <span class="comment">// 设置到本地缓存</span></div><div class="line"><span class="number">17</span>:     <span class="keyword">if</span> (apps == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">18</span>:         logger.error(<span class="string">"The application is null for some reason. Not storing this information"</span>);</div><div class="line"><span class="number">19</span>:     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fetchRegistryGeneration.compareAndSet(currentUpdateGeneration, currentUpdateGeneration + <span class="number">1</span>)) &#123;</div><div class="line"><span class="number">20</span>:         localRegionApps.set(<span class="keyword">this</span>.filterAndShuffle(apps));</div><div class="line"><span class="number">21</span>:         logger.debug(<span class="string">"Got full registry with apps hashcode &#123;&#125;"</span>, apps.getAppsHashCode());</div><div class="line"><span class="number">22</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">23</span>:         logger.warn(<span class="string">"Not updating applications as another thread is updating it already"</span>);</div><div class="line"><span class="number">24</span>:     &#125;</div><div class="line"><span class="number">25</span>: &#125;</div></pre></td></tr></table></figure><ul><li><p>第 6 至 14 行 ：<strong>全量</strong>获取注册信息，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractJerseyEurekaHttpClient.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> EurekaHttpResponse&lt;Applications&gt; <span class="title">getApplications</span><span class="params">(String... regions)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> getApplicationsInternal(<span class="string">"apps/"</span>, regions);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> EurekaHttpResponse&lt;Applications&gt; <span class="title">getApplicationsInternal</span><span class="params">(String urlPath, String[] regions)</span> </span>&#123;</div><div class="line">   ClientResponse response = <span class="keyword">null</span>;</div><div class="line">   String regionsParamValue = <span class="keyword">null</span>;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       WebResource webResource = jerseyClient.resource(serviceUrl).path(urlPath);</div><div class="line">       <span class="keyword">if</span> (regions != <span class="keyword">null</span> &amp;&amp; regions.length &gt; <span class="number">0</span>) &#123;</div><div class="line">           regionsParamValue = StringUtil.join(regions);</div><div class="line">           webResource = webResource.queryParam(<span class="string">"regions"</span>, regionsParamValue);</div><div class="line">       &#125;</div><div class="line">       Builder requestBuilder = webResource.getRequestBuilder();</div><div class="line">       addExtraHeaders(requestBuilder);</div><div class="line">       response = requestBuilder.accept(MediaType.APPLICATION_JSON_TYPE).get(ClientResponse.class); <span class="comment">// JSON</span></div><div class="line"></div><div class="line">       Applications applications = <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">if</span> (response.getStatus() == Status.OK.getStatusCode() &amp;&amp; response.hasEntity()) &#123;</div><div class="line">           applications = response.getEntity(Applications.class);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> anEurekaHttpResponse(response.getStatus(), Applications.class)</div><div class="line">               .headers(headersOf(response))</div><div class="line">               .entity(applications)</div><div class="line">               .build();</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">           logger.debug(<span class="string">"Jersey HTTP GET &#123;&#125;/&#123;&#125;?&#123;&#125;; statusCode=&#123;&#125;"</span>,</div><div class="line">                   serviceUrl, urlPath,</div><div class="line">                   regionsParamValue == <span class="keyword">null</span> ? <span class="string">""</span> : <span class="string">"regions="</span> + regionsParamValue,</div><div class="line">                   response == <span class="keyword">null</span> ? <span class="string">"N/A"</span> : response.getStatus()</div><div class="line">           );</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</div><div class="line">           response.close();</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>AbstractJerseyEurekaHttpClient#getApplications(...)</code> 方法，GET 请求 Eureka-Server 的 <code>apps/</code> 接口，参数为 <code>regions</code> ，返回格式为 JSON ，实现<strong>全量获取注册信息</strong>。</li></ul></li><li><p>第 16 至 24 行 ：设置到本地注册信息<strong>缓存</strong>。</p><ul><li>第 19 行 ：TODO[0025] ：并发更新的情况？？？</li><li>第 20 行 ：调用 <code>#filterAndShuffle(...)</code> 方法，根据配置 <code>eureka.shouldFilterOnlyUpInstances = true</code> ( 默认值 ：<code>true</code> ) 过滤只保留状态为开启( UP )的应用实例，并<strong>随机打乱</strong>应用实例顺序。打乱后，实现调用应用服务的随机性。代码比较易懂，点击<a href="https://github.com/YunaiV/eureka/blob/512697015ef081233c5cb7c472250bca6b779ab4/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java#L1603" rel="external nofollow noopener noreferrer" target="_blank">链接</a>查看方法实现。</li></ul></li></ul><h1 id="3-Eureka-Server-接收全量获取"><a href="#3-Eureka-Server-接收全量获取" class="headerlink" title="3. Eureka-Server 接收全量获取"></a>3. Eureka-Server 接收全量获取</h1><h2 id="3-1-接收全量获取请求"><a href="#3-1-接收全量获取请求" class="headerlink" title="3.1 接收全量获取请求"></a>3.1 接收全量获取请求</h2><p><code>com.netflix.eureka.resources.ApplicationsResource</code>，处理<strong>所有</strong>应用的请求操作的 Resource ( Controller )。</p><p>接收全量获取请求，映射 <code>ApplicationsResource#getContainers()</code> 方法，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@GET</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> Response <span class="title">getContainers</span><span class="params">(@PathParam(<span class="string">"version"</span>)</span> String version,</span></div><div class="line"><span class="function"> 3:                               @<span class="title">HeaderParam</span><span class="params">(HEADER_ACCEPT)</span> String acceptHeader,</span></div><div class="line"><span class="function"> 4:                               @<span class="title">HeaderParam</span><span class="params">(HEADER_ACCEPT_ENCODING)</span> String acceptEncoding,</span></div><div class="line"><span class="function"> 5:                               @<span class="title">HeaderParam</span><span class="params">(EurekaAccept.HTTP_X_EUREKA_ACCEPT)</span> String eurekaAccept,</span></div><div class="line"><span class="function"> 6:                               @Context UriInfo uriInfo,</span></div><div class="line"><span class="function"> 7:                               @Nullable @<span class="title">QueryParam</span><span class="params">(<span class="string">"regions"</span>)</span> String regionsStr) </span>&#123;</div><div class="line"> <span class="number">8</span>:     <span class="comment">// TODO[0009]：RemoteRegionRegistry</span></div><div class="line"> <span class="number">9</span>:     <span class="keyword">boolean</span> isRemoteRegionRequested = <span class="keyword">null</span> != regionsStr &amp;&amp; !regionsStr.isEmpty();</div><div class="line"><span class="number">10</span>:     String[] regions = <span class="keyword">null</span>;</div><div class="line"><span class="number">11</span>:     <span class="keyword">if</span> (!isRemoteRegionRequested) &#123;</div><div class="line"><span class="number">12</span>:         EurekaMonitors.GET_ALL.increment();</div><div class="line"><span class="number">13</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">14</span>:         regions = regionsStr.toLowerCase().split(<span class="string">","</span>);</div><div class="line"><span class="number">15</span>:         Arrays.sort(regions); <span class="comment">// So we don't have different caches for same regions queried in different order.</span></div><div class="line"><span class="number">16</span>:         EurekaMonitors.GET_ALL_WITH_REMOTE_REGIONS.increment();</div><div class="line"><span class="number">17</span>:     &#125;</div><div class="line"><span class="number">18</span>: </div><div class="line"><span class="number">19</span>:     <span class="comment">// 判断是否可以访问</span></div><div class="line"><span class="number">20</span>:     <span class="comment">// Check if the server allows the access to the registry. The server can</span></div><div class="line"><span class="number">21</span>:     <span class="comment">// restrict access if it is not</span></div><div class="line"><span class="number">22</span>:     <span class="comment">// ready to serve traffic depending on various reasons.</span></div><div class="line"><span class="number">23</span>:     <span class="keyword">if</span> (!registry.shouldAllowAccess(isRemoteRegionRequested)) &#123;</div><div class="line"><span class="number">24</span>:         <span class="keyword">return</span> Response.status(Status.FORBIDDEN).build();</div><div class="line"><span class="number">25</span>:     &#125;</div><div class="line"><span class="number">26</span>: </div><div class="line"><span class="number">27</span>:     <span class="comment">// API 版本</span></div><div class="line"><span class="number">28</span>:     CurrentRequestVersion.set(Version.toEnum(version));</div><div class="line"><span class="number">29</span>: </div><div class="line"><span class="number">30</span>:     <span class="comment">// 返回数据格式</span></div><div class="line"><span class="number">31</span>:     KeyType keyType = Key.KeyType.JSON;</div><div class="line"><span class="number">32</span>:     String returnMediaType = MediaType.APPLICATION_JSON;</div><div class="line"><span class="number">33</span>:     <span class="keyword">if</span> (acceptHeader == <span class="keyword">null</span> || !acceptHeader.contains(HEADER_JSON_VALUE)) &#123;</div><div class="line"><span class="number">34</span>:         keyType = Key.KeyType.XML;</div><div class="line"><span class="number">35</span>:         returnMediaType = MediaType.APPLICATION_XML;</div><div class="line"><span class="number">36</span>:     &#125;</div><div class="line"><span class="number">37</span>: </div><div class="line"><span class="number">38</span>:     <span class="comment">// 响应缓存键( KEY )</span></div><div class="line"><span class="number">39</span>:     Key cacheKey = <span class="keyword">new</span> Key(Key.EntityType.Application,</div><div class="line"><span class="number">40</span>:             ResponseCacheImpl.ALL_APPS,</div><div class="line"><span class="number">41</span>:             keyType, CurrentRequestVersion.get(), EurekaAccept.fromString(eurekaAccept), regions</div><div class="line"><span class="number">42</span>:     );</div><div class="line"><span class="number">43</span>: </div><div class="line"><span class="number">44</span>:     <span class="comment">//</span></div><div class="line"><span class="number">45</span>:     Response response;</div><div class="line"><span class="number">46</span>:     <span class="keyword">if</span> (acceptEncoding != <span class="keyword">null</span> &amp;&amp; acceptEncoding.contains(HEADER_GZIP_VALUE)) &#123;</div><div class="line"><span class="number">47</span>:         response = Response.ok(responseCache.getGZIP(cacheKey))</div><div class="line"><span class="number">48</span>:                 .header(HEADER_CONTENT_ENCODING, HEADER_GZIP_VALUE)</div><div class="line"><span class="number">49</span>:                 .header(HEADER_CONTENT_TYPE, returnMediaType)</div><div class="line"><span class="number">50</span>:                 .build();</div><div class="line"><span class="number">51</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">52</span>:         response = Response.ok(responseCache.get(cacheKey))</div><div class="line"><span class="number">53</span>:                 .build();</div><div class="line"><span class="number">54</span>:     &#125;</div><div class="line"><span class="number">55</span>:     <span class="keyword">return</span> response;</div><div class="line"><span class="number">56</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 8 至 17 行 ：TODO[0009]：RemoteRegionRegistry</li><li>第 19 至 25 行 ：Eureka-Server 启动完成，但是未处于就绪( Ready )状态，不接受请求全量应用注册信息的请求，例如，Eureka-Server 启动时，未能从其他 Eureka-Server 集群的节点获取到应用注册信息。</li><li><p>第 27 至 28 行 ：设置 API 版本号。<strong>默认</strong>最新 API 版本为 V2。实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Version &#123;</div><div class="line">    V1, V2;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Version <span class="title">toEnum</span><span class="params">(String v)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Version version : Version.values()) &#123;</div><div class="line">            <span class="keyword">if</span> (version.name().equalsIgnoreCase(v)) &#123;</div><div class="line">                <span class="keyword">return</span> version;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//Defaults to v2</span></div><div class="line">        <span class="keyword">return</span> V2;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>第 30 至 36 行 ：设置返回数据格式，默认 JSON 。</p></li><li>第 38 至 42 行 ：创建响应缓存( ResponseCache ) 的键( KEY )，在 <a href="#">「3.2.1 缓存键」</a>详细解析。 </li><li>第 44 至 55 行 ：从响应缓存读取<strong>全量</strong>注册信息，在 <a href="#">「3.3 缓存读取」</a>详细解析。 </li></ul><h2 id="3-2-响应缓存-ResponseCache"><a href="#3-2-响应缓存-ResponseCache" class="headerlink" title="3.2 响应缓存 ResponseCache"></a>3.2 响应缓存 ResponseCache</h2><p><code>com.netflix.eureka.registry.ResponseCache</code>，响应缓存<strong>接口</strong>，接口代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResponseCache</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function">String <span class="title">get</span><span class="params">(Key key)</span></span>;</div><div class="line">    </div><div class="line">    <span class="keyword">byte</span>[] getGZIP(Key key);</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invalidate</span><span class="params">(String appName, @Nullable String vipAddress, @Nullable String secureVipAddress)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">AtomicLong <span class="title">getVersionDelta</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    <span class="function">AtomicLong <span class="title">getVersionDeltaWithRegions</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>其中，<code>#getVersionDelta()</code> 和 <code>#getVersionDeltaWithRegions()</code> 已经废弃。这里保留的原因主要是考虑兼容性。判断依据来自如下代码：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Applications.java</span></div><div class="line"><span class="meta">@Deprecated</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVersion</span><span class="params">(Long version)</span> </span>&#123;</div><div class="line">   <span class="keyword">this</span>.versionDelta = version;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> Applications <span class="title">getApplicationDeltas</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// ... 省略其它无关代码</span></div><div class="line">    apps.setVersion(responseCache.getVersionDelta().get()); <span class="comment">// 唯一调用到 ResponseCache#getVersionDelta() 方法的地方</span></div><div class="line">    <span class="comment">// ... 省略其它无关代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p><code>#get()</code> ：获得缓存。</p></li><li><code>#getGZIP()</code> ：获得缓存，并 GZIP 。</li><li><code>#invalidate()</code> ：过期缓存。</li></ul><h3 id="3-2-1-缓存键"><a href="#3-2-1-缓存键" class="headerlink" title="3.2.1 缓存键"></a>3.2.1 缓存键</h3><p><code>com.netflix.eureka.registry.Key</code>，缓存键。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Key</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> KeyType &#123;</div><div class="line">        JSON, XML</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * An enum to define the entity that is stored in this cache for this key.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> EntityType &#123;</div><div class="line">        Application, VIP, SVIP</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 实体名</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String entityName;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * TODO[0009]：RemoteRegionRegistry</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] regions;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 请求参数类型</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> KeyType requestType;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 请求 API 版本号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Version requestVersion;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * hashKey</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String hashKey;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 实体类型</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> EntityType&#125;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EntityType entityType;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> EurekaAccept&#125;</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EurekaAccept eurekaAccept;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Key</span><span class="params">(EntityType entityType, String entityName, KeyType type, Version v, EurekaAccept eurekaAccept, @Nullable String[] regions)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.regions = regions;</div><div class="line">        <span class="keyword">this</span>.entityType = entityType;</div><div class="line">        <span class="keyword">this</span>.entityName = entityName;</div><div class="line">        <span class="keyword">this</span>.requestType = type;</div><div class="line">        <span class="keyword">this</span>.requestVersion = v;</div><div class="line">        <span class="keyword">this</span>.eurekaAccept = eurekaAccept;</div><div class="line">        hashKey = <span class="keyword">this</span>.entityType + <span class="keyword">this</span>.entityName + (<span class="keyword">null</span> != <span class="keyword">this</span>.regions ? Arrays.toString(<span class="keyword">this</span>.regions) : <span class="string">""</span>)</div><div class="line">                + requestType.name() + requestVersion.name() + <span class="keyword">this</span>.eurekaAccept.name();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Key</span><span class="params">(EntityType entityType, String entityName, KeyType type, Version v, EurekaAccept eurekaAccept, @Nullable String[] regions)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.regions = regions;</div><div class="line">        <span class="keyword">this</span>.entityType = entityType;</div><div class="line">        <span class="keyword">this</span>.entityName = entityName;</div><div class="line">        <span class="keyword">this</span>.requestType = type;</div><div class="line">        <span class="keyword">this</span>.requestVersion = v;</div><div class="line">        <span class="keyword">this</span>.eurekaAccept = eurekaAccept;</div><div class="line">        hashKey = <span class="keyword">this</span>.entityType + <span class="keyword">this</span>.entityName + (<span class="keyword">null</span> != <span class="keyword">this</span>.regions ? Arrays.toString(<span class="keyword">this</span>.regions) : <span class="string">""</span>)</div><div class="line">                + requestType.name() + requestVersion.name() + <span class="keyword">this</span>.eurekaAccept.name();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        String hashKey = getHashKey();</div><div class="line">        <span class="keyword">return</span> hashKey.hashCode();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (other <span class="keyword">instanceof</span> Key) &#123;</div><div class="line">            <span class="keyword">return</span> getHashKey().equals(((Key) other).getHashKey());</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-2-2-响应缓存实现类"><a href="#3-2-2-响应缓存实现类" class="headerlink" title="3.2.2 响应缓存实现类"></a>3.2.2 响应缓存实现类</h3><p><code>com.netflix.eureka.registry.ResponseCacheImpl</code>，响应缓存实现类。</p><p>在 ResponseCacheImpl 里，将缓存拆分成两层 ：</p><ul><li><strong>只读缓存</strong>( <code>readOnlyCacheMap</code> )</li><li><strong>固定过期</strong> + <strong>固定大小</strong>的<strong>读写缓存</strong>( <code>readWriteCacheMap</code> )</li></ul><p>默认配置下，<strong>缓存读取策略</strong>如下：</p><p><img src="http://www.iocoder.cn/images/Eureka/2018_06_29/04.png" alt=""></p><p><strong>缓存过期策略</strong>如下：</p><ul><li>应用实例注册、下线、过期时，<strong>只只只</strong>过期 <code>readWriteCacheMap</code> 。</li><li><code>readWriteCacheMap</code> 写入一段时间( 可配置 )后自动过期。</li><li><strong>定时</strong>任务对比 <code>readWriteCacheMap</code> 和 <code>readOnlyCacheMap</code> 的缓存值，若不一致，以前者为主。通过这样的方式，实现了 <code>readOnlyCacheMap</code> 的定时过期。</li></ul><p><strong>注意</strong>：应用实例注册、下线、过期时，不会很快刷新到 <code>readWriteCacheMap</code> 缓存里。默认配置下，最大延迟在 30 秒。</p><p><strong>为什么可以使用缓存？</strong></p><p>在 <a href="https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86" rel="external nofollow noopener noreferrer" target="_blank">CAP</a> 的选择上，Eureka 选择了 AP ，不同于 Zookeeper 选择了 CP 。</p><p>推荐阅读：</p><ul><li><a href="http://dockone.io/article/78" rel="external nofollow noopener noreferrer" target="_blank">《为什么不应该使用ZooKeeper做服务发现》</a></li><li><a href="http://blog.spring-cloud.io/blog/sc-eureka.html" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud Netflix Eureka源码导读与原理分析》「4. 作为服务注册中心，Eureka比Zookeeper好在哪里」</a></li></ul><h2 id="3-3-缓存读取"><a href="#3-3-缓存读取" class="headerlink" title="3.3 缓存读取"></a>3.3 缓存读取</h2><p>调用 <code>ResponseCacheImpl#get(...)</code> 方法( <code>#getGzip(...)</code> 类似 )，读取缓存，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Key, Value&gt; readOnlyCacheMap = <span class="keyword">new</span> ConcurrentHashMap&lt;Key, Value&gt;();</div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>: <span class="keyword">private</span> <span class="keyword">final</span> LoadingCache&lt;Key, Value&gt; readWriteCacheMap;</div><div class="line"> <span class="number">4</span>: </div><div class="line"> <span class="number">5</span>: <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">final</span> Key key)</span> </span>&#123;</div><div class="line"> <span class="number">6</span>:     <span class="keyword">return</span> get(key, shouldUseReadOnlyResponseCache);</div><div class="line"> <span class="number">7</span>: &#125;</div><div class="line"> <span class="number">8</span>: </div><div class="line"> <span class="number">9</span>: <span class="function">String <span class="title">get</span><span class="params">(<span class="keyword">final</span> Key key, <span class="keyword">boolean</span> useReadOnlyCache)</span> </span>&#123;</div><div class="line"><span class="number">10</span>:     Value payload = getValue(key, useReadOnlyCache);</div><div class="line"><span class="number">11</span>:     <span class="keyword">if</span> (payload == <span class="keyword">null</span> || payload.getPayload().equals(EMPTY_PAYLOAD)) &#123;</div><div class="line"><span class="number">12</span>:         <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"><span class="number">13</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">14</span>:         <span class="keyword">return</span> payload.getPayload();</div><div class="line"><span class="number">15</span>:     &#125;</div><div class="line"><span class="number">16</span>: &#125;</div><div class="line"><span class="number">17</span>: </div><div class="line"><span class="number">18</span>: <span class="function">Value <span class="title">getValue</span><span class="params">(<span class="keyword">final</span> Key key, <span class="keyword">boolean</span> useReadOnlyCache)</span> </span>&#123;</div><div class="line"><span class="number">19</span>:     Value payload = <span class="keyword">null</span>;</div><div class="line"><span class="number">20</span>:     <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">21</span>:         <span class="keyword">if</span> (useReadOnlyCache) &#123;</div><div class="line"><span class="number">22</span>:             <span class="keyword">final</span> Value currentPayload = readOnlyCacheMap.get(key);</div><div class="line"><span class="number">23</span>:             <span class="keyword">if</span> (currentPayload != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">24</span>:                 payload = currentPayload;</div><div class="line"><span class="number">25</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">26</span>:                 payload = readWriteCacheMap.get(key);</div><div class="line"><span class="number">27</span>:                 readOnlyCacheMap.put(key, payload);</div><div class="line"><span class="number">28</span>:             &#125;</div><div class="line"><span class="number">29</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">30</span>:             payload = readWriteCacheMap.get(key);</div><div class="line"><span class="number">31</span>:         &#125;</div><div class="line"><span class="number">32</span>:     &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line"><span class="number">33</span>:         logger.error(<span class="string">"Cannot get value for key :"</span> + key, t);</div><div class="line"><span class="number">34</span>:     &#125;</div><div class="line"><span class="number">35</span>:     <span class="keyword">return</span> payload;</div><div class="line"><span class="number">36</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 5 至 7 行 ：调用 <code>#get(key, useReadOnlyCache)</code> 方法，读取缓存。其中 <code>shouldUseReadOnlyResponseCache</code> 通过配置 <code>eureka.shouldUseReadOnlyResponseCache = true</code> (默认值 ：<code>true</code> ) 开启只读缓存。如果你对数据的一致性有相对高的要求，可以关闭这个开关，当然因为少了 <code>readOnlyCacheMap</code> ，性能会有一定的下降。</li><li><p>第 9 至 16 行 ：调用 <code>getValue(key, useReadOnlyCache)</code> 方法，读取缓存。从 <code>readOnlyCacheMap</code> 和 <code>readWriteCacheMap</code> 变量可以看到缓存值的类为 <code>com.netflix.eureka.registry.ResponseCacheImpl.Value</code> ，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Value</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 原始值</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String payload;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * GZIP 压缩后的值</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">byte</span>[] gzipped;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Value</span><span class="params">(String payload)</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>.payload = payload;</div><div class="line">       <span class="keyword">if</span> (!EMPTY_PAYLOAD.equals(payload)) &#123;</div><div class="line">           <span class="comment">// ... 省略 GZIP 压缩代码</span></div><div class="line">           gzipped = bos.toByteArray();</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           gzipped = <span class="keyword">null</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getPayload</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> payload;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">byte</span>[] getGzipped() &#123;</div><div class="line">       <span class="keyword">return</span> gzipped;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>第 21 至 31 行 ：读取缓存。</p><ul><li>第 21 至 28 行 ：先读取 <code>readOnlyCacheMap</code> 。读取不到，读取 <code>readWriteCacheMap</code> ，并设置到 <code>readOnlyCacheMap</code> 。</li><li>第 29 至 31 行 ：读取 <code>readWriteCacheMap</code> 。</li><li><p><code>readWriteCacheMap</code> 实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">this</span>.readWriteCacheMap =</div><div class="line">      CacheBuilder.newBuilder().initialCapacity(<span class="number">1000</span>)</div><div class="line">              .expireAfterWrite(serverConfig.getResponseCacheAutoExpirationInSeconds(), TimeUnit.SECONDS)</div><div class="line">              .removalListener(<span class="keyword">new</span> RemovalListener&lt;Key, Value&gt;() &#123;</div><div class="line">                  <span class="meta">@Override</span></div><div class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRemoval</span><span class="params">(RemovalNotification&lt;Key, Value&gt; notification)</span> </span>&#123;</div><div class="line">                      <span class="comment">// TODO[0009]：RemoteRegionRegistry</span></div><div class="line">                      Key removedKey = notification.getKey();</div><div class="line">                      <span class="keyword">if</span> (removedKey.hasRegions()) &#123;</div><div class="line">                          Key cloneWithNoRegions = removedKey.cloneWithoutRegions();</div><div class="line">                          regionSpecificKeys.remove(cloneWithNoRegions, removedKey);</div><div class="line">                      &#125;</div><div class="line">                  &#125;</div><div class="line">              &#125;)</div><div class="line">              .build(<span class="keyword">new</span> CacheLoader&lt;Key, Value&gt;() &#123;</div><div class="line">                  <span class="meta">@Override</span></div><div class="line">                  <span class="function"><span class="keyword">public</span> Value <span class="title">load</span><span class="params">(Key key)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                      <span class="comment">// // TODO[0009]：RemoteRegionRegistry</span></div><div class="line">                      <span class="keyword">if</span> (key.hasRegions()) &#123;</div><div class="line">                          Key cloneWithNoRegions = key.cloneWithoutRegions();</div><div class="line">                          regionSpecificKeys.put(cloneWithNoRegions, key);</div><div class="line">                      &#125;</div><div class="line">                      Value value = generatePayload(key);</div><div class="line">                      <span class="keyword">return</span> value;</div><div class="line">                  &#125;</div><div class="line">              &#125;);</div></pre></td></tr></table></figure><ul><li><code>readWriteCacheMap</code> 最大缓存数量为 1000 。</li><li>调用 <code>#generatePayload(key)</code> 方法，生成缓存值。</li></ul></li></ul></li><li><p><code>#generatePayload(key)</code> 方法，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">private</span> Value <span class="title">generatePayload</span><span class="params">(Key key)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     Stopwatch tracer = <span class="keyword">null</span>;</div><div class="line"> <span class="number">3</span>:     <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">4</span>:         String payload;</div><div class="line"> <span class="number">5</span>:         <span class="keyword">switch</span> (key.getEntityType()) &#123;</div><div class="line"> <span class="number">6</span>:             <span class="keyword">case</span> Application:</div><div class="line"> <span class="number">7</span>:                 <span class="keyword">boolean</span> isRemoteRegionRequested = key.hasRegions();</div><div class="line"> <span class="number">8</span>: </div><div class="line"> <span class="number">9</span>:                 <span class="keyword">if</span> (ALL_APPS.equals(key.getName())) &#123;</div><div class="line"><span class="number">10</span>:                     <span class="keyword">if</span> (isRemoteRegionRequested) &#123; <span class="comment">// TODO[0009]：RemoteRegionRegistry</span></div><div class="line"><span class="number">11</span>:                         tracer = serializeAllAppsWithRemoteRegionTimer.start();</div><div class="line"><span class="number">12</span>:                         payload = getPayLoad(key, registry.getApplicationsFromMultipleRegions(key.getRegions()));</div><div class="line"><span class="number">13</span>:                     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">14</span>:                         tracer = serializeAllAppsTimer.start();</div><div class="line"><span class="number">15</span>:                         payload = getPayLoad(key, registry.getApplications());</div><div class="line"><span class="number">16</span>:                     &#125;</div><div class="line"><span class="number">17</span>:                 &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ALL_APPS_DELTA.equals(key.getName())) &#123;</div><div class="line"><span class="number">18</span>:                     <span class="comment">// ... 省略增量获取相关的代码</span></div><div class="line"><span class="number">19</span>:                  &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">20</span>:                     tracer = serializeOneApptimer.start();</div><div class="line"><span class="number">21</span>:                     payload = getPayLoad(key, registry.getApplication(key.getName()));</div><div class="line"><span class="number">22</span>:                 &#125;</div><div class="line"><span class="number">23</span>:                 <span class="keyword">break</span>;</div><div class="line"><span class="number">24</span>:             <span class="comment">// ... 省略部分代码 </span></div><div class="line"><span class="number">25</span>:         &#125;</div><div class="line"><span class="number">26</span>:         <span class="keyword">return</span> <span class="keyword">new</span> Value(payload);</div><div class="line"><span class="number">27</span>:     &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">28</span>:         <span class="keyword">if</span> (tracer != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">29</span>:             tracer.stop();</div><div class="line"><span class="number">30</span>:         &#125;</div><div class="line"><span class="number">31</span>:     &#125;</div><div class="line"><span class="number">32</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 10 至 12 行 ：TODO[0009]：RemoteRegionRegistry</li><li>第 13 至 16 行 ：调用 <code>AbstractInstanceRegistry#getApplications()</code> 方法，获得注册的应用集合。后调用 <code>#getPayLoad()</code> 方法，将注册的应用集合转换成缓存值。🙂 这两个方法代码较多，下面详细解析。</li><li>第 17 至 18 行 ：获取增量注册信息的缓存值，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">《Eureka 源码解析 —— 应用实例注册发现 （七）之增量获取》</a> 详细解析。</li></ul></li></ul><h3 id="3-3-1-获得注册的应用集合"><a href="#3-3-1-获得注册的应用集合" class="headerlink" title="3.3.1 获得注册的应用集合"></a>3.3.1 获得注册的应用集合</h3><p>调用 <code>AbstractInstanceRegistry#getApplications()</code> 方法，获得注册的应用集合，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>: <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] EMPTY_STR_ARRAY = <span class="keyword">new</span> String[<span class="number">0</span>];</div><div class="line"> <span class="number">4</span>: </div><div class="line"> <span class="number">5</span>: <span class="function"><span class="keyword">public</span> Applications <span class="title">getApplications</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">6</span>:    <span class="keyword">boolean</span> disableTransparentFallback = serverConfig.disableTransparentFallbackToOtherRegion();</div><div class="line"> <span class="number">7</span>:    <span class="keyword">if</span> (disableTransparentFallback) &#123; <span class="comment">// TODO[0009]：RemoteRegionRegistry</span></div><div class="line"> <span class="number">8</span>:        <span class="keyword">return</span> getApplicationsFromLocalRegionOnly();</div><div class="line"> <span class="number">9</span>:    &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">10</span>:        <span class="keyword">return</span> getApplicationsFromAllRemoteRegions();  <span class="comment">// Behavior of falling back to remote region can be disabled.</span></div><div class="line"><span class="number">11</span>:    &#125;</div><div class="line"><span class="number">12</span>: &#125;</div><div class="line"><span class="number">13</span>: </div><div class="line"><span class="number">14</span>: <span class="function"><span class="keyword">public</span> Applications <span class="title">getApplicationsFromLocalRegionOnly</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">15</span>:    <span class="keyword">return</span> getApplicationsFromMultipleRegions(EMPTY_STR_ARRAY);</div><div class="line"><span class="number">16</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 6 至 8 行 ：TODO[0009]：RemoteRegionRegistry</li><li><p>第 9 至 16 行 ：调用 <code>#getApplicationsFromMultipleRegions(...)</code> 方法，获得注册的应用集合，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> Applications <span class="title">getApplicationsFromMultipleRegions</span><span class="params">(String[] remoteRegions)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// TODO[0009]：RemoteRegionRegistry</span></div><div class="line"> <span class="number">3</span>:     <span class="keyword">boolean</span> includeRemoteRegion = <span class="keyword">null</span> != remoteRegions &amp;&amp; remoteRegions.length != <span class="number">0</span>;</div><div class="line"> <span class="number">4</span>:     logger.debug(<span class="string">"Fetching applications registry with remote regions: &#123;&#125;, Regions argument &#123;&#125;"</span>,</div><div class="line"> <span class="number">5</span>:             includeRemoteRegion, Arrays.toString(remoteRegions));</div><div class="line"> <span class="number">6</span>:     <span class="keyword">if</span> (includeRemoteRegion) &#123;</div><div class="line"> <span class="number">7</span>:         GET_ALL_WITH_REMOTE_REGIONS_CACHE_MISS.increment();</div><div class="line"> <span class="number">8</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">9</span>:         GET_ALL_CACHE_MISS.increment();</div><div class="line"><span class="number">10</span>:     &#125;</div><div class="line"><span class="number">11</span>:     <span class="comment">// 获得获得注册的应用集合</span></div><div class="line"><span class="number">12</span>:     Applications apps = <span class="keyword">new</span> Applications();</div><div class="line"><span class="number">13</span>:     apps.setVersion(<span class="number">1L</span>);</div><div class="line"><span class="number">14</span>:     <span class="keyword">for</span> (Entry&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; entry : registry.entrySet()) &#123;</div><div class="line"><span class="number">15</span>:         Application app = <span class="keyword">null</span>;</div><div class="line"><span class="number">16</span>: </div><div class="line"><span class="number">17</span>:         <span class="keyword">if</span> (entry.getValue() != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">18</span>:             <span class="keyword">for</span> (Entry&lt;String, Lease&lt;InstanceInfo&gt;&gt; stringLeaseEntry : entry.getValue().entrySet()) &#123;</div><div class="line"><span class="number">19</span>:                 Lease&lt;InstanceInfo&gt; lease = stringLeaseEntry.getValue();</div><div class="line"><span class="number">20</span>:                 <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">21</span>:                     app = <span class="keyword">new</span> Application(lease.getHolder().getAppName());</div><div class="line"><span class="number">22</span>:                 &#125;</div><div class="line"><span class="number">23</span>:                 app.addInstance(decorateInstanceInfo(lease));</div><div class="line"><span class="number">24</span>:             &#125;</div><div class="line"><span class="number">25</span>:         &#125;</div><div class="line"><span class="number">26</span>:         <span class="keyword">if</span> (app != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">27</span>:             apps.addApplication(app);</div><div class="line"><span class="number">28</span>:         &#125;</div><div class="line"><span class="number">29</span>:     &#125;</div><div class="line"><span class="number">30</span>:     <span class="comment">// TODO[0009]：RemoteRegionRegistry</span></div><div class="line"><span class="number">31</span>:     <span class="keyword">if</span> (includeRemoteRegion) &#123;</div><div class="line"><span class="number">32</span>:         <span class="keyword">for</span> (String remoteRegion : remoteRegions) &#123;</div><div class="line"><span class="number">33</span>:             RemoteRegionRegistry remoteRegistry = regionNameVSRemoteRegistry.get(remoteRegion);</div><div class="line"><span class="number">34</span>:             <span class="keyword">if</span> (<span class="keyword">null</span> != remoteRegistry) &#123;</div><div class="line"><span class="number">35</span>:                 Applications remoteApps = remoteRegistry.getApplications();</div><div class="line"><span class="number">36</span>:                 <span class="keyword">for</span> (Application application : remoteApps.getRegisteredApplications()) &#123;</div><div class="line"><span class="number">37</span>:                     <span class="keyword">if</span> (shouldFetchFromRemoteRegistry(application.getName(), remoteRegion)) &#123;</div><div class="line"><span class="number">38</span>:                         logger.info(<span class="string">"Application &#123;&#125;  fetched from the remote region &#123;&#125;"</span>,</div><div class="line"><span class="number">39</span>:                                 application.getName(), remoteRegion);</div><div class="line"><span class="number">40</span>: </div><div class="line"><span class="number">41</span>:                         Application appInstanceTillNow = apps.getRegisteredApplications(application.getName());</div><div class="line"><span class="number">42</span>:                         <span class="keyword">if</span> (appInstanceTillNow == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">43</span>:                             appInstanceTillNow = <span class="keyword">new</span> Application(application.getName());</div><div class="line"><span class="number">44</span>:                             apps.addApplication(appInstanceTillNow);</div><div class="line"><span class="number">45</span>:                         &#125;</div><div class="line"><span class="number">46</span>:                         <span class="keyword">for</span> (InstanceInfo instanceInfo : application.getInstances()) &#123;</div><div class="line"><span class="number">47</span>:                             appInstanceTillNow.addInstance(instanceInfo);</div><div class="line"><span class="number">48</span>:                         &#125;</div><div class="line"><span class="number">49</span>:                     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">50</span>:                         logger.debug(<span class="string">"Application &#123;&#125; not fetched from the remote region &#123;&#125; as there exists a "</span></div><div class="line"><span class="number">51</span>:                                         + <span class="string">"whitelist and this app is not in the whitelist."</span>,</div><div class="line"><span class="number">52</span>:                                 application.getName(), remoteRegion);</div><div class="line"><span class="number">53</span>:                     &#125;</div><div class="line"><span class="number">54</span>:                 &#125;</div><div class="line"><span class="number">55</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">56</span>:                 logger.warn(<span class="string">"No remote registry available for the remote region &#123;&#125;"</span>, remoteRegion);</div><div class="line"><span class="number">57</span>:             &#125;</div><div class="line"><span class="number">58</span>:         &#125;</div><div class="line"><span class="number">59</span>:     &#125;</div><div class="line"><span class="number">60</span>:     <span class="comment">// 设置 应用集合 hashcode</span></div><div class="line"><span class="number">61</span>:     apps.setAppsHashCode(apps.getReconcileHashCode());</div><div class="line"><span class="number">62</span>:     <span class="keyword">return</span> apps;</div><div class="line"><span class="number">63</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 2 至 第 10 行 ：TODO[0009]：RemoteRegionRegistry</li><li>第 11 至 29 行 ：获得获得注册的应用集合。</li><li>第 30 至 59 行 ：TODO[0009]：RemoteRegionRegistry</li><li>第 61 行 ：计算应用集合 <code>hashcode</code> 。该变量用于校验<strong>增量</strong>获取的注册信息和 Eureka-Server <strong>全量</strong>的注册信息是否一致( 完整 )，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-fetch-delta/">《Eureka 源码解析 —— 应用实例注册发现 （七）之增量获取》</a> 详细解析。</li></ul></li></ul><h3 id="3-3-2-转换成缓存值"><a href="#3-3-2-转换成缓存值" class="headerlink" title="3.3.2 转换成缓存值"></a>3.3.2 转换成缓存值</h3><p>调用 <code>#getPayLoad()</code> 方法，将注册的应用集合转换成缓存值，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* Generate pay load with both JSON and XML formats for all applications.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getPayLoad</span><span class="params">(Key key, Applications apps)</span> </span>&#123;</div><div class="line">   <span class="comment">// 获得编码器</span></div><div class="line">   EncoderWrapper encoderWrapper = serverCodecs.getEncoder(key.getType(), key.getEurekaAccept());</div><div class="line">   String result;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 编码</span></div><div class="line">       result = encoderWrapper.encode(apps);</div><div class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">       logger.error(<span class="string">"Failed to encode the payload for all apps"</span>, e);</div><div class="line">       <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span>(logger.isDebugEnabled()) &#123;</div><div class="line">       logger.debug(<span class="string">"New application cache entry &#123;&#125; with apps hashcode &#123;&#125;"</span>, key.toStringCompact(), apps.getAppsHashCode());</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3-4-主动过期读写缓存"><a href="#3-4-主动过期读写缓存" class="headerlink" title="3.4 主动过期读写缓存"></a>3.4 主动过期读写缓存</h2><p>应用实例注册、下线、过期时，调用 <code>ResponseCacheImpl#invalidate()</code> 方法，主动过期读写缓存( <code>readWriteCacheMap</code> )，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">(String appName, @Nullable String vipAddress, @Nullable String secureVipAddress)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (Key.KeyType type : Key.KeyType.values()) &#123;</div><div class="line">       <span class="keyword">for</span> (Version v : Version.values()) &#123;</div><div class="line">           invalidate(</div><div class="line">                   <span class="keyword">new</span> Key(Key.EntityType.Application, appName, type, v, EurekaAccept.full),</div><div class="line">                   <span class="keyword">new</span> Key(Key.EntityType.Application, appName, type, v, EurekaAccept.compact),</div><div class="line">                   <span class="keyword">new</span> Key(Key.EntityType.Application, ALL_APPS, type, v, EurekaAccept.full),</div><div class="line">                   <span class="keyword">new</span> Key(Key.EntityType.Application, ALL_APPS, type, v, EurekaAccept.compact),</div><div class="line">                   <span class="keyword">new</span> Key(Key.EntityType.Application, ALL_APPS_DELTA, type, v, EurekaAccept.full),</div><div class="line">                   <span class="keyword">new</span> Key(Key.EntityType.Application, ALL_APPS_DELTA, type, v, EurekaAccept.compact)</div><div class="line">           );</div><div class="line">           <span class="keyword">if</span> (<span class="keyword">null</span> != vipAddress) &#123;</div><div class="line">               invalidate(<span class="keyword">new</span> Key(Key.EntityType.VIP, vipAddress, type, v, EurekaAccept.full));</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">if</span> (<span class="keyword">null</span> != secureVipAddress) &#123;</div><div class="line">               invalidate(<span class="keyword">new</span> Key(Key.EntityType.SVIP, secureVipAddress, type, v, EurekaAccept.full));</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>#invalidate(keys)</code> 方法，逐个过期每个缓存键值，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">(Key... keys)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (Key key : keys) &#123;</div><div class="line">       logger.debug(<span class="string">"Invalidating the response cache key : &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;, &#123;&#125;"</span>, key.getEntityType(), key.getName(), key.getVersion(), key.getType(), key.getEurekaAccept());</div><div class="line">       <span class="comment">// 过期读写缓存</span></div><div class="line">       readWriteCacheMap.invalidate(key);</div><div class="line">       <span class="comment">// TODO[0009]：RemoteRegionRegistry</span></div><div class="line">       Collection&lt;Key&gt; keysWithRegions = regionSpecificKeys.get(key);</div><div class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> != keysWithRegions &amp;&amp; !keysWithRegions.isEmpty()) &#123;</div><div class="line">           <span class="keyword">for</span> (Key keysWithRegion : keysWithRegions) &#123;</div><div class="line">               logger.debug(<span class="string">"Invalidating the response cache key : &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;"</span>,</div><div class="line">                       key.getEntityType(), key.getName(), key.getVersion(), key.getType(), key.getEurekaAccept());</div><div class="line">               readWriteCacheMap.invalidate(keysWithRegion);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h2 id="3-5-被动过期读写缓存"><a href="#3-5-被动过期读写缓存" class="headerlink" title="3.5 被动过期读写缓存"></a>3.5 被动过期读写缓存</h2><p>读写缓存( <code>readWriteCacheMap</code> ) 写入后，一段时间自动过期，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">expireAfterWrite(serverConfig.getResponseCacheAutoExpirationInSeconds())</div></pre></td></tr></table></figure><ul><li>配置 <code>eureka.responseCacheAutoExpirationInSeconds</code> ，设置写入过期时长。默认值 ：180 秒。</li></ul><h2 id="3-6-定时刷新只读缓存"><a href="#3-6-定时刷新只读缓存" class="headerlink" title="3.6 定时刷新只读缓存"></a>3.6 定时刷新只读缓存</h2><p><strong>定时</strong>任务对比 <code>readWriteCacheMap</code> 和 <code>readOnlyCacheMap</code> 的缓存值，若不一致，以前者为主。通过这样的方式，实现了 <code>readOnlyCacheMap</code> 的定时过期。实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: ResponseCacheImpl(EurekaServerConfig serverConfig, ServerCodecs serverCodecs, AbstractInstanceRegistry registry) &#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// ... 省略无关代码 </span></div><div class="line"> <span class="number">3</span>: </div><div class="line"> <span class="number">4</span>:     <span class="keyword">long</span> responseCacheUpdateIntervalMs = serverConfig.getResponseCacheUpdateIntervalMs();</div><div class="line"> <span class="number">5</span>:     <span class="comment">// ... 省略无关代码</span></div><div class="line"> <span class="number">6</span>: </div><div class="line"> <span class="number">7</span>:     <span class="keyword">if</span> (shouldUseReadOnlyResponseCache) &#123;</div><div class="line"> <span class="number">8</span>:         timer.schedule(getCacheUpdateTask(),</div><div class="line"> <span class="number">9</span>:                 <span class="keyword">new</span> Date(((System.currentTimeMillis() / responseCacheUpdateIntervalMs) * responseCacheUpdateIntervalMs)</div><div class="line"><span class="number">10</span>:                         + responseCacheUpdateIntervalMs),</div><div class="line"><span class="number">11</span>:                 responseCacheUpdateIntervalMs);</div><div class="line"><span class="number">12</span>:     &#125;</div><div class="line"><span class="number">13</span>: </div><div class="line"><span class="number">14</span>:     <span class="comment">// ... 省略无关代码</span></div><div class="line"><span class="number">15</span>: &#125;</div><div class="line"><span class="number">16</span>: </div><div class="line"><span class="number">17</span>: <span class="function"><span class="keyword">private</span> TimerTask <span class="title">getCacheUpdateTask</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">18</span>:     <span class="keyword">return</span> <span class="keyword">new</span> TimerTask() &#123;</div><div class="line"><span class="number">19</span>:         <span class="meta">@Override</span></div><div class="line"><span class="number">20</span>:         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">21</span>:             logger.debug(<span class="string">"Updating the client cache from response cache"</span>);</div><div class="line"><span class="number">22</span>:             <span class="keyword">for</span> (Key key : readOnlyCacheMap.keySet()) &#123; <span class="comment">// 循环 readOnlyCacheMap 的缓存键</span></div><div class="line"><span class="number">23</span>:                 <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line"><span class="number">24</span>:                     Object[] args = &#123;key.getEntityType(), key.getName(), key.getVersion(), key.getType()&#125;;</div><div class="line"><span class="number">25</span>:                     logger.debug(<span class="string">"Updating the client cache from response cache for key : &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;"</span>, args);</div><div class="line"><span class="number">26</span>:                 &#125;</div><div class="line"><span class="number">27</span>:                 <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">28</span>:                     CurrentRequestVersion.set(key.getVersion());</div><div class="line"><span class="number">29</span>:                     Value cacheValue = readWriteCacheMap.get(key);</div><div class="line"><span class="number">30</span>:                     Value currentCacheValue = readOnlyCacheMap.get(key);</div><div class="line"><span class="number">31</span>:                     <span class="keyword">if</span> (cacheValue != currentCacheValue) &#123; <span class="comment">// 不一致时，进行替换</span></div><div class="line"><span class="number">32</span>:                         readOnlyCacheMap.put(key, cacheValue);</div><div class="line"><span class="number">33</span>:                     &#125;</div><div class="line"><span class="number">34</span>:                 &#125; <span class="keyword">catch</span> (Throwable th) &#123;</div><div class="line"><span class="number">35</span>:                     logger.error(<span class="string">"Error while updating the client cache from response cache for key &#123;&#125;"</span>, key.toStringCompact(), th);</div><div class="line"><span class="number">36</span>:                 &#125;</div><div class="line"><span class="number">37</span>:             &#125;</div><div class="line"><span class="number">38</span>:         &#125;</div><div class="line"><span class="number">39</span>:     &#125;;</div><div class="line"><span class="number">40</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 7 至 12 行 ：初始化定时任务。配置 <code>eureka.responseCacheUpdateIntervalMs</code>，设置任务执行频率，默认值 ：30 * 1000 毫秒。</li><li>第 17 至 39 行 ：创建定时任务。<ul><li>第 22 行 ：循环 <code>readOnlyCacheMap</code> 的缓存键。<strong>为什么不循环 <code>readWriteCacheMap</code> 呢</strong>？ <code>readOnlyCacheMap</code> 的缓存过期依赖  <code>readWriteCacheMap</code>，因此缓存键会更多。</li><li>第 28 行 至 33 行 ：对比 <code>readWriteCacheMap</code> 和 <code>readOnlyCacheMap</code> 的缓存值，若不一致，以前者为主。通过这样的方式，实现了 <code>readOnlyCacheMap</code> 的定时过期。</li></ul></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>比预期，比想想，长老多老多的一篇文章。细思极恐。</p><p>估计下一篇增量获取会简洁很多。</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/instance-registry-fetch-all/&quot;&gt;http://www.iocoder.cn/Eureka/instance-registry-fetch-all/&lt;/a
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
  <entry>
    <title>Eureka 源码解析 —— 应用实例注册发现（五）之过期</title>
    <link href="http://www.iocoder.cn/Eureka/instance-registry-evict/"/>
    <id>http://www.iocoder.cn/Eureka/instance-registry-evict/</id>
    <published>2018-06-21T16:00:00.000Z</published>
    <updated>2017-10-12T05:39:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Eureka/instance-registry-evict/">http://www.iocoder.cn/Eureka/instance-registry-evict/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Eureka 1.8.X 版本</strong> </p><ul><li><a href="http://www.iocoder.cn/Eureka/instance-registry-evict/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-evict/">2. 为什么需要过期</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-evict/">3. EvictionTask</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-evict/">4. 过期逻辑</a></li><li><a href="http://www.iocoder.cn/Eureka/instance-registry-evict/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Eureka-Server 过期超时续租的租约</strong>。</p><blockquote><p>FROM <a href="《http://techshow.ctrip.com/archives/1699.html》">《深度剖析服务发现组件Netflix Eureka》</a><br><img src="http://www.iocoder.cn/images/Eureka/2018_06_22/01.png" alt=""></p></blockquote><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-为什么需要过期"><a href="#2-为什么需要过期" class="headerlink" title="2. 为什么需要过期"></a>2. 为什么需要过期</h1><p>正常情况下，应用实例下线时候会主动向 Eureka-Server 发起下线请求。但实际情况下，应用实例可能异常崩溃，又或者是网络异常等原因，导致下线请求无法被成功提交。</p><p>介于这种情况，通过 Eureka-Client 心跳延长租约，配合 Eureka-Server 清理超时的租约解决上述异常。</p><h1 id="3-EvictionTask"><a href="#3-EvictionTask" class="headerlink" title="3. EvictionTask"></a>3. EvictionTask</h1><p><code>com.netflix.eureka.registry.AbstractInstanceRegistry.EvictionTask</code>，清理租约过期任务。在 Eureka-Server 启动时，初始化 EvictionTask 定时执行，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractInstanceRegistry.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 清理租约过期任务</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;EvictionTask&gt; evictionTaskRef = <span class="keyword">new</span> AtomicReference&lt;EvictionTask&gt;();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postInit</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// .... 省略无关代码</span></div><div class="line"></div><div class="line">   <span class="comment">// 初始化 清理租约过期任务</span></div><div class="line">   <span class="keyword">if</span> (evictionTaskRef.get() != <span class="keyword">null</span>) &#123;</div><div class="line">       evictionTaskRef.get().cancel();</div><div class="line">   &#125;</div><div class="line">   evictionTaskRef.set(<span class="keyword">new</span> EvictionTask());</div><div class="line">   evictionTimer.schedule(evictionTaskRef.get(),</div><div class="line">           serverConfig.getEvictionIntervalTimerInMs(),</div><div class="line">           serverConfig.getEvictionIntervalTimerInMs());</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>配置 <code>eureka.evictionIntervalTimerInMs</code> ，清理租约过期任务执行频率，单位：毫秒。默认，60000 毫秒。</li><li><p>EvictionTask 实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EvictionTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           <span class="comment">// 获取 补偿时间毫秒数</span></div><div class="line">           <span class="keyword">long</span> compensationTimeMs = getCompensationTimeMs();</div><div class="line">           logger.info(<span class="string">"Running the evict task with compensationTime &#123;&#125;ms"</span>, compensationTimeMs);</div><div class="line">           <span class="comment">// 清理过期租约逻辑</span></div><div class="line">           evict(compensationTimeMs);</div><div class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">           logger.error(<span class="string">"Could not run the evict task"</span>, e);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 <code>#compensationTimeMs()</code> 方法，获得补偿时间毫秒数。计算公式 = 当前时间 - 最后任务执行时间 - 任务执行频率。为什么需要补偿时间毫秒数，在 <a href="#">「4. 过期逻辑」<code>Lease#isisExpired(additionalLeaseMs)</code> 方法</a> 揭晓。<code>#compensationTimeMs()</code> 实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 最后任务执行时间</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicLong lastExecutionNanosRef = <span class="keyword">new</span> AtomicLong(<span class="number">0L</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">getCompensationTimeMs</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> currNanos = getCurrentTimeNano();</div><div class="line">    <span class="keyword">long</span> lastNanos = lastExecutionNanosRef.getAndSet(currNanos);</div><div class="line">    <span class="keyword">if</span> (lastNanos == <span class="number">0L</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0L</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">long</span> elapsedMs = TimeUnit.NANOSECONDS.toMillis(currNanos - lastNanos);</div><div class="line">    <span class="keyword">long</span> compensationTime = elapsedMs - serverConfig.getEvictionIntervalTimerInMs();</div><div class="line">    <span class="keyword">return</span> compensationTime &lt;= <span class="number">0L</span> ? <span class="number">0L</span> : compensationTime;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>由于 JVM GC ，又或是时间偏移( clock skew ) 等原因，定时器执行实际比预期会<strong>略有延迟</strong>。笔者在本机<strong>低负载</strong>运行，大概 10 ms 内。</p><blockquote><p>compute a compensation time defined as the actual time this task was executed since the prev iteration, vs the configured amount of time for execution. This is useful for cases where changes in time (due to clock skew or gc for example) causes the actual eviction task to execute later than the desired time according to the configured cycle.</p></blockquote></li></ul></li><li><p>调用 <code>#evict(compensationTime)</code> 方法，执行清理过期租约逻辑，在 <a href="#">「4. 过期逻辑」</a> 详细解析。</p></li></ul></li></ul><h1 id="4-过期逻辑"><a href="#4-过期逻辑" class="headerlink" title="4. 过期逻辑"></a>4. 过期逻辑</h1><p>调用 <code>#evict(compensationTime)</code> 方法，执行清理过期租约逻辑，实现代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evict</span><span class="params">(<span class="keyword">long</span> additionalLeaseMs)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     logger.debug(<span class="string">"Running the evict task"</span>);</div><div class="line"> <span class="number">3</span>: </div><div class="line"> <span class="number">4</span>:     <span class="keyword">if</span> (!isLeaseExpirationEnabled()) &#123;</div><div class="line"> <span class="number">5</span>:         logger.debug(<span class="string">"DS: lease expiration is currently disabled."</span>);</div><div class="line"> <span class="number">6</span>:         <span class="keyword">return</span>;</div><div class="line"> <span class="number">7</span>:     &#125;</div><div class="line"> <span class="number">8</span>: </div><div class="line"> <span class="number">9</span>:     <span class="comment">// 获得 所有过期的租约</span></div><div class="line"><span class="number">10</span>:     <span class="comment">// We collect first all expired items, to evict them in random order. For large eviction sets,</span></div><div class="line"><span class="number">11</span>:     <span class="comment">// if we do not that, we might wipe out whole apps before self preservation kicks in. By randomizing it,</span></div><div class="line"><span class="number">12</span>:     <span class="comment">// the impact should be evenly distributed across all applications.</span></div><div class="line"><span class="number">13</span>:     List&lt;Lease&lt;InstanceInfo&gt;&gt; expiredLeases = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="number">14</span>:     <span class="keyword">for</span> (Entry&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; groupEntry : registry.entrySet()) &#123;</div><div class="line"><span class="number">15</span>:         Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; leaseMap = groupEntry.getValue();</div><div class="line"><span class="number">16</span>:         <span class="keyword">if</span> (leaseMap != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">17</span>:             <span class="keyword">for</span> (Entry&lt;String, Lease&lt;InstanceInfo&gt;&gt; leaseEntry : leaseMap.entrySet()) &#123;</div><div class="line"><span class="number">18</span>:                 Lease&lt;InstanceInfo&gt; lease = leaseEntry.getValue();</div><div class="line"><span class="number">19</span>:                 <span class="keyword">if</span> (lease.isExpired(additionalLeaseMs) &amp;&amp; lease.getHolder() != <span class="keyword">null</span>) &#123; <span class="comment">// 过期</span></div><div class="line"><span class="number">20</span>:                     expiredLeases.add(lease);</div><div class="line"><span class="number">21</span>:                 &#125;</div><div class="line"><span class="number">22</span>:             &#125;</div><div class="line"><span class="number">23</span>:         &#125;</div><div class="line"><span class="number">24</span>:     &#125;</div><div class="line"><span class="number">25</span>: </div><div class="line"><span class="number">26</span>:     <span class="comment">// 计算 最大允许清理租约数量</span></div><div class="line"><span class="number">27</span>:     <span class="comment">// To compensate for GC pauses or drifting local time, we need to use current registry size as a base for</span></div><div class="line"><span class="number">28</span>:     <span class="comment">// triggering self-preservation. Without that we would wipe out full registry.</span></div><div class="line"><span class="number">29</span>:     <span class="keyword">int</span> registrySize = (<span class="keyword">int</span>) getLocalRegistrySize();</div><div class="line"><span class="number">30</span>:     <span class="keyword">int</span> registrySizeThreshold = (<span class="keyword">int</span>) (registrySize * serverConfig.getRenewalPercentThreshold());</div><div class="line"><span class="number">31</span>:     <span class="keyword">int</span> evictionLimit = registrySize - registrySizeThreshold;</div><div class="line"><span class="number">32</span>: </div><div class="line"><span class="number">33</span>:     <span class="comment">// 计算 清理租约数量</span></div><div class="line"><span class="number">34</span>:     <span class="keyword">int</span> toEvict = Math.min(expiredLeases.size(), evictionLimit);</div><div class="line"><span class="number">35</span>:     <span class="keyword">if</span> (toEvict &gt; <span class="number">0</span>) &#123;</div><div class="line"><span class="number">36</span>:         logger.info(<span class="string">"Evicting &#123;&#125; items (expired=&#123;&#125;, evictionLimit=&#123;&#125;)"</span>, toEvict, expiredLeases.size(), evictionLimit);</div><div class="line"><span class="number">37</span>: </div><div class="line"><span class="number">38</span>:         <span class="comment">// 逐个过期</span></div><div class="line"><span class="number">39</span>:         Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</div><div class="line"><span class="number">40</span>:         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; toEvict; i++) &#123;</div><div class="line"><span class="number">41</span>:             <span class="comment">// Pick a random item (Knuth shuffle algorithm)</span></div><div class="line"><span class="number">42</span>:             <span class="keyword">int</span> next = i + random.nextInt(expiredLeases.size() - i);</div><div class="line"><span class="number">43</span>:             Collections.swap(expiredLeases, i, next);</div><div class="line"><span class="number">44</span>:             Lease&lt;InstanceInfo&gt; lease = expiredLeases.get(i);</div><div class="line"><span class="number">45</span>: </div><div class="line"><span class="number">46</span>:             String appName = lease.getHolder().getAppName();</div><div class="line"><span class="number">47</span>:             String id = lease.getHolder().getId();</div><div class="line"><span class="number">48</span>:             EXPIRED.increment();</div><div class="line"><span class="number">49</span>:             logger.warn(<span class="string">"DS: Registry: expired lease for &#123;&#125;/&#123;&#125;"</span>, appName, id);</div><div class="line"><span class="number">50</span>:             internalCancel(appName, id, <span class="keyword">false</span>);</div><div class="line"><span class="number">51</span>:         &#125;</div><div class="line"><span class="number">52</span>:     &#125;</div><div class="line"><span class="number">53</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 3 至 7 行 ：判断允许执行清理过期租约逻辑，主要和<strong>自我保护机制</strong>有关，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-self-preservation/?self">《Eureka 源码解析 —— 应用实例注册发现（四）之自我保护机制》</a> 有详细解析。</li><li><p>第 9 至 24 行 ：获得<strong>所有过期</strong>的租约集合。</p><ul><li><p>第 19 行 ：调用 <code>Lease#isisExpired(additionalLeaseMs)</code> 方法，判断租约是否过期，实现代码如下：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Lease.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">(<span class="keyword">long</span> additionalLeaseMs)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> (evictionTimestamp &gt; <span class="number">0</span> || System.currentTimeMillis() &gt; (lastUpdateTimestamp + duration + additionalLeaseMs));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">renew</span><span class="params">()</span> </span>&#123;</div><div class="line">   lastUpdateTimestamp = System.currentTimeMillis() + duration;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>😈<strong>注意</strong>：在不考虑 <code>additionalLeaseMs</code> 参数的情况下，租约过期时间比预期多了<strong>一个</strong> <code>duration</code>，原因在于 <code>#renew()</code> 方法错误的设置 <code>lastUpdateTimestamp = System.currentTimeMillis() + duration</code>，正确的设置应该是 <code>lastUpdateTimestamp = System.currentTimeMillis()</code> 。</p><blockquote><p>Note that due to renew() doing the ‘wrong” thing and setting lastUpdateTimestamp to +duration more than what it should be, the expiry will actually be 2 <em> duration. <em>*This is a minor bug and should only affect instances that ungracefully shutdown. Due to possible wide ranging impact to existing usage, this will not be fixed</em></em>. </p></blockquote></li><li><p>TODO[0023]：additionalLeaseMs</p></li></ul></li></ul></li><li><p>第 26 至 34 行 ：计算<strong>最大允许</strong>清理租约的数量，后计算允许清理租约的数量。</p><ul><li><p>😈<strong>注意</strong>：即使 Eureka-Server 关闭<strong>自我保护机制</strong>，如果使用<code>renewalPercentThreshold = 0.85</code> 默认配置，结果会是<strong>分批逐步</strong>过期。举个例子：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 假设 20 个租约，其中有 10 个租约过期。</span></div><div class="line"></div><div class="line"><span class="comment">// 第一轮执行开始</span></div><div class="line"><span class="keyword">int</span> registrySize = <span class="number">20</span>;</div><div class="line"><span class="keyword">int</span> registrySizeThreshold = (<span class="keyword">int</span>) (<span class="number">20</span> * <span class="number">0.85</span>) = <span class="number">17</span>;</div><div class="line"><span class="keyword">int</span> evictionLimit = <span class="number">20</span> - <span class="number">17</span> = <span class="number">3</span>;</div><div class="line"><span class="keyword">int</span> toEvict = Math.min(<span class="number">10</span>, <span class="number">3</span>) = <span class="number">3</span>;</div><div class="line"><span class="comment">// 第一轮执行结束，剩余 17 个租约，其中有 7 个租约过期。</span></div><div class="line"></div><div class="line"><span class="comment">// 第二轮执行开始</span></div><div class="line"><span class="keyword">int</span> registrySize = <span class="number">17</span>;</div><div class="line"><span class="keyword">int</span> registrySizeThreshold = (<span class="keyword">int</span>) (<span class="number">17</span> * <span class="number">0.85</span>) = <span class="number">14</span>;</div><div class="line"><span class="keyword">int</span> evictionLimit = <span class="number">17</span> - <span class="number">14</span> = <span class="number">3</span>;</div><div class="line"><span class="keyword">int</span> toEvict = Math.min(<span class="number">7</span>, <span class="number">3</span>) = <span class="number">3</span>;</div><div class="line"><span class="comment">// 第二轮执行结束，剩余 14 个租约，其中有 4 个租约过期。</span></div><div class="line"></div><div class="line"><span class="comment">// 第三轮执行开始</span></div><div class="line"><span class="keyword">int</span> registrySize = <span class="number">14</span>;</div><div class="line"><span class="keyword">int</span> registrySizeThreshold = (<span class="keyword">int</span>) (<span class="number">14</span> * <span class="number">0.85</span>) = <span class="number">11</span>;</div><div class="line"><span class="keyword">int</span> evictionLimit = <span class="number">14</span> - <span class="number">11</span> = <span class="number">3</span>;</div><div class="line"><span class="keyword">int</span> toEvict = Math.min(<span class="number">4</span>, <span class="number">3</span>) = <span class="number">3</span>;</div><div class="line"><span class="comment">// 第三轮执行结束，剩余 11 个租约，其中有 1 个租约过期。</span></div><div class="line"></div><div class="line"><span class="comment">// 第四轮执行开始</span></div><div class="line"><span class="keyword">int</span> registrySize = <span class="number">11</span>;</div><div class="line"><span class="keyword">int</span> registrySizeThreshold = (<span class="keyword">int</span>) (<span class="number">11</span> * <span class="number">0.85</span>) = <span class="number">9</span>;</div><div class="line"><span class="keyword">int</span> evictionLimit = <span class="number">11</span> - <span class="number">9</span> = <span class="number">2</span>;</div><div class="line"><span class="keyword">int</span> toEvict = Math.min(<span class="number">1</span>, <span class="number">2</span>) = <span class="number">1</span>;</div><div class="line"><span class="comment">// 第四轮执行结束，剩余 10 个租约，其中有 0 个租约过期。结束。</span></div></pre></td></tr></table></figure><ul><li>结论：是否开启自我保护的差别，在于是否执行清理过期租约逻辑。如果想关闭<strong>分批逐步</strong>过期，设置 <code>renewalPercentThreshold = 0</code> 。</li></ul></li><li><p>由于 JVM GC ，或是本地时间差异原因，可能自我保护机制的阀值 <code>expectedNumberOfRenewsPerMin</code>、<code>numberOfRenewsPerMinThreshold</code> 不够正确，在<strong>过期</strong>这个相对“危险”的操作，<strong>重新计算自我保护</strong>的阀值。</p></li></ul></li><li><p>第 35 至 51 行 ：<strong>随机</strong>清理过期的租约。由于租约是按照<strong>应用顺序</strong>添加到数组，通过随机的方式，<strong>尽量避免单个应用被全部过期</strong>。</p><ul><li>第 39 行 ：传入当前时间为种子生成随机，避免 Java 的伪随机情况。在 <a href="http://www.cnblogs.com/greatfish/p/5845924.html" rel="external nofollow noopener noreferrer" target="_blank">《为什么说Java中的随机数都是伪随机数？》</a> 有详细解析。</li><li>第 41 至 43 行 ：随机调换后面的元素到当前位置( <code>i</code> )。</li></ul></li><li>第 50 行 ：调用 <code>#internalCancel()</code> 方法，下线已过期的租约，在 <a href="http://www.iocoder.cn/Eureka/instance-registry-self-preservation/?self">《Eureka 源码解析 —— 应用实例注册发现（四）之自我保护机制》「3.2 下线应用实例信息」</a> 有详细解析。</li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>😫 原本觉得比较容易的一篇文章，结果消耗了比想象中的时间，可能有四个小时。主要卡在补偿时间，目前也没弄懂。如果有知道的胖友，麻烦告知下。</p><p>胖友，分享我的公众号( <strong>芋道源码</strong> ) 给你的胖友可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Eureka/instance-registry-evict/&quot;&gt;http://www.iocoder.cn/Eureka/instance-registry-evict/&lt;/a&gt; 「芋道源码」
      
    
    </summary>
    
      <category term="Eureka" scheme="http://www.iocoder.cn/categories/Eureka/"/>
    
    
  </entry>
  
</feed>
