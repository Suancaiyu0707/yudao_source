<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>芋道源码 —— 纯源码解析BLOG</title>
  
  <subtitle>愿半生编码，如一生老友！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.iocoder.cn/"/>
  <updated>2017-12-23T23:23:23.000Z</updated>
  <id>http://www.iocoder.cn/</id>
  
  <author>
    <name>芋道源码</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（二）</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-streaming-second/</id>
    <published>2020-08-31T16:00:00.000Z</published>
    <updated>2017-12-23T23:23:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">http://www.iocoder.cn/SkyWalking/collector-streaming-second/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">2. Data</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">2.1 Collection</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">2.2 DataCollection</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">2.3 Window</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">2.4 DataCache</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">3. AggregationWorker</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">4. PersistenceWorker</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">4.1 WorkerCreateListener</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">4.2 PersistenceTimer</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文接 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（一）》</a> ，主要分享 <strong>Collector Streaming 流式处理的第二部分</strong>。主要包含如下部分：<img src="http://www.iocoder.cn/images/SkyWalking/2020_09_01/01.png" alt=""></p><ul><li>AggregationWorker ：聚合处理数据，后提交 Data 到 Next 节点们处理。</li><li>PersistenceWorker ：聚合处理数据，后存储 Data 。</li></ul><h1 id="2-Data"><a href="#2-Data" class="headerlink" title="2. Data"></a>2. Data</h1><p>AggregationWorker 和 PersistenceWorker ，都先<strong>聚合</strong>处理数据，在进行各自的后续处理。那么聚合处理的数据结果，需要有<strong>容器</strong>进行缓存暂存：</p><ul><li><code>org.skywalking.apm.collector.core.cache</code> ：接口</li><li><code>org.skywalking.apm.collector.stream.worker.impl.data</code> ：实现</li></ul><p>类图如下：<img src="http://www.iocoder.cn/images/SkyWalking/2020_09_01/02.png" alt=""></p><ul><li>Collection ：数据采集，提供有读、写<strong>两个状态</strong>的数据容器。</li><li>Window ：窗口( 😈这个解释怪怪的 )，内有<strong>两个 Collection</strong>。<ul><li>一个 Collection ，负责写入<strong>数据</strong>数据</li><li>一个 Collection ，负责读出<strong>处理</strong>数据</li><li>当写的 Collection <strong>符合处理的条件</strong>，读写 Collection 切换</li></ul></li></ul><h2 id="2-1-Collection"><a href="#2-1-Collection" class="headerlink" title="2.1 Collection"></a>2.1 Collection</h2><p><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Collection.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.core.cache.Collection</code></a> ，数据采集<strong>接口</strong>。</p><ul><li>数据相关 ：<code>#collection()</code> / <code>#size()</code> / <code>#clear()</code></li><li>读相关 ：<code>#reading()</code> / <code>#isReading()</code> / <code>#finishReading()</code></li><li>写相关 ：<code>#writing()</code> / <code>#isWriting()</code> / <code>#finishWriting()</code></li></ul><h2 id="2-2-DataCollection"><a href="#2-2-DataCollection" class="headerlink" title="2.2 DataCollection"></a>2.2 DataCollection</h2><p><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/data/DataCollection.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.stream.worker.impl.data.DataCollection</code></a> ，实现 Collection 接口，数据采集实现类，使用 <a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/data/DataCollection.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>Map&lt;String, Data&gt;</code></a> 作为数据容器。</p><h2 id="2-3-Window"><a href="#2-3-Window" class="headerlink" title="2.3 Window"></a>2.3 Window</h2><p><code>org.skywalking.apm.collector.core.cache.Window</code> ，窗口<strong>抽象类</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L50" rel="external nofollow noopener noreferrer" target="_blank">构造方法</a> ，代码如下：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L44" rel="external nofollow noopener noreferrer" target="_blank"><code>windowDataA</code></a> 属性，窗口数据A 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L48" rel="external nofollow noopener noreferrer" target="_blank"><code>windowDataB</code></a> 属性，窗口数据B 。</li><li>通过 <a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L61" rel="external nofollow noopener noreferrer" target="_blank"><code>#collectionInstance()</code></a> <strong>抽象</strong>方法，创建窗口数据( Collection )对象。</li><li><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>pointer</code></a> 属性，数据指向 <code>windowDataA</code> 或 <code>windowDataA</code>。<ul><li><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L111" rel="external nofollow noopener noreferrer" target="_blank"><code>#getCurrent()</code></a> 方法，获得<strong>现</strong>数据指向，即 <code>pointer</code> 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L118" rel="external nofollow noopener noreferrer" target="_blank"><code>#getLast()</code></a> 方法，获得<strong>原</strong>数据指向，即<strong>非</strong> <code>pointer</code> 。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L33" rel="external nofollow noopener noreferrer" target="_blank"><code>windowSwitch</code></a> 属性，窗口切换计数。</li></ul><hr><p><strong>切换 Collection 相关</strong>，方法如下：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L68" rel="external nofollow noopener noreferrer" target="_blank"><code>#trySwitchPointer()</code></a> 方法，返回是否可以切换 Collection 。可以切换需要满足如下条件：<ul><li>只有<strong>一个调用方</strong>申请切换，通过 <code>windowSwitch</code> 属性进行计数。</li><li><strong>原</strong>数据指向<strong>不处于正在读取状态</strong>。如果切换，一边读一边写，可能会有并发问题。</li><li>无论是否可以切换 Collection ，需要调用 <a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L75" rel="external nofollow noopener noreferrer" target="_blank"><code>#trySwitchPointerFinally()</code></a> 方法，<strong>释放</strong> <code>windowSwitch</code> 的计数。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L82" rel="external nofollow noopener noreferrer" target="_blank"><code>#switchPointer()</code></a> 方法，切换数据指向，并标记<strong>原</strong>数据指向的 Collection <strong>正在读取中</strong>。</li><li><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L129" rel="external nofollow noopener noreferrer" target="_blank"><code>#finishReadingLast()</code></a> 方法，清空<strong>原</strong>数据指向的 Collection 数据，并标记<strong>原</strong>数据指向的 Collection <strong>完成读取</strong>( <strong>不在正在读取中</strong> )。</li></ul><hr><p><strong>写 Collection 相关</strong>，方法如下：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/d6019b49d686f79d07528a19b09d4f0ccc4eca9b/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/cache/Window.java#L98" rel="external nofollow noopener noreferrer" target="_blank"><code>#getCurrentAndWriting()</code></a> 方法，获得<strong>现</strong>数据指向，并标记<strong>正在写入中</strong>。通过<strong>正在写入</strong>标记，切换 Collection 完成后，可以判断该 Collection 正在写入中，<strong>若是，等待不在写入中，开始数据读取并处理</strong>。</li></ul><h2 id="2-4-DataCache"><a href="#2-4-DataCache" class="headerlink" title="2.4 DataCache"></a>2.4 DataCache</h2><p><code>org.skywalking.apm.collector.stream.worker.impl.data.DataCache</code> ，实现 Window 抽象类，数据缓存。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/e6e1a7899e7b0e674a61f323447d4b66cffa8136/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/data/DataCache.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><code>#collectionInstance()</code></a> <strong>实现</strong>方法，创建 DataCollection 对象。</li><li><a href="https://github.com/YunaiV/skywalking/blob/e6e1a7899e7b0e674a61f323447d4b66cffa8136/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/data/DataCache.java#L82" rel="external nofollow noopener noreferrer" target="_blank"><code>#currentCollectionSize()</code></a> 方法，获得当前数据指向( 写入 Collection )的数据数量。</li></ul><hr><p><strong>写 Collection 相关</strong>，方法如下：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/e6e1a7899e7b0e674a61f323447d4b66cffa8136/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/data/DataCache.java#L73" rel="external nofollow noopener noreferrer" target="_blank"><code>#writing()</code></a> 方法，调用 <code>#getCurrentAndWriting()</code> 方法，开始写入。即，获得<strong>现</strong>数据指向，并标记<strong>正在写入中</strong>。<ul><li><a href="https://github.com/YunaiV/skywalking/blob/e6e1a7899e7b0e674a61f323447d4b66cffa8136/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/data/DataCache.java#L34" rel="external nofollow noopener noreferrer" target="_blank"><code>lockedDataCollection</code></a> 属性，写入的窗口数据。</li><li><a href="https://github.com/YunaiV/skywalking/blob/e6e1a7899e7b0e674a61f323447d4b66cffa8136/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/data/DataCache.java#L66" rel="external nofollow noopener noreferrer" target="_blank"><code>#put(id, data)</code></a> 方法，向 <code>lockedDataCollection</code> 属性，写入 Data 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/e6e1a7899e7b0e674a61f323447d4b66cffa8136/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/data/DataCache.java#L56" rel="external nofollow noopener noreferrer" target="_blank"><code>#get(id)</code></a> 方法，向 <code>lockedDataCollection</code> 属性，根据 ID 获得 Data 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/e6e1a7899e7b0e674a61f323447d4b66cffa8136/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/data/DataCache.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#containsKey(id)</code></a> 方法，向 <code>lockedDataCollection</code> 属性，根据 ID 判断 Data 是否存在 。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/e6e1a7899e7b0e674a61f323447d4b66cffa8136/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/data/DataCache.java#L89" rel="external nofollow noopener noreferrer" target="_blank"><code>#finishWriting()</code></a> 方法，完成写入。即，标记 <code>lockedDataCollection</code> <strong>不在正在写入中</strong>。</li></ul><h1 id="3-AggregationWorker"><a href="#3-AggregationWorker" class="headerlink" title="3. AggregationWorker"></a>3. AggregationWorker</h1><p><code>org.skywalking.apm.collector.stream.worker.impl.AggregationWorker</code> ，实现 AbstractLocalAsyncWorker 抽象类，<strong>异步聚合</strong> Worker，负责聚合处理数据，后提交 Data 到 Next 节点们处理。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ccd030f6b449954fccc7be4e19c15290e8affc77/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/AggregationWorker.java#L47" rel="external nofollow noopener noreferrer" target="_blank"><strong>构造方法</strong></a> ，代码如下：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/ccd030f6b449954fccc7be4e19c15290e8affc77/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/AggregationWorker.java#L41" rel="external nofollow noopener noreferrer" target="_blank"><code>dataCache</code></a> 属性，数据缓存。</li><li><a href="https://github.com/YunaiV/skywalking/blob/ccd030f6b449954fccc7be4e19c15290e8affc77/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/AggregationWorker.java#L45" rel="external nofollow noopener noreferrer" target="_blank"><code>messageNum</code></a> 属性，消息计数。当超过一定数量( 目前是 100 )，重置计数归零。</li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/ccd030f6b449954fccc7be4e19c15290e8affc77/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/AggregationWorker.java#L52" rel="external nofollow noopener noreferrer" target="_blank"><code>#onWork(message)</code></a> <strong>实现</strong>方法，聚合处理数据，当满足条件时，提交 Data 到 Next 节点们处理。</p><ul><li>第 53 行：<code>messageNum</code> 计数增加。</li><li>第 56 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/ccd030f6b449954fccc7be4e19c15290e8affc77/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/AggregationWorker.java#L97" rel="external nofollow noopener noreferrer" target="_blank"><code>#aggregate(message)</code></a> 方法，聚合消息到数据。</li><li>第 59 至 62 行：<code>messageNum &gt;= 100</code> 时，调用 <a href="https://github.com/YunaiV/skywalking/blob/ccd030f6b449954fccc7be4e19c15290e8affc77/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/AggregationWorker.java#L70" rel="external nofollow noopener noreferrer" target="_blank"><code>#sendToNext()</code></a> ，提交缓存数据的<strong>读 Collection 的数据</strong>给 Next 节点们继续处理。</li><li>第 65 至 67 行：<code>messageNum.endOfBatch == true</code> 时，当消息是批处理的最后一条时，调用 <a href="https://github.com/YunaiV/skywalking/blob/ccd030f6b449954fccc7be4e19c15290e8affc77/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/AggregationWorker.java#L70" rel="external nofollow noopener noreferrer" target="_blank"><code>#sendToNext()</code></a> ，提交缓存数据的<strong>读 Collection 的数据</strong>给 Next 节点们继续处理。</li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/ccd030f6b449954fccc7be4e19c15290e8affc77/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/AggregationWorker.java#L70" rel="external nofollow noopener noreferrer" target="_blank"><code>#sendToNext()</code></a> 方法，提交缓存数据的<strong>读 Collection 的数据</strong>给 Next 节点们继续处理。</p><ul><li>第 72 行：<strong>直接</strong>调用 <code>Window#switchPointer()</code> 方法，切换数据指针，并标记<strong>原</strong>指向正在读取中。这里并未先调用 <code>Window#trySwitchPointer()</code> 方法，<strong>是否会有并发问题</strong>？目前这里是<strong>异步单线程</strong>，所以不会有问题，参见 <a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/?self">《SkyWalking 源码分析 —— Collector Queue 队列组件》</a> 。另外，在 <a href="#">「4. PersistenceWorker」</a> 会看到并发的情况处理。</li><li>第 74 至 80 行：等待<strong>原</strong>指向不在读取中。</li><li>第 82 至 85 行：提交数据给 Next 节点们继续处理。</li><li>第 87 行：标记<strong>原</strong>指向完成读取。</li></ul><h1 id="4-PersistenceWorker"><a href="#4-PersistenceWorker" class="headerlink" title="4. PersistenceWorker"></a>4. PersistenceWorker</h1><p><code>org.skywalking.apm.collector.stream.worker.impl.PersistenceWorker</code> ，实现 AbstractLocalAsyncWorker 抽象类，<strong>异步批量存储</strong> Worker，负责聚合处理数据，后存储 Data 。</p><p>考虑到需要保证存储的时效性，PersistenceWorker 使用 PersistenceTimer ，定时存储 Data ，在 <a href="#">「4.2 PersistenceWorker」</a> 详细解析。</p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/ccd030f6b449954fccc7be4e19c15290e8affc77/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/AggregationWorker.java#L47" rel="external nofollow noopener noreferrer" target="_blank"><strong>构造方法</strong></a> ，代码如下：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/bf563461e75b6717d7b4589d7c3f579acf305541/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/PersistenceWorker.java#L49" rel="external nofollow noopener noreferrer" target="_blank"><code>dataCache</code></a> 属性，数据缓存。</li><li><a href="https://github.com/YunaiV/skywalking/blob/bf563461e75b6717d7b4589d7c3f579acf305541/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/PersistenceWorker.java#L53" rel="external nofollow noopener noreferrer" target="_blank"><code>batchDAO</code></a> 属性，批量操作 DAO ，在 <a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/?self">《SkyWalking 源码分析 —— Collector Storage 存储组件》</a> 有详细解析。</li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/bf563461e75b6717d7b4589d7c3f579acf305541/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/PersistenceWorker.java#L186" rel="external nofollow noopener noreferrer" target="_blank"><code>#needMergeDBData()</code></a> <strong>抽象</strong>方法，存储时，是否需要合并数据。一些 Data 只有新增操作，没有更新操作。</p><p><a href="https://github.com/YunaiV/skywalking/blob/bf563461e75b6717d7b4589d7c3f579acf305541/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/PersistenceWorker.java#L181" rel="external nofollow noopener noreferrer" target="_blank"><code>#persistenceDAO()</code></a> <strong>抽象</strong>方法，获得 Data 对应的持久化 DAO 接口的<strong>实现类</strong>对象。</p><p>上述两个<strong>抽象</strong>方法，用于 <a href="https://github.com/YunaiV/skywalking/blob/bf563461e75b6717d7b4589d7c3f579acf305541/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/PersistenceWorker.java#L121" rel="external nofollow noopener noreferrer" target="_blank"><code>#prepareBatch(dataMap)</code></a> 方法，生成批量操作对象数组，最终调用 <code>IBatchDAO#batchPersistence(List&lt;?&gt;)</code> 方法，通过执行批量操作对象数组，实现批量持久化数据，在 <a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/?self">《SkyWalking 源码分析 —— Collector Storage 存储组件》</a> 有详细解析。</p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/bf563461e75b6717d7b4589d7c3f579acf305541/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/PersistenceWorker.java#L71" rel="external nofollow noopener noreferrer" target="_blank"><code>#onWork(message)</code></a> <strong>实现</strong>方法，当满足条件时存储 Data ，而后聚合数据。这点和 AggregationWorker 相反的，因为要考虑并发问题。代码如下：</p><ul><li>第 72 行：调用 <code>DataCache#currentCollectionSize()</code> 方法，获得当前写入 Collection 的数据数量，判断是否超过 5000 。<ul><li>第 75 行：调用 <code>DataCache#trySwitchPointer()</code> 方法，<strong>判断</strong>是否可以切换 Collection 。通过该判断，保证和 PersistenceTimer 一起时，不会出现<strong>并发问题</strong>。</li><li>第 77 行：调用 <code>Window#switchPointer()</code> 方法，切换数据指针，并标记<strong>原</strong>指向正在读取中。</li><li>第 80 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/bf563461e75b6717d7b4589d7c3f579acf305541/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/PersistenceWorker.java#L100" rel="external nofollow noopener noreferrer" target="_blank"><code>#buildBatchCollection()</code></a> 方法，创建批量操作对象数组。该方法和 <code>AggregationWorker#sendToNext()</code> 方法<strong>基本类似</strong>。</li><li>第 83 行：调用 <code>IBatchDAO#batchPersistence(List&lt;?&gt;)</code> 方法，通过执行批量操作对象数组，实现批量持久化数据。</li><li>第 86 行：调用 <code>DataCache#trySwitchPointerFinally()</code> 方法，<strong>释放</strong> <code>DataCache.windowSwitch</code> 的计数。</li></ul></li><li>第 91 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/bf563461e75b6717d7b4589d7c3f579acf305541/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/PersistenceWorker.java#L164" rel="external nofollow noopener noreferrer" target="_blank"><code>#aggregate(message)</code></a> 方法，聚合数据。该方法和 <code>AggregationWorker#aggregate(message)</code> 方法<strong>基本相似</strong>。</li></ul><h2 id="4-1-WorkerCreateListener"><a href="#4-1-WorkerCreateListener" class="headerlink" title="4.1 WorkerCreateListener"></a>4.1 WorkerCreateListener</h2><p><code>org.skywalking.apm.collector.stream.worker.base.WorkerCreateListener</code> ，Worker 创建监听器。</p><p>Worker 在创建时，会调用 <a href="https://github.com/YunaiV/skywalking/blob/bf563461e75b6717d7b4589d7c3f579acf305541/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/WorkerCreateListener.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><code>WorkerCreateListener#addWorker</code></a> 方法，记录所有的 PersistenceWorker 对象。</p><p><strong>记录下来有什么用呢</strong>？在 <a href="https://github.com/YunaiV/skywalking/blob/bf563461e75b6717d7b4589d7c3f579acf305541/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/AgentStreamBootStartup.java#L47" rel="external nofollow noopener noreferrer" target="_blank">AgentStreamBootStartup</a> 启动时，创建 PersistenceTimer 对象，并将 WorkerCreateListener 记录的 PersistenceWorker 对象集合<strong>传递</strong>给 PersistenceTimer 对象。这样，PersistenceTimer 能够”<strong>访问</strong>“到 PersistenceWorker 对象们的 DataCache ，<strong>定时</strong>存储数据。</p><h2 id="4-2-PersistenceTimer"><a href="#4-2-PersistenceTimer" class="headerlink" title="4.2 PersistenceTimer"></a>4.2 PersistenceTimer</h2><p><code>org.skywalking.apm.collector.stream.timer.PersistenceTimer</code> ，持久化定时任务，负责<strong>定时</strong>、<strong>批量</strong>存储 PersistenceWorker 缓存的数据。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ec95c9966b7e013c8a44ea2e0f748ad339363ce3/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/timer/PersistenceTimer.java#L43" rel="external nofollow noopener noreferrer" target="_blank"><code>#start(IBatchDAO, List&lt;PersistenceWorker&gt;)</code></a> 方法，创建延迟 1 秒，每 1 秒执行一次 <code>#extractDataAndSave()</code> 方法的定时任务，用于<strong>定时</strong>、<strong>批量</strong>存储 PersistenceWorker 缓存的数据。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ec95c9966b7e013c8a44ea2e0f748ad339363ce3/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/timer/PersistenceTimer.java#L52" rel="external nofollow noopener noreferrer" target="_blank"><code>#extractDataAndSave(IBatchDAO, List&lt;PersistenceWorker&gt;)</code></a> 方法，代码如下：</p><ul><li><p>第 55 至 68 行：获得所有 PersistenceWorker 读 Collection 缓存的数据。</p><ul><li>第 60 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/ec95c9966b7e013c8a44ea2e0f748ad339363ce3/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/PersistenceWorker.java#L61" rel="external nofollow noopener noreferrer" target="_blank"><code>PersistenceWorker#flushAndSwitch()</code></a> 切换数据指针，即切换读写 Collection 。</li><li>第 62 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/ec95c9966b7e013c8a44ea2e0f748ad339363ce3/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/PersistenceWorker.java#L100" rel="external nofollow noopener noreferrer" target="_blank"><code>PersistenceWorker#buildBatchCollection()</code></a> 方法，创建批量操作对象数组。</li><li><strong>怎么保证并发安全</strong>？通过 <code>Window#trySwitchPointer()</code> 方法，保证读 Collection <strong>正在被读取中</strong>时，PersistenceWorker 和 PersistenceTimer 有且仅有一个切换队列，读取数据。当读取完成后，调用 <code>Window#finishReadingLast()</code> 方法，清空原数据指向，并标记原数据指向完成正在读取中。</li></ul></li><li><p>第 71 行：调用 <code>IBatchDAO#batchPersistence(List&lt;?&gt;)</code> 方法，执行批量操作，进行存储。</p></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>呼呼，终于把流式处理给写完了，如果写的不详细或者不合适的，胖友看到麻烦告知笔者，谢谢。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_09_01/03.png" alt=""></p><p>胖友，分享一波朋友圈可好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-streaming-second/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-streaming-seco
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（一）</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-streaming-first/</id>
    <published>2020-08-24T16:00:00.000Z</published>
    <updated>2017-12-23T23:26:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/">http://www.iocoder.cn/SkyWalking/collector-streaming-first/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/">2. apm-collector-core/graph</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/">2.1 Graph 创建</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/">2.2 Graph 启动</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/">3. apm-collector-stream</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/">3.1 WayToNode 实现类</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/">3.2 NodeProcessor 实现类</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Collector Streaming 流式处理</strong>。主要包含如下部分：</p><ul><li><p><code>apm-collector-core</code> 模块的 <code>graph</code> 包，提供<strong>最精简</strong>、<strong>单节点</strong>的流式处理的封装。如下图所示：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/01.png" alt=""></p></li><li><p><code>apm-collector-stream</code> 模块，在 <code>graph</code> 包的基础上，提供<strong>异步</strong>、<strong>跨节点</strong>等等的流式处理的封装。如下图所示：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/02.png" alt=""></p></li></ul><blockquote><p>免打脸大保健：笔者对流式处理非常不了解，本文可能是一本正经的胡说八道。考虑到笔者是靠脸吃饭（颜值我只服我红雷哥），所以读者老爷请爱护下笔者。</p></blockquote><p>Collector Streaming 在 SkyWalking 架构图处于如下位置( <strong>红框</strong> ) ：</p><blockquote><p>FROM <a href="https://github.com/apache/incubating-skywalking" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubating-skywalking</a><br><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/03.jpeg" alt=""></p></blockquote><p>OK，下面来一本正经的代码走起！</p><h1 id="2-apm-collector-core-graph"><a href="#2-apm-collector-core-graph" class="headerlink" title="2. apm-collector-core/graph"></a>2. apm-collector-core/graph</h1><p>整体类图如下：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/04.png" alt=""></p><p>看起来略复杂，不要方，我们先来看一个流式大数据处理框架 Apache Storm 的说明：</p><blockquote><p>FROM <a href="http://www.csdn.net/article/2015-03-09/2824135" rel="external nofollow noopener noreferrer" target="_blank">《流式大数据处理的三种框架：Storm，Spark和Samza》</a><br>在 <a href="https://storm.apache.org/" rel="external nofollow noopener noreferrer" target="_blank">Storm</a> 中，先要设计一个用于实时计算的图状结构，我们称之为拓扑（topology）。这个拓扑将会被提交给集群，由集群中的主控节点（master node）分发代码，将任务分配给工作节点（worker node）执行。</p></blockquote><ul><li>Graph ：定义了一个<strong>数据</strong>在<strong>各个</strong> Node 的处理拓扑图。</li><li>WayToNode ：提交<strong>数据</strong>给 Node 的<strong>方式</strong>。</li><li>Node ：节点，包含一个 NodeProcessor 和 一个 Next 。 <ul><li>NodeProcessor ：Node 处理器，处理<strong>数据</strong>。</li><li>Next ：包含 WayToNode 数组，即 Node 提交<strong>数据</strong>给 Next 的 Node <strong>数组</strong>的<strong>方式</strong>。</li></ul></li></ul><p>整体交互流程如下：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/05.png" alt=""></p><ul><li><strong>粉色</strong>箭头：当数据进来时，提交给 Grpah 。按照定义的拓扑图，使用 NodeWay 提交给 Node ，NodeProcessor 进行处理。</li><li><strong>蓝色</strong>箭头：当 NodeProcessor 处理完成后，Next <strong>逐个</strong>使用 NodeWay <strong>数组</strong>提交给下面的 Node ，继续处理。<ul><li>ps ：<strong>注意</strong>，这块流程，根据不同的 NodeProcessor 的实现类会有不同，<strong>蓝色</strong>箭头的过程，只是<strong>其中的一种</strong>，下面会详细解析。</li></ul></li></ul><p>整体顺序图如下：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/06.png" alt=""></p><ul><li>DirectWay 是 WayToNode <strong>接口</strong>的一种实现，正如其名，<strong>直接</strong>提交数据给 Node 。在 <a href="#">「3. apm-collector-stream」</a> 会看到其他实现，例如提交到其他服务器节点的 Node，从而实现跨服务器节点的流式处理。</li><li>AbstractWorker 在 <code>apm-collector-stream</code> 模块，是 NodeProcessor <strong>接口</strong>的一种实现，处理提交给 Node 的数据。在 <code>#onWork(message)</code> <strong>抽象</strong>方法里，子类可以实现该方法，根据自身需求，是否调用 <code>#onNext(message)</code> 方法，Next 逐个使用 NodeWay 数组提交给下面的 Node ，继续处理。</li></ul><hr><p>下面，我们来详细分别看看如下逻辑的详细代码实现：</p><ul><li>Graph 创建</li><li>Graph 启动</li></ul><h2 id="2-1-Graph-创建"><a href="#2-1-Graph-创建" class="headerlink" title="2.1 Graph 创建"></a>2.1 Graph 创建</h2><p>创建 Graph 的顺序图如下：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/07.png" alt=""></p><ul><li>第一步，调用 <code>GraphManager#createIfAbsent(graphId, input)</code> 方法( <code>input</code> 参数没用 )，创建一个 Graph 对象。</li><li>第二步，调用 <code>Graph#addNode(WayToNode)</code> 方法，创建该 Graph 的<strong>首个</strong> Node 对象。</li><li>第三步，调用 <code>Node#addNext(WayToNode)</code> 方法，创建该 Node 的下一个 Node 对象。</li></ul><p>如下是 <code>collector-agent-stream-provider</code> 模块，<code>TraceStreamGraph#createServiceReferenceGraph()</code> 方法的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createServiceReferenceGraph</span><span class="params">()</span> </span>&#123;</div><div class="line">    QueueCreatorService&lt;ServiceReference&gt; queueCreatorService = moduleManager.find(QueueModule.NAME).getService(QueueCreatorService.class);</div><div class="line">    RemoteSenderService remoteSenderService = moduleManager.find(RemoteModule.NAME).getService(RemoteSenderService.class);</div><div class="line"></div><div class="line">    Graph&lt;ServiceReference&gt; graph = GraphManager.INSTANCE.createIfAbsent(SERVICE_REFERENCE_GRAPH_ID, ServiceReference.class);</div><div class="line">    graph.addNode(<span class="keyword">new</span> ServiceReferenceAggregationWorker.Factory(moduleManager, queueCreatorService).create(workerCreateListener))</div><div class="line">        .addNext(<span class="keyword">new</span> ServiceReferenceRemoteWorker.Factory(moduleManager, remoteSenderService, SERVICE_REFERENCE_GRAPH_ID).create(workerCreateListener))</div><div class="line">        .addNext(<span class="keyword">new</span> ServiceReferencePersistenceWorker.Factory(moduleManager, queueCreatorService).create(workerCreateListener));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>让我们来看看每个方法的具体代码实现。</p><hr><p><strong>第一步</strong></p><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/GraphManager.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>GraphManager#createIfAbsent(graphId, input)</code></a> 方法，创建一个 Graph 对象，并添加到 Graph 映射。代码如下：</p><ul><li><code>INSTANCE</code> 属性，单例。</li><li><code>allGraphs</code> 属性，Graph 映射。其中映射的 KEY 为<strong>每个</strong> Graph 全局唯一编号。在 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/graph/JvmMetricStreamGraph.java" rel="external nofollow noopener noreferrer" target="_blank">JvmMetricStreamGraph</a> 、<a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/graph/RegisterStreamGraph.java" rel="external nofollow noopener noreferrer" target="_blank">RegisterStreamGraph</a> 、<a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/graph/TraceStreamGraph.java" rel="external nofollow noopener noreferrer" target="_blank">TraceStreamGraph</a> 类中，枚举了实际使用的 Graph 编号们。</li><li>第 50 至 58 行：当 Graph 映射里不存在指定 Graph 编号时，创建 Graph 对象，并返回。</li></ul><hr><p><strong>第二步</strong></p><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/Graph.java#L56" rel="external nofollow noopener noreferrer" target="_blank"><code>Graph#addNode(WayToNode)</code></a> 方法，创建该 Graph 的<strong>首个</strong> Node 对象。代码如下：</p><ul><li><code>id</code> 属性，Graph 编号。</li><li><code>entryWay</code>，<strong>首个</strong>提交数据给 Node 的方式。</li><li>第 58 行 ：将方法参数 <code>entryWay</code> 赋值给 <code>this.entryWay</code> 属性。在下分享的 <code>Graph#start(input)</code> 方法里，我们会看到这是 Graph 启动的入口，<strong>首个</strong>提交给 Node 的方式。</li><li>第 60 至 62 行 ：调用 <code>WayToNode#buildDestination(Graph)</code> 方法，创建 Node 对象，并<strong>返回该 Node</strong> 。在上文中，我们已经说过创建的 Node 对象，为该 Graph 的<strong>首个</strong> Node 。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/WayToNode.java#L41" rel="external nofollow noopener noreferrer" target="_blank"><code>WayToNode#buildDestination()</code></a> 方法，创建该 <strong>WayToNode</strong> 的 Node 对象。代码如下：</p><ul><li><code>destination</code> 属性，目标 Node 。即该 WayToNode 提交<strong>数据</strong>到的 Node 。</li><li><code>destinationHandler</code> 属性，目标 Node 的处理器。见 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/WayToNode.java#L47" rel="external nofollow noopener noreferrer" target="_blank"><code>#out(INPUT)</code></a> 方法。</li><li>第 42 行：创建 Node 对象。<ul><li>目前，<code>destinationHandler</code> 属性，除了用于创建 Node 对象，无其他用途。</li></ul></li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/Node.java#L40" rel="external nofollow noopener noreferrer" target="_blank">Node <code>构造方法</code></a> 方法，代码如下：</p><ul><li><code>nodeProcessor</code> 属性，节点处理器。</li><li><code>next</code> 属性，包含 WayToNode 数组，即 Node 提交数据给 Next 的 Node 数组的方式。</li><li>第 44 行：调用 <code>Graph#checkForNewNode(Node)</code> 方法，校验 Node 的 NodeProcessor 在其 Graph 里，<strong>编号唯一</strong>。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/Graph.java#L71" rel="external nofollow noopener noreferrer" target="_blank"><code>Graph#checkForNewNode(Node)</code></a> 方法，校验 Node 的 NodeProcessor 在 Graph 里，<strong>编号唯一</strong>，代码如下：</p><ul><li><code>nodeIndex</code> 属性，处理器编号与 Node 的映射。其中映射的 KEY 为 <code>NodeProcessor#id()</code> 。 </li><li>第 72 至 78 行：校验 Node 的 NodeProcessor 在 Graph 里，<strong>编号唯一</strong>。</li></ul><hr><p><strong>第三步</strong></p><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/Node.java#L51" rel="external nofollow noopener noreferrer" target="_blank"><code>Node#addNext(WayToNode)</code></a> 方法，创建该 Node 的下一个 Node 对象。代码如下：</p><ul><li>第 54 行：调用 <code>WayToNode#buildDestination(Graph)</code> 方法，创建该 Node 的下面的 Node 对象。</li><li>第 56 行：添加创建的 Node 对象到 <code>next</code> 属性。</li><li>第 58 行：返回创建的 Node 对象。</li></ul><h2 id="2-2-Graph-启动"><a href="#2-2-Graph-启动" class="headerlink" title="2.2 Graph 启动"></a>2.2 Graph 启动</h2><p>创建 Graph 的顺序图如下：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/08.png" alt=""></p><table><thead><tr><th>数据流向</th><th>FROM</th><th>TO</th><th>逻辑</th></tr></thead><tbody><tr><td>第一步</td><td>Graph</td><td>WayToNode</td><td></td></tr><tr><td>第二步</td><td>WayToNode</td><td>Node</td><td></td></tr><tr><td>第三步</td><td>Node</td><td>NodeProcessor</td><td></td></tr><tr><td>第四步</td><td>NodeProcessor</td><td>Next</td><td>根据具体实现，若到 Next ，重复第一步</td></tr></tbody></table><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/09.png" alt=""></p><hr><p><strong>第一步</strong></p><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/Graph.java#L48" rel="external nofollow noopener noreferrer" target="_blank"><code>Graph#start(input)</code></a> 方法，启动 Graph ，处理数据。代码如下：</p><ul><li>第 49 行：调用 <code>WayToNode#in(input)</code> 方法，输入数据给 WayToNode 。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/WayToNode.java#L45" rel="external nofollow noopener noreferrer" target="_blank"><code>WayToNode#in(input)</code></a> <strong>抽象</strong>方法，以 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/DirectWay.java#L29" rel="external nofollow noopener noreferrer" target="_blank"><code>DirectWay#in(input)</code></a> <strong>实现</strong>方法举例子，代码如下：</p><ul><li>第 30 行：调用 <code>super#out(input)</code> 方法，<strong>直接</strong>输出数据，调用 <code>Node#execute(input)</code> 方法，提交数据给 Node ，进行处理。</li></ul><hr><p><strong>第二步</strong></p><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/Node.java#L62" rel="external nofollow noopener noreferrer" target="_blank"><code>Node#execute</code></a> 方法，调用 <code>NodeProcessor#process(input, next)</code> 方法，处理数据。</p><hr><p><strong>第三步</strong></p><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/NodeProcessor.java#L34" rel="external nofollow noopener noreferrer" target="_blank"><code>NodeProcessor#process(input, next)</code></a> <strong>接口</strong>方法，以 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/AbstractWorker.java#L62" rel="external nofollow noopener noreferrer" target="_blank"><code>AbstractWorker#process(input, next)</code></a> <strong>实现</strong>方法举例子，代码如下：</p><ul><li>第 64 行：将方法参数 <code>next</code> 赋值给 <code>this.next</code> 属性。<code>this.next</code> 属性，用于封装的 <code>#onNext(OUTPUT)</code> 方法，提交数据给当前 Node 的 Next ( 下面的 Node 们 )继续处理数据。</li><li>第 67 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/AbstractWorker.java#L60" rel="external nofollow noopener noreferrer" target="_blank"><code>#onWork</code></a> <strong>抽象</strong>方法，处理数据。当 AbstractWorker <strong>抽象类</strong>的实现类需要继续讲数据提交给 Next 时，需要在 <code>#onWork</code> 方法里，调用 <code>#onNext(OUTPUT)</code> 方法，例如 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationRegisterRemoteWorker.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>ApplicationRegisterRemoteWorker#onWork(Application)</code></a> 。</li></ul><hr><p><strong>第四步</strong></p><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/graph/Next.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>Next#execute(INPUT)</code></a> 方法，<strong>循环</strong> WayToNode 数组，输入数据给 WayNode ，相当于”<strong>重回</strong>“【第一步】。</p><h1 id="3-apm-collector-stream"><a href="#3-apm-collector-stream" class="headerlink" title="3. apm-collector-stream"></a>3. apm-collector-stream</h1><p>在文章的开头，我们提到了 <code>apm-collector-stream</code> 模块，在 <code>graph</code> 包的基础上，提供<strong>异步</strong>、<strong>跨节点</strong>等等的流式处理的封装。主要在 WayToNode 、NodeProcessor 的实现类上做文章。</p><h2 id="3-1-WayToNode-实现类"><a href="#3-1-WayToNode-实现类" class="headerlink" title="3.1 WayToNode 实现类"></a>3.1 WayToNode 实现类</h2><p>整体类图如下：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/10.png" alt=""></p><h3 id="3-1-1-WorkerRef"><a href="#3-1-1-WorkerRef" class="headerlink" title="3.1.1 WorkerRef"></a>3.1.1 WorkerRef</h3><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/WorkerRef.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.stream.worker.base.WorkerRef</code></a> ，Worker 引用<strong>抽象类</strong>。</p><p>在 <code>apm-collector-stream</code> 模块里，我们会发现类的命名从 Node / NodeProcessor 转向了 Worker ？<strong>这是为什么呢</strong>？关于这一点，我们特意<del>采访</del>( 请教 )了官方大佬。</p><blockquote><p>Worker 更具业务含义<br>Node / Processor 更偏技术含义</p></blockquote><p>目前，WorkerRef 无具体的方法。</p><h3 id="3-1-2-LocalAsyncWorkerRef"><a href="#3-1-2-LocalAsyncWorkerRef" class="headerlink" title="3.1.2 LocalAsyncWorkerRef"></a>3.1.2 LocalAsyncWorkerRef</h3><p><code>org.skywalking.apm.collector.stream.worker.base.LocalAsyncWorkerRef</code> ，异步 Worker 引用<strong>实现类</strong>，提供了<strong>异步</strong>的流式处理封装。</p><p>我们回到 <a href="#">「2.2 Graph 创建」</a> 的【第一步】。</p><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/LocalAsyncWorkerRef.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>LocalAsyncWorkerRef#in(INPUT)</code></a> 方法，代码如下：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/LocalAsyncWorkerRef.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><code>queueEventHandler</code></a> 属性，队列事件处理器。在 <a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/?self">《SkyWalking 源码分析 —— Collector Queue 队列组件》</a> 我们会详细解析它的代码实现，这里只简单介绍下。</li><li>第 47 行：将输入的数据，作为”<strong>事件</strong>“，提交到队列事件处理器中，不再执行后续逻辑。此后，队列事件处理器，会在<strong>后台</strong>处理到该”<strong>事件</strong>“( 数据 )，回调 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/LocalAsyncWorkerRef.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>LocalAsyncWorkerRef#execute</code></a> 方法，从而提交数据到 Worker ( Node )。详细参见 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-queue/collector-queue-disruptor-provider/src/main/java/org/skywalking/apm/collector/queue/disruptor/base/DisruptorEventHandler.java#L54" rel="external nofollow noopener noreferrer" target="_blank">DisruptorEventHandler#onEvent(…)</a> 方法。</li></ul><p><strong>那么为什么会回调呢</strong>？LocalAsyncWorkerRef 实现了 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-queue/collector-queue-define/src/main/java/org/skywalking/apm/collector/queue/base/QueueExecutor.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.queue.base.QueueExecutor</code></a> 接口，它自身被设置到 QueueEventHandler 中， 作为”<strong>事件</strong>“的执行器。</p><p>整体流程如下：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/11.png" alt=""></p><h3 id="3-1-3-RemoteWorkerRef"><a href="#3-1-3-RemoteWorkerRef" class="headerlink" title="3.1.3 RemoteWorkerRef"></a>3.1.3 RemoteWorkerRef</h3><p><code>org.skywalking.apm.collector.stream.worker.base.RemoteWorkerRef</code> ，远程 Worker 引用<strong>实现类</strong>，提供了<strong>远程跨节点</strong>的流式处理的封装。</p><p>我们再回到 <a href="#">「2.2 Graph 创建」</a> 的【第一步】。</p><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/RemoteWorkerRef.java#L53" rel="external nofollow noopener noreferrer" target="_blank"><code>RemoteWorkerRef#in(INPUT)</code></a> 方法，代码如下：</p><ul><li><code>remoteSenderService</code> 属性，远程发送服务。在 <a href="todo">TODO【4005】</a> 我们会详细解析它的代码实现，这里只简单介绍下。</li><li><code>remoteWorker</code> 属性，远程 Worker 。在下文会详细分享它的实现。</li><li>第 56 行：调用 <code>RemoteSenderService#send(...)</code> 方法，根据远程 Worker 的 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/Selector.java" rel="external nofollow noopener noreferrer" target="_blank">Selector 选择器</a>，选择一个 Worker 进行发送。</li><li>第 58 至 60 行：当选择的 Worker 为本地模式( <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-remote/collector-remote-define/src/main/java/org/skywalking/apm/collector/remote/service/RemoteSenderService.java#L36" rel="external nofollow noopener noreferrer" target="_blank">Mode</a> )时，调用 <code>#out(INPUT)</code> 方法，提交数据到本地的 Worker ( Node )。</li></ul><h2 id="3-2-NodeProcessor-实现类"><a href="#3-2-NodeProcessor-实现类" class="headerlink" title="3.2 NodeProcessor 实现类"></a>3.2 NodeProcessor 实现类</h2><p>整体类图如下：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/12.png" alt=""></p><ul><li><a href="todo"><code>org.skywalking.apm.collector.stream.worker.base.Provider</code></a> ，Worker 供应者<strong>接口</strong>，用于创建 Worker 和 WorkerRef 对象的<strong>工厂</strong>。</li></ul><h3 id="3-2-1-AbstractWorker"><a href="#3-2-1-AbstractWorker" class="headerlink" title="3.2.1 AbstractWorker"></a>3.2.1 AbstractWorker</h3><p>AbstractWorker 的代码实现，在 <a href="#">「2.2 Graph 启动」</a> 已经详细解析。</p><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/AbstractWorkerProvider.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.stream.worker.base.AbstractWorkerProvider</code></a> ，Worker 供应者<strong>抽象类</strong>，定义了 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/AbstractWorkerProvider.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#workerInstance(ModuleManager)</code></a> <strong>抽象</strong>方法，用于创建 Worker 对象。</p><h3 id="3-2-2-AbstractLocalAsyncWorker"><a href="#3-2-2-AbstractLocalAsyncWorker" class="headerlink" title="3.2.2 AbstractLocalAsyncWorker"></a>3.2.2 AbstractLocalAsyncWorker</h3><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/AbstractLocalAsyncWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.stream.worker.base.AbstractLocalAsyncWorker</code></a> ，异步 Worker <strong>抽象类</strong>。</p><p>目前，AbstractLocalAsyncWorker 无具体的方法。</p><p>实际使用时，继承 AbstractLocalAsyncWorker 类，实现 <code>#work(INPUT)</code> 方法，例如：<a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationRegisterSerialWorker.java#L56" rel="external nofollow noopener noreferrer" target="_blank">ApplicationRegisterSerialWorker</a> 。</p><hr><p><code>org.skywalking.apm.collector.stream.worker.base.AbstractLocalAsyncWorkerProvider</code> ，LocalAsyncWorker 供应者<strong>抽象类</strong>。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/AbstractLocalAsyncWorkerProvider.java#L35" rel="external nofollow noopener noreferrer" target="_blank"><code>queueCreatorService</code></a> 属性，队列创建服务，用于创建 QueueEventHandler 对象。</li><li><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/AbstractLocalAsyncWorkerProvider.java#L40" rel="external nofollow noopener noreferrer" target="_blank"><code>#queueSize()</code></a> <strong>抽象</strong>方法，声明队列大小。</li><li><a href=""><code>#create(WorkerCreateListener)</code></a> <strong>实现</strong>方法，创建 AbstractLocalAsyncWorker 和 LocalAsyncWorkerRef 对象。<ul><li>第 51 行：创建 AbstractLocalAsyncWorker <strong>实现类</strong>的对象。参见 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationRegisterSerialWorker.java#L90" rel="external nofollow noopener noreferrer" target="_blank">ApplicationRegisterSerialWorker.Factory#workerInstance(ModuleManager)</a> 方法。</li><li>第 54 行：添加 AbstractLocalAsyncWorker 到 WorkerCreateListener ( Worker 创建监听器 )。WorkerCreateListener 在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（二）》「4.1 WorkerCreateListener」</a> 详细解析。</li><li>第 57 行：创建 LocalAsyncWorkerRef 对象。</li><li>第 60 行：调用 <code>QueueCreatorService#create(...)</code> 方法，创建 QueueEventHandler 对象，<strong>并设置 LocalAsyncWorkerRef 作为它的执行器</strong>。</li><li>第 63 行：设置 LocalAsyncWorkerRef 的 QueueEventHandler 属性。</li></ul></li></ul><h3 id="3-2-3-AbstractRemoteWorker"><a href="#3-2-3-AbstractRemoteWorker" class="headerlink" title="3.2.3 AbstractRemoteWorker"></a>3.2.3 AbstractRemoteWorker</h3><p><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/AbstractRemoteWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.stream.worker.base.AbstractRemoteWorker</code></a> ，远程 Worker <strong>抽象类</strong>，定义了 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/AbstractRemoteWorker.java#L45" rel="external nofollow noopener noreferrer" target="_blank"><code>#selector()</code></a> <strong>抽象</strong>方法，获得选择器。RemoteSenderService 根据选择器，调用 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/service/selector/RemoteClientSelector.java#L31" rel="external nofollow noopener noreferrer" target="_blank"><code>RemoteClientSelector#select(...)</code></a> 方法，选择好远程节点，而后进行发送数据。</p><p>实际使用时，继承 AbstractLocalAsyncWorker 类，实现 <code>#work(INPUT)</code> 方法，例如：<a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationRegisterRemoteWorker.java" rel="external nofollow noopener noreferrer" target="_blank">ApplicationRegisterRemoteWorker</a> 。</p><hr><p><code>org.skywalking.apm.collector.stream.worker.base.AbstractRemoteWorkerProvider</code> ，AbstractRemoteWorker 供应者<strong>抽象类</strong>。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/AbstractRemoteWorkerProvider.java#L40" rel="external nofollow noopener noreferrer" target="_blank"><code>remoteSenderService</code></a> 属性，远程发送服务。</li><li><a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/base/AbstractRemoteWorkerProvider.java#L56" rel="external nofollow noopener noreferrer" target="_blank"><code>#create(WorkerCreateListener)</code></a> <strong>实现</strong>方法，创建 AbstractRemoteWorker 和 RemoteWorkerRef 对象。<ul><li>第 58 行：创建 AbstractRemoteWorker <strong>实现类</strong>的对象。参见 <a href="https://github.com/YunaiV/skywalking/blob/a0d559d08e87879a08bd7269b9651188083ce05e/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/register/ApplicationRegisterRemoteWorker.java#L61" rel="external nofollow noopener noreferrer" target="_blank">ApplicationRegisterRemoteWorker.Factory#workerInstance(ModuleManager)</a> 方法。</li><li>第 61 行：添加 AbstractLocalAsyncWorker 到 WorkerCreateListener ( Worker 创建监听器 )。WorkerCreateListener 在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（二）》「4.1 WorkerCreateListener」</a> 详细解析。</li><li>第 64 行：创建 RemoteWorkerRef 对象。</li></ul></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>呼呼，蛮嗨皮的。卡了一个周末，差点又堕落了。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_25/13.png" alt=""></p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-streaming-first/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-streaming-first
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector Storage 存储组件</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-storage-module/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-storage-module/</id>
    <published>2020-08-19T16:00:00.000Z</published>
    <updated>2017-12-23T23:29:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">http://www.iocoder.cn/SkyWalking/collector-storage-module/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">2. apm-collector-core</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">2.1 Table</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">2.2 TableDefine</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">2.3 Data</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">3. collector-storage-define</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">3.1 StorageModule</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">3.2 table 包</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">3.3 StorageInstaller</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">3.4 dao 包</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">4. collector-storage-h2-provider</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">5. collector-storage-es-provider</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">5.1 StorageModuleEsProvider</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">5.2 define 包</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">5.3 dao 包</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">5.4 DataTTLKeeperTimer</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>SkyWalking Collector Storage 存储组件</strong>。顾名思义，负责将调用链路、应用、应用实例等等信息存储到存储器，例如，ES 、H2 。</p><blockquote><p>友情提示：建议先阅读 <a href="http://www.iocoder.cn/SkyWalking/collector-init/?self">《SkyWalking 源码分析 —— Collector 初始化》</a> ，以了解 Collector 组件体系。</p><p>FROM <a href="https://github.com/apache/incubating-skywalking" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubating-skywalking</a><br><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_20/01.jpeg" alt=""></p></blockquote><p>下面我们来看看整体的项目结构，如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_20/02.png" alt=""></p><ul><li><code>apm-collector-core</code> 的 <code>data</code> 和 <code>define</code> <strong>包</strong> ：数据的抽象。 </li><li><code>collector-storage-define</code> ：定义存储组件接口。</li><li><code>collector-storage-h2-provider</code> ：基于 H2 的 存储组件实现。<strong>该实现是单机版，建议仅用于 SkyWalking 快速上手，生产环境不建议使用</strong>。</li><li><code>collector-storage-es-provider</code> ：基于 Elasticsearch 的集群管理实现。<strong>生产环境推荐使用</strong>。</li></ul><p>下面，我们从<strong>接口到实现</strong>的顺序进行分享。</p><h1 id="2-apm-collector-core"><a href="#2-apm-collector-core" class="headerlink" title="2. apm-collector-core"></a>2. apm-collector-core</h1><p><code>apm-collector-core</code> 的 <code>data</code> 和 <code>define</code> <strong>包</strong>，如下图所示：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_20/03.png" alt=""></p><p>我们对类进行梳理分类，如下图：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_20/04.png" alt=""></p><ul><li>Table ：Data 和 TableDefine 之间的桥梁，每个 Table 定义了该表的<strong>表名</strong>，<strong>字段名们</strong>。</li><li>TableDefine ：Table 的详细定义，包括<strong>表名</strong>，<strong>字段定义</strong>( ColumnDefine )们。在下文中，<a href="https://github.com/apache/incubator-skywalking/blob/15328202b8b7df89a609885d9110361ff29ce668/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/apache/skywalking/apm/collector/storage/StorageInstaller.java" rel="external nofollow noopener noreferrer" target="_blank">StorageInstaller</a> 会基于 TableDefine 初始化表的相关信息。</li><li>Data ：数据，包括<strong>一条</strong>数据的数据值们和数据字段( Column )们。在下文中，<a href="https://github.com/apache/incubator-skywalking/blob/15328202b8b7df89a609885d9110361ff29ce668/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/apache/skywalking/apm/collector/storage/base/dao/DAO.java" rel="external nofollow noopener noreferrer" target="_blank">Dao</a> 会存储 Data 到存储器中。另外，在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（一）》</a> 中，我们也会看到对 Data 的流式处理<strong>通用</strong>封装。</li></ul><h2 id="2-1-Table"><a href="#2-1-Table" class="headerlink" title="2.1 Table"></a>2.1 Table</h2><p><a href="https://github.com/YunaiV/skywalking/blob/beebd8f8f419ca0b25dc086c71a9b1c580a083d4/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/CommonTable.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.core.data.CommonTable</code></a> ，通用表。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/beebd8f8f419ca0b25dc086c71a9b1c580a083d4/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/CommonTable.java#L33" rel="external nofollow noopener noreferrer" target="_blank"><code>TABLE_TYPE</code></a> <strong>静态</strong>属性，表类型。目前只有 ES 存储组件使用到，下文详细解析。</li><li><a href="https://github.com/YunaiV/skywalking/blob/beebd8f8f419ca0b25dc086c71a9b1c580a083d4/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/CommonTable.java#L37" rel="external nofollow noopener noreferrer" target="_blank"><code>COLUMN_</code></a> 前缀的<strong>静态</strong>属性，通用的字段名。</li></ul><p>在 <code>collector-storage-define</code> 的 <a href="https://github.com/YunaiV/skywalking/tree/beebd8f8f419ca0b25dc086c71a9b1c580a083d4/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table" rel="external nofollow noopener noreferrer" target="_blank"><code>table</code></a> <strong>包</strong>下，我们可以看到所有 Table 类，以 <code>&quot;Table&quot;</code> 结尾。每个 Table 的表名，在每个实现类里，例如 <a href="https://github.com/YunaiV/skywalking/blob/beebd8f8f419ca0b25dc086c71a9b1c580a083d4/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/register/ApplicationTable.java" rel="external nofollow noopener noreferrer" target="_blank">ApplicationTable</a> 。</p><h2 id="2-2-TableDefine"><a href="#2-2-TableDefine" class="headerlink" title="2.2 TableDefine"></a>2.2 TableDefine</h2><p><code>org.skywalking.apm.collector.core.data.TableDefine</code> ，表定义<strong>抽象类</strong>。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/beebd8f8f419ca0b25dc086c71a9b1c580a083d4/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/TableDefine.java#L34" rel="external nofollow noopener noreferrer" target="_blank"><code>name</code></a> 属性，表名。</li><li><a href="https://github.com/YunaiV/skywalking/blob/beebd8f8f419ca0b25dc086c71a9b1c580a083d4/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/TableDefine.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>columnDefines</code></a> 属性，ColumnDefine数组。</li><li><a href="https://github.com/YunaiV/skywalking/blob/578ea4f66f11bdfe5dcda25f574a1ed57ca47d24/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/TableDefine.java#L48" rel="external nofollow noopener noreferrer" target="_blank"><code>#initialize()</code></a> <strong>抽象</strong>方法，初始化表定义。例如：<a href="https://github.com/YunaiV/skywalking/blob/578ea4f66f11bdfe5dcda25f574a1ed57ca47d24/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/define/ApplicationEsTableDefine.java#L38" rel="external nofollow noopener noreferrer" target="_blank">ApplicationEsTableDefine</a> 。</li></ul><p>不同的存储组件实现，有不同的 TableDefine 实现类，如下图：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_20/05.png" alt=""></p><ul><li><p>ElasticSearchTableDefine ：基于 Elasticsearch 的表定义<strong>抽象类</strong>，在 <code>collector-storage-es-provider</code> 的 <a href="https://github.com/YunaiV/skywalking/tree/beebd8f8f419ca0b25dc086c71a9b1c580a083d4/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/define" rel="external nofollow noopener noreferrer" target="_blank"><code>define</code></a> <strong>包</strong>下，我们可以看到<strong>所有</strong> ES 的 TableDefine 类。</p></li><li><p>H2TableDefine ：基于 H2 的表定义<strong>抽象类</strong>，在 <code>collector-storage-h2-provider</code> 的 <a href="https://github.com/YunaiV/skywalking/tree/beebd8f8f419ca0b25dc086c71a9b1c580a083d4/apm-collector/apm-collector-storage/collector-storage-h2-provider/src/main/java/org/skywalking/apm/collector/storage/h2/define" rel="external nofollow noopener noreferrer" target="_blank"><code>define</code></a> <strong>包</strong>下，我们可以看到<strong>所有</strong> H2 的 TableDefine 类。</p></li></ul><h3 id="2-2-1-ColumnDefine"><a href="#2-2-1-ColumnDefine" class="headerlink" title="2.2.1 ColumnDefine"></a>2.2.1 ColumnDefine</h3><p> <a href="https://github.com/YunaiV/skywalking/blob/beebd8f8f419ca0b25dc086c71a9b1c580a083d4/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/ColumnDefine.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.core.data.ColumnDefine</code></a> ，字段定义<strong>抽象类</strong>。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/beebd8f8f419ca0b25dc086c71a9b1c580a083d4/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/ColumnDefine.java#L31" rel="external nofollow noopener noreferrer" target="_blank"><code>name</code></a> 属性，字段名。</li><li><a href="https://github.com/YunaiV/skywalking/blob/beebd8f8f419ca0b25dc086c71a9b1c580a083d4/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/ColumnDefine.java#L35" rel="external nofollow noopener noreferrer" target="_blank"><code>type</code></a> 属性，字段类型。</li></ul><p>在 <code>collector-storage-xxx-provider</code> 模块中，H2ColumnDefine 、ElasticSearchColumnDefine 实现 ColumnDefine 。</p><h3 id="2-2-2-Loader"><a href="#2-2-2-Loader" class="headerlink" title="2.2.2 Loader"></a>2.2.2 Loader</h3><p>涉及到的类如下图所示：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_20/06.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/0aa5e6a49c1f29b43824ebabf6bb7d76b80e3eb7/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/StorageDefineLoader.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.core.data.StorageDefineLoader</code></a> ，调用 <a href="https://github.com/YunaiV/skywalking/blob/0aa5e6a49c1f29b43824ebabf6bb7d76b80e3eb7/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/define/DefinitionLoader.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.core.define.DefinitionLoader</code></a> ，从 <a href="https://github.com/YunaiV/skywalking/blob/0aa5e6a49c1f29b43824ebabf6bb7d76b80e3eb7/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/StorageDefinitionFile.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.core.data.StorageDefinitionFile</code></a> 中，加载 TableDefine 实现类数组。</p><p>另外，在 <code>collector-storage-es-provider</code> 和 <code>collector-storage-h2-provider</code> 里都有 <code>storage.define</code> 文件，如下图：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_20/07.png" alt=""></p><ul><li>StorageDefinitionFile 声明了读取该文件。</li><li><strong>注意</strong>，DefinitionLoader 在加载时，两个文件都会被读取，最终在 <code>StorageInstaller#defineFilter(List&lt;TableDefine&gt;)</code> 方法，进行过滤。</li></ul><p>代码比较简单，中文注释已加，胖友自己阅读理解下。</p><h2 id="2-3-Data"><a href="#2-3-Data" class="headerlink" title="2.3 Data"></a>2.3 Data</h2><p><code>org.skywalking.apm.collector.core.data.Data</code>  ，数据<strong>抽象类</strong>。</p><ul><li><a href=""><code>dataXXX</code></a> <strong>前缀</strong>的属性，字段值们。<ul><li><a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/Data.java#L30" rel="external nofollow noopener noreferrer" target="_blank"><code>dataStrings</code></a> 属性的第一位，是 <strong>ID</strong> 属性。参见 <a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/Data.java#L51" rel="external nofollow noopener noreferrer" target="_blank"><strong>构造方法</strong></a>的【第 51 行】 或者 <a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/Data.java#L142" rel="external nofollow noopener noreferrer" target="_blank"><code>#setId(id)</code></a> 方法。</li></ul></li><li><a href=""><code>xxxColumns</code></a> <strong>后缀</strong>的属性，字段( Column )们。</li><li>通过上述两种属性 + 自身类，可以确定一条数据记录的表、字段类型、字段名、字段值。</li><li><strong>继承</strong> <a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/EndOfBatchQueueMessage.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.core.data.EndOfBatchQueueMessage</code></a> ，带是否消息批处理的最后一条标记的<strong>消息抽象类</strong>，<a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/EndOfBatchQueueMessage.java#L31" rel="external nofollow noopener noreferrer" target="_blank"><code>endOfBatch</code></a> 属性，在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（二）》「3. AggregationWorker」</a> 详细解析。<ul><li><strong>继承</strong> <a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/AbstractHashMessage.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.core.data.AbstractHashMessage</code></a> ，带哈希码的<strong>消息抽象类</strong>，<a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/AbstractHashMessage.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>hashCode</code></a> 属性，在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（二）》「3. AggregationWorker」</a> 详细解析。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/Data.java#L154" rel="external nofollow noopener noreferrer" target="_blank"><code>#mergeData(Data)</code></a> 方法，合并传入的数据到自身。该方法被 <a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-stream/src/main/java/org/skywalking/apm/collector/stream/worker/impl/AggregationWorker.java#L94" rel="external nofollow noopener noreferrer" target="_blank"><code>AggregationWorker#aggregate(message)</code></a> 调用，在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（二）》「3. AggregationWorker」</a> 详细解析。</li></ul><p>在 <code>collector-storage-define</code> 的 <a href="https://github.com/YunaiV/skywalking/tree/beebd8f8f419ca0b25dc086c71a9b1c580a083d4/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table" rel="external nofollow noopener noreferrer" target="_blank"><code>table</code></a> <strong>包</strong>下，我们可以看到所有 Data 类，<strong>非</strong> <code>&quot;Table&quot;</code> 结尾，例如 <a href="https://github.com/YunaiV/skywalking/blob/beebd8f8f419ca0b25dc086c71a9b1c580a083d4/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table/register/Application.java" rel="external nofollow noopener noreferrer" target="_blank">Application</a> 。</p><h3 id="2-3-1-Column"><a href="#2-3-1-Column" class="headerlink" title="2.3.1 Column"></a>2.3.1 Column</h3><p><a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/Column.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.core.data.Column</code></a> ，字段。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/Column.java#L31" rel="external nofollow noopener noreferrer" target="_blank"><code>name</code></a> 属性，字段名。</li><li><a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/Column.java#L35" rel="external nofollow noopener noreferrer" target="_blank"><code>operation</code></a> 属性，操作( Operation )。</li></ul><h3 id="2-3-2-Operation"><a href="#2-3-2-Operation" class="headerlink" title="2.3.2 Operation"></a>2.3.2 Operation</h3><p><a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/Operation.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.core.data.Operation</code></a> ，操作<strong>接口</strong>。用于两个值之间的操作，例如，相加等等。目前实现类有：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/operator/AddOperation.java" rel="external nofollow noopener noreferrer" target="_blank">AddOperation</a> ：值相加操作。</li><li><a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/operator/CoverOperation.java" rel="external nofollow noopener noreferrer" target="_blank">CoverOperation</a> ：值覆盖操作，即以新值为返回。</li><li><a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/data/operator/NonOperation.java" rel="external nofollow noopener noreferrer" target="_blank">NonOperation</a> ：空操作，即以老值为返回。</li></ul><h1 id="3-collector-storage-define"><a href="#3-collector-storage-define" class="headerlink" title="3. collector-storage-define"></a>3. collector-storage-define</h1><p><code>collector-cluster-define</code> ：定义存储组件接口。项目结构如下 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_20/08.png" alt=""></p><h2 id="3-1-StorageModule"><a href="#3-1-StorageModule" class="headerlink" title="3.1 StorageModule"></a>3.1 StorageModule</h2><p><code>org.skywalking.apm.collector.storage.StorageModule</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java" rel="external nofollow noopener noreferrer" target="_blank">Module</a> 抽象类，集群管理 Module 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/StorageModule.java#L67" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回模块名为 <code>&quot;storage&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/StorageModule.java#L71" rel="external nofollow noopener noreferrer" target="_blank"><code>#services()</code></a> <strong>实现</strong>方法，返回 Service 类名：在 <a href="https://github.com/YunaiV/skywalking/tree/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/dao" rel="external nofollow noopener noreferrer" target="_blank">org.skywalking.apm.collector.storage.dao</a> <strong>包</strong>下的所有类 和 IBatchDAO。</p><h2 id="3-2-table-包"><a href="#3-2-table-包" class="headerlink" title="3.2 table 包"></a>3.2 table 包</h2><p>在 <a href="https://github.com/YunaiV/skywalking/tree/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/table" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.table</code></a> 包下，定义了存储模块所有的 Table 和 Data 实现类。</p><h2 id="3-3-StorageInstaller"><a href="#3-3-StorageInstaller" class="headerlink" title="3.3 StorageInstaller"></a>3.3 StorageInstaller</h2><p><code>org.skywalking.apm.collector.storage.StorageInstaller</code> ，存储安装器<strong>抽象类</strong>，基于 TableDefine ，初始化存储组件的表。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/2b700457124e7d4f788343d8bcd9a03d2e273aca/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/StorageInstaller.java#L71" rel="external nofollow noopener noreferrer" target="_blank"><code>#defineFilter(List&lt;TableDefine&gt;)</code></a> <strong>抽象</strong>方法，过滤 TableDefine 数组中，非自身需要的。例如说，ElasticSearchStorageInstaller 过滤后，只保留 ElasticSearchTableDefine 对象。</li><li><a href="https://github.com/YunaiV/skywalking/blob/2b700457124e7d4f788343d8bcd9a03d2e273aca/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/StorageInstaller.java#L81" rel="external nofollow noopener noreferrer" target="_blank"><code>#isExists(Client, TableDefine)</code></a> <strong>抽象</strong>方法，判断表是否存在。</li><li><a href="https://github.com/YunaiV/skywalking/blob/2b700457124e7d4f788343d8bcd9a03d2e273aca/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/StorageInstaller.java#L81" rel="external nofollow noopener noreferrer" target="_blank"><code>#deleteTable(Client, TableDefine)</code></a> <strong>抽象</strong>方法，删除表。</li><li><a href="https://github.com/YunaiV/skywalking/blob/2b700457124e7d4f788343d8bcd9a03d2e273aca/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/StorageInstaller.java#L81" rel="external nofollow noopener noreferrer" target="_blank"><code>#createTable(Client, TableDefine)</code></a> <strong>抽象</strong>方法，创建表。</li><li><a href="https://github.com/YunaiV/skywalking/blob/2b700457124e7d4f788343d8bcd9a03d2e273aca/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/StorageInstaller.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>#install(Client)</code></a> 方法，基于 TableDefine ，初始化存储组件的表。<ul><li>该方法会被 StorageModuleH2Provider 或 StorageModuleEsProvider 启动时调用。</li></ul></li></ul><h2 id="3-4-dao-包"><a href="#3-4-dao-包" class="headerlink" title="3.4 dao 包"></a>3.4 dao 包</h2><p>在 <code>collector-storage-define</code> 项目结构图，我们看到一共有<strong>两</strong>个 <code>bao</code> 包：</p><ul><li><code>org.skywalking.apm.collector.storage.base.dao</code> ，<strong>系统</strong>的 DAO 接口。</li><li><code>org.skywalking.apm.collector.storage.dao</code> ，<strong>业务</strong>的 DAO 接口。<ul><li><strong>继承</strong>系统的 DAO 接口。</li><li>被 <code>collector-storage-xxx-provider</code> 的 <code>dao</code> 包<strong>实现</strong>。</li></ul></li></ul><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_20/09.png" alt=""></p><h3 id="3-4-1-系统-DAO"><a href="#3-4-1-系统-DAO" class="headerlink" title="3.4.1 系统 DAO"></a>3.4.1 系统 DAO</h3><p><a href="https://github.com/YunaiV/skywalking/blob/2b700457124e7d4f788343d8bcd9a03d2e273aca/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/base/dao/DAO.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.base.dao.DAO</code></a> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> 接口，DAO <strong>接口</strong>。</p><p>无任何方法。</p><h4 id="3-4-1-1-AbstractDAO"><a href="#3-4-1-1-AbstractDAO" class="headerlink" title="3.4.1.1 AbstractDAO"></a>3.4.1.1 AbstractDAO</h4><p><a href="https://github.com/YunaiV/skywalking/blob/2b700457124e7d4f788343d8bcd9a03d2e273aca/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/base/dao/AbstractDAO.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.base.dao.AbstractDAO</code></a> ，实现 DAO 接口，DAO 抽象基类。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/2b700457124e7d4f788343d8bcd9a03d2e273aca/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/base/dao/AbstractDAO.java#L33" rel="external nofollow noopener noreferrer" target="_blank"><code>client</code></a> 属性，数据操作客户端。例如，H2Client 、ElasticSearchClient 。</li></ul><p>在 <code>collector-storage-xxx-provider</code> 模块中，H2DAO 、EsDAO 实现 AbstractDAO 。</p><h4 id="3-4-1-2-IPersistenceDAO"><a href="#3-4-1-2-IPersistenceDAO" class="headerlink" title="3.4.1.2 IPersistenceDAO"></a>3.4.1.2 IPersistenceDAO</h4><p><code>org.skywalking.apm.collector.storage.base.dao.IPersistenceDAO</code> ，实现 DAO 接口，持久化 DAO <strong>接口</strong>，定义了 Data 的增删改查操作。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/2b700457124e7d4f788343d8bcd9a03d2e273aca/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/base/dao/IPersistenceDAO.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>#get(id)</code></a> <strong>接口</strong>方法，根据 ID 查询一条 Data 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/2b700457124e7d4f788343d8bcd9a03d2e273aca/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/base/dao/IPersistenceDAO.java#L68" rel="external nofollow noopener noreferrer" target="_blank"><code>#deleteHistory(startTimestamp, endTimestamp)</code></a> <strong>接口</strong>方法，删除时间范围内的 Data 们。</li><li><a href="https://github.com/YunaiV/skywalking/blob/2b700457124e7d4f788343d8bcd9a03d2e273aca/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/base/dao/IPersistenceDAO.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>#prepareBatchInsert(data)</code></a> <strong>接口</strong>方法，准备批量插入操作对象。例如：<a href="https://github.com/YunaiV/skywalking/blob/2b700457124e7d4f788343d8bcd9a03d2e273aca/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/CpuMetricEsPersistenceDAO.java" rel="external nofollow noopener noreferrer" target="_blank"><code>CpuMetricEsPersistenceDAO#prepareBatchInsert(CpuMetric)</code></a> 方法，返回的是 <code>org.elasticsearch.action.index.IndexRequestBuilder</code> 对象。注意：<ul><li>该方法不会发起具体的 DAO 操作，仅仅是创建插入操作对象，最终的执行在 <code>IBatchDAO#batchPersistence(List&lt;?&gt;)</code>。</li><li>该方法创建的是批量插入操作对象们中的一个。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/2b700457124e7d4f788343d8bcd9a03d2e273aca/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/base/dao/IPersistenceDAO.java#L60" rel="external nofollow noopener noreferrer" target="_blank"><code>#prepareBatchUpdate(data)</code></a> <strong>接口</strong>方法，准备批量更新操作对象。类似 <code>#prepareBatchInsert(data)</code> 方法。</li></ul><h4 id="3-4-1-3-IBatchDAO"><a href="#3-4-1-3-IBatchDAO" class="headerlink" title="3.4.1.3 IBatchDAO"></a>3.4.1.3 IBatchDAO</h4><p><code>org.skywalking.apm.collector.storage.base.dao.IBatchDAO</code> ，实现 DAO 接口，批量操作 DAO <strong>接口</strong>。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/2b700457124e7d4f788343d8bcd9a03d2e273aca/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/base/dao/IBatchDAO.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>#batchPersistence(List&lt;?&gt; batchCollection)</code></a> <strong>接口</strong>方法，通过执行批量操作对象数组，实现批量持久化数据。<ul><li><code>batchCollection</code> <strong>方法参数</strong>，通过 <code>IPersistenceDAO#prepareBatchInsert</code> 或 <code>IPersistenceDAO#prepareBatchUpdate</code> 方法，生成<strong>每个</strong>操作数组元素。</li><li>该方法会被 <code>PersistenceTimer#extractDataAndSave(...)</code> 或 <code>PersistenceWorker#onWork(...)</code> 方法调用，在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（二）》「4. PersistenceWorker」</a> 详细解析。</li></ul></li></ul><p>在 <code>collector-storage-xxx-provider</code> 模块中，BatchH2DAO 、BatchEsDAO 实现 IBatchDAO 。</p><h3 id="3-4-2-业务-DAO"><a href="#3-4-2-业务-DAO" class="headerlink" title="3.4.2 业务 DAO"></a>3.4.2 业务 DAO</h3><p>在 <a href="https://github.com/YunaiV/skywalking/blob/445bf9da669784b28d24f2e31576d3b0673c2852/apm-collector/apm-collector-storage/collector-storage-define/src/main/java/org/skywalking/apm/collector/storage/StorageModule.java#L71" rel="external nofollow noopener noreferrer" target="_blank"><code>StorageModule#services()</code></a> 方法里，我们可以看到，业务 DAO 按照<strong>用途</strong>可以拆分成<strong>四种</strong>：</p><ul><li>Cache ：缓存应用、应用实例、服务名</li><li>Register ：注册应用、应用实例、服务名</li><li>Persistence ：持久化，实际可以理解成批量持久化</li><li>UI ：SkyWaling UI 查询使用。</li></ul><p>那么整理如下：</p><table><thead><tr><th>Package</th><th>Data</th><th>Cache / Register</th><th>Persistence</th><th>UI</th><th>关联文章</th></tr></thead><tbody><tr><td>register</td><td>Application</td><td>√</td><td></td><td></td><td></td></tr><tr><td>register</td><td>Instance</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>register</td><td>ServiceName</td><td>√</td><td></td><td></td><td></td></tr><tr><td>jvm</td><td>CpuMetric</td><td></td><td>√</td><td>√</td><td></td></tr><tr><td>jvm</td><td>CMetric</td><td></td><td>√</td><td>√</td><td></td></tr><tr><td>jvm</td><td>MemoryMetric</td><td></td><td>√</td><td>√</td><td></td></tr><tr><td>jvm</td><td>MemoryPoolMetric</td><td></td><td>√</td><td>√</td><td></td></tr><tr><td>global</td><td>GlobalTrace</td><td></td><td>√</td><td>√</td><td></td></tr><tr><td>instance</td><td>InstPerformance</td><td></td><td>√</td><td>√</td><td></td></tr><tr><td>node</td><td>NodeComponent</td><td></td><td>√</td><td>√</td><td></td></tr><tr><td>node</td><td>NodeMapping</td><td></td><td>√</td><td>√</td><td></td></tr><tr><td>noderef</td><td>NodeReference</td><td></td><td>√</td><td>√</td><td></td></tr><tr><td>segment</td><td>SegmentCost</td><td></td><td>√</td><td>√</td><td></td></tr><tr><td>segment</td><td>Segment</td><td></td><td>√</td><td>√</td><td></td></tr><tr><td>service</td><td>ServiceEntry</td><td></td><td>√</td><td>√</td><td></td></tr><tr><td>serviceref</td><td>ServiceReference</td><td></td><td>√</td><td>√</td></tr></tbody></table><h1 id="4-collector-storage-h2-provider"><a href="#4-collector-storage-h2-provider" class="headerlink" title="4. collector-storage-h2-provider"></a>4. collector-storage-h2-provider</h1><p><code>collector-storage-h2-provider</code> ，基于 H2 的存储组件实现。项目结构如下 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_20/12.png" alt=""></p><p><strong>该实现是单机版，建议仅用于 SkyWalking 快速上手，生产环境不建议使用</strong>。</p><p>由于生产环境主要使用 ES 的存储组件实现，所以本文暂不解析相关实现，感兴趣的胖友自己嗨起来。</p><h1 id="5-collector-storage-es-provider"><a href="#5-collector-storage-es-provider" class="headerlink" title="5. collector-storage-es-provider"></a>5. collector-storage-es-provider</h1><p><code>collector-storage-es-provider</code> ，基于 ES 的存储组件实现。项目结构如下 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_20/10.png" alt=""></p><p>实际使用时，通过 <code>application.yml</code> 配置如下：</p><figure class="highlight"><table><tr><td class="code"><pre><div class="line">storage:</div><div class="line">  elasticsearch:</div><div class="line">    cluster_name: elasticsearch</div><div class="line">    cluster_transport_sniffer: true</div><div class="line">    cluster_nodes: 127.0.0.1:9300</div><div class="line">    index_shards_number: 2</div><div class="line">    index_replicas_number: 0</div><div class="line">    ttl: 7</div></pre></td></tr></table></figure><ul><li>生产环境下，推荐 Elasticsearch 配置成集群。</li><li><code>cluster_name</code> 、<code>cluster_transport_sniffer</code> 、<code>cluster_nodes</code> 、<code>index_shards_number</code> 、<code>index_replicas_number</code> 参数，Elasticsearch 相关参数。</li><li><code>ttl</code> ：保留 N 天内的数据。超过 N 天的数据，将被自动滚动删除。<ul><li>该功能目前版本<strong>暂未发布</strong>，需要等到 5.0 版本后。</li></ul></li><li><a href="https://github.com/apache/incubator-skywalking/blob/master/docs/cn/Deploy-collector-in-cluster-mode-CN.md" rel="external nofollow noopener noreferrer" target="_blank">《部署集群collector》</a></li></ul><h2 id="5-1-StorageModuleEsProvider"><a href="#5-1-StorageModuleEsProvider" class="headerlink" title="5.1 StorageModuleEsProvider"></a>5.1 StorageModuleEsProvider</h2><p><code>org.skywalking.apm.collector.storage.es.StorageModuleEsProvider</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java" rel="external nofollow noopener noreferrer" target="_blank">ModuleProvider</a> <strong>抽象类</strong>，基于 ES 的存储组件服务提供者。</p><p><a href="https://github.com/YunaiV/skywalking/blob/7eecc004e69685fe6f5ce3b3dc4822475d6aa713/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/StorageModuleEsProvider.java#L62" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回组件服务提供者名为 <code>&quot;elasticsearch&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/7eecc004e69685fe6f5ce3b3dc4822475d6aa713/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/StorageModuleEsProvider.java#L66" rel="external nofollow noopener noreferrer" target="_blank"><code>module()</code></a> <strong>实现</strong>方法，返回组件类为 StorageModule 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/7eecc004e69685fe6f5ce3b3dc4822475d6aa713/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/StorageModuleEsProvider.java#L119" rel="external nofollow noopener noreferrer" target="_blank"><code>#requiredModules()</code></a> <strong>实现</strong>方法，返回依赖组件为 <code>&quot;cluster&quot;</code> 。</p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/7eecc004e69685fe6f5ce3b3dc4822475d6aa713/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/StorageModuleEsProvider.java#L70" rel="external nofollow noopener noreferrer" target="_blank"><code>#prepare(Properties)</code></a> <strong>实现</strong>方法，执行准备阶段逻辑。</p><ul><li>第 71 至 75 行 ：创建 <a href="https://github.com/YunaiV/skywalking/blob/7eecc004e69685fe6f5ce3b3dc4822475d6aa713/apm-collector/apm-collector-component/client-component/src/main/java/org/skywalking/apm/collector/client/elasticsearch/ElasticSearchClient.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.client.elasticsearch.ElasticSearchClient</code></a> 对象。</li><li>第 77 至 82 行 ：创建 DAO 对象们，并调用 <code>#registerServiceImplementation()</code> <strong>父类</strong>方法，注册到 <code>services</code> 。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/7eecc004e69685fe6f5ce3b3dc4822475d6aa713/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/StorageModuleEsProvider.java#L85" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> <strong>实现</strong>方法，执行启动阶段逻辑。</p><ul><li>第 90 行 ：调用 <code>ElasticSearchClient#initialize()</code> 方法，初始化 ZookeeperClient 。</li><li>第 93 至 94 行 ：创建 ElasticSearchStorageInstaller 对象，初始化存储组件的表。在 <a href="#">「5.2.4 ElasticSearchStorageInstaller」</a> 详细解析。</li><li>第 100 至 102 行 ：创建 <a href="https://github.com/YunaiV/skywalking/blob/7eecc004e69685fe6f5ce3b3dc4822475d6aa713/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/StorageModuleEsRegistration.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.es.StorageModuleEsRegistration</code></a> 对象，并注册信息到集群管理。在 <a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/?self">《SkyWalking 源码分析 —— Collector Cluster 集群管理》</a> 有详细解析。</li><li>第 105 至 107 行 ：创建 <a href="https://github.com/YunaiV/skywalking/blob/7eecc004e69685fe6f5ce3b3dc4822475d6aa713/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/StorageModuleEsNamingListener.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.storage.es.StorageModuleEsNamingListener</code></a> 对象，并注册信息到集群管理。在 <a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/?self">《SkyWalking 源码分析 —— Collector Cluster 集群管理》</a> 有详细解析。</li><li>第 110 至 111 行 ：创建 DataTTLKeeperTimer 对象。在 <a href="#">「5.4 DataTTLKeeperTimer」</a> 详细解析。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/7eecc004e69685fe6f5ce3b3dc4822475d6aa713/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/StorageModuleEsProvider.java#L114" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyAfterCompleted()</code></a> <strong>实现</strong>方法，执行启动完成逻辑。</p><ul><li>第 115 行 ：调用 <code>DataTTLKeeperTimer#start()</code> 方法，启动 DataTTLKeeperTimer 。在本文 <a href="#">「5.4 DataTTLKeeperTimer」</a> 详细解析。</li></ul><h2 id="5-2-define-包"><a href="#5-2-define-包" class="headerlink" title="5.2 define 包"></a>5.2 define 包</h2><p>在 <code>collector-storage-es-provider</code> 项目结构图，我们看到一共有<strong>两</strong>个 <code>define</code> 包：</p><ul><li><code>org.skywalking.apm.collector.storage.es.base.define</code> ，<strong>系统</strong>的 TableDefine 抽象类。</li><li><code>org.skywalking.apm.collector.storage.es.define</code> ，<strong>业务</strong>的 TableDefine 实现类。<ul><li><strong>继承</strong>系统的 TableDefine 抽象类。</li></ul></li></ul><h3 id="5-2-1-ElasticSearchTableDefine"><a href="#5-2-1-ElasticSearchTableDefine" class="headerlink" title="5.2.1 ElasticSearchTableDefine"></a>5.2.1 ElasticSearchTableDefine</h3><p><code>org.skywalking.apm.collector.storage.es.base.define.ElasticSearchTableDefine</code> ，实现 TableDefine 接口，基于 Elasticsearch 的表定义<strong>抽象类</strong>。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/7a4a409e266b953e523dca14a7ba88af07039f57/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/base/define/ElasticSearchTableDefine.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>#type()</code></a> 方法，文档元数据 <code>_type</code> 字段，参见  <a href="http://geosmart.github.io/2016/07/22/Elasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#type" rel="external nofollow noopener noreferrer" target="_blank">《Elasticsearch学习笔记》「_type」</a> 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/7a4a409e266b953e523dca14a7ba88af07039f57/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/base/define/ElasticSearchTableDefine.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#refreshInterval()</code></a> <strong>抽象</strong>方法，文档索引刷新频率，参见 <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/near-real-time.html#refresh-api" rel="external nofollow noopener noreferrer" target="_blank">《Elasticsearch: 权威指南 » 基础入门 » 分片内部原理 » 近实时搜索》「refresh API」</a>。</li></ul><h3 id="5-2-2-ElasticSearchColumnDefine"><a href="#5-2-2-ElasticSearchColumnDefine" class="headerlink" title="5.2.2 ElasticSearchColumnDefine"></a>5.2.2 ElasticSearchColumnDefine</h3><p><code>org.skywalking.apm.collector.storage.es.base.define.ElasticSearchColumnDefine</code> ，实现 ColumnDefine 抽象类，基于 ES 的字段定义。</p><ul><li><a href="https://github.com/peng-yongsheng/incubator-skywalking/blob/89c601ba386d30acb04b3713a90b52e6c0d501d8/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/apache/skywalking/apm/collector/storage/es/base/define/ElasticSearchColumnDefine.java#L32" rel="external nofollow noopener noreferrer" target="_blank">Type</a> <strong>枚举</strong>类：枚举 ES 字段类型。</li></ul><h3 id="5-2-3-业务-TableDefine-实现类"><a href="#5-2-3-业务-TableDefine-实现类" class="headerlink" title="5.2.3 业务 TableDefine 实现类"></a>5.2.3 业务 TableDefine 实现类</h3><p>在 <a href="https://github.com/peng-yongsheng/incubator-skywalking/tree/89c601ba386d30acb04b3713a90b52e6c0d501d8/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/apache/skywalking/apm/collector/storage/es/define" rel="external nofollow noopener noreferrer" target="_blank"><code>org.apache.skywalking.apm.collector.storage.es.define</code></a> <strong>包</strong>里，我们可以看到，<strong>所有</strong>基于 ES 的业务 TableDefine 实现类。例如：<a href="https://github.com/peng-yongsheng/incubator-skywalking/blob/89c601ba386d30acb04b3713a90b52e6c0d501d8/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/apache/skywalking/apm/collector/storage/es/define/ApplicationEsTableDefine.java" rel="external nofollow noopener noreferrer" target="_blank">ApplicationEsTableDefine</a> 。</p><p>整体 <code>#refreshInterval()</code> 方法返回的结果如下：</p><ul><li>1 s<ul><li>CpuMetricEsTableDefine</li><li>GCMetricEsTableDefine</li><li>MemoryMetricEsTableDefine</li><li>MemoryPoolMetricEsTableDefine</li></ul></li><li>2 s<ul><li>InstPerformanceEsTableDefine </li><li>NodeComponentEsTableDefine</li><li>NodeMappingEsTableDefine</li><li>NodeReferenceEsTableDefine</li><li>ServiceEntryEsTableDefine</li><li>ServiceReferenceEsTableDefine</li></ul></li><li>2 s &amp;&amp; <a href="https://static.javadoc.io/org.elasticsearch/elasticsearch/5.0.0/org/elasticsearch/action/support/WriteRequest.RefreshPolicy.html#IMMEDIATE" rel="external nofollow noopener noreferrer" target="_blank">WriteRequest.RefreshPolicy.IMMEDIATE</a><ul><li>【WriteRequest.RefreshPolicy.IMMEDIATE】参见 <a href="https://github.com/YunaiV/skywalking/blob/6f925c180fbd1bb543fbf5bbf6fafe118f031d11/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/ApplicationEsRegisterDAO.java#L60" rel="external nofollow noopener noreferrer" target="_blank"><code>ApplicationEsRegisterDAO#save(Application)</code></a> 方法</li><li>ApplicationEsTableDefine</li><li>InstanceEsTableDefine</li><li>ServiceNameEsTableDefine</li></ul></li><li>5 s<ul><li>GlobalTraceEsTableDefine</li><li>SegmentCostEsTableDefine</li></ul></li><li>10 s<ul><li>SegmentEsTableDefine</li></ul></li></ul><h3 id="5-2-4-ElasticSearchStorageInstaller"><a href="#5-2-4-ElasticSearchStorageInstaller" class="headerlink" title="5.2.4 ElasticSearchStorageInstaller"></a>5.2.4 ElasticSearchStorageInstaller</h3><blockquote><p>友情提示：ElasticSearchStorageInstaller 主要是对 Elasticsearch Java API 的使用，所以不熟悉的胖友，可以 Google 下。</p></blockquote><p><code>org.skywalking.apm.collector.storage.es.base.define.ElasticSearchStorageInstaller</code> ，实现 StorageInstaller 抽象类， 基于 ES 存储安装器实现类。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/222024defff2d1a7647dbeb5811cad146c49a604/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/base/define/ElasticSearchStorageInstaller.java#L53" rel="external nofollow noopener noreferrer" target="_blank"><code>#defineFilter(List&lt;TableDefine&gt;)</code></a> <strong>实现</strong>方法，过滤数组中，非 ElasticSearchTableDefine 的元素。</li><li><a href="https://github.com/YunaiV/skywalking/blob/222024defff2d1a7647dbeb5811cad146c49a604/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/base/define/ElasticSearchStorageInstaller.java#L63" rel="external nofollow noopener noreferrer" target="_blank"><code>#createTable(Client, TableDefine)</code></a> <strong>实现</strong>方法，创建 Elasticsearch 索引。<ul><li>文档数据结构如下：<ul><li><code>_id</code> ：数据编号，String 类型。</li><li><code>_type</code> ：<code>&quot;type&quot;</code> 。</li><li><code>_index</code> ：TableDefine 定义的<strong>表名</strong>。</li><li><code>source</code>  ：Data 数据。</li></ul></li><li>了解 Elasticsearch 的胖友可能有和笔者一样的疑惑，网络上很多文章把 <code>_index</code> 类比成关系数据库的 DB ，<code>_type</code> 类比成关系数据库的 Table ，和 SkyWalking 目前使用的方式<strong>不一致</strong>？<ul><li>SkyWalking <a href="https://github.com/peng-yongsheng" rel="external nofollow noopener noreferrer" target="_blank">彭勇升</a> ：<code>_index</code>和 <code>_type</code> 是 ES 特有的，考虑其他数据库接入，所以没有用他这个特性。</li><li>SkyWalking QQ交流群( 392443393 ) ，<a href="#">小心</a> 群友 ：<code>_type</code> 本来就没做物理隔离，Lucene 层面也不存在，ES 6.x 已经废弃了。</li><li><a href="https://elasticsearch.cn/article/158" rel="external nofollow noopener noreferrer" target="_blank">《Elasticsearch 6.0 将移除 Type》</a></li></ul></li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/222024defff2d1a7647dbeb5811cad146c49a604/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/base/define/ElasticSearchStorageInstaller.java#L131" rel="external nofollow noopener noreferrer" target="_blank"><code>#deleteTable(Client, TableDefine)</code></a> <strong>实现</strong>方法，删除 Elasticsearch 索引。</li><li><a href="https://github.com/YunaiV/skywalking/blob/222024defff2d1a7647dbeb5811cad146c49a604/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/base/define/ElasticSearchStorageInstaller.java#L141" rel="external nofollow noopener noreferrer" target="_blank"><code>#isExists(Client, TableDefine)</code></a> <strong>实现</strong>方法，判断 Elasticsearch 索引是否存在。</li><li>在方法里，笔者添加了一些 API 的说明，不熟悉的胖友，可以仔细阅读理解。</li></ul><h2 id="5-3-dao-包"><a href="#5-3-dao-包" class="headerlink" title="5.3 dao 包"></a>5.3 dao 包</h2><p>在 <code>collector-storage-es-provider</code> 项目结构图，我们看到一共有<strong>两</strong>个 <code>dao</code> 包：</p><ul><li><code>org.skywalking.apm.collector.storage.es.base.dao</code> ，<strong>系统</strong>的 DAO 抽象类。</li><li><code>org.skywalking.apm.collector.storage.es.dao</code> ，<strong>业务</strong>的 DAO 实现类。<ul><li><strong>继承</strong>系统的 DAO 抽象类。</li></ul></li></ul><h3 id="5-3-1-EsDAO"><a href="#5-3-1-EsDAO" class="headerlink" title="5.3.1 EsDAO"></a>5.3.1 EsDAO</h3><p><code>org.skywalking.apm.collector.storage.es.base.dao.EsDAO</code> ，实现 AbstractDAO 抽象类，基于 ES 的 DAO <strong>抽象类</strong>。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/6f925c180fbd1bb543fbf5bbf6fafe118f031d11/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/base/dao/EsDAO.java#L49" rel="external nofollow noopener noreferrer" target="_blank"><code>#getMaxId(indexName, columnName)</code></a> 方法，获得索引名的指定字段的<strong>最大值</strong>。</li><li><a href="https://github.com/YunaiV/skywalking/blob/6f925c180fbd1bb543fbf5bbf6fafe118f031d11/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/base/dao/EsDAO.java#L75" rel="external nofollow noopener noreferrer" target="_blank"><code>#getMinId(indexName, columnName)</code></a> 方法，获得索引名的指定字段的<strong>最小值</strong>。</li></ul><h3 id="5-3-2-BatchEsDAO"><a href="#5-3-2-BatchEsDAO" class="headerlink" title="5.3.2 BatchEsDAO"></a>5.3.2 BatchEsDAO</h3><p><code>org.skywalking.apm.collector.storage.es.base.dao.BatchEsDAO</code> ，实现 IBatchDAO 接口，继承 EsDAO 抽象类，基于 ES 批量操作 DAO 实现类。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/6f925c180fbd1bb543fbf5bbf6fafe118f031d11/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/base/dao/BatchEsDAO.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#batchPersistence(List&lt;?&gt;)</code></a> <strong>实现</strong>方法，将 <code>org.elasticsearch.action.index.IndexRequestBuilder</code> 和 <code>org.elasticsearch.action.index.UpdateRequestBuilder</code> 数组，创建成 <code>org.elasticsearch.action.bulk.BulkRequestBuilder</code> 对象，批量持久化。<ul><li>IndexRequestBuilder 和 UpdateRequestBuilder 的创建，在 <a href="#">「5.3.3 业务 DAO 实现类」</a> 会看到。</li></ul></li></ul><h3 id="5-3-3-业务-DAO-实现类"><a href="#5-3-3-业务-DAO-实现类" class="headerlink" title="5.3.3 业务 DAO 实现类"></a>5.3.3 业务 DAO 实现类</h3><p>在 <a href="https://github.com/YunaiV/skywalking/tree/6f925c180fbd1bb543fbf5bbf6fafe118f031d11/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao" rel="external nofollow noopener noreferrer" target="_blank"><code>org.apache.skywalking.apm.collector.storage.es.dao</code></a> <strong>包</strong>里，我们可以看到，<strong>所有</strong>基于 ES 的业务 DAO 实现类。</p><p>实现代码易懂，胖友可以自己阅读。良心如我们，按照 DAO 的业务用途，推荐例子如下：</p><ul><li>Cache ：<a href="https://github.com/YunaiV/skywalking/blob/6f925c180fbd1bb543fbf5bbf6fafe118f031d11/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/ApplicationEsCacheDAO.java" rel="external nofollow noopener noreferrer" target="_blank">ApplicationEsCacheDAO</a></li><li>Register ：<a href="https://github.com/YunaiV/skywalking/blob/6f925c180fbd1bb543fbf5bbf6fafe118f031d11/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/ApplicationEsRegisterDAO.java" rel="external nofollow noopener noreferrer" target="_blank">ApplicationEsRegisterDAO</a> </li><li>Persistence ：<a href="https://github.com/YunaiV/skywalking/blob/6f925c180fbd1bb543fbf5bbf6fafe118f031d11/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/SegmentEsPersistenceDAO.java" rel="external nofollow noopener noreferrer" target="_blank">SegmentEsPersistenceDAO</a><ul><li>此处可见 IndexRequestBuilder 和 UpdateRequestBuilder 的创建。</li></ul></li><li>UI ：<a href="https://github.com/YunaiV/skywalking/blob/6f925c180fbd1bb543fbf5bbf6fafe118f031d11/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/dao/SegmentEsUIDAO.java" rel="external nofollow noopener noreferrer" target="_blank">SegmentEsUIDAO</a> </li></ul><h2 id="5-4-DataTTLKeeperTimer"><a href="#5-4-DataTTLKeeperTimer" class="headerlink" title="5.4 DataTTLKeeperTimer"></a>5.4 DataTTLKeeperTimer</h2><p><code>org.skywalking.apm.collector.storage.es.DataTTLKeeperTimer</code> ，过期数据删除<strong>定时器</strong>。通过该定时器，只保留 N 天内的数据。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/efe2967813b706ae97901d7620fef9d7f975e745/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/DataTTLKeeperTimer.java#L47" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> 方法，启动定时任务。<ul><li>第 49 行：创建延迟 1 小时，每 8 小时执行一次 <code>#delete()</code> 方法的定时任务。目前该行代码被注释，胖友可以等待 SkyWallking 5.0 版本的发布。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/efe2967813b706ae97901d7620fef9d7f975e745/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/DataTTLKeeperTimer.java#L53" rel="external nofollow noopener noreferrer" target="_blank"><code>#delete()</code></a> 方法，删除过期数据。<ul><li>第 54 至 66 行：计算删除的开始与结束时间，即指定时间的<strong>前一天</strong>。例如，2017-12-23 执行时，删除 2017-12-16 那天的数据。</li><li>第 69 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/efe2967813b706ae97901d7620fef9d7f975e745/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/DataTTLKeeperTimer.java#L73" rel="external nofollow noopener noreferrer" target="_blank"><code>#deleteJVMRelatedData(startTimestamp, endTimestamp)</code></a> 方法，删除 JVM 相关的数据。</li><li>第 70 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/efe2967813b706ae97901d7620fef9d7f975e745/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/DataTTLKeeperTimer.java#L87" rel="external nofollow noopener noreferrer" target="_blank"><code>#deleteTraceRelatedData(startTimestamp, endTimestamp)</code></a> 方法，删除 Trace 相关的数据。</li></ul></li></ul><p>如下是<strong>不会删除</strong>的数据的表：</p><ul><li>Application</li><li>Instance</li><li>ServiceName</li><li>ServiceEntry</li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>😈 有种自己把简单的东西写的太复杂了，悲伤。</p><p>胖友望见谅。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_20/11.png" alt=""></p><p>胖友，分享一波朋友圈可好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-storage-module/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-storage-module/&lt;
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector Queue 队列组件</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-queue-module/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-queue-module/</id>
    <published>2020-08-14T16:00:00.000Z</published>
    <updated>2017-12-23T23:27:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/">http://www.iocoder.cn/SkyWalking/collector-queue-module/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/">2. collector-queue-define</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/">2.1 QueueModule</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/">2.2 QueueCreatorService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/">2.3 MessageHolder</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/">2.4 QueueEventHandler</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/">2.5 DaemonThreadFactory</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/">3. collector-queue-disruptor-provider</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/">3.1 QueueModuleDisruptorProvider</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/">2.2 DisruptorQueueCreatorService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/">3.3 DisruptorEventHandler</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/">4. collector-queue-datacarrier-provider</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>SkyWalking Collector Queue Module</strong>，队列组件。该组件被 Collector Streaming Module 流式处理使用，提供<strong>异步</strong>执行的特性。</p><blockquote><p>友情提示：建议先阅读 <a href="http://www.iocoder.cn/SkyWalking/collector-init/?self">《SkyWalking 源码分析 —— Collector 初始化》</a> ，以了解 Collector 组件体系。</p></blockquote><p>Cluster Module 在 SkyWalking 架构图处于如下位置( <strong>红框</strong> ) ：</p><blockquote><p>FROM <a href="https://github.com/apache/incubating-skywalking" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubating-skywalking</a><br><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_15/01.jpeg" alt=""></p></blockquote><p>下面我们来看看整体的项目结构，如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_15/02.png" alt=""></p><ul><li><code>collector-queue-define</code> ：定义队列组件接口。</li><li><code>collector-queue-datacarrier-provider</code> ：基于 <a href="https://github.com/YunaiV/skywalking/tree/master/apm-commons/apm-datacarrier" rel="external nofollow noopener noreferrer" target="_blank">apm-datacarrier</a> 的队列组件实现。<em>目前暂未完成</em>。</li><li><code>collector-queue-zookeeper-provider</code> ：基于 <a href="https://github.com/LMAX-Exchange/disruptor" rel="external nofollow noopener noreferrer" target="_blank">Disruptor</a> 的队列组件实现。</li></ul><p>下面，我们从<strong>接口到实现</strong>的顺序进行分享。</p><h1 id="2-collector-queue-define"><a href="#2-collector-queue-define" class="headerlink" title="2. collector-queue-define"></a>2. collector-queue-define</h1><p><code>collector-queue-define</code> ：定义队列组件接口。项目结构如下 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_15/03.png" alt=""></p><h2 id="2-1-QueueModule"><a href="#2-1-QueueModule" class="headerlink" title="2.1 QueueModule"></a>2.1 QueueModule</h2><p><code>org.skywalking.apm.collector.queue.QueueModule</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java" rel="external nofollow noopener noreferrer" target="_blank">Module</a> 抽象类，队列 Module 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-define/src/main/java/org/skywalking/apm/collector/queue/QueueModule.java#L33" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回模块名为 <code>&quot;queue&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-define/src/main/java/org/skywalking/apm/collector/queue/QueueModule.java#L37" rel="external nofollow noopener noreferrer" target="_blank"><code>#services()</code></a> <strong>实现</strong>方法，返回 Service 类名：QueueCreatorService 。</p><h2 id="2-2-QueueCreatorService"><a href="#2-2-QueueCreatorService" class="headerlink" title="2.2 QueueCreatorService"></a>2.2 QueueCreatorService</h2><p><code>org.skywalking.apm.collector.queue.service.QueueCreatorService</code> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> 接口，队列创建服务<strong>接口</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-define/src/main/java/org/skywalking/apm/collector/queue/service/QueueCreatorService.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>#create(queueSize, executor)</code></a> <strong>接口</strong>方法，创建队列处理器。</p><ul><li>一般情况下，实现该接口方法，调用 <a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-define/src/main/java/org/skywalking/apm/collector/queue/base/QueueCreator.java#L35" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.queue.base.QueueCreator#create(queueSize, executor)</code></a> 方法，创建队列处理器。</li></ul><h2 id="2-3-MessageHolder"><a href="#2-3-MessageHolder" class="headerlink" title="2.3 MessageHolder"></a>2.3 MessageHolder</h2><p><code>org.skywalking.apm.collector.queue.base.MessageHolder</code> ，消息持有者。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-define/src/main/java/org/skywalking/apm/collector/queue/base/MessageHolder.java#L33" rel="external nofollow noopener noreferrer" target="_blank"><code>message</code></a> 属性，持有的消息。</li><li><a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-define/src/main/java/org/skywalking/apm/collector/queue/base/MessageHolder.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#reset()</code></a> 方法，<strong>清空</strong>消息。为什么会有这个方法，下文胖友会看到。</li></ul><h2 id="2-4-QueueEventHandler"><a href="#2-4-QueueEventHandler" class="headerlink" title="2.4 QueueEventHandler"></a>2.4 QueueEventHandler</h2><p><a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-define/src/main/java/org/skywalking/apm/collector/queue/base/QueueEventHandler.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.queue.base.QueueEventHandler</code></a>，队列处理器<strong>接口</strong>。它定义了 <a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-define/src/main/java/org/skywalking/apm/collector/queue/base/QueueEventHandler.java#L33" rel="external nofollow noopener noreferrer" target="_blank"><code>#tell(message)</code></a> <strong>接口</strong>方法，输入消息给自己。最终，QueueEventHandler 会”<strong>提交</strong>“消息给 <a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-define/src/main/java/org/skywalking/apm/collector/queue/base/QueueExecutor.java#L28" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.queue.base.QueueExecutor</code></a>，执行处理该消息。</p><p>LocalAsyncWorkerRef 实现 QueueEventHandler 接口，在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（一）》「3.1.2 LocalAsyncWorkerRef」</a> 有详细解析。</p><h2 id="2-5-DaemonThreadFactory"><a href="#2-5-DaemonThreadFactory" class="headerlink" title="2.5 DaemonThreadFactory"></a>2.5 DaemonThreadFactory</h2><p><a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-define/src/main/java/org/skywalking/apm/collector/queue/base/DaemonThreadFactory.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.queue.base.DaemonThreadFactory</code></a>，守护进程线程<strong>工厂</strong>，被用于创建消息处理器的线程。</p><h1 id="3-collector-queue-disruptor-provider"><a href="#3-collector-queue-disruptor-provider" class="headerlink" title="3. collector-queue-disruptor-provider"></a>3. collector-queue-disruptor-provider</h1><p><code>collector-queue-disruptor-provider</code> ，基于 <a href="https://github.com/LMAX-Exchange/disruptor" rel="external nofollow noopener noreferrer" target="_blank">Disruptor</a> 的队列组件实现。</p><p>项目结构如下 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_15/04.png" alt=""></p><p><strong>默认配置</strong>，在 <a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-core/src/main/resources/application-default.yml#L7" rel="external nofollow noopener noreferrer" target="_blank"><code>application-default.yml</code></a> <strong>已经</strong>配置如下：</p><figure class="highlight"><table><tr><td class="code"><pre><div class="line">queue:</div><div class="line">  disruptor:</div></pre></td></tr></table></figure><h2 id="3-1-QueueModuleDisruptorProvider"><a href="#3-1-QueueModuleDisruptorProvider" class="headerlink" title="3.1 QueueModuleDisruptorProvider"></a>3.1 QueueModuleDisruptorProvider</h2><p><code>org.skywalking.apm.collector.queue.disruptor.CQueueModuleDisruptorProvider</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java" rel="external nofollow noopener noreferrer" target="_blank">ModuleProvider</a> <strong>抽象类</strong>，基于 Disruptor 的队列服务提供者。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-disruptor-provider/src/main/java/org/skywalking/apm/collector/queue/disruptor/QueueModuleDisruptorProvider.java#L35" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回组件服务提供者名为 <code>&quot;disruptor&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-disruptor-provider/src/main/java/org/skywalking/apm/collector/queue/disruptor/QueueModuleDisruptorProvider.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>module()</code></a> <strong>实现</strong>方法，返回组件类为 QueueModule 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-disruptor-provider/src/main/java/org/skywalking/apm/collector/queue/disruptor/QueueModuleDisruptorProvider.java#L55" rel="external nofollow noopener noreferrer" target="_blank"><code>#requiredModules()</code></a> <strong>实现</strong>方法，返回依赖组件为空。</p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-disruptor-provider/src/main/java/org/skywalking/apm/collector/queue/disruptor/QueueModuleDisruptorProvider.java#L43" rel="external nofollow noopener noreferrer" target="_blank"><code>#prepare(Properties)</code></a> <strong>实现</strong>方法，执行准备阶段逻辑。</p><ul><li>第 44 行 ：创建 DisruptorQueueCreatorService 对象，并调用 <code>#registerServiceImplementation()</code> <strong>父类</strong>方法，注册到 <code>services</code> 。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-disruptor-provider/src/main/java/org/skywalking/apm/collector/queue/disruptor/QueueModuleDisruptorProvider.java#L47" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> <strong>实现</strong>方法，方法为空。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-disruptor-provider/src/main/java/org/skywalking/apm/collector/queue/disruptor/QueueModuleDisruptorProvider.java#L51" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyAfterCompleted()</code></a> <strong>实现</strong>方法，方法为空。</p><h2 id="2-2-DisruptorQueueCreatorService"><a href="#2-2-DisruptorQueueCreatorService" class="headerlink" title="2.2 DisruptorQueueCreatorService"></a>2.2 DisruptorQueueCreatorService</h2><p><code>org.skywalking.apm.collector.queue.disruptor.service.DisruptorQueueCreatorService</code> ，实现 QueueCreatorService <strong>接口</strong>，基于 Disruptor 的队列创建服务<strong>实现类</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-disruptor-provider/src/main/java/org/skywalking/apm/collector/queue/disruptor/service/DisruptorQueueCreatorService.java#L42" rel="external nofollow noopener noreferrer" target="_blank"><code>#create(queueSize, executor)</code></a> <strong>实现</strong>方法，调用 <code>DisruptorQueueCreator#register(queueSize, executor)</code> 方法，创建队列处理器。</p><h3 id="3-2-1-DisruptorQueueCreator"><a href="#3-2-1-DisruptorQueueCreator" class="headerlink" title="3.2.1 DisruptorQueueCreator"></a>3.2.1 DisruptorQueueCreator</h3><blockquote><p>友情提示：如果胖友对 Disruptor 暂时不了解，建议先使用 Disruptor 写个小 Demo 。</p><p>如下是笔者阅读的文章：  </p><ul><li><a href="http://colobu.com/2014/08/01/3-steps-to-create-a-disruptor-application/" rel="external nofollow noopener noreferrer" target="_blank">《三步创建Disruptor应用》</a></li><li><a href="http://ifeve.com/disruptor-getting-started/" rel="external nofollow noopener noreferrer" target="_blank">《Disruptor入门》</a></li><li><a href="http://ifeve.com/dissecting-disruptor-whats-so-special/" rel="external nofollow noopener noreferrer" target="_blank">《剖析Disruptor:为什么会这么快？（一）Ringbuffer的特别之处》</a> </li></ul></blockquote><p><code>org.skywalking.apm.collector.queue.disruptor.base.DisruptorQueueCreator</code> ，实现 QueueCreator <strong>接口</strong>，基于 Disruptor 的队列创建器<strong>实现类</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-disruptor-provider/src/main/java/org/skywalking/apm/collector/queue/disruptor/base/DisruptorQueueCreator.java#L41" rel="external nofollow noopener noreferrer" target="_blank"><code>#create(queueSize, executor)</code></a> <strong>实现</strong>方法，代码如下：</p><ul><li>第 42 至 45 行：<strong>校验</strong>队列大小为 2 的指数，否则创建 Disruptor 对象会报 <code>&quot;bufferSize must be a power of 2&quot;</code> 的异常，参见 <a href="https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/AbstractSequencer.java#L50" rel="external nofollow noopener noreferrer" target="_blank">AbstractSequencer</a> 的代码。</li><li>第 49 行：<strong>创建</strong> Disruptor 对象。<ul><li><a href="https://github.com/YunaiV/skywalking/blob/8b7205313e60e84d50579261992042c8b581492f/apm-collector/apm-collector-queue/collector-queue-disruptor-provider/src/main/java/org/skywalking/apm/collector/queue/disruptor/base/MessageHolderFactory.java#L29" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.queue.disruptor.base.MessageHolderFactory</code></a> ，MessageHolder <strong>工厂</strong>。</li></ul></li><li>第 51 至 64 行：设置 Disruptor 对象的<strong>默认异常处理器</strong>。</li><li>第 67 至 70 行：创建 DisruptorEventHandler 对象，并设置为 Disruptor 对象的<strong>事件处理器</strong>。</li><li>第 74 行：<strong>启动</strong> Disruptor 对象。</li></ul><p><strong>为什么 Disruptor 要求队列大小为 2 的指数呢</strong>？如下是相关资料，感兴趣的同学可以看看( 可跳过 )：</p><ul><li>FROM <a href="https://zh.wikipedia.org/wiki/%E7%92%B0%E5%BD%A2%E7%B7%A9%E8%A1%9D%E5%8D%80#Linux.E5.86.85.E6.A0.B8.E7.9A.84kfifo" rel="external nofollow noopener noreferrer" target="_blank">《环形缓冲器》</a></li></ul><blockquote><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_15/05.png" alt=""></p></blockquote><ul><li><code>SingleProducerSequencer#hasAvailableCapacity(requiredCapacity)</code> 方法，代码如下：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_15/06.png" alt=""></li></ul><h2 id="3-3-DisruptorEventHandler"><a href="#3-3-DisruptorEventHandler" class="headerlink" title="3.3 DisruptorEventHandler"></a>3.3 DisruptorEventHandler</h2><p><code>org.skywalking.apm.collector.queue.disruptor.base.DisruptorEventHandler</code> ，基于 Disruptor 的队列处理器<strong>实现类</strong>。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/0feb6bce291fa945eff5bf52100c82c960851143/apm-collector/apm-collector-queue/collector-queue-disruptor-provider/src/main/java/org/skywalking/apm/collector/queue/disruptor/base/DisruptorEventHandler.java#L43" rel="external nofollow noopener noreferrer" target="_blank"><code>ringBuffer</code></a> 属性，Disruptor RingBuffer 对象。</li><li><a href="https://github.com/YunaiV/skywalking/blob/0feb6bce291fa945eff5bf52100c82c960851143/apm-collector/apm-collector-queue/c方法参数ollector-queue-disruptor-provider/src/main/java/org/skywalking/apm/collector/queue/disruptor/base/DisruptorEventHandler.java#L47" rel="external nofollow noopener noreferrer" target="_blank"><code>executor</code></a> 属性，执行器。</li><li>实现 <code>org.skywalking.apm.collector.queue.base.QueueEventHandler</code> <strong>接口</strong> 的 <a href="https://github.com/YunaiV/skywalking/blob/0feb6bce291fa945eff5bf52100c82c960851143/apm-collector/apm-collector-queue/collector-queue-disruptor-provider/src/main/java/org/skywalking/apm/collector/queue/disruptor/base/DisruptorEventHandler.java#L80" rel="external nofollow noopener noreferrer" target="_blank"><code>#tell(message)</code></a> 接口方法，标准的 Disruptor 发布事件的代码。</li><li>实现 <a href="https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/EventHandler.java" rel="external nofollow noopener noreferrer" target="_blank"><code>com.lmax.disruptor.EventHandler</code></a> 的 <a href="https://github.com/YunaiV/skywalking/blob/0feb6bce291fa945eff5bf52100c82c960851143/apm-collector/apm-collector-queue/collector-queue-disruptor-provider/src/main/java/org/skywalking/apm/collector/queue/disruptor/base/DisruptorEventHandler.java#L62" rel="external nofollow noopener noreferrer" target="_blank"><code>#onEvent(event, sequence, endOfBatch)</code></a> 接口方法，代码如下：<ul><li><code>endOfBatch</code> <strong>方法参数</strong>，标记该事件( 消息 )是否是 Disruptor <strong>每次批处理</strong>的最后一个事件。胖友可以参见 <a href="https://stackoverflow.com/questions/33716825/lmax-disruptor-what-determines-the-batch-size" rel="external nofollow noopener noreferrer" target="_blank">《LMAX Disruptor - what determines the batch size?》</a> 这篇文章，自己搭建一个 Demo 理解下该参数。</li><li>第 66 行：调用 <code>MessageHolder#reset()</code> 方法，清空消息，因为在 Disruptor RingBuffer 里，事件( 消息 )对象是<strong>重用</strong>的，虽然后续发布事件( 消息 )可以进行<strong>覆盖</strong>，考虑到安全性进行清空。</li><li>第 69 行：设置消息为该批量的结尾( 最后一条 )。<strong>为什么</strong>？在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（二）》「3. AggregationWorker」</a> 揭晓答案。</li><li>第 72 行：调用 <code>QueueExecutor#execute(message)</code> 方法，执行处理消息。</li></ul></li></ul><h1 id="4-collector-queue-datacarrier-provider"><a href="#4-collector-queue-datacarrier-provider" class="headerlink" title="4. collector-queue-datacarrier-provider"></a>4. collector-queue-datacarrier-provider</h1><p><code>collector-queue-datacarrier-provider</code> ：基于 <a href="https://github.com/YunaiV/skywalking/tree/master/apm-commons/apm-datacarrier" rel="external nofollow noopener noreferrer" target="_blank">apm-datacarrier</a> 的队列组件实现。</p><p><em>目前暂未完成</em>。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>在地铁里，夹缝中写代码( 😈 当然有座位 )。</p><p>不容易，回家看《蜘蛛侠》。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_15/07.png" alt=""></p><p>胖友，分享一波朋友圈可好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-queue-module/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-queue-module/&lt;/a&gt; 
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector Naming Server 命名服务</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-naming-server/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-naming-server/</id>
    <published>2020-08-09T16:00:00.000Z</published>
    <updated>2017-12-15T11:36:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/">http://www.iocoder.cn/SkyWalking/collector-naming-server/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/">2. Collector Naming Server</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/">2.1 NamingModule</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/">2.2 NamingModuleJettyProvider</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/">2.3 NamingHandlerRegisterService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/">2.4 配置文件</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/">3. CollectorDiscoveryService</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/">3.1 CollectorDiscoveryService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/">3.2 配置文件</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Collector Naming Server 命名服务</strong>。主要包含如下部分：</p><ul><li>Collector Naming Server 提供 Http 两个接口，提供 Agent <strong>分别</strong>查询 Collector Agent Jetty Server 、Collector Agent gRPC Server 集群。</li><li>Collector Agent Jetty Server 、Collector Agent gRPC Server 集群内部的注册与发现。</li></ul><blockquote><p>友情提示，建议胖友已经读过 <a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module//?self">《SkyWalking 源码分析 —— Collector Server Component 服务器组件》</a> 、<a href="http://www.iocoder.cn/SkyWalking/collector-server-component/?self">《SkyWalking 源码分析 —— Collector Server Component 服务器组件》</a></p></blockquote><p>Collector Agent Server ( 包括 Jetty 和 gRPC )，提供上传调用链路，JVM Metric 等等 API 给 Agent 调用。<br>Agent 通过 Collector Naming Server 调用 Collector Agent Server 的 API ，查询 Collector Agent Server <strong>最新</strong>的集群地址。</p><p>Naming Server 在 SkyWalking 架构图处于如下位置( <strong>红框</strong> ) ：</p><blockquote><p>FROM <a href="https://github.com/apache/incubating-skywalking" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubating-skywalking</a><br><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_10/01.jpeg" alt=""></p></blockquote><p>下面我们来看看整体的项目结构，如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_10/02.png" alt=""></p><h1 id="2-Collector-Naming-Server"><a href="#2-Collector-Naming-Server" class="headerlink" title="2. Collector Naming Server"></a>2. Collector Naming Server</h1><p>Collector Naming Server 通过 <code>apm-collector-naming</code> 项目实现，其中：</p><ul><li><code>collector-naming-define</code> 项目：定义了 Naming Server 的接口。</li><li><code>collector-naming-jetty-provider</code> 项目：基于 Jetty Server 的 Naming Server 实现。</li></ul><h2 id="2-1-NamingModule"><a href="#2-1-NamingModule" class="headerlink" title="2.1 NamingModule"></a>2.1 NamingModule</h2><p><code>org.skywalking.apm.collector.cluster.ClusterModule</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java" rel="external nofollow noopener noreferrer" target="_blank">Module</a> 抽象类，集群管理 Module 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-naming/collector-naming-define/src/main/java/org/skywalking/apm/collector/naming/NamingModule.java#L34" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回模块名为 <code>&quot;naming&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-naming/collector-naming-define/src/main/java/org/skywalking/apm/collector/naming/NamingModule.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>#services()</code></a> <strong>实现</strong>方法，返回 Service 类名：NamingHandlerRegisterService 。</p><h2 id="2-2-NamingModuleJettyProvider"><a href="#2-2-NamingModuleJettyProvider" class="headerlink" title="2.2 NamingModuleJettyProvider"></a>2.2 NamingModuleJettyProvider</h2><p><code>org.skywalking.apm.collector.naming.jetty.NamingModuleJettyProvider</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java" rel="external nofollow noopener noreferrer" target="_blank">ModuleProvider</a> <strong>抽象类</strong>，基于 Jetty 的命名组件服务提供者实现类。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-naming/collector-naming-jetty-provider/src/main/java/org/skywalking/apm/collector/naming/jetty/NamingModuleJettyProvider.java#L44" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回组件服务提供者名为 <code>&quot;jetty&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-naming/collector-naming-jetty-provider/src/main/java/org/skywalking/apm/collector/naming/jetty/NamingModuleJettyProvider.java#L48" rel="external nofollow noopener noreferrer" target="_blank"><code>module()</code></a> <strong>实现</strong>方法，返回组件类为 NamingModule 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterModuleZookeeperProvider.java#L94" rel="external nofollow noopener noreferrer" target="_blank"><code>#requiredModules()</code></a> <strong>实现</strong>方法，返回依赖组件为 ClusterModule 、JettyManagerModule。</p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterModuleZookeeperProvider.java#L52" rel="external nofollow noopener noreferrer" target="_blank"><code>#prepare(Properties)</code></a> <strong>实现</strong>方法，执行准备阶段逻辑。</p><ul><li>第 55 行 ：创建 ZookeeperModuleListenerService / NamingJettyHandlerRegisterService 对象，并调用 <code>#registerServiceImplementation()</code> <strong>父类</strong>方法，注册到 <code>services</code> 。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-naming/collector-naming-jetty-provider/src/main/java/org/skywalking/apm/collector/naming/jetty/NamingModuleJettyProvider.java#L58" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> <strong>实现</strong>方法，执行启动阶段逻辑。</p><ul><li>第 65 行 ：调用 <code>JettyManagerService#createIfAbsent(host, port, contextPath)</code> 方法，创建 Jetty Server ，<strong>此时不会启动 Jetty Server</strong>。在 <code>JettyManagerProvider#notifyAfterCompleted()</code> 方法，统一启动所有 Jetty Server，在 <a href="http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/?self">《SkyWalking 源码分析 —— Collector Jetty Server Manager》「3. JettyManagerProvider」</a> 有详细解析。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-naming/collector-naming-jetty-provider/src/main/java/org/skywalking/apm/collector/naming/jetty/NamingModuleJettyProvider.java#L68" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyAfterCompleted()</code></a> <strong>实现</strong>方法，执行启动完成逻辑。目前是个空方法。</p><h2 id="2-3-NamingHandlerRegisterService"><a href="#2-3-NamingHandlerRegisterService" class="headerlink" title="2.3 NamingHandlerRegisterService"></a>2.3 NamingHandlerRegisterService</h2><p><code>org.skywalking.apm.collector.naming.service.NamingHandlerRegisterService</code> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> 接口，命名处理器注册服务<strong>接口</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-naming/collector-naming-define/src/main/java/org/skywalking/apm/collector/naming/service/NamingHandlerRegisterService.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><code>#register(ServerHandler)</code></a> <strong>接口</strong>方法，注册 Server 请求处理器。Collector Agent Server 会调用该方法，将其实现的 用于 Naming 的 ServerHandler 进行注册。如下图所示：<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_10/03.png" alt=""></p><h3 id="2-3-1-NamingJettyHandlerRegisterService"><a href="#2-3-1-NamingJettyHandlerRegisterService" class="headerlink" title="2.3.1 NamingJettyHandlerRegisterService"></a>2.3.1 NamingJettyHandlerRegisterService</h3><p><code>org.skywalking.apm.collector.naming.jetty.service.service.NamingJettyHandlerRegisterService</code> ，基于 Jetty 的命名处理器注册服务<strong>实现类</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-naming/collector-naming-jetty-provider/src/main/java/org/skywalking/apm/collector/naming/jetty/service/NamingJettyHandlerRegisterService.java#L48" rel="external nofollow noopener noreferrer" target="_blank"><code>#register(moduleName, providerName, registration)</code></a> <strong>实现</strong>方法，调用 <code>JettyManagerService#addHandler(path, registration)</code> 方法，注册 Jetty Server 请求处理器。</p><h3 id="2-3-2-AgentJettyNamingHandler"><a href="#2-3-2-AgentJettyNamingHandler" class="headerlink" title="2.3.2 AgentJettyNamingHandler"></a>2.3.2 AgentJettyNamingHandler</h3><p><code>org.skywalking.apm.collector.agent.jetty.handler.naming.AgentJettyNamingHandler</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyHandler.java" rel="external nofollow noopener noreferrer" target="_blank">JettyHandler</a> <strong>抽象类</strong>，Collector Agent Jetty Server 实现的命名处理器。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-agent-jetty/collector-agent-jetty-provider/src/main/java/org/skywalking/apm/collector/agent/jetty/handler/naming/AgentJettyNamingHandler.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>#pathSpec()</code></a> <strong>实现</strong>方法，获得请求路径为 <code>&quot;/agent/jetty&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-agent-jetty/collector-agent-jetty-provider/src/main/java/org/skywalking/apm/collector/agent/jetty/handler/naming/AgentJettyNamingHandler.java#L43" rel="external nofollow noopener noreferrer" target="_blank"><code>#doGet()</code></a> <strong>实现</strong>方法，调用 <code>AgentJettyNamingListener#getAddresses()</code> 方法，获得 Collector Agent Jetty Server 集群地址。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-agent-jetty/collector-agent-jetty-provider/src/main/java/org/skywalking/apm/collector/agent/jetty/handler/naming/AgentJettyNamingListener.java#L28" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.jetty.handler.naming.AgentJettyNamingListener</code></a> 基于 Collector Cluster 组件，<strong>实现了集群地址变化的发现</strong>，在 <a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/?self">《SkyWalking 源码分析 —— Collector Cluster 集群管理》</a> 有详细解析。</li></ul><h3 id="2-3-3-AgentGRPCNamingHandler"><a href="#2-3-3-AgentGRPCNamingHandler" class="headerlink" title="2.3.3 AgentGRPCNamingHandler"></a>2.3.3 AgentGRPCNamingHandler</h3><p><code>org.skywalking.apm.collector.agent.grpc.handler.naming.AgentGRPCNamingHandler</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/8eece7df8a9174067793f0714b8b71d09f142312/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyHandler.java" rel="external nofollow noopener noreferrer" target="_blank">JettyHandler</a> <strong>抽象类</strong>，Collector Agent gRPC Server 实现的命名处理器。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ac6c98c1732d6aa62b9d244369478654411ac203/apm-collector/apm-collector-agent-grpc/collector-agent-grpc-provider/src/main/java/org/skywalking/apm/collector/agent/grpc/handler/naming/AgentGRPCNamingHandler.java#L42" rel="external nofollow noopener noreferrer" target="_blank"><code>#pathSpec()</code></a> <strong>实现</strong>方法，获得请求路径为 <code>&quot;/agent/gRPC&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ac6c98c1732d6aa62b9d244369478654411ac203/apm-collector/apm-collector-agent-grpc/collector-agent-grpc-provider/src/main/java/org/skywalking/apm/collector/agent/grpc/handler/naming/AgentGRPCNamingHandler.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#doGet()</code></a> <strong>实现</strong>方法，调用 <code>AgentGRPCNamingListener#getAddresses()</code> 方法，获得 Collector Agent gRPC Server 集群地址。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/ac6c98c1732d6aa62b9d244369478654411ac203/apm-collector/apm-collector-agent-grpc/collector-agent-grpc-provider/src/main/java/org/skywalking/apm/collector/agent/grpc/handler/naming/AgentGRPCNamingListener.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.grpc.handler.naming.AgentGRPCNamingListener</code></a> 基于 Collector Cluster 组件，<strong>实现了集群地址变化的发现</strong>，在 <a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/?self">《SkyWalking 源码分析 —— Collector Cluster 集群管理》</a> 有详细解析。</li></ul><h2 id="2-4-配置文件"><a href="#2-4-配置文件" class="headerlink" title="2.4 配置文件"></a>2.4 配置文件</h2><p>配置文件如下 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_10/02.png" alt=""></p><ul><li>配置 Naming Server 启动在 10800 端口。</li><li>Naming Server <strong>内嵌</strong>在 Collector Server 。通过启动多个 Collector Server 节点，形成 Naming Server 集群。Agent 配置多个 Naming Server 地址。</li></ul><h1 id="3-CollectorDiscoveryService"><a href="#3-CollectorDiscoveryService" class="headerlink" title="3. CollectorDiscoveryService"></a>3. CollectorDiscoveryService</h1><p><code>org.skywalking.apm.agent.core.remote.CollectorDiscoveryService</code> ， 实现 Agent 的 <a href="https://github.com/YunaiV/skywalking/blob/ac6c98c1732d6aa62b9d244369478654411ac203/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/boot/BootService.java" rel="external nofollow noopener noreferrer" target="_blank">BootService</a> <strong>接口</strong>，Collector Agent Server 地址<strong>发现</strong>服务。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ac6c98c1732d6aa62b9d244369478654411ac203/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/CollectorDiscoveryService.java#L45" rel="external nofollow noopener noreferrer" target="_blank"><code>#boot()</code></a> <strong>实现</strong>方法，调用 <code>ScheduledExecutorService#scheduleAtFixedRate(...)</code> 方法，创建定时任务。该定时任务<strong>无初始化延迟</strong>，每 <code>Config.Collector.DISCOVERY_CHECK_INTERVAL</code> ( 默认：60 s ) 执行一次。</p><ul><li>DiscoveryRestServiceClient 实现 <code>java.lang.Runnable</code> <strong>接口</strong>，即创建的任务。</li></ul><h2 id="3-1-CollectorDiscoveryService"><a href="#3-1-CollectorDiscoveryService" class="headerlink" title="3.1 CollectorDiscoveryService"></a>3.1 CollectorDiscoveryService</h2><p><code>org.skywalking.apm.agent.core.remote.CollectorDiscoveryService</code> ，实现 <code>java.lang.Runnable</code> <strong>接口</strong>，Collector 服务发现客户端，基于 <strong>Rest</strong> 方式通信。</p><p><a href="https://github.com/YunaiV/skywalking/blob/e30787c3a7ce91ae6314003cd488e71c1a534d7c/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/DiscoveryRestServiceClient.java#L61" rel="external nofollow noopener noreferrer" target="_blank"><strong>构造方法</strong></a> ，首先随机选择一个 Collector Naming Server ，用于下面 <code>#findServerList()</code> 方法，首次获取 Collector Agent Server 集群地址。</p><p><a href="https://github.com/YunaiV/skywalking/blob/e30787c3a7ce91ae6314003cd488e71c1a534d7c/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/DiscoveryRestServiceClient.java#L76" rel="external nofollow noopener noreferrer" target="_blank"><code>#run()</code></a> <strong>实现</strong>方法，调用 <code>#findServerList()</code> 方法，获取 Collector Agent Server 集群地址。</p><p><a href="https://github.com/YunaiV/skywalking/blob/e30787c3a7ce91ae6314003cd488e71c1a534d7c/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/DiscoveryRestServiceClient.java#L84" rel="external nofollow noopener noreferrer" target="_blank"><code>#findServerList()</code></a> 方法，获取 Collector Agent Server 集群地址。</p><ul><li>第 85 行 ：创建 <code>org.apache.http.impl.client.CloseableHttpClient</code> 对象。目前使用 HttpClient <code>4.5.3</code> 版本。</li><li>第 87 行 ：调用 <a href="https://github.com/YunaiV/skywalking/blob/e30787c3a7ce91ae6314003cd488e71c1a534d7c/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/DiscoveryRestServiceClient.java#L142" rel="external nofollow noopener noreferrer" target="_blank"><code>#buildGet()</code></a> 方法，创建 <code>org.apache.http.client.methods.HttpGet</code> 对象。目前 Agent 查询的是 Collector Agent gRPC Server 集群地址，因为 gRPC 的性能相比 HTTP 更优秀。</li><li>第 89 行 ：向 Collector Naming Server 发起请求。</li><li>第 90 至 93 行 ：当响应状态码非 <code>200</code> 时，调用 <code>#findBackupServer()</code> 方法，<strong>顺序</strong>选择 Collector Naming Server 列表的下一个。<strong>注意</strong>，此时不会再发起请求，需要等下一次执行。</li><li>第 95 至 111 行 ：处理响应结果，若 Collector Agent gRPC Server 集群地址发生变化，进行更新到 <code>RemoteDownstreamConfig.Collector.GRPC_SERVERS</code> 。</li><li>第 114 至 117 行 ：请求发生异常，调用 <code>#findBackupServer()</code> 方法，<strong>顺序</strong>选择 Collector Naming Server 列表的下一个。</li><li>第 119 行 ：调用 <code>CloseableHttpClient#close()</code> 方法，进行关闭。</li></ul><h2 id="3-2-配置文件"><a href="#3-2-配置文件" class="headerlink" title="3.2 配置文件"></a>3.2 配置文件</h2><p>配置文件如下 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_10/05.png" alt=""></p><ul><li>生产环境使用时，<strong>推荐</strong> Agent 配置多个 Naming Server 地址。</li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>2017.12.15 归途 从北京回上海。</p><p>突然有种感觉，获得像包方便面，快捷而不营养。</p><p>有点”丧”。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_10/06.png" alt=""></p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-naming-server/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-naming-server/&lt;/a
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector gRPC Server Manager</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-grpc-server-module/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-grpc-server-module/</id>
    <published>2020-08-04T16:00:00.000Z</published>
    <updated>2017-12-14T16:41:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-grpc-server-module/">http://www.iocoder.cn/SkyWalking/collector-grpc-server-module/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-grpc-server-module/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-grpc-server-module/">2. GRPCManagerModule</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-grpc-server-module/">3. GRPCManagerProvider</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-grpc-server-module/">4. GRPCManagerService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-grpc-server-module/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Collector gRPC Server Manager</strong>。Collector 通过该管理器，管理启动的多个 gRPC Server，例如 Agent gRPC Server、Remote gRPC Server 。<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_05/02.png" alt=""></p><blockquote><p>友情提示：建议胖友已经读过 <a href="http://www.iocoder.cn/SkyWalking/collector-server-component/?self">《SkyWalking 源码分析 —— Collector Server Component 服务器组件》</a></p><p>另外，本文和 <a href="http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/?self">《SkyWalking 源码分析 —— Collector Jetty Server Manager》</a> 相似度 99%</p></blockquote><p>gRPC Server Manager 在 SkyWalking 架构图处于如下位置( <strong>红框</strong> ) ：</p><blockquote><p>FROM <a href="https://github.com/apache/incubating-skywalking" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubating-skywalking</a><br><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_05/01.jpeg" alt=""></p></blockquote><p>下面我们来看看整体的项目结构，如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_05/03.png" alt=""></p><p>😈 代码量非常少，考虑到这是个单独的项目，所以单独成文。</p><h1 id="2-GRPCManagerModule"><a href="#2-GRPCManagerModule" class="headerlink" title="2. GRPCManagerModule"></a>2. GRPCManagerModule</h1><p><code>org.skywalking.apm.collector.grpc.manager.GRPCManagerModule</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java" rel="external nofollow noopener noreferrer" target="_blank">Module</a> 抽象类，gRPC Server 管理器 Module 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/621598af465bfcefee3432c2ef80aff25a33f1bf/apm-collector/apm-collector-grpc-manager/collector-grpc-manager-define/src/main/java/org/skywalking/apm/collector/grpc/manager/GRPCManagerModule.java#L33" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回模块名为 <code>&quot;gRPC_manager&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/621598af465bfcefee3432c2ef80aff25a33f1bf/apm-collector/apm-collector-grpc-manager/collector-grpc-manager-define/src/main/java/org/skywalking/apm/collector/grpc/manager/GRPCManagerModule.java#L37" rel="external nofollow noopener noreferrer" target="_blank"><code>#services()</code></a> <strong>实现</strong>方法，返回 Service 类名：GRPCManagerService 。</p><h1 id="3-GRPCManagerProvider"><a href="#3-GRPCManagerProvider" class="headerlink" title="3. GRPCManagerProvider"></a>3. GRPCManagerProvider</h1><p><code>org.skywalking.apm.collector.grpc.manager.GRPCManagerProvider</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java" rel="external nofollow noopener noreferrer" target="_blank">ModuleProvider</a> <strong>抽象类</strong>，gRPC Server 管理器组件服务提供者。</p><p><a href="https://github.com/YunaiV/skywalking/blob/f9de7bf75f62c16fd05cc0d1beb8f5b756108ec3/apm-collector/apm-collector-grpc-manager/collector-grpc-manager-provider/src/main/java/org/skywalking/apm/collector/grpc/manager/GRPCManagerProvider.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回组件服务提供者名为 <code>&quot;gRPC&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/f9de7bf75f62c16fd05cc0d1beb8f5b756108ec3/apm-collector/apm-collector-grpc-manager/collector-grpc-manager-provider/src/main/java/org/skywalking/apm/collector/grpc/manager/GRPCManagerProvider.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>module()</code></a> <strong>实现</strong>方法，返回组件类为 GRPCManagerModule 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/f9de7bf75f62c16fd05cc0d1beb8f5b756108ec3/apm-collector/apm-collector-grpc-manager/collector-grpc-manager-provider/src/main/java/org/skywalking/apm/collector/grpc/manager/GRPCManagerProvider.java#L72" rel="external nofollow noopener noreferrer" target="_blank"><code>#requiredModules()</code></a> <strong>实现</strong>方法，返回依赖组件为空。</p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/f9de7bf75f62c16fd05cc0d1beb8f5b756108ec3/apm-collector/apm-collector-grpc-manager/collector-grpc-manager-provider/src/main/java/org/skywalking/apm/collector/grpc/manager/GRPCManagerProvider.java#L54" rel="external nofollow noopener noreferrer" target="_blank"><code>#prepare(Properties)</code></a> <strong>实现</strong>方法，执行准备阶段逻辑。</p><ul><li>第 55 行 ：创建 GRPCManagerServiceImpl 对象，并调用 <code>#registerServiceImplementation(...)</code> <strong>父类</strong>方法，注册到 <code>services</code> 。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/f9de7bf75f62c16fd05cc0d1beb8f5b756108ec3/apm-collector/apm-collector-grpc-manager/collector-grpc-manager-provider/src/main/java/org/skywalking/apm/collector/grpc/manager/GRPCManagerProvider.java#L58" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> <strong>实现</strong>方法，执行启动阶段逻辑。目前是个<strong>空方法</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/f9de7bf75f62c16fd05cc0d1beb8f5b756108ec3/apm-collector/apm-collector-grpc-manager/collector-grpc-manager-provider/src/main/java/org/skywalking/apm/collector/grpc/manager/GRPCManagerProvider.java#L62" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyAfterCompleted()</code></a> <strong>实现</strong>方法，执行启动完成逻辑。</p><ul><li>第 63 至 69 行 ：遍历注册的服务器列表，逐个调用 <code>GRPCServer#start()</code> 方法，进行启动。</li></ul><h1 id="4-GRPCManagerService"><a href="#4-GRPCManagerService" class="headerlink" title="4. GRPCManagerService"></a>4. GRPCManagerService</h1><p><code>org.skywalking.apm.collector.grpc.manager.service.GRPCManagerService</code> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> <strong>接口</strong>，gRPC Server 管理器服务<strong>接口</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/48f76a555c043fee2932230077a8112d4888d10f/apm-collector/apm-collector-grpc-manager/collector-grpc-manager-define/src/main/java/org/skywalking/apm/collector/grpc/manager/service/GRPCManagerService.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>#createIfAbsent(host, port)</code></a> <strong>接口</strong>方法，创建 gRPC Server ，若不存在。</p><p><strong>怎么没有类似 JettyManagerService 的 <code>#addHandler(...)</code> 方法</strong>？目前是调用方直接调用 <code>#createIfAbsent(host, port)</code> 方法，获得 gRPC Server 后，后调用 <code>Server#addHandler(ServerHandler)</code> 方法。例如：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/9c586ca730cc89d4d5ad6b4294f2779a23925a8c/apm-collector/apm-collector-agent-grpc/collector-agent-grpc-provider/src/main/java/org/skywalking/apm/collector/agent/grpc/AgentModuleGRPCProvider.java#L72" rel="external nofollow noopener noreferrer" target="_blank"><code>AgentModuleGRPCProvider#start(Properties)</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/9c586ca730cc89d4d5ad6b4294f2779a23925a8c/apm-collector/apm-collector-remote/collector-remote-grpc-provider/src/main/java/org/skywalking/apm/collector/remote/grpc/RemoteModuleGRPCProvider.java#L61" rel="external nofollow noopener noreferrer" target="_blank"><code>RemoteModuleGRPCProvider#start(Properties)</code></a></li></ul><h2 id="4-1-GRPCManagerServiceImpl"><a href="#4-1-GRPCManagerServiceImpl" class="headerlink" title="4.1 GRPCManagerServiceImpl"></a>4.1 GRPCManagerServiceImpl</h2><p><code>org.skywalking.apm.collector.grpc.manager.service.GRPCManagerServiceImpl</code> ，gRPC Server 管理器服务<strong>实现类</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/9c586ca730cc89d4d5ad6b4294f2779a23925a8c/apm-collector/apm-collector-grpc-manager/collector-grpc-manager-provider/src/main/java/org/skywalking/apm/collector/grpc/manager/service/GRPCManagerServiceImpl.java#L44" rel="external nofollow noopener noreferrer" target="_blank"><strong>构造方法</strong></a> ，使用来自 GRPCManagerProvider 的 <code>servers</code> 服务器数组。<strong>这是为什么 GRPCManagerProvider 没有对 <code>servers</code> 做新增操作，结果里面有数据的原因</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/9c586ca730cc89d4d5ad6b4294f2779a23925a8c/apm-collector/apm-collector-grpc-manager/collector-grpc-manager-provider/src/main/java/org/skywalking/apm/collector/grpc/manager/service/GRPCManagerServiceImpl.java#L48" rel="external nofollow noopener noreferrer" target="_blank"><code>#createIfAbsent(host, port)</code></a> <strong>实现</strong>方法，创建 gRPC Server ，若不存在。判断方式为 <code>host + port</code> 为唯一。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>呵呵哒的一篇，嘿嘿。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_05/04.png" alt=""></p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-grpc-server-module/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-grpc-server-
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector Jetty Server Manager</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/</id>
    <published>2020-07-31T16:00:00.000Z</published>
    <updated>2017-12-14T16:30:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/">http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/">2. JettyManagerModule</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/">3. JettyManagerProvider</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/">4. JettyManagerService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Collector Jetty Server Manager</strong>。Collector 通过该管理器，管理启动的多个 Jetty Server，例如 Agent Jetty Server、Naming Jetty Server、UI Jetty Server。<img src="http://www.iocoder.cn/images/SkyWalking/2020_08_01/02.png" alt=""></p><blockquote><p>友情提示：建议胖友已经读过 <a href="http://www.iocoder.cn/SkyWalking/collector-server-component/?self">《SkyWalking 源码分析 —— Collector Server Component 服务器组件》</a></p></blockquote><p>Jetty Server Manager 在 SkyWalking 架构图处于如下位置( <strong>红框</strong> ) ：</p><blockquote><p>FROM <a href="https://github.com/apache/incubating-skywalking" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubating-skywalking</a><br><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_01/01.jpeg" alt=""></p></blockquote><p>下面我们来看看整体的项目结构，如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_01/03.png" alt=""></p><p>😈 代码量非常少，考虑到这是个单独的项目，所以单独成文。</p><h1 id="2-JettyManagerModule"><a href="#2-JettyManagerModule" class="headerlink" title="2. JettyManagerModule"></a>2. JettyManagerModule</h1><p><code>org.skywalking.apm.collector.jetty.manager.JettyManagerModule</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java" rel="external nofollow noopener noreferrer" target="_blank">Module</a> 抽象类，Jetty 管理器 Module 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/39ee2260b8463316550c52276109a5af917e34e8/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-define/src/main/java/org/skywalking/apm/collector/jetty/manager/JettyManagerModule.java#L33" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回模块名为 <code>&quot;jetty_manager&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/39ee2260b8463316550c52276109a5af917e34e8/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-define/src/main/java/org/skywalking/apm/collector/jetty/manager/JettyManagerModule.java#L37" rel="external nofollow noopener noreferrer" target="_blank"><code>#services()</code></a> <strong>实现</strong>方法，返回 Service 类名：JettyManagerService 。</p><h1 id="3-JettyManagerProvider"><a href="#3-JettyManagerProvider" class="headerlink" title="3. JettyManagerProvider"></a>3. JettyManagerProvider</h1><p><code>org.skywalking.apm.collector.jetty.manager.JettyManagerProvider</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java" rel="external nofollow noopener noreferrer" target="_blank">ModuleProvider</a> <strong>抽象类</strong>，Jetty 管理器组件服务提供者。</p><p><a href="https://github.com/YunaiV/skywalking/blob/39ee2260b8463316550c52276109a5af917e34e8/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-provider/src/main/java/org/skywalking/apm/collector/jetty/manager/JettyManagerProvider.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回组件服务提供者名为 <code>&quot;jetty&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/39ee2260b8463316550c52276109a5af917e34e8/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-provider/src/main/java/org/skywalking/apm/collector/jetty/manager/JettyManagerProvider.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>module()</code></a> <strong>实现</strong>方法，返回组件类为 JettyManagerModule 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/39ee2260b8463316550c52276109a5af917e34e8/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-provider/src/main/java/org/skywalking/apm/collector/jetty/manager/JettyManagerProvider.java#L72" rel="external nofollow noopener noreferrer" target="_blank"><code>#requiredModules()</code></a> <strong>实现</strong>方法，返回依赖组件为空。</p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/39ee2260b8463316550c52276109a5af917e34e8/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-provider/src/main/java/org/skywalking/apm/collector/jetty/manager/JettyManagerProvider.java#L54" rel="external nofollow noopener noreferrer" target="_blank"><code>#prepare(Properties)</code></a> <strong>实现</strong>方法，执行准备阶段逻辑。</p><ul><li>第 55 行 ：创建 JettyManagerServiceImpl 对象，并调用 <code>#registerServiceImplementation(...)</code> <strong>父类</strong>方法，注册到 <code>services</code> 。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/39ee2260b8463316550c52276109a5af917e34e8/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-provider/src/main/java/org/skywalking/apm/collector/jetty/manager/JettyManagerProvider.java#L58" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> <strong>实现</strong>方法，执行启动阶段逻辑。目前是个<strong>空方法</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/39ee2260b8463316550c52276109a5af917e34e8/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-provider/src/main/java/org/skywalking/apm/collector/jetty/manager/JettyManagerProvider.java#L61" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyAfterCompleted()</code></a> <strong>实现</strong>方法，执行启动完成逻辑。</p><ul><li>第 63 至 69 行 ：遍历注册的服务器列表，逐个调用 <code>JettyServer#start()</code> 方法，进行启动。</li></ul><h1 id="4-JettyManagerService"><a href="#4-JettyManagerService" class="headerlink" title="4. JettyManagerService"></a>4. JettyManagerService</h1><p><code>org.skywalking.apm.collector.jetty.manager.service.JettyManagerService</code> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> <strong>接口</strong>，Jetty 管理器服务<strong>接口</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/71993b1790b29df66644334dcfe1796e889ddc9b/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-define/src/main/java/org/skywalking/apm/collector/jetty/manager/service/JettyManagerService.java#L40" rel="external nofollow noopener noreferrer" target="_blank"><code>#createIfAbsent(host, port, contextPath)</code></a> <strong>接口</strong>方法，创建 Jetty Server ，若不存在。</p><p><a href="https://github.com/YunaiV/skywalking/blob/71993b1790b29df66644334dcfe1796e889ddc9b/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-define/src/main/java/org/skywalking/apm/collector/jetty/manager/service/JettyManagerService.java#L49" rel="external nofollow noopener noreferrer" target="_blank"><code>#addHandler(host, port, serverHandler)</code></a> <strong>接口</strong>方法，添加 Jetty Server 请求处理器。</p><h2 id="4-1-JettyManagerServiceImpl"><a href="#4-1-JettyManagerServiceImpl" class="headerlink" title="4.1 JettyManagerServiceImpl"></a>4.1 JettyManagerServiceImpl</h2><p><code>org.skywalking.apm.collector.jetty.manager.service.JettyManagerServiceImpl</code> ，Jetty 管理器服务<strong>实现类</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/21a84f89165f74c7fe702650ff4d12db5a9613e4/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-provider/src/main/java/org/skywalking/apm/collector/jetty/manager/service/JettyManagerServiceImpl.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><strong>构造方法</strong></a> ，使用来自 JettyManagerProvider 的 <code>servers</code> 服务器数组。<strong>这是为什么 JettyManagerProvider 没有对 <code>servers</code> 做新增操作，结果里面有数据的原因</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/21a84f89165f74c7fe702650ff4d12db5a9613e4/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-provider/src/main/java/org/skywalking/apm/collector/jetty/manager/service/JettyManagerServiceImpl.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>#createIfAbsent(host, port, contextPath)</code></a> <strong>实现</strong>方法，创建 Jetty Server ，若不存在。判断方式为 <code>host + port</code> 为唯一。</p><p><a href="https://github.com/YunaiV/skywalking/blob/21a84f89165f74c7fe702650ff4d12db5a9613e4/apm-collector/apm-collector-jetty-manager/collector-jetty-manager-provider/src/main/java/org/skywalking/apm/collector/jetty/manager/service/JettyManagerServiceImpl.java#L66" rel="external nofollow noopener noreferrer" target="_blank"><code>#addHandler(host, port, serverHandler)</code></a> <strong>实现</strong>方法，添加 Jetty Server 请求处理器。判断方式为 <code>host + port</code> 为唯一。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>呵呵哒的一篇，嘿嘿。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_08_01/04.png" alt=""></p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-jetty-serve
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector Server Component 服务器组件</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-server-component/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-server-component/</id>
    <published>2020-07-27T16:00:00.000Z</published>
    <updated>2017-12-14T14:44:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">http://www.iocoder.cn/SkyWalking/collector-server-component/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">2. 接口</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">2.1 Server</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">2.2 ServerHandler</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">3. gRPC 实现</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">3.1 GRPCServer</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">3.2 GRPCHandler</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">4. Jetty 实现</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">3.1 JettyServer</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">3.2 JettyHandler</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-server-component/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>SkyWalking Collector Server Component 服务器组件</strong>。Collector 通过服务器，提供 API 接口给调用方，例如 Agent 、WebUI 。</p><p>Server Component 在 SkyWalking 架构图处于如下位置( <strong>红框</strong> ) ：</p><blockquote><p>FROM <a href="https://github.com/apache/incubating-skywalking" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubating-skywalking</a><br><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_25/01.jpeg" alt=""></p></blockquote><p>下面我们来看看整体的项目结构，如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_28/02.png" alt=""></p><p>OK，我们从<strong>接口到实现</strong>的顺序进行分享。</p><h1 id="2-接口"><a href="#2-接口" class="headerlink" title="2. 接口"></a>2. 接口</h1><h2 id="2-1-Server"><a href="#2-1-Server" class="headerlink" title="2.1 Server"></a>2.1 Server</h2><p><code>org.skywalking.apm.collector.server.Server</code> ，服务器<strong>接口</strong>。其实现子类，如下类图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_28/03.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/Server.java#L31" rel="external nofollow noopener noreferrer" target="_blank"><code>#hostPort()</code></a> <strong>接口</strong>方法，获得服务器地址。<br><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/Server.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><code>#serverClassify()</code></a> <strong>接口</strong>方法，获得服务器分类。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/Server.java#L43" rel="external nofollow noopener noreferrer" target="_blank"><code>#initialize()</code></a> <strong>接口</strong>方法，初始化服务器。<br><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/Server.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> <strong>接口</strong>方法，启动服务器。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/Server.java#L57" rel="external nofollow noopener noreferrer" target="_blank"><code>#addHandler()</code></a> <strong>接口</strong>方法，添加请求处理器( ServerHandler )</p><h2 id="2-2-ServerHandler"><a href="#2-2-ServerHandler" class="headerlink" title="2.2 ServerHandler"></a>2.2 ServerHandler</h2><p><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/ServerHandler.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.server.ServerHandler</code></a> ，服务器处理器<strong>接口</strong>。其实现子类，如下类图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_28/04.png" alt=""></p><p>ServerHandler 无任何接口方法。</p><p>一个 ServerHandler 对应一个请求的处理。</p><h1 id="3-gRPC-实现"><a href="#3-gRPC-实现" class="headerlink" title="3. gRPC 实现"></a>3. gRPC 实现</h1><h2 id="3-1-GRPCServer"><a href="#3-1-GRPCServer" class="headerlink" title="3.1 GRPCServer"></a>3.1 GRPCServer</h2><p><code>org.skywalking.apm.collector.server.grpc.GRPCServer</code> ，基于 gRPC 的服务器实现。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/grpc/GRPCServer.java#L47" rel="external nofollow noopener noreferrer" target="_blank"><code>#hostPort()</code></a> <strong>实现</strong>方法，获得服务器地址。<br><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/grpc/GRPCServer.java#L51" rel="external nofollow noopener noreferrer" target="_blank"><code>#serverClassify()</code></a> <strong>实现</strong>方法，获得服务器分类为 <code>&quot;Google-RPC&quot;</code>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/grpc/GRPCServer.java#L55" rel="external nofollow noopener noreferrer" target="_blank"><code>#initialize()</code></a> <strong>实现</strong>方法，调用 <code>io.grpc.netty.NettyServerBuilder#forAddress(address)</code> 方法，NettyServerBuilder 。此处，服务器并未创建与启动。<br><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/grpc/GRPCServer.java#L61" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> <strong>实现</strong>方法，创建 <code>io.grpc.Server</code> 对象，并启动服务器。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/grpc/GRPCServer.java#L70" rel="external nofollow noopener noreferrer" target="_blank"><code>#addHandler(handler)</code></a> <strong>实现</strong>方法，调用 <code>NettyServerBuilder#addService(...)</code> 方法，添加 gRPC 请求处理器( GRPCHandler )。</p><p>目前，GRPCServer 使用在 <a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-agent-grpc/collector-agent-grpc-provider/" rel="external nofollow noopener noreferrer" target="_blank"><code>collector-agent-grpc-provider</code></a> / <a href="https://github.com/YunaiV/skywalking/tree/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-remote/collector-remote-grpc-provider" rel="external nofollow noopener noreferrer" target="_blank"><code>collector-remote-grpc-provider</code></a> 项目。</p><h2 id="3-2-GRPCHandler"><a href="#3-2-GRPCHandler" class="headerlink" title="3.2 GRPCHandler"></a>3.2 GRPCHandler</h2><p><a href="https://github.com/YunaiV/skywalking/blob/ceee65ca1e03c34a756922034f85c5d95b8f2178/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/ServerHandler.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.server.grpc.GRPCHandler</code></a> ，gRPC 请求处理器<strong>接口</strong>。其实现子类，如下类图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_28/05.png" alt=""></p><p>GRPCHandler 无任何接口方法。</p><h1 id="4-Jetty-实现"><a href="#4-Jetty-实现" class="headerlink" title="4. Jetty 实现"></a>4. Jetty 实现</h1><h2 id="3-1-JettyServer"><a href="#3-1-JettyServer" class="headerlink" title="3.1 JettyServer"></a>3.1 JettyServer</h2><p><code>org.skywalking.apm.collector.server.jetty.JettyServer</code> ，基于 Jetty 的服务器实现。</p><p><a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyServer.java#L52" rel="external nofollow noopener noreferrer" target="_blank"><code>#hostPort()</code></a> <strong>实现</strong>方法，获得服务器地址。<br><a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyServer.java#L56" rel="external nofollow noopener noreferrer" target="_blank"><code>#serverClassify()</code></a> <strong>实现</strong>方法，获得服务器分类为 <code>&quot;Jetty&quot;</code>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyServer.java#L60" rel="external nofollow noopener noreferrer" target="_blank"><code>#initialize()</code></a> <strong>实现</strong>方法，创建 <code>org.eclipse.jetty.server.Server</code> 和 <code>org.eclipse.jetty.servle.ServletContextHandler</code> 对象。此处，服务器并未启动。<br><a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyServer.java#L80" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> <strong>实现</strong>方法，启动服务器。</p><p><a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyServer.java#L72" rel="external nofollow noopener noreferrer" target="_blank"><code>#addHandler(handler)</code></a> <strong>实现</strong>方法，使用 ServerHandler 创建 <code>org.eclipse.jetty.servlet.ServletHolder</code> 对象，并调用 <code>ServletContextHandler#addServlet(servlet, pathSpec)</code> 方法进行添加。</p><p>目前，JettyServer 使用在 <a href="https://github.com/YunaiV/skywalking/tree/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-agent-jetty/collector-agent-jetty-provider" rel="external nofollow noopener noreferrer" target="_blank"><code>collector-agent-jetty-provider</code></a> / <a href="https://github.com/YunaiV/skywalking/tree/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-ui/collector-ui-jetty-provider" rel="external nofollow noopener noreferrer" target="_blank"><code>collector-ui-jetty-provider</code></a> 项目。</p><h2 id="3-2-JettyHandler"><a href="#3-2-JettyHandler" class="headerlink" title="3.2 JettyHandler"></a>3.2 JettyHandler</h2><p><code>org.skywalking.apm.collector.server.jetty.JettyHandler</code> ，继承 <code>javax.servlet.http.HttpServlet</code> <strong>抽象类</strong>，Jetty 请求处理。</p><p><a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyHandler.java#L43" rel="external nofollow noopener noreferrer" target="_blank"><code>#pathSpec()</code></a> <strong>抽象</strong>方法，请求路径定义。</p><p><a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyHandler.java#L61" rel="external nofollow noopener noreferrer" target="_blank"><code>#doGet(HttpServletRequest)</code></a> <strong>抽象</strong>方法，处理 Get 请求，并返回 <code>com.google.gson.JsonElement</code> 对象。</p><ul><li>该抽象方法会被 <a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyHandler.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#doGet(HttpServletRequest, HttpServletResponse)</code></a> 方法调用。<ul><li>成功时，调用 <a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyHandler.java#L174" rel="external nofollow noopener noreferrer" target="_blank"><code>#reply(HttpServletResponse, JsonElement)</code></a> 方法，返回 JSON 。</li><li>错误时，调用 <a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyHandler.java#L195" rel="external nofollow noopener noreferrer" target="_blank"><code>#replyError(HttpServletResponse, errorMessage, status)</code></a> 方法，返回 JSON 。</li></ul></li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyHandler.java#L79" rel="external nofollow noopener noreferrer" target="_blank"><code>#doPost(HttpServletRequest)</code></a> <strong>抽象</strong>方法，处理 Post 请求，并返回 <code>com.google.gson.JsonElement</code> 对象。</p><ul><li>该抽象方法会被 <a href="https://github.com/YunaiV/skywalking/blob/3c964d8b5678cf6f715dc252e6fe48ba87d0f9e9/apm-collector/apm-collector-component/server-component/src/main/java/org/skywalking/apm/collector/server/jetty/JettyHandler.java#L64" rel="external nofollow noopener noreferrer" target="_blank"><code>#doPost(HttpServletRequest, HttpServletResponse)</code></a> 方法调用。</li></ul><p><strong>HttpServlet 所有方法被重写，并标记 <code>final</code> 修饰符，不允许子类重写</strong>。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>又双叒叕成功更新了一篇水文。😜</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_28/06.png" alt=""></p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-server-component/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-server-compone
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector Client Component 客户端组件</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-client-component/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-client-component/</id>
    <published>2020-07-24T16:00:00.000Z</published>
    <updated>2017-12-14T14:44:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-client-component/">http://www.iocoder.cn/SkyWalking/collector-client-component/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-client-component/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-client-component/">2. Client</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-client-component/">3. ElasticSearchClient</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-client-component/">4. GRPCClient</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-client-component/">5. H2Client</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-client-component/">6. RedisClient</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-client-component/">7. ZookeeperClient</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-client-component/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>SkyWalking Collector Client Component 客户端组件</strong>。Collector 通过客户端，和其他服务进行通信，例如 Elastic Search 、Zookeeper 、H2 等等。</p><p>Client Component 在 SkyWalking 架构图处于如下位置( <strong>红框</strong> ) ：</p><blockquote><p>FROM <a href="https://github.com/apache/incubating-skywalking" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubating-skywalking</a><br><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_25/01.jpeg" alt=""></p></blockquote><p>下面我们来看看整体的项目结构，如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_25/02.png" alt=""></p><p>OK，我们从<strong>接口到实现</strong>的顺序进行分享。</p><h1 id="2-Client"><a href="#2-Client" class="headerlink" title="2. Client"></a>2. Client</h1><p><a href="https://github.com/YunaiV/skywalking/blob/c546a9a4d4588d99bf532da519ae721ef60b918e/apm-collector/apm-collector-component/client-component/src/main/java/org/skywalking/apm/collector/client/Client.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.client.Client</code></a> ，客户端<strong>接口</strong>。其定义接口方法如下：</p><ul><li><code>#initialize()</code> 方法，初始化客户端。</li><li><code>#shutdown()</code> 方法，关闭客户端。</li></ul><p>Client 的实现类，如下类图：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_25/03.png" alt=""></p><h1 id="3-ElasticSearchClient"><a href="#3-ElasticSearchClient" class="headerlink" title="3. ElasticSearchClient"></a>3. ElasticSearchClient</h1><p><a href="https://github.com/YunaiV/skywalking/blob/001f700612ad52bc1eb1a278bc0e2ff9e5330df8/apm-collector/apm-collector-component/client-component/src/main/java/org/skywalking/apm/collector/client/elasticsearch/ElasticSearchClient.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.client.elasticsearch.ElasticSearchClient</code></a> ，Elastic Search 客户端。 </p><p>基于 <code>org.elasticsearch.client.transport</code> 的 <code>5.5.0</code> 版本，封装 SkyWalking 需要的 Elastic Search 操作。目前用于 <a href="https://github.com/YunaiV/skywalking/blob/001f700612ad52bc1eb1a278bc0e2ff9e5330df8/apm-collector/apm-collector-storage/collector-storage-es-provider" rel="external nofollow noopener noreferrer" target="_blank"><code>collector-storage-es-provider</code></a> 模块。</p><h1 id="4-GRPCClient"><a href="#4-GRPCClient" class="headerlink" title="4. GRPCClient"></a>4. GRPCClient</h1><p><a href="https://github.com/YunaiV/skywalking/blob/001f700612ad52bc1eb1a278bc0e2ff9e5330df8/apm-collector/apm-collector-component/client-component/src/main/java/org/skywalking/apm/collector/client/grpc/GRPCClient.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.client.grpc.GRPCClient</code></a> ，gRPC 客户端。</p><p>基于 <code>io.grpc.grpc-core</code> 的 <code>1.8.0</code> 版本，封装 SkyWalking 需要的 gRPC 操作。目前用于 <a href="https://github.com/YunaiV/skywalking/tree/001f700612ad52bc1eb1a278bc0e2ff9e5330df8/apm-collector/apm-collector-remote/collector-remote-grpc-provider" rel="external nofollow noopener noreferrer" target="_blank"><code>collector-remote-grpc-provider</code></a> 模块。 </p><h1 id="5-H2Client"><a href="#5-H2Client" class="headerlink" title="5. H2Client"></a>5. H2Client</h1><p><a href="https://github.com/YunaiV/skywalking/blob/001f700612ad52bc1eb1a278bc0e2ff9e5330df8/apm-collector/apm-collector-component/client-component/src/main/java/org/skywalking/apm/collector/client/h2/H2Client.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.client.h2.H2Client</code></a> ，H2 数据库客户端。</p><p>基于 <code>com.h2database.h2</code> 的 <code>1.4.196</code> 版本，封装 SkyWalking 需要的 H2 数据库操作。目前用于 <a href="https://github.com/YunaiV/skywalking/tree/001f700612ad52bc1eb1a278bc0e2ff9e5330df8/apm-collector/apm-collector-storage/collector-storage-h2-provider" rel="external nofollow noopener noreferrer" target="_blank"><code>collector-storage-h2-provider</code></a> / <a href="https://github.com/YunaiV/skywalking/tree/001f700612ad52bc1eb1a278bc0e2ff9e5330df8/apm-collector/apm-collector-cluster/collector-cluster-standalone-provider" rel="external nofollow noopener noreferrer" target="_blank"><code>collector-cluster-standalone-provider</code></a> 模块。</p><h1 id="6-RedisClient"><a href="#6-RedisClient" class="headerlink" title="6. RedisClient"></a>6. RedisClient</h1><p><a href="https://github.com/YunaiV/skywalking/blob/001f700612ad52bc1eb1a278bc0e2ff9e5330df8/apm-collector/apm-collector-component/client-component/src/main/java/org/skywalking/apm/collector/client/redis/RedisClient.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.client.redis.RedisClient</code></a> ，Redis 客户端。</p><p>基于 <code>redis.clients.jedis</code> 的 <code>2.9.0</code> 版本，封装 SkyWalking 需要的 Reids 操作。预计未来用于 <a href="https://github.com/YunaiV/skywalking/tree/001f700612ad52bc1eb1a278bc0e2ff9e5330df8/apm-collector/apm-collector-cluster/collector-cluster-redis-provider" rel="external nofollow noopener noreferrer" target="_blank"><code>collector-cluster-redis-provider</code></a> 模块。</p><h1 id="7-ZookeeperClient"><a href="#7-ZookeeperClient" class="headerlink" title="7. ZookeeperClient"></a>7. ZookeeperClient</h1><p><a href="https://github.com/YunaiV/skywalking/blob/001f700612ad52bc1eb1a278bc0e2ff9e5330df8/apm-collector/apm-collector-component/client-component/src/main/java/org/skywalking/apm/collector/client/zookeeper/ZookeeperClient.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.client.zookeeper.ZookeeperClient</code></a> ，Zookeeper 客户端。</p><p>基于 <code>org.apache.zookeeper.zookeeper</code> 的 <code>3.4.10</code> 版本，封装 SkyWalking 需要的 Zookeeper 操作。预计未来用于 <a href="https://github.com/YunaiV/skywalking/tree/001f700612ad52bc1eb1a278bc0e2ff9e5330df8/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider" rel="external nofollow noopener noreferrer" target="_blank"><code>collector-cluster-zookeeper-provider</code></a> 模块。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>哈哈哈，是不是看的很有成就感( 笔者又在水更了 )。</p><p>不要方，下面还有一篇水更。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_25/04.png" alt=""></p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-client-component/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-client-compone
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector Cluster 集群管理</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-cluster-module/</id>
    <published>2020-07-19T16:00:00.000Z</published>
    <updated>2017-12-15T08:29:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">http://www.iocoder.cn/SkyWalking/collector-cluster-module/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">2. collector-cluster-define</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">2.1 ClusterModule</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">2.2 ModuleRegisterService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">2.3 ModuleListenerService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">2.4 DataMonitor</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">3. collector-cluster-zookeeper-provider</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">3.1 ClusterModuleZookeeperProvider</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">3.2 ZookeeperModuleRegisterService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">3.3 ZookeeperModuleListenerService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">3.4 ClusterZKDataMonitor</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">3.5 ZookeeperClient</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">4. collector-cluster-standalone-provider</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">5. collector-cluster-redis-provider</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>SkyWalking Collector Cluster Module</strong>，负责集群的管理，即 Collector 节点的注册于发现。</p><blockquote><p>友情提示：建议先阅读 <a href="http://www.iocoder.cn/SkyWalking/collector-init/?self">《SkyWalking 源码分析 —— Collector 初始化》</a> ，以了解 Collector 组件体系。</p></blockquote><p>Cluster Module 在 SkyWalking 架构图处于如下位置( <strong>红框</strong> ) ：</p><blockquote><p>FROM <a href="https://github.com/apache/incubating-skywalking" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubating-skywalking</a><br><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_20/01.jpeg" alt=""></p></blockquote><p>下面我们来看看整体的项目结构，如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_20/02.png" alt=""></p><ul><li><code>collector-cluster-define</code> ：定义集群管理接口。</li><li><code>collector-cluster-standalone-provider</code> ：基于 H2 的 集群管理实现。<strong>该实现是单机版，建议仅用于 SkyWalking 快速上手，生产环境不建议使用</strong>。</li><li><code>collector-cluster-redis-provider</code> ：基于 Redis 的集群管理实现。<em>目前暂未完成</em>。</li><li><code>collector-cluster-zookeeper-provider</code> ：基于 Zookeeper 的集群管理实现。<strong>生产环境推荐使用</strong></li></ul><p>下面，我们从<strong>接口到实现</strong>的顺序进行分享。</p><h1 id="2-collector-cluster-define"><a href="#2-collector-cluster-define" class="headerlink" title="2. collector-cluster-define"></a>2. collector-cluster-define</h1><p><code>collector-cluster-define</code> ：定义集群管理接口。项目结构如下 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_20/03.png" alt=""></p><ul><li><p>交互如下图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_20/04.png" alt=""></p></li><li><p>ModuleListenerService 暴露给其他 Module 注册监听器 ( ClusterModuleListener ) 到 DataMonitor 。</p></li><li>ModuleRegisterService 暴露给其他 Module 注册组件登记( ModuleRegistration ) 到 DataMonitor 。</li><li>通过实现 DataMonitor 接口，基于不同的存储器实现注册发现。</li></ul><h2 id="2-1-ClusterModule"><a href="#2-1-ClusterModule" class="headerlink" title="2.1 ClusterModule"></a>2.1 ClusterModule</h2><p><code>org.skywalking.apm.collector.cluster.ClusterModule</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java" rel="external nofollow noopener noreferrer" target="_blank">Module</a> 抽象类，集群管理 Module 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/ClusterModule.java#L33" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回模块名为 <code>&quot;cluster&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/ClusterModule.java#L37" rel="external nofollow noopener noreferrer" target="_blank"><code>#services()</code></a> <strong>实现</strong>方法，返回 Service 类名：ModuleListenerService / ModuleRegisterService 。</p><h2 id="2-2-ModuleRegisterService"><a href="#2-2-ModuleRegisterService" class="headerlink" title="2.2 ModuleRegisterService"></a>2.2 ModuleRegisterService</h2><p><code>org.skywalking.apm.collector.cluster.service.ModuleRegisterService</code> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> 接口，模块注册服务<strong>接口</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/service/ModuleRegisterService.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>#register(moduleName, providerName, registration)</code></a> <strong>接口</strong>方法，注册模块注册信息。一般情况下，实现该接口方法，调用 <code>DataMonitor#register(path, registration)</code> 方法。</p><h3 id="2-2-1-ModuleRegistration"><a href="#2-2-1-ModuleRegistration" class="headerlink" title="2.2.1 ModuleRegistration"></a>2.2.1 ModuleRegistration</h3><p><code>org.skywalking.apm.collector.cluster.ModuleRegistration</code> ，模块注册信息<strong>抽象类</strong>。不同 Module 通过实现 ModuleRegistration ，将它们注册到 ModuleRegisterService。目前子类如下 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_20/05.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/ModuleRegistration.java" rel="external nofollow noopener noreferrer" target="_blank"><code>#buildValue()</code></a> <strong>抽象</strong>方法，获得模块注册信息( <a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/ModuleRegistration.java#L30" rel="external nofollow noopener noreferrer" target="_blank">Value</a> )。</p><h2 id="2-3-ModuleListenerService"><a href="#2-3-ModuleListenerService" class="headerlink" title="2.3 ModuleListenerService"></a>2.3 ModuleListenerService</h2><p><code>org.skywalking.apm.collector.cluster.service.ModuleListenerService</code> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> 接口，注册监听器服务<strong>接口</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/service/ModuleListenerService.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><code>#addListener(listener)</code></a> <strong>接口</strong>方法，添加监听器。一般情况下，实现该接口方法，调用 <code>DataMonitor#addListener(listener)</code> 方法。</p><h3 id="2-3-1-ClusterModuleListener"><a href="#2-3-1-ClusterModuleListener" class="headerlink" title="2.3.1 ClusterModuleListener"></a>2.3.1 ClusterModuleListener</h3><p><code>org.skywalking.apm.collector.cluster.ClusterModuleListener</code> ，集群组件监听器<strong>抽象类</strong>。目前子类如下 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_20/11.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/ClusterModuleListener.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><strong>构造方法</strong></a>，创建地址数组( <code>addresses</code> )。该数组的读写方法如下：</p><ul><li><code>#addAddress(address)</code></li><li><code>#removeAddress(address)</code></li><li><code>#getAddresses()</code></li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/ClusterModuleListener.java#L43" rel="external nofollow noopener noreferrer" target="_blank"><code>#path()</code></a> <strong>抽象</strong>方法，返回路径。该路径即为 ClusterModuleListener 监听的<strong>“事件”</strong>。多个 Collector 节点的相同 Module ，<strong>通过路径分组形成集群</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/ClusterModuleListener.java#L62" rel="external nofollow noopener noreferrer" target="_blank"><code>#serverJoinNotify(serverAddress)</code></a> / <a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/ClusterModuleListener.java#L69" rel="external nofollow noopener noreferrer" target="_blank"><code>#serverQuitNotify(serverAddress)</code></a> <strong>抽象</strong>方法，通知服务的加入 / 下线。目前只有 GRPCRemoteSenderService <strong>真正</strong>( 其它都是空方法 )实现该方法，在 <a href="">TODO 【4002】Remote</a> 详细解析。</p><h2 id="2-4-DataMonitor"><a href="#2-4-DataMonitor" class="headerlink" title="2.4 DataMonitor"></a>2.4 DataMonitor</h2><p><code>org.skywalking.apm.collector.cluster.DataMonitor</code> ，数据监<strong>视</strong>器<strong>接口</strong>。通过实现 DataMonitor 接口，基于不同的存储器实现注册发现。目前子类如下 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_20/06.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/DataMonitor.java#L40" rel="external nofollow noopener noreferrer" target="_blank"><code>#register(path, registration)</code></a> <strong>接口</strong>方法，注册模块注册信息。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/DataMonitor.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>#addListener(ClusterModuleListener)</code></a> <strong>接口</strong>方法，添加监听器。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/DataMonitor.java#L42" rel="external nofollow noopener noreferrer" target="_blank"><code>#getListener(path)</code></a> <strong>接口</strong>方法，获得监听<strong>指定路径</strong>的监听器。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/DataMonitor.java#L36" rel="external nofollow noopener noreferrer" target="_blank"><code>#setClient(Client)</code></a> <strong>接口</strong>方法，设置 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-component/client-component/src/main/java/org/skywalking/apm/collector/client/Client.java" rel="external nofollow noopener noreferrer" target="_blank">Client</a> 。在 <a href="https://github.com/YunaiV/skywalking/tree/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-component/client-component/src/main/java/org/skywalking/apm/collector/client" rel="external nofollow noopener noreferrer" target="_blank"><code>client-component</code></a> 有 ZookeeperClient / H2Client / ElasticSearchClient 等多种实现。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/DataMonitor.java#L34" rel="external nofollow noopener noreferrer" target="_blank"><code>BASE_CATALOG</code></a> 属性，基础目录为 <code>&quot;/skywalking&quot;</code> 。例如说，在 Zookeeper 为根节点的路径。</li><li><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/DataMonitor.java#L44" rel="external nofollow noopener noreferrer" target="_blank"><code>#createPath(path)</code></a> <strong>接口</strong>方法，使用 Client 创建路径。</li><li><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-define/src/main/java/org/skywalking/apm/collector/cluster/DataMonitor.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#setData(path)</code></a> <strong>接口</strong>方法，使用 Client 设置路径的值。</li></ul><h1 id="3-collector-cluster-zookeeper-provider"><a href="#3-collector-cluster-zookeeper-provider" class="headerlink" title="3. collector-cluster-zookeeper-provider"></a>3. collector-cluster-zookeeper-provider</h1><p><code>collector-cluster-zookeeper-provider</code> ，基于 Zookeeper 的集群管理实现。项目结构如下 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_20/07.png" alt=""></p><p>实际使用时，通过 <code>application.yml</code> 配置如下：</p><figure class="highlight"><table><tr><td class="code"><pre><div class="line">cluster:</div><div class="line">  zookeeper:</div><div class="line">    hostPort: localhost:2181</div><div class="line">    sessionTimeout: 100000</div></pre></td></tr></table></figure><ul><li>生产环境下，推荐 Zookeeper 配置成集群。</li></ul><h2 id="3-1-ClusterModuleZookeeperProvider"><a href="#3-1-ClusterModuleZookeeperProvider" class="headerlink" title="3.1 ClusterModuleZookeeperProvider"></a>3.1 ClusterModuleZookeeperProvider</h2><p><code>org.skywalking.apm.collector.cluster.zookeeper.ClusterModuleZookeeperProvider</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java" rel="external nofollow noopener noreferrer" target="_blank">ModuleProvider</a> <strong>抽象类</strong>，基于 Zookeeper 的集群管理服务提供者。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterModuleZookeeperProvider.java#L53" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>实现</strong>方法，返回组件服务提供者名为 <code>&quot;zookeeper&quot;</code> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterModuleZookeeperProvider.java#L57" rel="external nofollow noopener noreferrer" target="_blank"><code>module()</code></a> <strong>实现</strong>方法，返回组件类为 ClusterModule 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterModuleZookeeperProvider.java#L94" rel="external nofollow noopener noreferrer" target="_blank"><code>#requiredModules()</code></a> <strong>实现</strong>方法，返回依赖组件为空。</p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterModuleZookeeperProvider.java#L61" rel="external nofollow noopener noreferrer" target="_blank"><code>#prepare(Properties)</code></a> <strong>实现</strong>方法，执行准备阶段逻辑。</p><ul><li>第 63 行 ：创建 ClusterZKDataMonitor 对象。</li><li>第 69 行 ：创建 ZookeeperClient 对象。<strong>注意，此时并未连接 Zookeeper</strong> 。</li><li>第 71 至 73 行 ：创建 ZookeeperModuleListenerService / ZookeeperModuleRegisterService 对象，并调用 <code>#registerServiceImplementation()</code> <strong>父类</strong>方法，注册到 <code>services</code> 。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterModuleZookeeperProvider.java#L76" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> <strong>实现</strong>方法，执行启动阶段逻辑。</p><ul><li>第 79 行 ：调用 <code>ZookeeperClient#initialize()</code> 方法，初始化 ZookeeperClient ，<strong>此时会连接 Zookeeper</strong>。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterModuleZookeeperProvider.java#L85" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyAfterCompleted()</code></a> <strong>实现</strong>方法，执行启动完成逻辑。</p><ul><li>第 88 行 ：调用 <code>ClusterZKDataMonitor#start()</code> 方法，启动 ClusterZKDataMonitor 。在本文 <a href="#">「3.4 ClusterZKDataMonitor」</a> 详细解析。</li></ul><h2 id="3-2-ZookeeperModuleRegisterService"><a href="#3-2-ZookeeperModuleRegisterService" class="headerlink" title="3.2 ZookeeperModuleRegisterService"></a>3.2 ZookeeperModuleRegisterService</h2><p><code>org.skywalking.apm.collector.cluster.zookeeper.service.ZookeeperModuleRegisterService</code> ，基于 Zookeeper 的模块注册服务<strong>实现类</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/service/ZookeeperModuleRegisterService.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>#register(moduleName, providerName, registration)</code></a> <strong>实现</strong>方法，调用 <code>ClusterZKDataMonitor#register(path, registration)</code> 方法，注册模块注册信息。</p><h2 id="3-3-ZookeeperModuleListenerService"><a href="#3-3-ZookeeperModuleListenerService" class="headerlink" title="3.3 ZookeeperModuleListenerService"></a>3.3 ZookeeperModuleListenerService</h2><p><code>org.skywalking.apm.collector.cluster.zookeeper.service.ZookeeperModuleListenerService</code> ，基于 Zookeeper 的注册监听器服务<strong>实现类</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/service/ZookeeperModuleListenerService.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>#addListener(ClusterModuleListener)</code></a> <strong>实现</strong>方法，调用 <code>ClusterZKDataMonitor#addListener(ClusterModuleListener)</code> 方法，注册模块注册信息。</p><h2 id="3-4-ClusterZKDataMonitor"><a href="#3-4-ClusterZKDataMonitor" class="headerlink" title="3.4 ClusterZKDataMonitor"></a>3.4 ClusterZKDataMonitor</h2><p><code>org.skywalking.apm.collector.cluster.zookeeper.ClusterZKDataMonitor</code> ，基于 Zookeeper 的数据监视器<strong>实现类</strong>。</p><p>在看具体代码实现之前，我们先来看看 Zookeeper 是如何存储数据的，如下图所示 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_20/08.png" alt=""></p><ul><li>紫色部分，通过调用 <a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterZKDataMonitor.java#L172" rel="external nofollow noopener noreferrer" target="_blank"><code>#createPath(path)</code></a> 方法，顺着路径，逐层创建<strong>持久</strong>节点。</li><li>黄色部分，通过调用 <a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterZKDataMonitor.java#L184" rel="external nofollow noopener noreferrer" target="_blank"><code>#setData(path)</code></a> 方法，创建<strong>临时</strong>节点，设置 Collector 模块地址。若 Collector 集群有 N 个节点，则此处会有 N 个<strong>临时</strong>节点。</li><li><p>打开 <code>zkClient.sh</code> ，我们来看一个例子 ：</p>  <figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 1] ls /skywalking</div><div class="line">[remote, ui, agent_jetty, agent_gRPC]</div><div class="line"></div><div class="line">[zk: localhost:2181(CONNECTED) 2] ls /skywalking/ui</div><div class="line">[jetty]</div><div class="line"></div><div class="line">[zk: localhost:2181(CONNECTED) 3] ls /skywalking/ui/jetty</div><div class="line">[localhost:12800]</div><div class="line"></div><div class="line">[zk: localhost:2181(CONNECTED) 4] get /skywalking/ui/jetty/localhost:12800</div><div class="line">/</div><div class="line">cZxid = 0x24</div><div class="line">ctime = Thu Dec 14 16:05:25 CST 2017</div><div class="line">mZxid = 0x24</div><div class="line">mtime = Thu Dec 14 16:05:25 CST 2017</div><div class="line">pZxid = 0x24</div><div class="line">cversion = 0</div><div class="line">dataVersion = 0</div><div class="line">aclVersion = 0</div><div class="line">ephemeralOwner = 0x16052d8b9f40006</div><div class="line">dataLength = 1</div><div class="line">numChildren = 0</div></pre></td></tr></table></figure></li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterZKDataMonitor.java#L163" rel="external nofollow noopener noreferrer" target="_blank"><code>#register(path, registration)</code></a> <strong>实现</strong>方法，添加到组件注册信息集合( <code>registrations</code> )。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterZKDataMonitor.java#L123" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> 方法，启动 ClusterZKDataMonitor ，将组件注册信息( <code>registrations</code> ) 写到 Zookeeper 中。</p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterZKDataMonitor.java#L157" rel="external nofollow noopener noreferrer" target="_blank"><code>#addListener(listener)</code></a> <strong>实现</strong>方法，添加到监听器集合( <code>listeners</code> )。</p><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-cluster/collector-cluster-zookeeper-provider/src/main/java/org/skywalking/apm/collector/cluster/zookeeper/ClusterZKDataMonitor.java#L123" rel="external nofollow noopener noreferrer" target="_blank"><code>#process(WatchedEvent)</code></a> <strong>实现</strong>方法，处理有 Collector 节点的组件加入或下线。总体逻辑是，从 Zookeeper 获取变更的路径下的地址数组，和本地的地址( <code>ClusterModuleListener.addresses</code> )比较，处理加入或移除逻辑的地址。</p><ul><li>ClusterZKDataMonitor 实现 <code>org.apache.zookeeper.Watcher</code> <strong>接口</strong>，所以实现该方法。</li><li>该方法是 <code>synchronized</code> 方法，以保证不会出现并发问题。</li></ul><h2 id="3-5-ZookeeperClient"><a href="#3-5-ZookeeperClient" class="headerlink" title="3.5 ZookeeperClient"></a>3.5 ZookeeperClient</h2><p><a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-component/client-component/src/main/java/org/skywalking/apm/collector/client/zookeeper/ZookeeperClient.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.client.zookeeper.ZookeeperClient</code></a> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/20d38d7fcbbaac65e10eb8d256881fc9c0cedd87/apm-collector/apm-collector-component/client-component/src/main/java/org/skywalking/apm/collector/client/Client.java" rel="external nofollow noopener noreferrer" target="_blank">Client</a> <strong>接口</strong>，Zookeeper 客户端。</p><p>代码比较简单，胖友自己阅读理解。</p><h1 id="4-collector-cluster-standalone-provider"><a href="#4-collector-cluster-standalone-provider" class="headerlink" title="4. collector-cluster-standalone-provider"></a>4. collector-cluster-standalone-provider</h1><p><code>collector-cluster-standalone-provider.ClusterStandaloneDataMonitor</code> ，基于 H2 的 集群管理实现。<strong>该实现是单机版，建议仅用于 SkyWalking 快速上手，生产环境不建议使用</strong>。项目结构如下 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_20/09.png" alt=""></p><p>大体实现和 <code>collector-cluster-zookeeper-provider</code> 差不多，差异在对 DataMonitor 的实现类 ClusterStandaloneDataMonitor 上。</p><p>在 ClusterStandaloneDataMonitor 里，实际并未使用 H2Client ，而是基于内存，胖友可以自己查看下。</p><h1 id="5-collector-cluster-redis-provider"><a href="#5-collector-cluster-redis-provider" class="headerlink" title="5. collector-cluster-redis-provider"></a>5. collector-cluster-redis-provider</h1><p><code>collector-cluster-redis-provider</code> ：基于 Redis 的集群管理实现。<em>目前暂未完成</em>。</p><p>【TODO 4003】等实现后来写写，基于 Redis Pub Sub 保证实时性</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>有一种硬生生把很简单的东西，写的很复杂的感觉。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_20/10.png" alt=""></p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-cluster-module/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-cluster-module/&lt;
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Collector 初始化</title>
    <link href="http://www.iocoder.cn/SkyWalking/collector-init/"/>
    <id>http://www.iocoder.cn/SkyWalking/collector-init/</id>
    <published>2020-07-14T16:00:00.000Z</published>
    <updated>2017-12-23T23:37:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/collector-init/">http://www.iocoder.cn/SkyWalking/collector-init/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-init/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-init/">2. CollectorBootStartUp</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-init/">2. ApplicationConfigLoader</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-init/">3. ModuleManager</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-init/">3.1 Module</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-init/">3.2 ModuleProvider</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-init/">3.3 Service</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-init/">3.4 BootstrapFlow</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-init/">4. Module 实现类简介</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>SkyWalking Collector 启动初始化的过程</strong>。在分享的过程中，我们会<strong>简单</strong>介绍 Collector 每个模块及其用途。</p><p>ps ：Collector 是 SkyWalking 的 Server 端。整体如下图 ：</p><blockquote><p>FROM <a href="https://github.com/apache/incubating-skywalking" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubating-skywalking</a><br><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/01.png" alt=""></p></blockquote><h1 id="2-CollectorBootStartUp"><a href="#2-CollectorBootStartUp" class="headerlink" title="2. CollectorBootStartUp"></a>2. CollectorBootStartUp</h1><p><code>org.skywalking.apm.collector.boot.CollectorBootStartUp</code> ，在 <code>apm-sniffer/apm-agent</code> Maven 模块项目里，SkyWalking Collector <strong>启动入口</strong>。 </p><p><a href="https://github.com/YunaiV/skywalking/blob/c633c1f0e143d1df2457926ab239350a642f7be2/apm-collector/apm-collector-boot/src/main/java/org/skywalking/apm/collector/boot/CollectorBootStartUp.java#L38" rel="external nofollow noopener noreferrer" target="_blank"><code>#main(args)</code></a> 方法，启动 Collector ，代码如下 ：</p><ul><li>第 45 行 ：调用 <code>ApplicationConfiguration#load()</code> 方法，加载 Collector <strong>配置</strong>。</li><li>第 47 行 ：调用 <code>ModuleManager#init(...)</code> 方法，初始化 Collector <strong>组件</strong>们。</li><li>第 60 行 ：调用 <code>Thread#sleep(60000)</code> 方法，等待 Collector 内嵌的 Jetty Server 启动完成。</li></ul><h1 id="2-ApplicationConfigLoader"><a href="#2-ApplicationConfigLoader" class="headerlink" title="2. ApplicationConfigLoader"></a>2. ApplicationConfigLoader</h1><p><code>org.skywalking.apm.collector.boot.config.ApplicationConfigLoader</code> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/c633c1f0e143d1df2457926ab239350a642f7be2/apm-collector/apm-collector-boot/src/main/java/org/skywalking/apm/collector/boot/config/ConfigLoader.java#L24" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.boot.config.ConfigLoader</code></a> 接口，Collector 配置( <a href="https://github.com/YunaiV/skywalking/blob/c633c1f0e143d1df2457926ab239350a642f7be2/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ApplicationConfiguration.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.core.module.ApplicationConfiguration</code></a> )加载器。</p><p>在看具体代码实现之前，我们先了解下 ApplicationConfiguration 整体类结构。如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/02.png" alt=""></p><ul><li>Collector 使用组件管理器( ModuleManager )，管理<strong>多个</strong>组件( <a href="https://github.com/YunaiV/skywalking/blob/c633c1f0e143d1df2457926ab239350a642f7be2/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java" rel="external nofollow noopener noreferrer" target="_blank">Module</a> )。<ul><li>一个组件有多种组件服务提供者( <a href="https://github.com/YunaiV/skywalking/blob/c633c1f0e143d1df2457926ab239350a642f7be2/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java" rel="external nofollow noopener noreferrer" target="_blank">ModuleProvider</a> )，<strong>同时</strong>一个组件只允许使用<strong>一个</strong>组件服务提供者。这块下面会有代码解析说明。</li></ul></li><li>Collector 使用一个应用配置类( <a href="https://github.com/YunaiV/skywalking/blob/c633c1f0e143d1df2457926ab239350a642f7be2/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ApplicationConfiguration.java" rel="external nofollow noopener noreferrer" target="_blank">ApplicationConfiguration</a> )。<ul><li>一个应用配置类包含多个组件配置类( <a href="https://github.com/YunaiV/skywalking/blob/c633c1f0e143d1df2457926ab239350a642f7be2/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ApplicationConfiguration.java#L62" rel="external nofollow noopener noreferrer" target="_blank">ModuleConfiguration</a> )。每个组件对应一个组件配置类。</li><li>一个组件配置类包含多个组件服务提供者配置( <a href="https://github.com/YunaiV/skywalking/blob/c633c1f0e143d1df2457926ab239350a642f7be2/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ApplicationConfiguration.java#L93" rel="external nofollow noopener noreferrer" target="_blank">ProviderConfiguration</a> )。每个组件服务提供者对应一个组件配置类。<strong>注意</strong>：因为一个组件只允许<strong>同时</strong>使用<strong>一个</strong>组件服务提供者，所以一个组件配置类<strong>只设置</strong>一个组件服务提供者配置。</li></ul></li><li>整个配置文件，对应应用配置类。<strong>绿框</strong>部分，对应一个组件配置类。<strong>红框</strong>部分，对应一个组件服务提供者配置类。</li></ul><p>下面，我们来看看 <a href="https://github.com/YunaiV/skywalking/blob/c633c1f0e143d1df2457926ab239350a642f7be2/apm-collector/apm-collector-boot/src/main/java/org/skywalking/apm/collector/boot/config/ApplicationConfigLoader.java#L43" rel="external nofollow noopener noreferrer" target="_blank"><code>ApplicationConfigLoader#load()</code></a> 方法，代码如下 ：</p><ul><li>第 47 行 ：调用 <code>#loadConfig()</code> 方法，从 <code>apm-collector-core</code> 的 <a href="https://github.com/YunaiV/skywalking/blob/c633c1f0e143d1df2457926ab239350a642f7be2/apm-collector/apm-collector-core/src/main/resources/application-default.yml" rel="external nofollow noopener noreferrer" target="_blank"><code>application.yml</code></a> 加载自定义配置。</li><li>第 49 行 ：调用 <code>#loadDefaultConfig()</code> 方法，从 <code>apm-collector-core</code> 的 <a href="https://github.com/YunaiV/skywalking/blob/c633c1f0e143d1df2457926ab239350a642f7be2/apm-collector/apm-collector-core/src/main/resources/application-default.yml" rel="external nofollow noopener noreferrer" target="_blank"><code>application-default.yml</code></a> 加载默认配置。</li><li>两个方法逻辑基本一致，已经添加代码注释，胖友自己阅读理解。</li></ul><h1 id="3-ModuleManager"><a href="#3-ModuleManager" class="headerlink" title="3. ModuleManager"></a>3. ModuleManager</h1><p><code>org.skywalking.apm.collector.core.module.ModuleManager</code> ，组件管理器，负责组件的管理与初始化。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ff055ee52da855ef6cc8bfdfae7c2758ae3c61cd/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleManager.java#L49" rel="external nofollow noopener noreferrer" target="_blank"><code>#init()</code></a> 方法，初始化组件们，代码如下 ：</p><ul><li><p>第 51 至 53 行 ：调用 <code>java.util.ServiceLoader#load(Module.class)</code> 方法，加载所有 Module 实现类的实例数组。ServiceManager 基于 SPI (Service Provider Interface) 机制，在每个 <code>apm-collector-xxx-define</code> 项目的 <code>/resources/META-INF.services/org.skywalking.apm.collector.core.module.Module</code> 文件里，定义了该项目 Module 的实现类。如果胖友对 SPI 机制不熟悉，可以看下如下文章 ：</p><ul><li><a href="http://www.jianshu.com/p/32d3e108f30a" rel="external nofollow noopener noreferrer" target="_blank">《SPI 和 ServiceLoader》</a> </li><li><a href="http://www.jianshu.com/p/46aa69643c97" rel="external nofollow noopener noreferrer" target="_blank">《跟我学Dubbo系列之Java SPI机制简介》</a> </li></ul></li><li><p>第 55 至 75 行 ：遍历所有 Module 实现类的实例数组，创建<strong>在配置中</strong>的 Module 实现类的实例，并执行 Module 准备阶段的逻辑，后添加到加载的组件实例的映射( <code>loadedModules</code> )。</p><ul><li>第 59 至 67 行 ：创建 Module 对象。</li><li>第 69 行 ：调用 <code>Module#prepare(...)</code> 方法，执行 Module 准备阶段的逻辑。在改方法内部，会创建 Module 对应的 ModuleProvider 。在 <a href="#">「3.1 Module」</a> 详细解析。</li><li>第 71 行 ：添加到 <code>loadedModules</code> 。</li></ul></li><li>第 77 至 80 行 ：校验<strong>在配置中</strong>的 Module 实现类的实例都创建了，否则抛出异常。</li><li>第 84 行 ：调用 <code>BootstrapFlow#start(...)</code> 方法，执行 Module 启动逻辑。<a href="#">「3.4 BootstrapFlow」</a> 详细解析。</li><li>第 86 行 ：调用 <code>BootstrapFlow#notifyAfterCompleted()</code> 方法，执行 Module 启动完成，通知 ModuleProvider 。<a href="#">「3.4 BootstrapFlow」</a> 详细解析。</li><li>总的来说，Module 初始化的过程，可以理解成三个阶段，如下图所示 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/03.png" alt=""></li></ul><h2 id="3-1-Module"><a href="#3-1-Module" class="headerlink" title="3.1 Module"></a>3.1 Module</h2><p><code>org.skywalking.apm.collector.core.module.Module</code> ，组件<strong>抽象类</strong>。通过实现 Module 抽象类，实现不同功能的组件。目前 Collector 的 Module 实现类如下图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/04.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/204a9e658dd95cc8ee5d4e65d7ca1ed58f3a71da/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>抽象</strong>方法，获得组件名。目前组件名有 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/05.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/204a9e658dd95cc8ee5d4e65d7ca1ed58f3a71da/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java#L110" rel="external nofollow noopener noreferrer" target="_blank"><code>#providers()</code></a> 方法，获得 ModuleProvider 数组。实际上，一个 Module <strong>同时</strong>只能有一个 ModuleProvider ，参见 <a href="https://github.com/YunaiV/skywalking/blob/204a9e658dd95cc8ee5d4e65d7ca1ed58f3a71da/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java#L114" rel="external nofollow noopener noreferrer" target="_blank"><code>#provider()</code></a> 方法。</p><p><a href="https://github.com/YunaiV/skywalking/blob/204a9e658dd95cc8ee5d4e65d7ca1ed58f3a71da/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java#L55" rel="external nofollow noopener noreferrer" target="_blank"><code>#services()</code></a> <strong>抽象</strong>方法，获得 Service <strong>类</strong>数组。具体 Service <strong>对象</strong>，在 ModuleProvider 对象里获取，参见 <a href="https://github.com/YunaiV/skywalking/blob/204a9e658dd95cc8ee5d4e65d7ca1ed58f3a71da/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java#L122" rel="external nofollow noopener noreferrer" target="_blank"><code>#getService(serviceType)</code></a> 方法。</p><p><a href="https://github.com/YunaiV/skywalking/blob/204a9e658dd95cc8ee5d4e65d7ca1ed58f3a71da/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Module.java#L66" rel="external nofollow noopener noreferrer" target="_blank"><code>#prepare(...)</code></a> 方法，执行 Module <strong>准备阶段</strong>的逻辑，代码如下 ：</p><ul><li>第 69 行 ：调用 <code>java.util.ServiceLoader#load(ModuleProvider.class)</code> 方法，加载所有 ModuleProvider 实现类的实例数组。ServiceManager 基于 SPI (Service Provider Interface) 机制，在每个 <code>apm-collector-xxx-yyy-provider</code> 项目的 <code>/resources/META-INF.services/org.skywalking.apm.collector.core.module.ModuleProvider</code> 文件里，定义了该项目 ModuleProvider 的实现类。</li><li>第 72 至 93 行 ：遍历所有 ModuleProvider 实现类的实例数组，创建<strong>在配置中</strong>的 ModuleProvider 实现类的实例，后添加到加载的组件服务提供者实例的映射( <code>loadedProviders</code> )。</li><li>第 95 至 98 行 ：校验有 ModuleProvider 初始化，否则抛出异常。</li><li>第 100 至 104 行 ：调用 <code>ModuleProvider#prepare(...)</code>  方法，执行 ModuleProvider 准备阶段的逻辑。在改方法内部，会创建 ModuleProvider 对应的 Service 。在 <a href="#">「3.2 ModuleProvider」</a> 详细解析。</li></ul><h2 id="3-2-ModuleProvider"><a href="#3-2-ModuleProvider" class="headerlink" title="3.2 ModuleProvider"></a>3.2 ModuleProvider</h2><p><code>org.skywalking.apm.collector.core.module.ModuleProvider</code> ，组件服务提供者<strong>抽象类</strong>。通过实现 ModuleProvider 抽象类，实现不同功能的组件服务提供者。目前 Collector 的 ModuleProvider 实现类如下图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/06.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java#L64" rel="external nofollow noopener noreferrer" target="_blank"><code>#name()</code></a> <strong>抽象</strong>方法，获得组件服务提供者名。目前组件服务提供者名有 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/07.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java#L69" rel="external nofollow noopener noreferrer" target="_blank"><code>#module()</code></a> <strong>抽象</strong>方法，获得 ModuleProvider 对应的 Module <strong>类</strong>。注意，ModuleProvider 的名字可以重复，例如上图的 <code>jetty</code> ，通过对应的 Module <strong>类</strong>来区分。</p><p><a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java#L95" rel="external nofollow noopener noreferrer" target="_blank"><code>#requiredModules()</code></a> <strong>抽象</strong>方法，获得 ModuleProvider 依赖的 Module <strong>名字</strong>数组。</p><p>———- Service 相关方法 Begin ———-</p><p><a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java#L103" rel="external nofollow noopener noreferrer" target="_blank"><code>#registerServiceImplementation(Class&lt;? extends Service&gt;, Service)</code></a> 方法，注册 Service 对象。一个 ModuleProvider 可以有 0 到 N 个 Service 对象。</p><p><a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java#L133" rel="external nofollow noopener noreferrer" target="_blank"><code>#getService(Class&lt;T&gt;)</code></a> 方法，获得 Service 对象。</p><p><a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java#L118" rel="external nofollow noopener noreferrer" target="_blank"><code>#requiredCheck(...)</code></a> 方法，<strong>校验</strong> ModuleProvider 包含的 Service 们都创建成功。</p><ul><li><strong>方法参数</strong>，从 <code>Module#services()</code> 方法获得。</li><li>该方法会被 <code>BootstrapFlow#start()</code> 方法调用，在 <a href="#">「3.4 BootstrapFlow」</a> 详细解析。</li></ul><p>———- Service 相关方法 End ———-</p><p><a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java#L76" rel="external nofollow noopener noreferrer" target="_blank"><code>#prepare(Properties)</code></a> <strong>抽象</strong>方法，执行 ModuleProvider 准备阶段的逻辑：Service 的创建，私有变量的创建等等。例如，<a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-storage/collector-storage-h2-provider/src/main/java/org/skywalking/apm/collector/storage/h2/StorageModuleH2Provider.java#L123" rel="external nofollow noopener noreferrer" target="_blank"><code>StorageModuleH2Provider#prepare(Properties)</code></a> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java#L83" rel="external nofollow noopener noreferrer" target="_blank"><code>#start(Properties)</code></a> <strong>抽象</strong>方法，执行 ModuleProvider 启动阶段的逻辑：私有变量的初始化等等。例如，<a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-storage/collector-storage-h2-provider/src/main/java/org/skywalking/apm/collector/storage/h2/StorageModuleH2Provider.java#L136" rel="external nofollow noopener noreferrer" target="_blank"><code>StorageModuleH2Provider#start(Properties)</code></a> 。</p><ul><li>该方法会被 <code>BootstrapFlow#start()</code> 方法调用，在 <a href="#">「3.4 BootstrapFlow」</a> 详细解析。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/ModuleProvider.java#L90" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyAfterCompleted()</code></a> <strong>抽象</strong>方法，执行 ModuleProvider 启动完成阶段的逻辑：私有变量的初始化等等。例如，<a href="https://github.com/YunaiV/skywalking/blob/3fb837104a111ff94abef9c871c814fb60c18340/apm-collector/apm-collector-storage/collector-storage-es-provider/src/main/java/org/skywalking/apm/collector/storage/es/StorageModuleEsProvider.java#L170" rel="external nofollow noopener noreferrer" target="_blank"><code>StorageModuleEsProvider#notifyAfterCompleted(Properties)</code></a> 。</p><ul><li>该方法会被 <code>BootstrapFlow#notifyAfterCompleted()</code> 方法调用，在 <a href="#">「3.4 BootstrapFlow」</a> 详细解析。</li></ul><h2 id="3-3-Service"><a href="#3-3-Service" class="headerlink" title="3.3 Service"></a>3.3 Service</h2><p><code>org.skywalking.apm.collector.core.module.Service</code> ，服务<strong>接口</strong>。通过实现 Service 接口，实现不同功能的服务。目前 Collector 的 Service 实现类如下图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/08.png" alt=""></p><p>这里有一点要注意下，实际上 Module 是与 Service <strong>“直接”</strong> 一对多的关系。中间 有一层 ModuleProvider 存在的原因是，相同 Module 可以有多种 ModuleProvider 实现，而 ModuleProvider 提供提供相同功能的 Service ，但是实现不同。</p><p>以 <code>apm-collector-storage</code> 举例子，如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/09.png" alt=""></p><ul><li>StorageModuleEsProvider / StorageModuleH2Provider 分别基于 ES / H2 实现，其提供存储相同数据的不同实现。例如 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/10.png" alt=""></li></ul><p>一般 <code>collector-xxx-define</code> 的 <code>service</code> 包下，会定义当前模块提供的 Service 接口，如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/12.png" alt=""></p><p>这也是为什么有 <code>Module#services()</code> 和 <code>#requiredCheck(Class&lt;? extends Service&gt;[])</code> 这样的方法涉及的原因。</p><p>另外，如下是 Service 接口的解释：</p><blockquote><p>The <code>Service</code> implementation is a service provided by its own modules.  </p><p>And every {@link ModuleProvider} must provide all the given services of the {@link Module}.</p></blockquote><h2 id="3-4-BootstrapFlow"><a href="#3-4-BootstrapFlow" class="headerlink" title="3.4 BootstrapFlow"></a>3.4 BootstrapFlow</h2><p><a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/BootstrapFlow.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.core.module.BootstrapFlow</code></a>，组件启动流程。</p><p>BootstrapFlow <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/BootstrapFlow.java#L42" rel="external nofollow noopener noreferrer" target="_blank"><strong>构造方法</strong></a>，调用 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/BootstrapFlow.java#L86" rel="external nofollow noopener noreferrer" target="_blank"><code>#makeSequence()</code></a> 方法，获得 ModuleProvider 启动顺序，这个是该类的<strong>重点</strong>。</p><p><a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/BootstrapFlow.java#L51" rel="external nofollow noopener noreferrer" target="_blank"><code>#start()</code></a> 方法，执行 Module 启动逻辑。</p><ul><li>第 54 至 63 行 ：校验<strong>依赖</strong> Module 已经都存在。</li><li>第 67 行 ：校验 ModuleProvider 包含的 Service 们都<strong>创建成功</strong>。</li><li>第 70 行 ：调用 <code>ModuleProvider#start(...)</code> 方法，执行 ModuleProvider 启动阶段逻辑。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/BootstrapFlow.java#L74" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyAfterCompleted()</code></a> 方法，调用 <code>ModuleProvider#notifyAfterCompleted()</code> 方法，执行 ModuleProvider 启动完成阶段的逻辑。</p><h1 id="4-Module-实现类简介"><a href="#4-Module-实现类简介" class="headerlink" title="4. Module 实现类简介"></a>4. Module 实现类简介</h1><p><img src="https://camo.githubusercontent.com/2a00cb347f6a7d7afb8faef8d8b0f2a0d3215d9d/68747470733a2f2f736b7977616c6b696e67746573742e6769746875622e696f2f706167652d7265736f75726365732f332e322e352532625f6172636869746563747572652e6a7067" alt=""></p><ul><li>Naming Module ：<a href="http://www.iocoder.cn/SkyWalking/collector-naming-server/?self">《SkyWalking 源码分析 —— Collector Naming Server 命名服务》</a></li><li>UI Module ：</li><li>Queue Module ：<a href="http://www.iocoder.cn/SkyWalking/collector-queue-module/?self">《SkyWalking 源码分析 —— Collector Queue 队列组件》</a></li><li><code>Cache Module</code> ：TODO</li><li>Cluster Module ：<a href="http://www.iocoder.cn/SkyWalking/collector-cluster-module/?self">《SkyWalking 源码分析 —— Collector Cluster 集群管理》</a></li><li>Component Libraries ：<a href="http://www.iocoder.cn/SkyWalking/collector-client-component/?self">《SkyWalking 源码分析 —— Collector Client Component 客户端组件》</a> 、<a href="http://www.iocoder.cn/SkyWalking/collector-server-component/?self">《SkyWalking 源码分析 —— Collector Server Component 服务器组件》</a></li><li>Core ：<ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/?self">《SkyWalking 源码分析 —— Collector Storage 存储组件》「2. apm-collector-core」</a> </li><li><a href="http://www.iocoder.cn/SkyWalking/collector-init/?self">《SkyWalking 源码分析 —— Collector 初始化》「3. ModuleManager」</a></li></ul></li><li>Storage Module ：<a href="http://www.iocoder.cn/SkyWalking/collector-storage-module/?self">《SkyWalking 源码分析 —— Collector Storage 存储组件》</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（一）》「2. apm-collector-core/graph」</a> </li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（二）》「2. Data」</a> </li></ul></li><li>Agent Module ：TODO</li><li>Jetty Manager Module ：<a href="http://www.iocoder.cn/SkyWalking/collector-jetty-server-module/?self">《SkyWalking 源码分析 —— Collector Jetty Server Manager》</a></li><li>gRPC Manager Module ：<a href="http://www.iocoder.cn/SkyWalking/collector-grpc-server-module/?self">《SkyWalking 源码分析 —— Collector gRPC Server Manager》</a></li><li>Agent Streaming Computing ：<ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（一）》「2. apm-collector-core/graph」</a> </li><li><a href="http://www.iocoder.cn/SkyWalking/collector-streaming-second/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（二）》「2. Data」</a> </li><li>TODO</li></ul></li><li>Baseline Module ：todo</li><li>Alerting Module ：todo</li></ul><p>TODO 【4001】Module 实现文章链接 </p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>可能要进入特别忙碌的一段时间，不确定 SkyWalking 文章后续的更新频率。</p><p>继续加油。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_15/11.png" alt=""></p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/collector-init/&quot;&gt;http://www.iocoder.cn/SkyWalking/collector-init/&lt;/a&gt; 「芋道源码」欢迎转载，保留摘要，
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Agent 插件体系</title>
    <link href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/"/>
    <id>http://www.iocoder.cn/SkyWalking/agent-plugin-system/</id>
    <published>2020-07-09T16:00:00.000Z</published>
    <updated>2017-12-12T09:06:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">http://www.iocoder.cn/SkyWalking/agent-plugin-system/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">2. 插件的加载</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">2.1 AgentClassLoader</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">2.2 PluginResourcesResolver</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">2.3 PluginCfg</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">2.4 AbstractClassEnhancePluginDefine</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">2.5 小结</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">3. 插件的匹配</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">3.1 InstrumentDebuggingClass</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">3.2 ClassMatch</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">3.3 PluginFinder</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">4. 插件的拦截</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">4.1 ClassEnhancePluginDefine</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">4.2 InterceptPoint</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">4.3 Interceptor</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">4.4 Inter</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">4.5 小结</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>SkyWalking Agent 插件体系</strong>。主要涉及三个流程 ：</p><ul><li>插件的加载</li><li>插件的匹配</li><li>插件的拦截</li></ul><p>可能看起来有点抽象，不太容易理解。淡定，我们每个小章节进行解析。</p><p>本文涉及到的类主要在 <a href="https://github.com/YunaiV/skywalking/tree/3de8a6c15d07aa3b2c3b4e732e6654fc87c4e70e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin</code></a> 包里，如下图所示 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/01.png" alt=""></p><p>每个流程会涉及到较多的类，我们会贯穿着解析代码实现。</p><h1 id="2-插件的加载"><a href="#2-插件的加载" class="headerlink" title="2. 插件的加载"></a>2. 插件的加载</h1><p>在 <a href="http://www.iocoder.cn/SkyWalking/agent-init/?self">《SkyWalking 源码分析 —— Agent 初始化》</a> 一文中，Agent 初始化时，调用 <code>PluginBootstrap#loadPlugins()</code> 方法，加载所有的插件。整体流程如下图 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/03.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/130f0a5a3438663b393e53ba2cca02a8d13c258a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginBootstrap.java#L45" rel="external nofollow noopener noreferrer" target="_blank"><code>PluginBootstrap#loadPlugins()</code></a> 方法，代码如下 ：</p><ul><li>第 47 行 ：调用 <code>AgentClassLoader#initDefaultLoader()</code> 方法，初始化 AgentClassLoader 。在本文 <a href="#">「2.1 AgentClassLoader」</a> 详细解析。</li><li>第 50 至 56 行 ：获得插件<strong>定义路径</strong>数组。在本文 <a href="#">「2.2 PluginResourcesResolver」</a> 详细解析。</li><li>第 59 至 66 行 ：获得插件<strong>定义</strong>( <a href="https://github.com/OpenSkywalking/skywalking/blob/b16d23c1484bec941367d6b36fa932b8ace40971/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginDefine.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.PluginDefine</code></a> )数组。在本文 <a href="#">「2.3 PluginCfg」</a> 详细解析。</li><li>第 69 至 82 行 ：创建<strong>类增强插件定义</strong>( <a href="https://github.com/OpenSkywalking/skywalking/blob/b16d23c1484bec941367d6b36fa932b8ace40971/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/AbstractClassEnhancePluginDefine.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.AbstractClassEnhancePluginDefine</code></a> )对象数组。不同插件通过实现 AbstractClassEnhancePluginDefine <strong>抽象类</strong>，定义不同框架的<strong>切面</strong>，<strong>记录调用链路</strong>。在本文 <a href="#">「2.4 AbstractClassEnhancePluginDefine」</a> 简单解析。</li></ul><h2 id="2-1-AgentClassLoader"><a href="#2-1-AgentClassLoader" class="headerlink" title="2.1 AgentClassLoader"></a>2.1 AgentClassLoader</h2><p><code>org.skywalking.apm.agent.core.plugin.loader.AgentClassLoader</code> ，继承 <code>java.lang.ClassLoader</code> ，Agent 类加载器。</p><p><strong>为什么实现自定义的 ClassLoader</strong> ？应用<strong>透明</strong>接入 SkyWalking ，不会<strong>显示</strong>导入 SkyWalking 的插件依赖。通过实现自定义的 ClassLoader ，从插件 Jar 中查找相关类。例如说，从 <code>apm-dubbo-plugin-3.2.6-2017.jar</code> 查找 <code>org.skywalking.apm.plugin.dubbo.DubboInstrumentation</code> 。</p><hr><p>AgentClassLoader <strong>构造方法</strong>，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AgentClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * The default class loader for the agent.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AgentClassLoader DEFAULT_LOADER;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * classpath</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> List&lt;File&gt; classpath;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Jar 数组</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> List&lt;Jar&gt; allJars;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Jar 读取时的锁</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> ReentrantLock jarScanLock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AgentClassLoader</span><span class="params">(ClassLoader parent)</span> <span class="keyword">throws</span> AgentPackageNotFoundException </span>&#123;</div><div class="line">        <span class="keyword">super</span>(parent);</div><div class="line">        File agentDictionary = AgentPackagePath.getPath();</div><div class="line">        classpath = <span class="keyword">new</span> LinkedList&lt;File&gt;();</div><div class="line">        classpath.add(<span class="keyword">new</span> File(agentDictionary, <span class="string">"plugins"</span>));</div><div class="line">        classpath.add(<span class="keyword">new</span> File(agentDictionary, <span class="string">"activations"</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>DEFAULT_LOADER</code> <strong>静态</strong>属性，默认单例。通过 <a href="https://github.com/YunaiV/skywalking/blob/3de8a6c15d07aa3b2c3b4e732e6654fc87c4e70e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/loader/AgentClassLoader.java#L56" rel="external nofollow noopener noreferrer" target="_blank"><code>#getDefault()</code></a> 方法，可以获取到它。</li><li><code>classpath</code> 属性，Java 类所在的目录。在构造方法中，我们可以看到 <code>${AGENT_PACKAGE_PATH}/plugins</code> / <code>${AGENT_PACKAGE_PATH}/activations</code> 添加到 <code>classpath</code> 。在 <a href="https://github.com/YunaiV/skywalking/blob/3de8a6c15d07aa3b2c3b4e732e6654fc87c4e70e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/loader/AgentClassLoader.java#L163" rel="external nofollow noopener noreferrer" target="_blank"><code>#getAllJars()</code></a>  方法中，加载该目录下的 Jar 中的 Class 文件。</li><li><code>allJars</code> 属性，Jar 数组。</li><li><code>jarScanLock</code> 属性，Jar 读取时的<strong>锁</strong>。</li></ul><hr><p><code>#initDefaultLoader()</code> <strong>静态</strong>方法，初始化<strong>默认</strong>的 AgentClassLoader ，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AgentClassLoader <span class="title">initDefaultLoader</span><span class="params">()</span> <span class="keyword">throws</span> AgentPackageNotFoundException </span>&#123;</div><div class="line">    DEFAULT_LOADER = <span class="keyword">new</span> AgentClassLoader(PluginBootstrap.class.getClassLoader());</div><div class="line">    <span class="keyword">return</span> getDefault();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>使用 <code>org.skywalking.apm.agent.core.plugin.PluginBootstrap</code> 的类加载器作为 AgentClassLoader 的<strong>父类加载器</strong>。</li></ul><hr><p>如下方法已经添加相关中文注释，胖友请自行阅读理解 ：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/778093d38a0a820b90092c2ed77a08e3393169eb/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/loader/AgentClassLoader.java#L132" rel="external nofollow noopener noreferrer" target="_blank"><code>#findResource(name)</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/778093d38a0a820b90092c2ed77a08e3393169eb/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/loader/AgentClassLoader.java#L150" rel="external nofollow noopener noreferrer" target="_blank"><code>#findResources(String name)</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/778093d38a0a820b90092c2ed77a08e3393169eb/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/loader/AgentClassLoader.java#L182" rel="external nofollow noopener noreferrer" target="_blank"><code>#getAllJars()</code></a></li></ul><p>在 ClassLoader 加载资源( 例如，类 )，会调用 <code>#findResource(name)</code> / <code>#findResources(name)</code> 方法。</p><h2 id="2-2-PluginResourcesResolver"><a href="#2-2-PluginResourcesResolver" class="headerlink" title="2.2 PluginResourcesResolver"></a>2.2 PluginResourcesResolver</h2><p><code>org.skywalking.apm.agent.core.plugin.PluginResourcesResolver</code> ，插件资源解析器，读取所有插件的定义文件。插件定义文件必须以 <code>skywalking-plugin.def</code> <strong>命名</strong>，例如 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/02.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/d4a6ba291419ab90379a3d1c423b747f682f857f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginResourcesResolver.java#L45" rel="external nofollow noopener noreferrer" target="_blank"><code>#getResources()</code></a> 方法，获得插件定义路径数组，代码如下 ：</p><ul><li>第 50 行 ：使用 AgentClassLoader 获得所有 <code>skywalking-plugin.def</code> 的路径。</li></ul><h2 id="2-3-PluginCfg"><a href="#2-3-PluginCfg" class="headerlink" title="2.3 PluginCfg"></a>2.3 PluginCfg</h2><p><code>org.skywalking.apm.agent.core.plugin.PluginCfg</code> ，插件定义配置，读取 <code>skywalking-plugin.def</code> 文件，生成插件定义( <a href="https://github.com/YunaiV/skywalking/blob/43241fff19e17f19b918c96ffd588787f8f05519/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginDefine.java#L27" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.PluginDefinie</code></a> )数组。</p><p><a href="https://github.com/YunaiV/skywalking/blob/43241fff19e17f19b918c96ffd588787f8f05519/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginCfg.java#L55" rel="external nofollow noopener noreferrer" target="_blank"><code>#load(InputStream)</code></a> 方法，读取 <code>skywalking-plugin.def</code> 文件，添加到 <code>pluginClassList</code> 。如下是 <code>apm-springmvc-annotation-4.x-plugin-3.2.6-2017.jar</code> 插件的定义文件 ：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">spring-mvc-annotation-4.x=org.skywalking.apm.plugin.spring.mvc.v4.define.ControllerInstrumentation</div><div class="line">spring-mvc-annotation-4.x=org.skywalking.apm.plugin.spring.mvc.v4.define.RestControllerInstrumentation</div><div class="line">spring-mvc-annotation-4.x=org.skywalking.apm.plugin.spring.mvc.v4.define.HandlerMethodInstrumentation</div><div class="line">spring-mvc-annotation-4.x=org.skywalking.apm.plugin.spring.mvc.v4.define.InvocableHandlerInstrumentation</div></pre></td></tr></table></figure><h2 id="2-4-AbstractClassEnhancePluginDefine"><a href="#2-4-AbstractClassEnhancePluginDefine" class="headerlink" title="2.4 AbstractClassEnhancePluginDefine"></a>2.4 AbstractClassEnhancePluginDefine</h2><p><code>org.skywalking.apm.agent.core.plugin.AbstractClassEnhancePluginDefine</code> ，类增强插件定义<strong>抽象基类</strong>。不同插件通过实现 AbstractClassEnhancePluginDefine <strong>抽象类</strong>，定义不同框架的<strong>切面</strong>，<strong>记录调用链路</strong>。以 Spring 插件为例子，如下是相关类图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_05/06.png" alt=""></p><p>PluginDefine 对象的 <code>defineClass</code> 属性，即对应不同插件对AbstractClassEnhancePluginDefine 的<strong>实现类</strong>。所以在 <a href="https://github.com/YunaiV/skywalking/blob/130f0a5a3438663b393e53ba2cca02a8d13c258a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginBootstrap.java#L45" rel="external nofollow noopener noreferrer" target="_blank"><code>PluginBootstrap#loadPlugins()</code></a> 方法的【<strong>第 74 行</strong>】，我们看到通过该属性，创建创建<strong>类增强插件定义</strong>对象。</p><h2 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h2><p>胖友，回过头，在看一下流程图，理解理解。</p><h1 id="3-插件的匹配"><a href="#3-插件的匹配" class="headerlink" title="3. 插件的匹配"></a>3. 插件的匹配</h1><p>在 <a href="http://www.iocoder.cn/SkyWalking/agent-init/?self">《SkyWalking 源码分析 —— Agent 初始化》</a> 一文，我们提到，SkyWalking Agent 基于 <strong>JavaAgent</strong> 机制，实现应用<strong>透明</strong>接入 SkyWalking 。下面笔者默认胖友已经对 JavaAgent 机制已经有一定的了解。如果胖友暂时不了解，建议先阅读如下文章 ：</p><ul><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html" rel="external nofollow noopener noreferrer" target="_blank">《Instrumentation 新功能》</a></li><li><a href="http://www.infoq.com/cn/articles/javaagent-illustrated" rel="external nofollow noopener noreferrer" target="_blank">《JVM源码分析之javaagent原理完全解读》</a></li></ul><blockquote><p>友情提示 ：建议自己手撸一个简单的 JavaAgent ，更容易理解 SkyWalking Agent 。 </p><p>笔者练手的 JavaAgent 项目地址 ：<a href="https://github.com/YunaiV/learning/tree/master/javaagent01" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/YunaiV/learning/tree/master/javaagent01</a></p></blockquote><p>通过 JavaAgent 机制，我们可以在 <code>#premain(String, Instrumentation)</code> 方法里，调用 <code>Instrumentation#addTransformer(ClassFileTransformer)</code> 方法，向 Instrumentation 注册 <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/instrument/ClassFileTransformer.html" rel="external nofollow noopener noreferrer" target="_blank"><code>java.lang.instrument.ClassFileTransformer</code></a> 对象，可以修改 Java 类的二进制，从而<strong>动态</strong>修改 Java 类的代码实现。</p><p>如果胖友使用过 AOP 实现切面记录日志，那么就很容易理解，SkyWalking 通过这样的方式，使用不同框架定义<strong>方法切面</strong>，从而在在切面<strong>记录调用链路</strong>。</p><hr><p>直接修改 Java 类的二进制，是非常繁杂的。因此，SkyWalking 引入了 <a href="https://github.com/raphw/byte-buddy" rel="external nofollow noopener noreferrer" target="_blank"><code>byte-buddy</code></a> 。</p><blockquote><p><code>byte-buddy</code> 是一个代码生成和操作库，用于在 Java 应用程序<br>运行时创建和修改 Java 类，而徐无需编译器的帮助。</p><p>除了参与 Java 类库一起提供代码生成工具外，<code>byte-buddy</code> 允许创建任意类，并不限于实现用于创建运行时代理的接口。  </p><p>此外，<code>byte-buddy</code> 提供了一个方便的 API ，用于 Java Agent 或在构建过程中更改类。</p></blockquote><p>下面笔者默认胖友已经对 <code>byte-buddy</code> 有一定的了解。如果胖友暂不了解，建议先阅读如下文章 ：</p><ul><li><a href="http://www.jianshu.com/p/fe1448bf7d31" rel="external nofollow noopener noreferrer" target="_blank">《Java字节码3-使用ByteBuddy实现一个Java-Agent》</a></li><li><a href="https://notes.diguage.com/byte-buddy-tutorial/" rel="external nofollow noopener noreferrer" target="_blank">《Byte Buddy 教程》</a></li><li><a href="https://www.infoq.com/articles/Easily-Create-Java-Agents-with-ByteBuddy" rel="external nofollow noopener noreferrer" target="_blank">《Easily Create Java Agents with Byte Buddy》</a></li><li><a href="http://www.kailing.pub/article/index/arcid/178.html" rel="external nofollow noopener noreferrer" target="_blank">《skywalking源码分析之javaAgent工具ByteBuddy的应用》</a> 搜索 “BYTE BUDDY应用” 部分</li></ul><blockquote><p>友情提示 ：建议自己简单使用下 <code>byte-buddy</code> ，更容易理解 SkyWalking Agent 。 </p><p>笔者练手的 <code>byte-buddy</code> 项目地址 ：<a href="https://github.com/YunaiV/learning/tree/master/bytebuddy" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/YunaiV/learning/tree/master/bytebuddy</a></p></blockquote><hr><p>下面，让我们打开 <a href="https://github.com/YunaiV/skywalking/blob/b68162306b4db7adfd4a2c2891a205b7085f38f0/apm-sniffer/apm-agent/src/main/java/org/skywalking/apm/agent/SkyWalkingAgent.java#L79" rel="external nofollow noopener noreferrer" target="_blank"><code>SkyWalkingAgent#premain(String, Instrumentation)</code></a> 方法，从【第 79 行】代码开始看 ：</p><ul><li>第 79 至 104 行 ：创建 <a href="https://github.com/raphw/byte-buddy/blob/188366ace6e16ec167a00b144c9048d78495165f/byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java" rel="external nofollow noopener noreferrer" target="_blank"><code>net.bytebuddy.agent.builder.AgentBuilder</code></a> 对象，并设置相关属性。<ul><li>AgentBuilder ，提供便利的 API ，创建 Java Agent 。</li><li>第 79 行 ：调用 <code>AgentBuilder#type(ElementMatcher)</code> 方法，实现 <a href="https://github.com/raphw/byte-buddy/blob/188366ace6e16ec167a00b144c9048d78495165f/byte-buddy-dep/src/main/java/net/bytebuddy/matcher/ElementMatcher.java#L13" rel="external nofollow noopener noreferrer" target="_blank"><code>net.bytebuddy.matcher.ElementMatcher</code></a> 接口，设置需要拦截的类。<code>PluginFinder#buildMatch()</code> 方法，在本文 <a href="#">「3.3 PluginFinder」</a> 详细解析。</li><li>第 79 至 104 行 ：调用 <code>AgentBuilder#transform(Transformer)</code> 方法，设置 Java 类的修改逻辑。<ul><li>第 84 行 ：调用 <code>PluginFinder#find(TypeDescription, ClassLoader)</code> 方法，获得<strong>匹配</strong>的 AbstractClassEnhancePluginDefine 数组。因为在【<strong>第 79 行</strong>】的代码，设置了<strong>所有</strong>插件需要拦截的类，所以此处需要匹配<strong>该类对应</strong>的 AbstractClassEnhancePluginDefine 数组。<code>PluginFinder#find(TypeDescription, ClassLoader)</code> 方法，在本文 <a href="#">「3.3 PluginFinder」</a> 详细解析。</li><li>第 85 行 ：判断匹配的 AbstractClassEnhancePluginDefine 数组大于零。从目前的代码看下来，此处属于<strong>防御性编程</strong>，在【<strong>第 79 行</strong>】的代码保证一定能匹配到 AbstractClassEnhancePluginDefine 。</li><li>第 86 至 100 行 ：循环匹配到 AbstractClassEnhancePluginDefine 数组，调用 <code>AbstractClassEnhancePluginDefine#define(...)</code> 方法，设置 <a href="https://github.com/raphw/byte-buddy/blob/188366ace6e16ec167a00b144c9048d78495165f/byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java" rel="external nofollow noopener noreferrer" target="_blank"><code>net.bytebuddy.dynamic.DynamicType.Builder</code></a> 对象。通过该对象，定义<strong>如何拦截</strong>需要修改的 Java 类。在 <code>AbstractClassEnhancePluginDefine#define(...)</code> 方法的内部，会调用 <a href="https://github.com/raphw/byte-buddy/blob/188366ace6e16ec167a00b144c9048d78495165f/byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java#L1512" rel="external nofollow noopener noreferrer" target="_blank"><code>net.bytebuddy.dynamic.DynamicType.ImplementationDefinition#intercept(Implementation)</code></a> 方法，本文 <a href="#">「4. 插件的拦截」</a> 也会详细解析。</li><li>第 91 行 ：为什么会出现返回为<strong>空</strong>的情况呢？同一个框架在不同的<strong>大</strong>版本，使用的方式相同，但是实现的代码却不尽相同。举个例子，SpringMVC 3 和 SpringMVC 4 ，<strong>都</strong>有 <code>@RequestMapping</code> 注解定义 URL ，所以【<strong>第 84 行</strong>】会匹配到 <code>AbstractSpring3Instrumentation</code> / <code>AbstractSpring4Instrumentation</code> <strong>两个</strong>。当应用使用的是 Spring MVC 4 时，调用 <code>AbstractSpring3Instrumentation#define(...)</code> 方法会返回空，而调用 <code>AbstractSpring4Instrumentation#define(...)</code> 方法会有返回值。这是如何实现的呢？本文 <a href="#">「4. 插件的拦截」</a> 也会详细解析。</li></ul></li></ul></li><li>第 105 至 134 行 ：调用 <a href="https://github.com/raphw/byte-buddy/blob/188366ace6e16ec167a00b144c9048d78495165f/byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java#L114" rel="external nofollow noopener noreferrer" target="_blank"><code>AgentBuilder#with(Listener)</code></a> 方法，添加监听器。<ul><li><code>#onTransformation(...)</code> 方法，当 Java 类的修改<strong>成功</strong>，进行调用。</li><li><code>#onError(...)</code> 方法，当 Java 类的修改<strong>失败</strong>，进行调用。InstrumentDebuggingClass 在本文 <a href="#">「3.1 InstrumentDebuggingClass」</a> 详细解析。</li></ul></li><li>第 135 行 ：调用 <a href="https://github.com/raphw/byte-buddy/blob/master/byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/AgentBuilder.java#L620" rel="external nofollow noopener noreferrer" target="_blank"><code>AgentBuilder#installOn(Instrumentation)</code></a> 方法，根据<strong>上面</strong> AgentBuilder 设置的属性，创建 <a href="https://github.com/raphw/byte-buddy/blob/188366ace6e16ec167a00b144c9048d78495165f/byte-buddy-dep/src/main/java/net/bytebuddy/agent/builder/ResettableClassFileTransformer.java" rel="external nofollow noopener noreferrer" target="_blank"><code>net.bytebuddy.agent.builder.ResettableClassFileTransformer</code></a> 对象，配置到 Instrumentation 对象上。在 <code>AgentBuilder#installOn(Instrumentation)</code> 方法的内部，会调用 <code>Instrumentation#addTransformer(ClassFileTransformer)</code> 方法。</li></ul><hr><p>😈 这个方法信息量比较大，笔者对 <code>byte-buddy</code> 不是很熟悉，花费了较多时间梳理与理解。建议，如果胖友此处不是理解的很清晰，可以阅读完全文，在回过头再捋一捋这块的代码实现。</p><h2 id="3-1-InstrumentDebuggingClass"><a href="#3-1-InstrumentDebuggingClass" class="headerlink" title="3.1 InstrumentDebuggingClass"></a>3.1 InstrumentDebuggingClass</h2><p><code>org.skywalking.apm.agent.InstrumentDebuggingClass</code> ，Instrument 调试类，用于将被 JavaAgent 修改的<strong>所有</strong>类存储到 <code>${JAVA_AGENT_PACKAGE}/debugger</code> 目录下。需要配置 <code>agent.is_open_debugging_class = true</code> ，效果如下图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/04.png" alt=""></p><p>代码比较简单，胖友点击 <a href="https://github.com/YunaiV/skywalking/blob/b68162306b4db7adfd4a2c2891a205b7085f38f0/apm-sniffer/apm-agent/src/main/java/org/skywalking/apm/agent/InstrumentDebuggingClass.java" rel="external nofollow noopener noreferrer" target="_blank">InstrumentDebuggingClass</a> 理解。</p><h2 id="3-2-ClassMatch"><a href="#3-2-ClassMatch" class="headerlink" title="3.2 ClassMatch"></a>3.2 ClassMatch</h2><p>在分享本节相关内容之前，我们先来看下 <code>bytebuddy</code> 的 <a href="https://github.com/raphw/byte-buddy/tree/188366ace6e16ec167a00b144c9048d78495165f/byte-buddy-dep/src/main/java/net/bytebuddy/matcher" rel="external nofollow noopener noreferrer" target="_blank"><code>net.bytebuddy.matcher</code></a> 模块。该模块提供了各种灵活的匹配方法。那么 SkyWalking 为什么实现自己的 <a href="https://github.com/YunaiV/skywalking/tree/43241fff19e17f19b918c96ffd588787f8f05519/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/match" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.match</code></a> 模块？笔者认为，仅定位于<strong>类级别的匹配</strong>，更常用而又精简的 API 。</p><hr><p><code>org.skywalking.apm.agent.core.plugin.match.ClassMatch</code> ，类匹配<strong>接口</strong>。目前子类如下 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/05.png" alt=""></p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/b68162306b4db7adfd4a2c2891a205b7085f38f0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/match/NameMatch.java#L28" rel="external nofollow noopener noreferrer" target="_blank">NameMatch</a> ：基于<strong>完整的类名</strong>进行匹配，例如：<code>&quot;com.alibaba.dubbo.monitor.support.MonitorFilter&quot;</code> 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/b68162306b4db7adfd4a2c2891a205b7085f38f0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/match/IndirectMatch.java" rel="external nofollow noopener noreferrer" target="_blank">IndirectMatch</a> ：<strong>间接</strong>匹配<strong>接口</strong>。相比 NameMatch 来说，确实比较 “委婉” 🙂 。<ul><li><a href="https://github.com/YunaiV/skywalking/blob/b68162306b4db7adfd4a2c2891a205b7085f38f0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/match/ClassAnnotationMatch.java" rel="external nofollow noopener noreferrer" target="_blank">ClassAnnotationMatch</a> ：基于<strong>类注解</strong>进行匹配，可设置<strong>同时</strong>匹配多个。例如：<code>&quot;@RequestMapping&quot;</code>。</li><li><a href="https://github.com/YunaiV/skywalking/blob/b68162306b4db7adfd4a2c2891a205b7085f38f0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/match/HierarchyMatch.java" rel="external nofollow noopener noreferrer" target="_blank">HierarchyMatch</a> ：基于<strong>父类 / 接口</strong>进行匹配，可设置<strong>同时</strong>匹配多个。</li><li><a href="https://github.com/YunaiV/skywalking/blob/b68162306b4db7adfd4a2c2891a205b7085f38f0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/match/MethodAnnotationMatch.java" rel="external nofollow noopener noreferrer" target="_blank">MethodAnnotationMatch</a> ：基于<strong>方法注解</strong>进行匹配，可设置<strong>同时</strong>匹配多个。目前项目里主要用于匹配方法上的  <a href="https://github.com/OpenSkywalking/skywalking/blob/8d9820322bdfc956d9d4f0d04f55ce985926cfae/apm-application-toolkit/apm-toolkit-trace/src/main/java/org/apache/skywalking/apm/toolkit/trace/Trace.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.toolkit.trace.@Trace</code></a> 注解。</li></ul></li></ul><p>每个类已经添加详细的代码注释，胖友喜欢哪个点哪个哟。</p><h2 id="3-3-PluginFinder"><a href="#3-3-PluginFinder" class="headerlink" title="3.3 PluginFinder"></a>3.3 PluginFinder</h2><p><code>org.skywalking.apm.agent.core.plugin.PluginFinder</code> ，插件发现者。其提供 <a href="https://github.com/YunaiV/skywalking/blob/09c654af33081e56547cb8b3b9e0c8525ddce32f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginFinder.java#L80" rel="external nofollow noopener noreferrer" target="_blank"><code>#find(...)</code></a> 方法，获得<strong>类增强插件定义</strong>( <a href="https://github.com/OpenSkywalking/skywalking/blob/b16d23c1484bec941367d6b36fa932b8ace40971/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/AbstractClassEnhancePluginDefine.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.AbstractClassEnhancePluginDefine</code></a> )对象。</p><p>PluginFinder <strong><a href="https://github.com/YunaiV/skywalking/blob/09c654af33081e56547cb8b3b9e0c8525ddce32f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginFinder.java#L56" rel="external nofollow noopener noreferrer" target="_blank">构造方法</a></strong>，代码如下 ：</p><ul><li>第 57 至 77 行 ：循环 AbstractClassEnhancePluginDefine 对象数组，添加到 <code>nameMatchDefine</code> / <code>signatureMatchDefine</code> 属性，方便 <code>#find(...)</code> 方法查找 AbstractClassEnhancePluginDefine 对象。<ul><li>第 65 至 72 行 ：处理 NameMatch 为匹配的 AbstractClassEnhancePluginDefine 对象，添加到 <code>nameMatchDefine</code>  属性。</li><li>第 74 至 76 行 ：处理<strong>非</strong> NameMatch 为匹配的 AbstractClassEnhancePluginDefine 对象，添加到 <code>signatureMatchDefine</code> 属性。</li></ul></li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/b68162306b4db7adfd4a2c2891a205b7085f38f0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginFinder.java#L89" rel="external nofollow noopener noreferrer" target="_blank"><code>#find(...)</code></a> 方法，获得<strong>类增强插件定义</strong>( <a href="https://github.com/OpenSkywalking/skywalking/blob/b16d23c1484bec941367d6b36fa932b8ace40971/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/AbstractClassEnhancePluginDefine.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.AbstractClassEnhancePluginDefine</code></a> )对象，代码如下 ：</p><ul><li>第 92 至 96 行 ：以 <code>nameMatchDefine</code> 属性来匹配 AbstractClassEnhancePluginDefine 对象。</li><li>第 98 至 104 行 ：以 <code>signatureMatchDefine</code> 属性来匹配 AbstractClassEnhancePluginDefine 对象。在这个过程中，会调用 <code>IndirectMatch#isMatch(TypeDescription)</code> 方法，进行匹配。</li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/b68162306b4db7adfd4a2c2891a205b7085f38f0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginFinder.java#L116" rel="external nofollow noopener noreferrer" target="_blank"><code>#buildMatch()</code></a> 方法，获得全部插件的类匹配，多个插件的类匹配条件以 <code>or</code> 分隔，代码如下 ：</p><ul><li>第 117 至 123 行 ：以 <code>nameMatchDefine</code> 属性来匹配。</li><li>第 124 至 132 行 ：以 <code>signatureMatchDefine</code> 属性来匹配。</li><li><strong>实际上，该方法和 <code>#find(...)</code> 方法逻辑是一致的</strong>。</li></ul><h1 id="4-插件的拦截"><a href="#4-插件的拦截" class="headerlink" title="4. 插件的拦截"></a>4. 插件的拦截</h1><p>在上文中，我们已经提到，SkyWalking 通过 JavaAgent 机制，对需要拦截的类的方法，使用 <code>byte-buddy</code> <strong>动态</strong>修改 Java 类的二进制，从而进行方法切面拦截，记录调用链路。</p><p>看具体的代码实现之前，想一下<strong>拦截</strong>会涉及到哪些元素 ：</p><ul><li>拦截切面 InterceptPoint</li><li>拦截器 Interceptor</li><li>拦截类的定义 Define ：一个类有哪些拦截切面及对应的拦截器</li></ul><p>下面，我们来看看本小节会涉及到的类。如图所示：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/06.png" alt=""></p><p>看起来类比想象的多？梳理之，结果如图 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/07.png" alt=""></p><ul><li>根据方法类型的不同，使用不同 ClassEnhancePluginDefine 的实现类。其中，构造方法和静态方法使用相同的实现类。</li><li><p>相比上面提到<strong>拦截</strong>会涉及到的元素，多了一个 <strong>Inter</strong> ？如下是官方的说明 ：</p><blockquote><p>In this class, it provide a bridge between <code>byte-buddy</code> and <code>sky-walking</code> plugin.</p></blockquote></li></ul><h2 id="4-1-ClassEnhancePluginDefine"><a href="#4-1-ClassEnhancePluginDefine" class="headerlink" title="4.1 ClassEnhancePluginDefine"></a>4.1 ClassEnhancePluginDefine</h2><p>整体类图如下：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/08.png" alt=""></p><ul><li>AbstractClassEnhancePluginDefine ：SkyWalking 类增强插件定义<strong>抽象基类</strong>。</li><li>ClassEnhancePluginDefine ：SkyWalking 类增强插件定义<strong>抽象类</strong>。</li><li>从 UML 图中的方法，我们可以看出，AbstractClassEnhancePluginDefine 注重在<strong>定义</strong>( Define )，ClassEnhancePluginDefine 注重在<strong>增强</strong>( Enhance )。</li></ul><p>整体流程如下 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/09.png" alt=""></p><p>OK ，下面我们开始看看代码是如何实现的。</p><h3 id="4-1-1-AbstractClassEnhancePluginDefine"><a href="#4-1-1-AbstractClassEnhancePluginDefine" class="headerlink" title="4.1.1 AbstractClassEnhancePluginDefine"></a>4.1.1 AbstractClassEnhancePluginDefine</h3><p><code>org.skywalking.apm.agent.core.plugin.AbstractClassEnhancePluginDefine</code> ，SkyWalking 类增强插件定义<strong>抽象基类</strong>。它注重在<strong>定义</strong>( Define )的抽象与实现。</p><p><a href="https://github.com/YunaiV/skywalking/blob/30683167c79c71ad088666c587a05c6d9f0daf3f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/AbstractClassEnhancePluginDefine.java#L93" rel="external nofollow noopener noreferrer" target="_blank"><code>#enhanceClass()</code></a> <strong>抽象</strong>方法，定义了类匹配( ClassMatch ) 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/30683167c79c71ad088666c587a05c6d9f0daf3f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/AbstractClassEnhancePluginDefine.java#L105" rel="external nofollow noopener noreferrer" target="_blank"><code>#witnessClasses()</code></a> 方法，见证类列表。当且仅当应用存在见证类列表，插件才生效。<strong>什么意思</strong>？让我们看看这种情况：一个<strong>类库</strong>存在两个发布的版本( 如 <code>1.0</code> 和 <code>2.0</code> )，其中包括<strong>相同</strong>的目标类，但不同的方法或不同的方法参数列表。所以我们需要根据库的不同版本使用插件的不同版本。然而版本显然不是一个选项，这时需要使用见证类列表，判断出当前引用类库的发布版本。</p><ul><li>举个实际的例子，SpringMVC 3 和 SpringMVC 4 ，<strong>都</strong>有 <code>@RequestMapping</code> 注解定义 URL 。<ul><li>通过判断存在 <code>org.springframework.web.servlet.view.xslt.AbstractXsltView</code> 类，应用使用 SpringMVC 3 ，使用 <code>apm-springmvc-annotation-3.x-plugin.jar</code> 。</li><li>通过判断存在 <code>org.springframework.web.servlet.tags.ArgumentTag</code> 类，应用使用 SpringMVC 4 ，使用 <code>apm-springmvc-annotation-4.x-plugin.jar</code> 。</li></ul></li><li><strong>另外</strong>，该方法返回<strong>空数组</strong>。即默认情况，插件生效，无需见证类列表。</li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/30683167c79c71ad088666c587a05c6d9f0daf3f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/AbstractClassEnhancePluginDefine.java#L46" rel="external nofollow noopener noreferrer" target="_blank"><code>#define(...)</code></a> 方法，设置 <a href="https://github.com/raphw/byte-buddy/blob/188366ace6e16ec167a00b144c9048d78495165f/byte-buddy-dep/src/main/java/net/bytebuddy/dynamic/DynamicType.java" rel="external nofollow noopener noreferrer" target="_blank"><code>net.bytebuddy.dynamic.DynamicType.Builder</code></a> 对象。通过该对象，定义<strong>如何拦截</strong>需要修改的目标 Java 类(方法的 <code>transformClassName</code> 参数)。代码如下 ：</p><ul><li>第 57 至 70 行 ：判断见证类列表是否都存在。若不存在，则插件不生效。<ul><li><a href="https://github.com/YunaiV/skywalking/blob/30683167c79c71ad088666c587a05c6d9f0daf3f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/WitnessClassFinder.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.WitnessClassFinder</code></a> ，已经添加完整注释，胖友点击查看。</li></ul></li><li>第 72 至 76 行 ：调用 <code>#enhance(...)</code> <strong>抽象</strong>方法，使用拦截器增强目标类。</li></ul><h3 id="4-1-2-ClassEnhancePluginDefine"><a href="#4-1-2-ClassEnhancePluginDefine" class="headerlink" title="4.1.2 ClassEnhancePluginDefine"></a>4.1.2 ClassEnhancePluginDefine</h3><p><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.ClassEnhancePluginDefine</code> ，SkyWalking 类增强插件定义<strong>抽象类</strong>。它注重在<strong>增强</strong>( Enhance )的抽象与实现。包括如下 ：</p><ul><li>静态方法、构造方法、实例方法的<strong>增强</strong></li><li>静态方法、构造方法、实例方法的<strong>拦截切面</strong></li></ul><hr><p>拦截切面，在 <a href="#">「4.2 InterceptPoint」</a> 有相关解析。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/ClassEnhancePluginDefine.java#L248" rel="external nofollow noopener noreferrer" target="_blank"><code>#getStaticMethodsInterceptPoints()</code></a> <strong>抽象</strong>方法，获得 StaticMethodsInterceptPoint <strong>数组</strong>。<br><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/ClassEnhancePluginDefine.java#L185" rel="external nofollow noopener noreferrer" target="_blank"><code>#getConstructorsInterceptPoints()</code></a> <strong>抽象</strong>方法，获得 ConstructorInterceptPoint <strong>数组</strong>。<br><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/ClassEnhancePluginDefine.java#L192" rel="external nofollow noopener noreferrer" target="_blank"><code>#getInstanceMethodsInterceptPoints()</code></a> <strong>抽象</strong>方法，获得 InstanceMethodsInterceptPoint <strong>数组</strong>。</p><hr><p><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/ClassEnhancePluginDefine.java#L67" rel="external nofollow noopener noreferrer" target="_blank"><code>#enhance(...)</code></a> 方法，增强静态方法、构造方法、实例方法。</p><h4 id="4-1-2-1-增强静态方法"><a href="#4-1-2-1-增强静态方法" class="headerlink" title="4.1.2.1 增强静态方法"></a>4.1.2.1 增强静态方法</h4><p>调用 <a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/ClassEnhancePluginDefine.java#L203" rel="external nofollow noopener noreferrer" target="_blank"><code>#enhanceClass(...)</code></a> 方法，增强静态方法，代码如下 ：</p><ul><li>第 206 至 210 行 ：调用 <code>#getStaticMethodsInterceptPoints()</code> 方法，获得 StaticMethodsInterceptPoint 数组。若为<strong>空</strong>，不进行增强。</li><li>第 212 至 238 行 ：<strong>遍历</strong> StaticMethodsInterceptPoint 数组，逐个增强StaticMethodsInterceptPoint 对应的静态方法。<ul><li>第 214 至 218 行 ：获得拦截器的<strong>类名</strong>。拦截器的实例，在 <strong>Inter 类</strong>里获取。</li><li>第 221 至 229 行 ：当 <code>StaticMethodsInterceptPoint#isOverrideArgs()</code> 方法返回 <code>true</code> 时，使用 StaticMethodsInterWithOverrideArgs 处理拦截逻辑。在 <a href="#">「4.4.3 静态方法 Inter」</a> 详细解析。</li><li>第 230 至 236 行 ：当 <code>StaticMethodsInterceptPoint#isOverrideArgs()</code> 方法返回 <code>false</code> 时，使用 StaticMethodsInter 处理拦截逻辑，在 <a href="#">「4.4.3 静态方法 Inter」</a> 详细解析。</li></ul></li></ul><h4 id="4-1-2-2-增强构造方法和实例方法"><a href="#4-1-2-2-增强构造方法和实例方法" class="headerlink" title="4.1.2.2 增强构造方法和实例方法"></a>4.1.2.2 增强构造方法和实例方法</h4><p>调用 <a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/ClassEnhancePluginDefine.java#L89" rel="external nofollow noopener noreferrer" target="_blank"><code>#enhanceInstance()</code></a> 方法，增强构造方法和实例方法，代码如下 ：</p><ul><li>第 92 至 110 行 ：调用 <code>#getConstructorsInterceptPoints()</code> / <code>#getInstanceMethodsInterceptPoints()</code>  方法，获得 ConstructorInterceptPoint / InstanceMethodsInterceptPoint 数组。若<strong>都</strong>为<strong>空</strong>，不进行增强。</li><li>第 112 至 128 行 ：使用 <code>byte-buddy</code> ，为目标 Java 类<strong>“自动”</strong>实现 <a href="https://github.com/OpenSkywalking/skywalking/blob/15328202b8b7df89a609885d9110361ff29ce668/apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/plugin/interceptor/enhance/EnhancedInstance.java#L25" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.EnhancedInstance</code></a> 接口。这样，目标 Java 类就有一个私有变量，拦截器在执行过程中，可以存储状态到该私有变量。这里如果暂时不理解<strong>没关系</strong>，后面分享每个插件的实现时，会有实际的例子，更易懂。</li><li>———- 构造方法 ———-</li><li>第 130 至 143 行 ：<strong>遍历</strong> ConstructorInterceptPoint 数组，逐个增强 ConstructorInterceptPoint 对应的构造方法。使用 ConstructorInter 处理拦截逻辑，在 <a href="#">「4.4.1 构造方法 Inter」</a> 详细解析。</li><li>———- 实例方法 ———-</li><li>第 145 至 175 行 ：<strong>遍历</strong> InstanceMethodsInterceptPoint 数组，逐个增强 InstanceMethodsInterceptPoint 对应的静态方法。<ul><li>第 151 至 154 行 ：获得拦截器的<strong>类名</strong>。拦截器的实例，在 <strong>Inter 类</strong>里获取。</li><li>第 156 至 165 行 ：当 <code>InstanceMethodsInterceptPoint#isOverrideArgs()</code> 方法返回 <code>true</code> 时，使用 InstMethodsInterWithOverrideArgs 处理拦截逻辑。在 <a href="#">「4.4.2 实例方法 Inter」</a> 详细解析。</li><li>第 166 至 173 行 ：当 <code>InstanceMethodsInterceptPoint#isOverrideArgs()</code> 方法返回 <code>false</code> 时，使用 InstMethodsInter 处理拦截逻辑，在 <a href="#">「4.4.2 实例方法 Inter」</a> 详细解析。</li></ul></li></ul><h3 id="4-1-3-ClassStaticMethodsEnhancePluginDefine"><a href="#4-1-3-ClassStaticMethodsEnhancePluginDefine" class="headerlink" title="4.1.3 ClassStaticMethodsEnhancePluginDefine"></a>4.1.3 ClassStaticMethodsEnhancePluginDefine</h3><p><a href="https://github.com/YunaiV/skywalking/blob/c7c800bba485dcb9d532d6cb5686df273ae53d6d/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/ClassStaticMethodsEnhancePluginDefine.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.ClassStaticMethodsEnhancePluginDefine</code></a> ，类<strong>增强静态方法</strong>的插件定义<strong>抽象类</strong>，和本文 <a href="#">「4.1.2.1 增强静态方法」</a> 对应。</p><p>实现 <code>#getConstructorsInterceptPoints()</code> / <code>#getInstanceMethodsInterceptPoints()</code> <strong>抽象</strong>方法，返回空，表示不增强构造方法和实例方法。<strong>即只增强静态方法</strong>。</p><h3 id="4-1-4-ClassInstanceMethodsEnhancePluginDefine"><a href="#4-1-4-ClassInstanceMethodsEnhancePluginDefine" class="headerlink" title="4.1.4 ClassInstanceMethodsEnhancePluginDefine"></a>4.1.4 ClassInstanceMethodsEnhancePluginDefine</h3><p><a href="https://github.com/YunaiV/skywalking/blob/c7c800bba485dcb9d532d6cb5686df273ae53d6d/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/ClassInstanceMethodsEnhancePluginDefine.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.ClassInstanceMethodsEnhancePluginDefine</code></a> ，类<strong>增强构造方法和实例方法</strong>的插件定义<strong>抽象类</strong>，和本文 <a href="#">「4.1.2.2 增强构造方法和实例方法」</a> 对应。</p><p>实现 <code>#getStaticMethodsInterceptPoints()</code> <strong>抽象</strong>方法，返回空，表示不增强静态方法。<strong>即只增强构造方法和实例方法</strong>。</p><h2 id="4-2-InterceptPoint"><a href="#4-2-InterceptPoint" class="headerlink" title="4.2 InterceptPoint"></a>4.2 InterceptPoint</h2><table><thead><tr><th>InterceptPoint</th><th>方法类型</th><th>方法匹配</th><th>拦截器</th><th><code>#isOverrideArgs()</code></th></tr></thead><tbody><tr><td>StaticMethodsInterceptPoint</td><td>静态方法</td><td><code>#getMethodsMatcher()</code></td><td><code>#getMethodsInterceptor()</code></td><td>有</td></tr><tr><td>ConstructorInterceptPoint</td><td>构造方法</td><td><code>#getConstructorMatcher()</code></td><td><code>#getConstructorInterceptor()</code></td><td>无</td></tr><tr><td>InstanceMethodsInterceptPoint</td><td>实例方法</td><td><code>#getMethodsMatcher()</code></td><td><code>#getMethodsInterceptor()</code></td><td>有</td></tr></tbody></table><p>XXXInterceptPoint <strong>接口</strong>，对应一个 <code>net.bytebuddy.matcher.ElementMatcher</code>  和一个拦截器。</p><p>代码比较简单，胖友自己查看。</p><h2 id="4-3-Interceptor"><a href="#4-3-Interceptor" class="headerlink" title="4.3 Interceptor"></a>4.3 Interceptor</h2><p>在开始分享 <strong>Inter</strong> 之前，我们先来看看 Interceptor 相关接口。如下图所见：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/10.png" alt=""></p><ul><li>InstanceConstructorInterceptor ，构造方法拦截器<strong>接口</strong>。</li><li><em>AroundInterceptor</em><ul><li>StaticMethodsAroundInterceptor ，静态方法拦截器<strong>接口</strong>。</li><li>InstanceMethodsAroundInterceptor ，实例方法拦截器<strong>接口</strong>。</li><li>接口方法基本一致，下面 Inter 逻辑也基本一致。</li></ul></li></ul><p>在 <a href="#">「4. 2 InterceptPoint」</a> 里，我们看到 <code>#getXXXInterceptor()</code> 方法返回的拦截器类名，需要通过 <a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/loader/InterceptorInstanceLoader.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.loader.InterceptorInstanceLoader</code></a> 加载与创建拦截器实例。</p><h2 id="4-4-Inter"><a href="#4-4-Inter" class="headerlink" title="4.4 Inter"></a>4.4 Inter</h2><p>我们先来看 Inter 的定义 ：</p><blockquote><p>In this class, it provide a bridge between byte-buddy and sky-walking plugin.</p></blockquote><p>根据方法类型，将 Inter 整理如下 ：</p><table><thead><tr><th>方法类型</th><th></th><th></th></tr></thead><tbody><tr><td>构造方法</td><td>ConstructorInter</td><td></td></tr><tr><td>实例方法</td><td>InstMethodsInter</td><td>InstMethodsInterWithOverrideArgs</td></tr><tr><td>静态方法</td><td>StaticMethodsInter</td><td>StaticMethodsInterWithOverrideArgs</td></tr></tbody></table><h3 id="4-4-1-构造方法-Inter"><a href="#4-4-1-构造方法-Inter" class="headerlink" title="4.4.1 构造方法 Inter"></a>4.4.1 构造方法 Inter</h3><p><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/ConstructorInter.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.ConstructorInter</code></a> ，构造方法 Inter 。</p><p>ConstructorInter <a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/ConstructorInter.java#L52" rel="external nofollow noopener noreferrer" target="_blank"><strong>构造方法</strong></a>，调用 <code>InterceptorInstanceLoader#load(String, classLoader)</code> 方法，加载构造方法拦截器。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/ConstructorInter.java#L68" rel="external nofollow noopener noreferrer" target="_blank"><code>#intercept(Object)</code></a> 方法，<strong>在构造方法执行完成后进行拦截</strong>，调用 <code>InstanceConstructorInterceptor#onConstruct(...)</code> 方法。</p><p><strong>为什么没有 ConstructorInterWithOverrideArgs</strong>？<code>InstanceConstructorInterceptor#onConstruct(...)</code> 方法，是<strong>在构造方法执行完成后进行调用拦截</strong>，OverrideArgs 用于在调用方法之前，<strong>改变传入方法的参数</strong>。所以，在此处暂时没这块需要，因而没有 ConstructorInterWithOverrideArgs 。</p><h3 id="4-4-2-实例方法-Inter"><a href="#4-4-2-实例方法-Inter" class="headerlink" title="4.4.2 实例方法 Inter"></a>4.4.2 实例方法 Inter</h3><p><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/InstMethodsInter.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.InstMethodsInter</code></a> ，实例方法 Inter 。</p><p>ConstructorInter <a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/InstMethodsInter.java#L51" rel="external nofollow noopener noreferrer" target="_blank"><strong>构造方法</strong></a>，调用 <code>InterceptorInstanceLoader#load(String, classLoader)</code> 方法，加载实例方法拦截器。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/InstMethodsInter.java#L72" rel="external nofollow noopener noreferrer" target="_blank"><code>#intercept(...)</code></a> 方法，<strong>Before-After</strong> 方式拦截实例方法，代码如下 ：</p><ul><li>第 79 至 86 行 ：调用 <code>InstanceMethodsAroundInterceptor#beforeMethod(...)</code> 方法，执行在实例方法之前的逻辑。<ul><li><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/MethodInterceptResult.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.MethodInterceptResult</code></a> ，方法拦截器执行结果。当调用 <a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/MethodInterceptResult.java#L51" rel="external nofollow noopener noreferrer" target="_blank"><code>MethodInterceptResult#defineReturnValue(Object)</code></a> 方法，设置执行结果，并标记不再继续执行。</li></ul></li><li>第 90 至 92 行 ：当 MethodInterceptResult 已经有执行结果，<strong>不再执行原有方法，直接返回结果</strong>。</li><li>第 94 至 96 行 ：调用 <code>Callable#call()</code> 方法，执行原有实例方法。</li><li>第 97 至 105 行 ：调用 <code>InstanceMethodsAroundInterceptor#handleMethodException(...)</code> 方法，处理异常。</li><li>第 107 至 113 行 ：调用 <code>InstanceMethodsAroundInterceptor#afterMethod(...)</code> 方法，执行后置逻辑。</li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/InstMethodsInterWithOverrideArgs.java#L37" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.InstMethodsInterWithOverrideArgs</code></a> ，<strong>覆写参数</strong>的实例方法 Inter 。</p><p>不太理解<strong>覆写参数</strong>？有这样一个场景，<code>InstanceMethodsAroundInterceptor#beforeMethod(...)</code> 方法里，我们修改了方法参数，并且希望原有实例方法执行时，<strong>使用的是修改了的方法参数</strong>，此时，就需要使用 InstMethodsInterWithOverrideArgs 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/InstMethodsInterWithOverrideArgs.java#L73" rel="external nofollow noopener noreferrer" target="_blank"><code>InstMethodsInterWithOverrideArgs#intercept(...)</code></a> 方法，总体逻辑和 InstMethodsInter 是一致的，下面我们来看看差异点 ：</p><ul><li>第 76 行 ：方法参数类型是 <a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/OverrideCallable.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.OverrideCallable</code></a>，并且带有 <a href="https://github.com/raphw/byte-buddy/blob/188366ace6e16ec167a00b144c9048d78495165f/byte-buddy-dep/src/main/java/net/bytebuddy/implementation/bind/annotation/Morph.java" rel="external nofollow noopener noreferrer" target="_blank"><code>net.bytebuddy.implementation.bind.annotation.@Morph</code></a> 注解。</li><li>第 96 行 ：调用 <a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/OverrideCallable.java#L37" rel="external nofollow noopener noreferrer" target="_blank"><code>OverrideCallable#call(args)</code></a> 方法，使用被前置方法修改过的参数，执行原有实例方法。</li></ul><p>先来瞅瞅 <code>@Morph</code> 注解的定义 ：</p><blockquote><p>This annotation instructs Byte Buddy to inject a proxy class that calls a method’s super method with explicit arguments.  </p><p>For this, the {@link Morph.Binder} needs to be installed for an interface type that takes an argument of the array type {@link java.lang.Object} and returns a non-array type of {@link java.lang.Object}. </p><p>This is an alternative to using the {@link net.bytebuddy.implementation.bind.annotation.SuperCall} or {@link net.bytebuddy.implementation.bind.annotation.DefaultCall} annotations which call a super method using the same arguments as the intercepted method was invoked with.</p></blockquote><p>简单的来说 ：</p><ul><li><code>@Morph</code> 注解，注入一个代理对象，该对象会使用传入的参数，调用被代理的方法。例如在 InstMethodsInterWithOverrideArgs 里，调用 <code>OverrideCallable#call(args)</code> 方法，会调用原有实例方法。</li><li><p>需要使用 <code>Morph.Binder</code> 设置一个接口，并且该接口的方法定义为 <code>Object methodName(Object[])</code> 。在 InstMethodsInterWithOverrideArgs 使用的是  <a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/OverrideCallable.java#L29" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.OverrideCallable</code></a> 接口。另外，调用 <code>Morph.Binder#install(Class&lt;?&gt;)</code> 方法的代码如下 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ClassEnhancePluginDefine.java </span></div><div class="line"><span class="comment">// `#enhanceInstance(...)` 方法</span></div><div class="line">newClassBuilder =</div><div class="line">    newClassBuilder.method(not(isStatic()).and(instanceMethodsInterceptPoint.getMethodsMatcher())) <span class="comment">// 匹配</span></div><div class="line">        .intercept( <span class="comment">// 拦截</span></div><div class="line">            MethodDelegation.withDefaultConfiguration()</div><div class="line">                .withBinders(</div><div class="line">                    Morph.Binder.install(OverrideCallable.class) <span class="comment">// 覆写参数</span></div><div class="line">                )</div><div class="line">                .to(<span class="keyword">new</span> InstMethodsInterWithOverrideArgs(interceptor, classLoader))</div><div class="line">        );</div></pre></td></tr></table></figure></li></ul><h3 id="4-4-3-静态方法-Inter"><a href="#4-4-3-静态方法-Inter" class="headerlink" title="4.4.3 静态方法 Inter"></a>4.4.3 静态方法 Inter</h3><p><a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/StaticMethodsInter.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.StaticMethodsInter</code></a> 和 <a href="https://github.com/YunaiV/skywalking/blob/ea8b4e879092b39070215b1a2d194e6df12f0ef8/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/interceptor/enhance/StaticMethodsInterWithOverrideArgs.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.interceptor.enhance.StaticMethodsInterWithOverrideArgs</code></a> 和<strong>实例方法 Inter</strong>基本一致，胖友可以自己捋一捋，笔者就不瞎比比了。</p><h2 id="4-5-小结"><a href="#4-5-小结" class="headerlink" title="4.5 小结"></a>4.5 小结</h2><p>总的来说，涉及到的组件，如下图 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/11.png" alt=""></p><p>胖友再梳理梳理。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>写完，蛮嗨皮😜。</p><p>近期最认真的一篇文章，没有之一，满足。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_10/12.png" alt=""></p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/agent-plugin-system/&quot;&gt;http://www.iocoder.cn/SkyWalking/agent-plugin-system/&lt;/a&gt; 「芋道源码」
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— Agent 初始化</title>
    <link href="http://www.iocoder.cn/SkyWalking/agent-init/"/>
    <id>http://www.iocoder.cn/SkyWalking/agent-init/</id>
    <published>2020-07-04T16:00:00.000Z</published>
    <updated>2017-12-13T18:28:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/agent-init/">http://www.iocoder.cn/SkyWalking/agent-init/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-init/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-init/">2. SkyWalkingAgent</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-init/">3. SnifferConfigInitializer</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-init/">3.1 Config</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-init/">3.2 RemoteDownstreamConfig</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-init/">4. Plugin</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-init/">4.1 PluginBootstrap</a></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-init/">4.2 PluginFinder</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-init/">5. ServiceManager</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/agent-init/">5.1 BootService</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/agent-init/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>SkyWalking Agent 启动初始化的过程</strong>。</p><p>SkyWalking Agent 基于 <strong>JavaAgent</strong> 机制，实现应用<strong>透明</strong>接入 SkyWalking 。关于 JavaAgent 机制，笔者推荐如下两篇文章 ：</p><ul><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html" rel="external nofollow noopener noreferrer" target="_blank">《Instrumentation 新功能》</a></li><li><a href="http://www.infoq.com/cn/articles/javaagent-illustrated" rel="external nofollow noopener noreferrer" target="_blank">《JVM源码分析之javaagent原理完全解读》</a></li></ul><blockquote><p>友情提示 ：建议自己手撸一个简单的 JavaAgent ，更容易理解 SkyWalking Agent 。 </p><p>笔者练手的 JavaAgent 项目地址 ：<a href="https://github.com/YunaiV/learning/tree/master/javaagent01" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/YunaiV/learning/tree/master/javaagent01</a></p></blockquote><h1 id="2-SkyWalkingAgent"><a href="#2-SkyWalkingAgent" class="headerlink" title="2. SkyWalkingAgent"></a>2. SkyWalkingAgent</h1><p><code>org.skywalking.apm.agent.SkyWalkingAgent</code> ，在 <code>apm-sniffer/apm-agent</code> Maven 模块项目里，SkyWalking Agent <strong>启动入口</strong>。为什么说它是启动入口呢？在 <code>apm-sniffer/apm-agent</code> 的 <a href="https://github.com/OpenSkywalking/skywalking/blob/23133f7d97d17b471f69e7214a01885ebcd2e882/apm-sniffer/apm-agent/pom.xml#L53" rel="external nofollow noopener noreferrer" target="_blank"><code>pom.xml</code></a> 文件的【第 73 行】，我们可以看到 SkyWalkingAgent 被配置成 JavaAgent 的 <strong>PremainClass</strong> 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/c51dbc997348111674dbeedb71d22b0414936cdb/apm-sniffer/apm-agent/src/main/java/org/skywalking/apm/agent/SkyWalkingAgent.java#L54" rel="external nofollow noopener noreferrer" target="_blank"><code>#premain(...)</code></a> 方法，代码如下 ：</p><ul><li>第 58 行 ：调用 <code>SnifferConfigInitializer#initialize()</code> 方法，初始化 Agent 配置。</li><li>第 61 行 ：调用 <code>PluginBootstrap#loadPlugins()</code> 方法，加载 Agent 插件们。而后，创建 PluginFinder 。 </li><li>第 64 行 ：调用 <code>ServiceManager#boot()</code> 方法，初始化 Agent 服务管理。在这过程中，Agent 服务们会被初始化。</li><li>第 79 至 133 行 ：基于 <a href="https://github.com/raphw/byte-buddy" rel="external nofollow noopener noreferrer" target="_blank">byte-buddy</a> ，初始化 Instrumentation 的 <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/instrument/ClassFileTransformer.html" rel="external nofollow noopener noreferrer" target="_blank"><code>java.lang.instrument.ClassFileTransformer</code></a> 。</li></ul><h1 id="3-SnifferConfigInitializer"><a href="#3-SnifferConfigInitializer" class="headerlink" title="3. SnifferConfigInitializer"></a>3. SnifferConfigInitializer</h1><p><code>org.skywalking.apm.agent.core.conf.SnifferConfigInitializer</code> ，Agent 配置初始化器。</p><p>在看具体代码实现之前，我们先看下 <code>org.skywalking.apm.agent.core.conf</code> 包的大体结构 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_05/02.png" alt=""></p><p>配置类有 Config 和 RemoteDownstreamConfig 两种。从命名上可以看出 ：</p><ul><li>Config 为 Agent <strong>本地</strong>配置类，使用 SnifferConfigInitializer 进行初始化。</li><li>RemoteDownstreamConfig 为 Agent <strong>远程</strong>配置类，从 <a href="https://github.com/OpenSkywalking/skywalking/wiki/3.2.3-%E9%83%A8%E7%BD%B2Collector" rel="external nofollow noopener noreferrer" target="_blank">Collector Server</a> 读取。 </li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/cea46a7e93437bbb16db2bfe0fae5c6fcf733fc2/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/conf/SnifferConfigInitializer.java#L56" rel="external nofollow noopener noreferrer" target="_blank"><code>#initialize()</code></a> 方法，初始化 Agent 本地配置，代码如下 ：</p><ul><li>第 59 至 67 行 ：从配置文件( <code>agent.config</code> ) 加载配置。配置文件所在<strong>固定</strong>路径为 <code>${AGENT_PACKAGE_PATH}/config/agent.config</code> ，其中 <code>${AGENT_PACKAGE_PATH}</code> 通过 <a href="https://github.com/YunaiV/skywalking/blob/c51dbc997348111674dbeedb71d22b0414936cdb/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/boot/AgentPackagePath.java#L31" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.boot.AgentPackagePath</code></a> 初始化。Agent 整理目录如下图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_05/01.png" alt=""></li><li>第 70 至 74 行 ：从环境变量<strong>覆盖</strong>配置。环境变量 <strong>Key</strong> 需以 <code>&quot;skywalking.&quot;</code> 开头。例如，<code>Config.Agent.APPLICATION_CODE</code> 在 <code>agent.config</code> 为 <code>agent.application_code</code> ，环境变量为 <code>skywalking.agent.application_code</code> 。另外，环境变量包括 JVM 进程的和系统的。</li><li>第 77 至 82 行 ：校验配置是否正确加载。</li></ul><h2 id="3-1-Config"><a href="#3-1-Config" class="headerlink" title="3.1 Config"></a>3.1 Config</h2><p><code>org.skywalking.apm.agent.core.conf.Config</code> ，Agent 本地配置类。</p><p>打开 <a href="https://github.com/YunaiV/skywalking/blob/cea46a7e93437bbb16db2bfe0fae5c6fcf733fc2/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/conf/Config.java#L32" rel="external nofollow noopener noreferrer" target="_blank">Config</a> ，我们会看到拆分了 Agent / Collector / Jvm / Buffer / Dictionary / Logging / Plugin 七个小类。如下图 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_05/03.png" alt=""></p><p>本文暂不对配置项详细解析，胖友可以看下每个属性的英文注释。</p><h2 id="3-2-RemoteDownstreamConfig"><a href="#3-2-RemoteDownstreamConfig" class="headerlink" title="3.2 RemoteDownstreamConfig"></a>3.2 RemoteDownstreamConfig</h2><p><code>org.skywalking.apm.agent.core.conf.RemoteDownstreamConfig</code> ，Agent 远程配置类。</p><p>打开 <a href="https://github.com/YunaiV/skywalking/blob/cea46a7e93437bbb16db2bfe0fae5c6fcf733fc2/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/conf/RemoteDownstreamConfig.java" rel="external nofollow noopener noreferrer" target="_blank">RemoteDownstreamConfig</a> ，我们会看到拆分了 Agent / Collector 两小类。如下图 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_05/04.png" alt=""></p><p>本文暂不对配置项详细解析，胖友可以看下每个属性的英文注释。</p><h1 id="4-Plugin"><a href="#4-Plugin" class="headerlink" title="4. Plugin"></a>4. Plugin</h1><p>SkyWalking Agent 提供了多种插件，实现不同框架的<strong>透明</strong>接入 SkyWalking 。在 <a href="https://github.com/OpenSkywalking/skywalking/wiki/3.2.3-supported-list" rel="external nofollow noopener noreferrer" target="_blank">《官方文档 —— supported list》</a> 里，有目前的插件列表。</p><p>另外，在 <code>apm-sniffer/apm-sdk-plugin</code> 目录下，有插件的实现代码 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_05/05.png" alt=""></p><p>本小节会分享的较为简单，在 <a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/?self">《SkyWalking 源码分析 —— Agent 插件体系》</a> 详细解析。</p><h2 id="4-1-PluginBootstrap"><a href="#4-1-PluginBootstrap" class="headerlink" title="4.1 PluginBootstrap"></a>4.1 PluginBootstrap</h2><p><code>org.skywalking.apm.agent.core.plugin.PluginBootstrap</code> ，插件引导程序类，创建需要加载的插件对象数组。</p><p><a href="https://github.com/YunaiV/skywalking/blob/130f0a5a3438663b393e53ba2cca02a8d13c258a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginBootstrap.java#L45" rel="external nofollow noopener noreferrer" target="_blank"><code>#loadPlugins()</code></a> 方法，代码如下 ：</p><ul><li>第 47 行 ：初始化 AgentClassLoader 。</li><li>第 50 至 56 行 ：获得插件<strong>定义路径</strong>数组。</li><li>第 59 至 66 行 ：获得插件<strong>定义</strong>( <a href="https://github.com/OpenSkywalking/skywalking/blob/b16d23c1484bec941367d6b36fa932b8ace40971/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginDefine.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.PluginDefine</code></a> )数组。</li><li>第 69 至 82 行 ：创建<strong>类增强插件定义</strong>( <a href="https://github.com/OpenSkywalking/skywalking/blob/b16d23c1484bec941367d6b36fa932b8ace40971/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/AbstractClassEnhancePluginDefine.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.AbstractClassEnhancePluginDefine</code></a> )对象数组。不同插件通过实现 AbstractClassEnhancePluginDefine <strong>抽象类</strong>，定义不同框架的<strong>切面</strong>，<strong>记录调用链路</strong>。以 Spring 插件为例子，如下是相关类图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_05/06.png" alt=""></li></ul><h2 id="4-2-PluginFinder"><a href="#4-2-PluginFinder" class="headerlink" title="4.2 PluginFinder"></a>4.2 PluginFinder</h2><p><code>org.skywalking.apm.agent.core.plugin.PluginFinder</code> ，插件发现者。其提供 <a href="https://github.com/YunaiV/skywalking/blob/09c654af33081e56547cb8b3b9e0c8525ddce32f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginFinder.java#L80" rel="external nofollow noopener noreferrer" target="_blank"><code>#find(...)</code></a> 方法，获得<strong>类增强插件定义</strong>( <a href="https://github.com/OpenSkywalking/skywalking/blob/b16d23c1484bec941367d6b36fa932b8ace40971/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/AbstractClassEnhancePluginDefine.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.plugin.AbstractClassEnhancePluginDefine</code></a> )对象。</p><p>PluginFinder <strong><a href="https://github.com/YunaiV/skywalking/blob/09c654af33081e56547cb8b3b9e0c8525ddce32f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/plugin/PluginFinder.java#L56" rel="external nofollow noopener noreferrer" target="_blank">构造方法</a></strong>，代码如下 ：</p><ul><li>第 57 至 77 行 ：循环 AbstractClassEnhancePluginDefine 对象数组，添加到 <code>nameMatchDefine</code> / <code>signatureMatchDefine</code> 属性，方便 <code>#find(...)</code> 方法查找 AbstractClassEnhancePluginDefine 对象。<ul><li>第 65 至 72 行 ：处理 NameMatch 为匹配的 AbstractClassEnhancePluginDefine 对象，添加到 <code>nameMatchDefine</code>  属性。</li><li>第 74 至 76 行 ：处理<strong>非</strong> NameMatch 为匹配的 AbstractClassEnhancePluginDefine 对象，添加到 <code>signatureMatchDefine</code> 属性。</li></ul></li></ul><h1 id="5-ServiceManager"><a href="#5-ServiceManager" class="headerlink" title="5. ServiceManager"></a>5. ServiceManager</h1><p><code>org.skywalking.apm.agent.core.boot.ServiceManager</code> ，<a href="https://github.com/YunaiV/skywalking/blob/09c654af33081e56547cb8b3b9e0c8525ddce32f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/boot/BootService.java" rel="external nofollow noopener noreferrer" target="_blank">BootService</a> 管理器。负责管理、初始化 BootService 实例们。</p><p><a href="https://github.com/YunaiV/skywalking/blob/3de8a6c15d07aa3b2c3b4e732e6654fc87c4e70e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/boot/ServiceManager.java#L45" rel="external nofollow noopener noreferrer" target="_blank"><code>#boot()</code></a> 方法，代码如下 ：</p><ul><li><p>第 47 行 ：调用 <a href="https://github.com/YunaiV/skywalking/blob/3de8a6c15d07aa3b2c3b4e732e6654fc87c4e70e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/boot/ServiceManager.java#L72" rel="external nofollow noopener noreferrer" target="_blank"><code>#loadAllServices()</code></a> 方法，加载所有 BootService 实现类的实例数组。ServiceManager 基于 SPI (Service Provider Interface) 机制，在 <a href="https://github.com/OpenSkywalking/skywalking/blob/b16d23c1484bec941367d6b36fa932b8ace40971/apm-sniffer/apm-agent-core/src/main/resources/META-INF/services/org.skywalking.apm.agent.core.boot.BootService" rel="external nofollow noopener noreferrer" target="_blank">/resources/META-INF.services/org.skywalking.apm.agent.core.boot.BootService</a> 文件里，定义了所有 BootService 的实现类。如果胖友对 SPI 机制不熟悉，可以看下如下文章 ：</p><ul><li><a href="http://www.jianshu.com/p/32d3e108f30a" rel="external nofollow noopener noreferrer" target="_blank">《SPI 和 ServiceLoader》</a> </li><li><a href="http://www.jianshu.com/p/46aa69643c97" rel="external nofollow noopener noreferrer" target="_blank">《跟我学Dubbo系列之Java SPI机制简介》</a> </li></ul></li><li><p>第 50 行 ：调用 <a href="https://github.com/YunaiV/skywalking/blob/3de8a6c15d07aa3b2c3b4e732e6654fc87c4e70e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/boot/ServiceManager.java#L82" rel="external nofollow noopener noreferrer" target="_blank"><code>#beforeBoot()</code></a> 方法，调用每个 <code>BootService#beforeBoot()</code> 方法。</p></li><li>第 52 行 ：调用 <a href="https://github.com/YunaiV/skywalking/blob/3de8a6c15d07aa3b2c3b4e732e6654fc87c4e70e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/boot/ServiceManager.java#L92" rel="external nofollow noopener noreferrer" target="_blank"><code>#startup()</code></a> 方法，调用每个 <code>BootService#boot()</code> 方法。</li><li>第 54 行 ：调用 <a href="https://github.com/YunaiV/skywalking/blob/3de8a6c15d07aa3b2c3b4e732e6654fc87c4e70e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/boot/ServiceManager.java#L102" rel="external nofollow noopener noreferrer" target="_blank"><code>#afterBoot()</code></a> 方法，调用每个 <code>BootService#afterBoot()</code> 方法。</li></ul><h2 id="5-1-BootService"><a href="#5-1-BootService" class="headerlink" title="5.1 BootService"></a>5.1 BootService</h2><p><code>org.skywalking.apm.agent.core.boot.BootService</code> ，Agent 启动服务<strong>接口</strong>，定义了 <code>#beforeBoot()</code> / <code>#boot()</code> / <code>#afterBoot()</code> / <code>#shutdown()</code> 接口方法。</p><p>BootService 目前有<strong>七个</strong>实现类，在后续的文章，我们会解析相关实现。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_05/07.png" alt=""></p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>每次写初始化相关的文章，写少了，怕太水；写多了，又怕太复杂。</p><p>嗯，送一发妹子。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_05/08.png" alt=""></p><p>胖友，分享个朋友圈可好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/agent-init/&quot;&gt;http://www.iocoder.cn/SkyWalking/agent-init/&lt;/a&gt; 「芋道源码」欢迎转载，保留摘要，谢谢！&lt;/p&gt;

      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>SkyWalking 源码分析 —— 调试环境搭建</title>
    <link href="http://www.iocoder.cn/SkyWalking/build-debugging-environment/"/>
    <id>http://www.iocoder.cn/SkyWalking/build-debugging-environment/</id>
    <published>2020-06-30T16:00:00.000Z</published>
    <updated>2017-12-10T02:02:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/build-debugging-environment/">http://www.iocoder.cn/SkyWalking/build-debugging-environment/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><ul><li><a href="http://www.iocoder.cn/SkyWalking/build-debugging-environment/">1. 依赖工具</a></li><li><a href="http://www.iocoder.cn/SkyWalking/build-debugging-environment/">2. 源码拉取</a></li><li><a href="http://www.iocoder.cn/SkyWalking/build-debugging-environment/">3. 启动 SkyWalking Collector</a></li><li><a href="http://www.iocoder.cn/SkyWalking/build-debugging-environment/">4. 启动 SkyWalking Agent</a></li><li><a href="http://www.iocoder.cn/SkyWalking/build-debugging-environment/">5. 启动 SkyWalking Web UI</a></li><li><a href="http://www.iocoder.cn/SkyWalking/build-debugging-environment/">6. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-依赖工具"><a href="#1-依赖工具" class="headerlink" title="1. 依赖工具"></a>1. 依赖工具</h1><ul><li>Maven</li><li>Git</li><li>JDK</li><li>IntelliJ IDEA</li></ul><h1 id="2-源码拉取"><a href="#2-源码拉取" class="headerlink" title="2. 源码拉取"></a>2. 源码拉取</h1><p>从官方仓库 <a href="https://github.com/OpenSkywalking/skywalking" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/OpenSkywalking/skywalking</a> <code>Fork</code> 出属于自己的仓库。为什么要 <code>Fork</code> ？既然开始阅读、调试源码，我们可能会写一些注释，有了自己的仓库，可以进行自由的提交。😈</p><p>使用 <code>IntelliJ IDEA</code> 从 <code>Fork</code> 出来的仓库拉取代码。拉取完成后，<code>Maven</code> 会下载依赖包，可能会花费一些时间，耐心等待下。</p><p>本文基于 <code>master</code> 分支。</p><h1 id="3-启动-SkyWalking-Collector"><a href="#3-启动-SkyWalking-Collector" class="headerlink" title="3. 启动 SkyWalking Collector"></a>3. 启动 SkyWalking Collector</h1><p>参考 <a href="https://github.com/OpenSkywalking/skywalking/wiki/How-to-build" rel="external nofollow noopener noreferrer" target="_blank">《官方文档 —— How to build》</a></p><ol><li>在 IntelliJ IDEA Terminal 中，执行 <code>mvn compile -Dmaven.test.skip=true</code> 进行编译。</li><li><p>设置 gRPC 的<strong>自动生成</strong>的代码目录，为<strong>源码</strong>目录 ：</p><ul><li>/apm-network/target/generated-sources/protobuf/ 下的 <code>grpc-java</code> 和 <code>java</code> 目录</li><li>/apm-collector-remote/collector-remote-grpc-provider/target/generated-sources/protobuf/ 下的 <code>grpc-java</code> 和 <code>java</code> 目录</li><li><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_01/01.png" alt=""></p><blockquote><p>从 3.2 开始，网络通讯协议引入 GRPC ，所以增加上述的步骤</p></blockquote></li></ul></li><li><p>运行 <code>org.skywalking.apm.collector.bootCollectorBootStartUp</code> 的 <code>#main(args)</code> 方法，启动 Collector 。</p></li><li>访问 <code>http://127.0.0.1:10800/agent/jetty</code> 地址，返回 <code>[&quot;localhost:12800/&quot;]</code> ，说明启动<strong>成功</strong>。</li></ol><h1 id="4-启动-SkyWalking-Agent"><a href="#4-启动-SkyWalking-Agent" class="headerlink" title="4. 启动 SkyWalking Agent"></a>4. 启动 SkyWalking Agent</h1><p>感谢 <a href="https://github.com/wu-sheng" rel="external nofollow noopener noreferrer" target="_blank">吴晟</a> 指导如何搭建 Agent 调试环境。</p><ol><li>在 IntelliJ IDEA Terminal 中，执行 <code>mvn compile -Dmaven.test.skip=true</code> 进行编译。在 /packages/skywalking-agent 目录下，我们可以看到编译出来的 Agent ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_01/02.png" alt=""></li><li><p>使用 Spring Boot 创建一个简单的 Web 项目。类似如下 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_01/03.png" alt=""></p><blockquote><p>友情提示 ：<strong>这里一定要注意下</strong>。创建的 Web 项目，使用  IntelliJ IDEA 的<strong>菜单</strong> File / New / Module 或 File / New / Module from Existing Sources ，<strong>保证 Web 项目和 skywalking 项目平级</strong>。这样，才可以使用 IntelliJ IDEA 调试  Agent 。</p></blockquote><ul><li><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_01/04.png" alt=""></li><li><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_01/05.png" alt=""></li></ul></li><li><p>在 <code>org.skywalking.apm.agent.SkyWalkingAgent</code> 的 <code>#premain(...)</code> 方法，打上调试断点。</p></li><li>运行 Web 项目的 Application 的 <code>#main(args)</code> 方法，并增加 JVM 启动参数，<code>-javaagent:/path/to/skywalking-agent/skywalking-agent.jar</code>。<code>/path/to</code> <strong>参数值</strong>为上面我们编译出来的 /packages/skywalking-agent 目录的绝对路径。如下图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_01/06.png" alt=""></li><li>如果在【<strong>第三步</strong>】的调试断点停住，说明 Agent 启动<strong>成功</strong>。</li></ol><hr><p>考虑到可能我们会在 Agent 上增加代码注释，这样每次不得不重新编译 Agent 。可以配置如下图，自动编译 Agent ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_01/07.png" alt=""></p><ul><li><code>-T 1C clean  package -Dmaven.test.skip=true -Dmaven.compile.fork=true</code> 。</li></ul><hr><p>另外，使用 IntelliJ IDEA Remote 远程调试，也是可以的。如下图 ：<img src="http://www.iocoder.cn/images/SkyWalking/2020_07_01/10.png" alt=""></p><h1 id="5-启动-SkyWalking-Web-UI"><a href="#5-启动-SkyWalking-Web-UI" class="headerlink" title="5. 启动 SkyWalking Web UI"></a>5. 启动 SkyWalking Web UI</h1><p>考虑到调试过程中，我们要看下是否收集到追踪日志，可以安装 SkyWalking Web UI 进行查看。</p><p>参考 <a href="https://github.com/OpenSkywalking/skywalking-ui#quickstart-zh" rel="external nofollow noopener noreferrer" target="_blank">《官方文档 —— Sky Walking Web UI》</a> 安装。</p><h1 id="6-彩蛋"><a href="#6-彩蛋" class="headerlink" title="6. 彩蛋"></a>6. 彩蛋</h1><p>SkyWalking 环境搭建完成，胖友们可以起飞，源码读起来。</p><p>这会是个系列文章，笔者会慢慢更新。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_01/08.png" alt=""></p><p>如下是笔者对代码量和用途的简单整理，完善度比较低，可能有一丢丢的帮助 ：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_07_01/09.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/SkyWalking/build-debugging-environment/&quot;&gt;http://www.iocoder.cn/SkyWalking/build-debugging-environ
      
    
    </summary>
    
      <category term="SkyWalking" scheme="http://www.iocoder.cn/categories/SkyWalking/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring-Cloud-Gateway 源码解析 —— 网关管理 HTTP API</title>
    <link href="http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-api/"/>
    <id>http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-api/</id>
    <published>2020-04-14T16:00:00.000Z</published>
    <updated>2017-12-01T16:48:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-api/">http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-api/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Spring-Cloud-Gateway 2.0.X M4</strong>  </p><ul><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-api/">1. 概述</a><ul><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-api/">2. 过滤器 HTTP API</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-api/">2.1 全局过滤器列表</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-api/">2.2 路由过滤器工厂列表</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-api/">3. 路由 HTTP API</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-api/">2.1 路由列表</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-api/">2.2 单个路由信息</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-api/">2.3 单个路由的过滤器</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-api/">2.4 添加/修改单个路由</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-api/">2.5 删除单个路由</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-api/">2.6 刷新路由缓存</a></li></ul></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-api/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享<strong>网关管理 HTTP API</strong>。</p><p><code>org.springframework.cloud.gateway.actuate.GatewayWebfluxEndpoint</code> ，提供<strong>管理</strong>网关的 HTTP API 。<strong>构造方法</strong>，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"$&#123;management.context-path:/application&#125;/gateway"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GatewayWebfluxEndpoint</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(GatewayWebfluxEndpoint.class);</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 路由定义定位器</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="keyword">private</span> RouteDefinitionLocator routeDefinitionLocator;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 全局过滤器</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="keyword">private</span> List&lt;GlobalFilter&gt; globalFilters;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 网关过滤器工厂</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="keyword">private</span> List&lt;GatewayFilterFactory&gt; gatewayFilters;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 存储器 RouteDefinitionLocator 对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="keyword">private</span> RouteDefinitionWriter routeDefinitionWriter;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 路由定位器</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="keyword">private</span> RouteLocator routeLocator;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 应用事件发布器</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="keyword">private</span> ApplicationEventPublisher publisher;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">GatewayWebfluxEndpoint</span><span class="params">(RouteDefinitionLocator routeDefinitionLocator, List&lt;GlobalFilter&gt; globalFilters,</span></span></div><div class="line"><span class="function"><span class="params">  List&lt;GatewayFilterFactory&gt; GatewayFilters, RouteDefinitionWriter routeDefinitionWriter,</span></span></div><div class="line"><span class="function"><span class="params">  RouteLocator routeLocator)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.routeDefinitionLocator = routeDefinitionLocator;</div><div class="line"><span class="keyword">this</span>.globalFilters = globalFilters;</div><div class="line"><span class="keyword">this</span>.gatewayFilters = GatewayFilters;</div><div class="line"><span class="keyword">this</span>.routeDefinitionWriter = routeDefinitionWriter;</div><div class="line"><span class="keyword">this</span>.routeLocator = routeLocator;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>@RequestMapping</code> 注解，HTTP  API 以 <code>&quot;${management.context-path:/application}/gateway&quot;</code> 。</li><li><code>routeDefinitionLocator</code> 属性，路由定义定位器。在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/route-locator-route-definition/?self">《Spring-Cloud-Gateway 源码解析 —— 路由（2.2）之 RouteDefinitionRouteLocator 路由配置》</a> 有详细解析。</li><li><code>globalFilters</code> 属性，全局过滤器。在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-intro/?self">《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.1) 之 GatewayFilter 一览》</a> 有详细解析。</li><li><code>gatewayFilters</code> 属性，网关过滤器工厂。在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-factory/?self">《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.2) 之 GatewayFilterFactory 过滤器工厂》</a></li><li><code>routeLocator</code> 属性，路由定位器。在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/route-locator-intro/?self">《Spring-Cloud-Gateway 源码解析 —— 路由（2.1）之 RouteLocator 一览》</a> 有详细解析。</li><li><code>publisher</code> 属性，应用事件发布器。在 <a href="https://muyinchen.github.io/2017/09/27/Spring5%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8/" rel="external nofollow noopener noreferrer" target="_blank">《Spring5源码解析-Spring框架中的事件和监听器》</a> 有相关解析。</li></ul><hr><p>GatewayWebfluxEndpoint 提供两类 HTTP API ：</p><ul><li>过滤器 HTTP API</li><li>路由 HTTP API</li></ul><hr><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h2 id="2-过滤器-HTTP-API"><a href="#2-过滤器-HTTP-API" class="headerlink" title="2. 过滤器 HTTP API"></a>2. 过滤器 HTTP API</h2><h2 id="2-1-全局过滤器列表"><a href="#2-1-全局过滤器列表" class="headerlink" title="2.1 全局过滤器列表"></a>2.1 全局过滤器列表</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"/globalfilters"</span>)</div><div class="line"><span class="keyword">public</span> Mono&lt;HashMap&lt;String, Object&gt;&gt; globalfilters() &#123;</div><div class="line"><span class="keyword">return</span> getNamesToOrders(<span class="keyword">this</span>.globalFilters);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> &lt;T&gt; Mono&lt;HashMap&lt;String, Object&gt;&gt; getNamesToOrders(List&lt;T&gt; list) &#123;</div><div class="line"><span class="keyword">return</span> Flux.fromIterable(list).reduce(<span class="keyword">new</span> HashMap&lt;&gt;(), <span class="keyword">this</span>::putItem);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> HashMap&lt;String, Object&gt; <span class="title">putItem</span><span class="params">(HashMap&lt;String, Object&gt; map, Object o)</span> </span>&#123;</div><div class="line">Integer order = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> Ordered) &#123;</div><div class="line">order = ((Ordered)o).getOrder();</div><div class="line">&#125;</div><div class="line"><span class="comment">//filters.put(o.getClass().getName(), order);</span></div><div class="line">map.put(o.toString(), order);</div><div class="line"><span class="keyword">return</span> map;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="2-2-路由过滤器工厂列表"><a href="#2-2-路由过滤器工厂列表" class="headerlink" title="2.2 路由过滤器工厂列表"></a>2.2 路由过滤器工厂列表</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"/routefilters"</span>)</div><div class="line"><span class="keyword">public</span> Mono&lt;HashMap&lt;String, Object&gt;&gt; routefilers() &#123;</div><div class="line"><span class="keyword">return</span> getNamesToOrders(<span class="keyword">this</span>.gatewayFilters);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3-路由-HTTP-API"><a href="#3-路由-HTTP-API" class="headerlink" title="3. 路由 HTTP API"></a>3. 路由 HTTP API</h2><h2 id="2-1-路由列表"><a href="#2-1-路由列表" class="headerlink" title="2.1 路由列表"></a>2.1 路由列表</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"/routes"</span>)</div><div class="line"><span class="keyword">public</span> Mono&lt;Map&lt;String, List&gt;&gt; routes() &#123;</div><div class="line">Mono&lt;List&lt;RouteDefinition&gt;&gt; routeDefs = <span class="keyword">this</span>.routeDefinitionLocator.getRouteDefinitions().collectList();</div><div class="line">Mono&lt;List&lt;Route&gt;&gt; routes = <span class="keyword">this</span>.routeLocator.getRoutes().collectList();</div><div class="line"><span class="keyword">return</span> Mono.zip(routeDefs, routes).map(tuple -&gt; &#123;</div><div class="line">Map&lt;String, List&gt; allRoutes = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">allRoutes.put(<span class="string">"routeDefinitions"</span>, tuple.getT1());</div><div class="line">allRoutes.put(<span class="string">"routes"</span>, tuple.getT2());</div><div class="line"><span class="keyword">return</span> allRoutes;</div><div class="line">&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="2-2-单个路由信息"><a href="#2-2-单个路由信息" class="headerlink" title="2.2 单个路由信息"></a>2.2 单个路由信息</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"/routes/&#123;id&#125;"</span>)</div><div class="line"><span class="keyword">public</span> Mono&lt;ResponseEntity&lt;RouteDefinition&gt;&gt; route(<span class="meta">@PathVariable</span> String id) &#123;</div><div class="line"><span class="comment">//<span class="doctag">TODO:</span> missing RouteLocator</span></div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.routeDefinitionLocator.getRouteDefinitions()</div><div class="line">.filter(route -&gt; route.getId().equals(id))</div><div class="line">.singleOrEmpty()</div><div class="line">.map(route -&gt; ResponseEntity.ok(route))</div><div class="line">.switchIfEmpty(Mono.just(ResponseEntity.notFound().build()));</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>从 <code>TODO: missing RouteLocator</code> ，我们可以看到，目前不支持从 RouteLocator 获取 Route ，只返回 RouteDefinition 。等待未来的版本支持。</li></ul><h2 id="2-3-单个路由的过滤器"><a href="#2-3-单个路由的过滤器" class="headerlink" title="2.3 单个路由的过滤器"></a>2.3 单个路由的过滤器</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"/routes/&#123;id&#125;/combinedfilters"</span>)</div><div class="line"><span class="keyword">public</span> Mono&lt;HashMap&lt;String, Object&gt;&gt; combinedfilters(<span class="meta">@PathVariable</span> String id) &#123;</div><div class="line"><span class="comment">//<span class="doctag">TODO:</span> missing global filters</span></div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.routeLocator.getRoutes()</div><div class="line">.filter(route -&gt; route.getId().equals(id))</div><div class="line">.reduce(<span class="keyword">new</span> HashMap&lt;&gt;(), <span class="keyword">this</span>::putItem);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>从 <code>TODO: missing global filters</code> ，我们可以看到，目前返回的过滤器不包括 GlobalFilter ，可以调用 <code>/globalfilters</code> 查看。等待未来的版本支持。</li></ul><h2 id="2-4-添加-修改单个路由"><a href="#2-4-添加-修改单个路由" class="headerlink" title="2.4 添加/修改单个路由"></a>2.4 添加/修改单个路由</h2><p>在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/route-definition-locator-repository/?self">《Spring-Cloud-Gateway 源码解析 —— 路由（1.3）之 RouteDefinitionRepository 存储器》「5. GatewayWebfluxEndpoint」</a> 有详细解析。</p><h2 id="2-5-删除单个路由"><a href="#2-5-删除单个路由" class="headerlink" title="2.5 删除单个路由"></a>2.5 删除单个路由</h2><p>在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/route-definition-locator-repository/?self">《Spring-Cloud-Gateway 源码解析 —— 路由（1.3）之 RouteDefinitionRepository 存储器》「5. GatewayWebfluxEndpoint」</a> 有详细解析。</p><h2 id="2-6-刷新路由缓存"><a href="#2-6-刷新路由缓存" class="headerlink" title="2.6 刷新路由缓存"></a>2.6 刷新路由缓存</h2><p>在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/route-locator-intro/?self">《Spring-Cloud-Gateway 源码解析 —— 路由（2.1）之 RouteLocator 一览》「5. CachingRouteLocator」</a> 有详细解析。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>水更一篇，哈哈哈。</p><p><img src="http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_04_15/01.png" alt=""></p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-api/&quot;&gt;http://www.iocoder.cn/Spring-Cloud-Gateway/manager-http-a
      
    
    </summary>
    
      <category term="Spring-Cloud-Gateway" scheme="http://www.iocoder.cn/categories/Spring-Cloud-Gateway/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.10) 之 RequestRateLimiterGatewayFilterFactory 请求限流</title>
    <link href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-request-rate-limiter/"/>
    <id>http://www.iocoder.cn/Spring-Cloud-Gateway/filter-request-rate-limiter/</id>
    <published>2020-04-09T16:00:00.000Z</published>
    <updated>2017-12-01T16:41:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-request-rate-limiter/">http://www.iocoder.cn/Spring-Cloud-Gateway/filter-request-rate-limiter/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Spring-Cloud-Gateway 2.0.X M4</strong>  </p><ul><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/">2. 环境搭建</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/">3. RequestRateLimiterGatewayFilterFactory</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/">4. KeyResolver</a><ul><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/">4.1 PrincipalNameKeyResolver</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/">4.2 自定义 KeyResolver</a></li></ul></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/">5. RateLimiter</a><ul><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/">5.1 GatewayRedisAutoConfiguration</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/">5.2 RedisRateLimiter</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/">5.3 Redis Lua 脚本</a></li></ul></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>RequestRateLimiterGatewayFilterFactory 的代码实现</strong>。</p><p>在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-factory/?self">《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.2) 之 GatewayFilterFactory 过滤器工厂》</a> 一文中，我们看到 Spring Cloud Gateway 提供了多种 GatewayFilterFactory 的实现，而 RequestRateLimiterGatewayFilterFactory 也是其中的一种。</p><p>通过 RequestRateLimiterGatewayFilterFactory ，可以创建 RequestRateLimiterGatewayFilter ( 实际是内部匿名类，为了表述方便，下面继续这么称呼 ) 。</p><p>RequestRateLimiterGatewayFilter 使用 <strong>Redis + Lua</strong> 实现分布式限流。而限流的粒度，例如 URL / 用户 / IP 等，通过 <code>org.springframework.cloud.gateway.filter.ratelimit.KeyResolver</code> <strong>实现类</strong>决定，在 <a href="#">「4. KeyResolver」</a> 详细解析。</p><p>这里，笔者一本正经的推荐下自己分享的 <a href="http://www.iocoder.cn/Eureka/rate-limiter/?self">《Eureka 源码解析 —— 基于令牌桶算法的 RateLimiter》</a> ，简直业界良心。</p><hr><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2. 环境搭建"></a>2. 环境搭建</h1><p>第一步，以 <code>spring-cloud-gateway-sample</code> 项目为基础，在 <code>pom.xml</code> 文件添加依赖库。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis-reactive&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure><p>第二步，在 <code>application.yml</code> 配置<strong>一个</strong> RouteDefinition 。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  cloud:</span></div><div class="line"><span class="attr">    gateway:</span></div><div class="line"><span class="attr">      routes:</span></div><div class="line">      <span class="comment"># =====================================</span></div><div class="line"><span class="attr">      - id:</span> <span class="string">default_path_to_httpbin</span></div><div class="line"><span class="attr">        uri:</span> <span class="attr">http://127.0.0.1:8081</span></div><div class="line"><span class="attr">        order:</span> <span class="number">10000</span></div><div class="line"><span class="attr">        predicates:</span></div><div class="line"><span class="bullet">        -</span> <span class="string">Path=/**</span></div><div class="line"><span class="attr">        filters:</span></div><div class="line"><span class="bullet">        -</span> <span class="string">RequestRateLimiter=10,</span> <span class="number">20</span><span class="string">,</span> <span class="comment">#&#123;@principalNameKeyResolver&#125;</span></div></pre></td></tr></table></figure><ul><li><code>- RequestRateLimiter=10, 20, #{@principalNameKeyResolver}</code> ，配置 RequestRateLimiterGatewayFilterFactory 。 <ul><li>默认情况下，基于<strong>令牌桶算法</strong>实现限流。 </li><li>第一个参数，<code>burstCapacity</code> ，令牌桶上限 。</li><li>第二个参数，<code>replenishRate</code> ，令牌桶填充平均速率，单位：秒。</li><li>第三个参数，<code>keyResolver</code> ，限流<strong>键</strong>解析器 Bean 对象名字，根据 <code>#{@beanName}</code> ，使用 SpEL 表达式，从 Spring 容器中获取 Bean 对象，详细参见 <a href="https://github.com/spring-cloud/spring-cloud-gateway/blob/83496b78944269050373bb92bb2181e1b7c070e8/spring-cloud-gateway-core/src/main/java/org/springframework/cloud/gateway/route/RouteDefinitionRouteLocator.java#L182" rel="external nofollow noopener noreferrer" target="_blank"><code>RouteDefinitionRouteLocator#getTuple(ArgumentHints, Map&lt;String, String&gt;, SpelExpressionParser, BeanFactory)</code></a> 处的代码。另外，这里有一个 BUG ：在 YAML 里，<code>#</code> 代表注释，所以第三个参数无法正确被读取，需要等待官方修复。如果比较着急使用，可以考虑将此处的 <code>#</code> 修改成 <code>\#</code> ，并修改部分相关代码以解决该 BUG 。</li></ul></li></ul><p>第三步，配置完成，启动 <code>spring-cloud-gateway-sample</code> 项目。</p><blockquote><p><strong>友情提示</strong>，RequestRateLimiterGatewayFilter 使用了 RedisTemplate ，生产环境请配置。</p></blockquote><h1 id="3-RequestRateLimiterGatewayFilterFactory"><a href="#3-RequestRateLimiterGatewayFilterFactory" class="headerlink" title="3. RequestRateLimiterGatewayFilterFactory"></a>3. RequestRateLimiterGatewayFilterFactory</h1><p><code>org.springframework.cloud.gateway.filter.factory.RequestRateLimiterGatewayFilterFactory</code> ，请求限流网关过滤器<strong>工厂</strong>类。代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestRateLimiterGatewayFilterFactory</span> <span class="keyword">implements</span> <span class="title">GatewayFilterFactory</span> </span>&#123;</div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>: <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_RESOLVER_KEY = <span class="string">"keyResolver"</span>;</div><div class="line"> <span class="number">4</span>: </div><div class="line"> <span class="number">5</span>: <span class="keyword">private</span> <span class="keyword">final</span> RateLimiter rateLimiter;</div><div class="line"> <span class="number">6</span>: <span class="keyword">private</span> <span class="keyword">final</span> KeyResolver defaultKeyResolver;</div><div class="line"> <span class="number">7</span>: </div><div class="line"> <span class="number">8</span>: <span class="function"><span class="keyword">public</span> <span class="title">RequestRateLimiterGatewayFilterFactory</span><span class="params">(RateLimiter rateLimiter,</span></span></div><div class="line"><span class="function"><span class="params"> <span class="number">9</span>: KeyResolver defaultKeyResolver)</span> </span>&#123;</div><div class="line"><span class="number">10</span>: <span class="keyword">this</span>.rateLimiter = rateLimiter;</div><div class="line"><span class="number">11</span>: <span class="keyword">this</span>.defaultKeyResolver = defaultKeyResolver;</div><div class="line"><span class="number">12</span>: &#125;</div><div class="line"><span class="number">13</span>: </div><div class="line"><span class="number">14</span>: <span class="meta">@Override</span></div><div class="line"><span class="number">15</span>: <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">argNames</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">16</span>:         <span class="keyword">return</span> Arrays.asList(</div><div class="line"><span class="number">17</span>:                 RedisRateLimiter.REPLENISH_RATE_KEY,</div><div class="line"><span class="number">18</span>:                 RedisRateLimiter.BURST_CAPACITY_KEY,</div><div class="line"><span class="number">19</span>:                 KEY_RESOLVER_KEY</div><div class="line"><span class="number">20</span>:         );</div><div class="line"><span class="number">21</span>: &#125;</div><div class="line"><span class="number">22</span>: </div><div class="line"><span class="number">23</span>: <span class="meta">@Override</span></div><div class="line"><span class="number">24</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateArgs</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">25</span>:  <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"><span class="number">26</span>: &#125;</div><div class="line"><span class="number">27</span>: </div><div class="line"><span class="number">28</span>: <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="number">29</span>: <span class="meta">@Override</span></div><div class="line"><span class="number">30</span>: <span class="function"><span class="keyword">public</span> GatewayFilter <span class="title">apply</span><span class="params">(Tuple args)</span> </span>&#123;</div><div class="line"><span class="number">31</span>:         validateMin(<span class="number">2</span>, args);</div><div class="line"><span class="number">32</span>: </div><div class="line"><span class="number">33</span>:         <span class="comment">// 获得 KeyResolver</span></div><div class="line"><span class="number">34</span>: KeyResolver keyResolver;</div><div class="line"><span class="number">35</span>: <span class="keyword">if</span> (args.hasFieldName(KEY_RESOLVER_KEY)) &#123;</div><div class="line"><span class="number">36</span>: keyResolver = args.getValue(KEY_RESOLVER_KEY, KeyResolver.class);</div><div class="line"><span class="number">37</span>: &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">38</span>: keyResolver = defaultKeyResolver;</div><div class="line"><span class="number">39</span>: &#125;</div><div class="line"><span class="number">40</span>: </div><div class="line"><span class="number">41</span>: <span class="keyword">return</span> (exchange, chain) -&gt; keyResolver.resolve(exchange).flatMap(key -&gt;</div><div class="line"><span class="number">42</span>:             <span class="comment">// <span class="doctag">TODO:</span> if key is empty?</span></div><div class="line"><span class="number">43</span>:             rateLimiter.isAllowed(key, args).flatMap(response -&gt; &#123;</div><div class="line"><span class="number">44</span>:                 <span class="comment">// <span class="doctag">TODO:</span> set some headers for rate, tokens left</span></div><div class="line"><span class="number">45</span>: </div><div class="line"><span class="number">46</span>:                 <span class="comment">// 允许访问</span></div><div class="line"><span class="number">47</span>:                 <span class="keyword">if</span> (response.isAllowed()) &#123;</div><div class="line"><span class="number">48</span>:                     <span class="keyword">return</span> chain.filter(exchange);</div><div class="line"><span class="number">49</span>:                 &#125;</div><div class="line"><span class="number">50</span>: </div><div class="line"><span class="number">51</span>:                 <span class="comment">// 被限流，不允许访问</span></div><div class="line"><span class="number">52</span>:                 exchange.getResponse().setStatusCode(HttpStatus.TOO_MANY_REQUESTS);</div><div class="line"><span class="number">53</span>:                 <span class="keyword">return</span> exchange.getResponse().setComplete();</div><div class="line"><span class="number">54</span>:             &#125;));</div><div class="line"><span class="number">55</span>: &#125;</div><div class="line"><span class="number">56</span>: </div><div class="line"><span class="number">57</span>: &#125;</div></pre></td></tr></table></figure><ul><li><code>rateLimiter</code> 属性，限流器。默认情况下，使用 RedisRateLimiter 。</li><li><code>defaultKeyResolver</code> 属性，默认限流<strong>键</strong>解析器。默认情况下，使用 PrincipalNameKeyResolver 。</li><li><code>#argNames()</code> 方法，定义了 Tuple 参数的 Key 为 <code>replenishRate</code> / <code>burstCapacity</code> / <code>keyResolver</code> 。</li><li><code>#validateArgs()</code> 方法，定义在 <a href="https://github.com/spring-cloud/spring-cloud-gateway/blob/83496b78944269050373bb92bb2181e1b7c070e8/spring-cloud-gateway-core/src/main/java/org/springframework/cloud/gateway/route/RouteDefinitionRouteLocator.java#L182" rel="external nofollow noopener noreferrer" target="_blank"><code>RouteDefinitionRouteLocator#getTuple(ArgumentHints, Map&lt;String, String&gt;, SpelExpressionParser, BeanFactory)</code></a> 无需校验 Tuple 结果。因为 <code>keyResolver</code> 非必填项，在 <code>#apply()</code> 方法，创建 RequestRateLimiterGatewayFilter 时<strong>校验</strong>。</li><li><code>#apply()</code> 方法，创建 RequestRateLimiterGatewayFilter 对象。</li><li>第 31 行 ：校验 Tuple 参数至少有两个元素，即 <code>replenishRate</code> 和 <code>burstCapacity</code> 。而 <code>keyResolver</code> 是<strong>选填</strong>，为空时，使用默认值 <code>defaultKeyResolver</code> 。</li><li>第 34 至 39 行 ：获得 <code>keyResolver</code> 。通过它，获得请求的限流<strong>键</strong>，例如URL / 用户 / IP 等。</li><li>——— 第 41 至 54 行 ：<strong>创建 RequestRateLimiterGatewayFilter 对象并返回</strong>。</li><li>第 41 行 ：调用 <code>KeyResolver#resolve(ServerWebExchange)</code> 方法，获得请求的限流<strong>键</strong>。<ul><li><strong>注意下</strong>，这里未处理限流<strong>键</strong>为空的情况( <code>TODO: if key is empty?</code> )。所以，当限流<strong>键</strong>为空时，过滤器链不会继续向下执行，也就是说，不会请求后端 Http / Websocket 服务，并且最终返回客户端 <strong>200</strong> 状态码，内容为<strong>空</strong>。</li></ul></li><li>第 43 至 54 行 ：调用 <code>RateLimiter#isAllowed(ServerWebExchange, Tuple)</code> 方法，判断是否被限流。<ul><li>第 47 至 49 行 ：<strong>未</strong>被限流，允许访问，提交过滤器链继续过滤。</li><li>第 52 至 53 行 ：被限流， <strong>不</strong>允许访问，设置响应 429 状态码，并回写客户端<strong>响应</strong>( <code>exchange.getResponse().setComplete()</code> ) 。</li></ul></li></ul><h1 id="4-KeyResolver"><a href="#4-KeyResolver" class="headerlink" title="4. KeyResolver"></a>4. KeyResolver</h1><p><code>org.springframework.cloud.gateway.filter.ratelimit.KeyResolver</code> ，请求<strong>键</strong>解析器<strong>接口</strong>。代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">KeyResolver</span> </span>&#123;</div><div class="line"><span class="function">Mono&lt;String&gt; <span class="title">resolve</span><span class="params">(ServerWebExchange exchange)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>KeyResolver#resolve(ServerWebExchange)</code> 方法，获得请求的限流<strong>键</strong>。</li></ul><p>通过实现 KeyResolver 接口，实现获得不同的请求的限流<strong>键</strong>，例如URL / 用户 / IP 等。</p><p>目前版本，Spring Cloud Gateway 提供的 KeyResolver 实现类只有 PrincipalNameKeyResolver 。据官方说法，在未来的里程碑版本中，将会有一些 KeyResolver 具体实现类。</p><h2 id="4-1-PrincipalNameKeyResolver"><a href="#4-1-PrincipalNameKeyResolver" class="headerlink" title="4.1 PrincipalNameKeyResolver"></a>4.1 PrincipalNameKeyResolver</h2><p><code>org.springframework.cloud.gateway.filter.ratelimit.PrincipalNameKeyResolver</code> ，使用请求认证的 <code>java.security.Principal</code> 作为限流<strong>键</strong>。代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrincipalNameKeyResolver</span> <span class="keyword">implements</span> <span class="title">KeyResolver</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEAN_NAME = <span class="string">"principalNameKeyResolver"</span>;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Mono&lt;String&gt; <span class="title">resolve</span><span class="params">(ServerWebExchange exchange)</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> exchange.getPrincipal().map(Principal::getName).switchIfEmpty(Mono.empty());</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="4-2-自定义-KeyResolver"><a href="#4-2-自定义-KeyResolver" class="headerlink" title="4.2 自定义 KeyResolver"></a>4.2 自定义 KeyResolver</h2><p>通过实现 KeyResolver 接口，实现自定义 KeyResolver 。下面我们实现一个使用请求 IP 作为限流<strong>键</strong>的 KeyResolver 。</p><p>第一步，创建 RemoteAddrKeyResolver 类，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteAddrKeyResolver</span> <span class="keyword">implements</span> <span class="title">KeyResolver</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEAN_NAME = <span class="string">"remoteAddrKeyResolver"</span>;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Mono&lt;String&gt; <span class="title">resolve</span><span class="params">(ServerWebExchange exchange)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Mono.just(exchange.getRequest().getRemoteAddress().getAddress().getHostAddress());</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>第二步，配置 RemoteAddrKeyResolver Bean 对象，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Bean</span>(name = RemoteAddrKeyResolver.BEAN_NAME)</div><div class="line"><span class="meta">@ConditionalOnBean</span>(RateLimiter.class)</div><div class="line"><span class="function"><span class="keyword">public</span> RemoteAddrKeyResolver <span class="title">remoteAddrKeyResolver</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RemoteAddrKeyResolver();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>第三步，配置 RouteDefinition 路由配置，配置如下 ：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  cloud:</span></div><div class="line"><span class="attr">    gateway:</span></div><div class="line"><span class="attr">      routes:</span></div><div class="line">      <span class="comment"># =====================================</span></div><div class="line"><span class="attr">      - id:</span> <span class="string">default_path_to_httpbin</span></div><div class="line"><span class="attr">        uri:</span> <span class="attr">http://127.0.0.1:8081</span></div><div class="line"><span class="attr">        order:</span> <span class="number">10000</span></div><div class="line"><span class="attr">        predicates:</span></div><div class="line"><span class="bullet">        -</span> <span class="string">Path=/**</span></div><div class="line"><span class="attr">        filters:</span></div><div class="line"><span class="bullet">        -</span> <span class="string">RequestRateLimiter=10,</span> <span class="number">20</span><span class="string">,</span> <span class="comment">#&#123;@remoteAddrKeyResolver&#125;</span></div></pre></td></tr></table></figure><p>第四步，<strong>大功告成</strong>，启动 Spring Cloud Gateway 即可。</p><p>另外，推荐 <a href="https://mp.weixin.qq.com/s?__biz=MzI4ODQ3NjE2OA==&amp;mid=2247483811&amp;idx=1&amp;sn=16fe7e25a90635e93c60048ebe8b40a2&amp;chksm=ec3c9cc4db4b15d2937fb8b2ef571c941b2bb9fefcf5ed8232e3699b4868392022a62b963699&amp;mpshare=1&amp;scene=1&amp;srcid=1201O46Ma9D5ln5TuxHUgziY#rd" rel="external nofollow noopener noreferrer" target="_blank">《周立 —— Spring Cloud限流详解（附源码）》</a>，里面有一些限流维度的分析。</p><h1 id="5-RateLimiter"><a href="#5-RateLimiter" class="headerlink" title="5. RateLimiter"></a>5. RateLimiter</h1><p><code>org.springframework.cloud.gateway.filter.ratelimit.RateLimiter</code> ，限流器<strong>接口</strong>。代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RateLimiter</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function">Mono&lt;Response&gt; <span class="title">isAllowed</span><span class="params">(String id, Tuple args)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>#isAllowed(String id, Tuple args)</code> 方法，判断是否被限流。</li><li><p>Response 类，代码如下 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Response</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 是否允许访问( 未被限流 )</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> allowed;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 令牌桶剩余数量</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> tokensRemaining;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Response</span><span class="params">(<span class="keyword">boolean</span> allowed, <span class="keyword">long</span> tokensRemaining)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.allowed = allowed;</div><div class="line"><span class="keyword">this</span>.tokensRemaining = tokensRemaining;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h2 id="5-1-GatewayRedisAutoConfiguration"><a href="#5-1-GatewayRedisAutoConfiguration" class="headerlink" title="5.1 GatewayRedisAutoConfiguration"></a>5.1 GatewayRedisAutoConfiguration</h2><p><code>org.springframework.cloud.gateway.config.GatewayRedisAutoConfiguration</code> ，Redis 相关配置类，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Configuration</span></div><div class="line"> <span class="number">2</span>: <span class="meta">@AutoConfigureAfter</span>(RedisReactiveAutoConfiguration.class)</div><div class="line"> <span class="number">3</span>: <span class="meta">@AutoConfigureBefore</span>(GatewayAutoConfiguration.class)</div><div class="line"> <span class="number">4</span>: <span class="meta">@ConditionalOnBean</span>(ReactiveRedisTemplate.class)</div><div class="line"> <span class="number">5</span>: <span class="meta">@ConditionalOnClass</span>(&#123;RedisTemplate.class, DispatcherHandler.class&#125;)</div><div class="line"> <span class="number">6</span>: <span class="class"><span class="keyword">class</span> <span class="title">GatewayRedisAutoConfiguration</span> </span>&#123;</div><div class="line"> <span class="number">7</span>: </div><div class="line"> <span class="number">8</span>: <span class="meta">@Bean</span></div><div class="line"> <span class="number">9</span>: <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="number">10</span>: <span class="function"><span class="keyword">public</span> RedisScript <span class="title">redisRequestRateLimiterScript</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">11</span>: DefaultRedisScript redisScript = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;();</div><div class="line"><span class="number">12</span>: redisScript.setScriptSource(<span class="keyword">new</span> ResourceScriptSource(<span class="keyword">new</span> ClassPathResource(<span class="string">"META-INF/scripts/request_rate_limiter.lua"</span>)));</div><div class="line"><span class="number">13</span>: redisScript.setResultType(List.class);</div><div class="line"><span class="number">14</span>: <span class="keyword">return</span> redisScript;</div><div class="line"><span class="number">15</span>: &#125;</div><div class="line"><span class="number">16</span>: </div><div class="line"><span class="number">17</span>: <span class="meta">@Bean</span></div><div class="line"><span class="number">18</span>: <span class="comment">//<span class="doctag">TODO:</span> replace with ReactiveStringRedisTemplate in future</span></div><div class="line"><span class="number">19</span>: <span class="function"><span class="keyword">public</span> ReactiveRedisTemplate&lt;String, String&gt; <span class="title">stringReactiveRedisTemplate</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params"><span class="number">20</span>: ReactiveRedisConnectionFactory reactiveRedisConnectionFactory,</span></span></div><div class="line"><span class="function"><span class="params"><span class="number">21</span>: ResourceLoader resourceLoader)</span> </span>&#123;</div><div class="line"><span class="number">22</span>: RedisSerializer&lt;String&gt; serializer = <span class="keyword">new</span> StringRedisSerializer();</div><div class="line"><span class="number">23</span>: RedisSerializationContext&lt;String , String&gt; serializationContext = RedisSerializationContext</div><div class="line"><span class="number">24</span>: .&lt;String, String&gt;newSerializationContext()</div><div class="line"><span class="number">25</span>: .key(serializer)</div><div class="line"><span class="number">26</span>: .value(serializer)</div><div class="line"><span class="number">27</span>: .hashKey(serializer)</div><div class="line"><span class="number">28</span>: .hashValue(serializer)</div><div class="line"><span class="number">29</span>: .build();</div><div class="line"><span class="number">30</span>: <span class="keyword">return</span> <span class="keyword">new</span> ReactiveRedisTemplate&lt;&gt;(reactiveRedisConnectionFactory,</div><div class="line"><span class="number">31</span>: serializationContext);</div><div class="line"><span class="number">32</span>: &#125;</div><div class="line"><span class="number">33</span>: </div><div class="line"><span class="number">34</span>: <span class="meta">@Bean</span></div><div class="line"><span class="number">35</span>: <span class="function"><span class="keyword">public</span> RedisRateLimiter <span class="title">redisRateLimiter</span><span class="params">(ReactiveRedisTemplate&lt;String, String&gt; redisTemplate,</span></span></div><div class="line"><span class="function"><span class="params"><span class="number">36</span>:  @Qualifier(<span class="string">"redisRequestRateLimiterScript"</span>)</span> RedisScript&lt;List&lt;Long&gt;&gt; redisScript) </span>&#123;</div><div class="line"><span class="number">37</span>: <span class="keyword">return</span> <span class="keyword">new</span> RedisRateLimiter(redisTemplate, redisScript);</div><div class="line"><span class="number">38</span>: &#125;</div><div class="line"><span class="number">39</span>: </div><div class="line"><span class="number">40</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 8 至 15 行 ：创建 <code>org.springframework.data.redis.core.script.RedisScript</code> Bean 对象，加载 <code>META-INF/scripts/request_rate_limiter.lua</code> 路径下的 Redis Lua 脚本。该脚本使用 Redis 基于<strong>令牌桶算法</strong>实现限流。在本文 <a href="#">「Redis Lua 脚本」</a> 详细解析。 </li><li>第 17 至 32 行 ：创建 <code>org.springframework.data.redis.core.ReactiveRedisTemplate</code> Bean 对象。</li><li>第 34 至 38 行 ：使用 RedisScript 和 ReactiveRedisTemplate Bean 对象，创建 RedisRateLimiter Bean 对象。</li></ul><h2 id="5-2-RedisRateLimiter"><a href="#5-2-RedisRateLimiter" class="headerlink" title="5.2 RedisRateLimiter"></a>5.2 RedisRateLimiter</h2><p><code>org.springframework.cloud.gateway.filter.ratelimit.RedisRateLimiter</code> ，基于 Redis 的分布式限流器<strong>实现类</strong>。</p><p><strong>构造方法</strong>，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisRateLimiter</span> <span class="keyword">implements</span> <span class="title">RateLimiter</span> </span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REPLENISH_RATE_KEY = <span class="string">"replenishRate"</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BURST_CAPACITY_KEY = <span class="string">"burstCapacity"</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReactiveRedisTemplate&lt;String, String&gt; redisTemplate;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> RedisScript&lt;List&lt;Long&gt;&gt; script;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">RedisRateLimiter</span><span class="params">(ReactiveRedisTemplate&lt;String, String&gt; redisTemplate,</span></span></div><div class="line"><span class="function"><span class="params">RedisScript&lt;List&lt;Long&gt;&gt; script)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.redisTemplate = redisTemplate;</div><div class="line"><span class="keyword">this</span>.script = script;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>redisTemplate</code> 属性，RedisTemplate 。</li><li><code>script</code> 属性，Lua 脚本。</li></ul><hr><p><code>#isAllowed(id, Tuple)</code> ，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> Mono&lt;Response&gt; <span class="title">isAllowed</span><span class="params">(String id, Tuple args)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>: <span class="comment">// How many requests per second do you want a user to be allowed to do?</span></div><div class="line"> <span class="number">3</span>: <span class="keyword">int</span> replenishRate = args.getInt(REPLENISH_RATE_KEY);</div><div class="line"> <span class="number">4</span>: </div><div class="line"> <span class="number">5</span>: <span class="comment">// How much bursting do you want to allow?</span></div><div class="line"> <span class="number">6</span>: <span class="keyword">int</span> burstCapacity;</div><div class="line"> <span class="number">7</span>: <span class="keyword">if</span> (args.hasFieldName(BURST_CAPACITY_KEY)) &#123;</div><div class="line"> <span class="number">8</span>: burstCapacity = args.getInt(BURST_CAPACITY_KEY);</div><div class="line"> <span class="number">9</span>: &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">10</span>: burstCapacity = <span class="number">0</span>;</div><div class="line"><span class="number">11</span>: &#125;</div><div class="line"><span class="number">12</span>: </div><div class="line"><span class="number">13</span>: <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">14</span>: <span class="comment">// Make a unique key per user.</span></div><div class="line"><span class="number">15</span>: String prefix = <span class="string">"request_rate_limiter."</span> + id;</div><div class="line"><span class="number">16</span>: </div><div class="line"><span class="number">17</span>: <span class="comment">// You need two Redis keys for Token Bucket.</span></div><div class="line"><span class="number">18</span>: List&lt;String&gt; keys = Arrays.asList(prefix + <span class="string">".tokens"</span>, prefix + <span class="string">".timestamp"</span>);</div><div class="line"><span class="number">19</span>: </div><div class="line"><span class="number">20</span>: <span class="comment">// The arguments to the LUA script. time() returns unixtime in seconds.</span></div><div class="line"><span class="number">21</span>: List&lt;String&gt; scriptArgs = Arrays.asList(replenishRate + <span class="string">""</span>, burstCapacity + <span class="string">""</span>,</div><div class="line"><span class="number">22</span>:  Instant.now().getEpochSecond() + <span class="string">""</span>, <span class="string">"1"</span>);</div><div class="line"><span class="number">23</span>: <span class="comment">// allowed, tokens_left = redis.eval(SCRIPT, keys, args)</span></div><div class="line"><span class="number">24</span>: Flux&lt;List&lt;Long&gt;&gt; flux = <span class="keyword">this</span>.redisTemplate.execute(<span class="keyword">this</span>.script, keys, scriptArgs);</div><div class="line"><span class="number">25</span>: <span class="comment">// .log("redisratelimiter", Level.FINER);</span></div><div class="line"><span class="number">26</span>: <span class="keyword">return</span> flux</div><div class="line"><span class="number">27</span>: <span class="comment">// Throwable =&gt; Flux.just(Arrays.asList(1L, -1L)) 。</span></div><div class="line"><span class="number">28</span>: .onErrorResume(throwable -&gt; Flux.just(Arrays.asList(<span class="number">1L</span>, -<span class="number">1L</span>)))</div><div class="line"><span class="number">29</span>: <span class="comment">// Flux&lt;List&lt;Long&gt;&gt; =&gt; Mono&lt;List&lt;Long&gt;&gt;</span></div><div class="line"><span class="number">30</span>: .reduce(<span class="keyword">new</span> ArrayList&lt;Long&gt;(), (longs, l) -&gt; &#123;</div><div class="line"><span class="number">31</span>: longs.addAll(l);</div><div class="line"><span class="number">32</span>: <span class="keyword">return</span> longs;</div><div class="line"><span class="number">33</span>: &#125;)</div><div class="line"><span class="number">34</span>: <span class="comment">// Mono&lt;List&lt;Long&gt;&gt; =&gt; Mono&lt;Response&gt;</span></div><div class="line"><span class="number">35</span>: .map(results -&gt; &#123;</div><div class="line"><span class="number">36</span>: <span class="keyword">boolean</span> allowed = results.get(<span class="number">0</span>) == <span class="number">1L</span>;</div><div class="line"><span class="number">37</span>: Long tokensLeft = results.get(<span class="number">1</span>);</div><div class="line"><span class="number">38</span>: </div><div class="line"><span class="number">39</span>: Response response = <span class="keyword">new</span> Response(allowed, tokensLeft);</div><div class="line"><span class="number">40</span>: </div><div class="line"><span class="number">41</span>: <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</div><div class="line"><span class="number">42</span>: log.debug(<span class="string">"response: "</span> + response);</div><div class="line"><span class="number">43</span>: &#125;</div><div class="line"><span class="number">44</span>: <span class="keyword">return</span> response;</div><div class="line"><span class="number">45</span>: &#125;);</div><div class="line"><span class="number">46</span>: &#125;</div><div class="line"><span class="number">47</span>: <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"><span class="number">48</span>: <span class="comment">/*</span></div><div class="line"><span class="comment">49:  * We don't want a hard dependency on Redis to allow traffic. Make sure to set</span></div><div class="line"><span class="comment">50:  * an alert so you know if this is happening too much. Stripe's observed</span></div><div class="line"><span class="comment">51:  * failure rate is 0.01%.</span></div><div class="line"><span class="comment">52:  */</span></div><div class="line"><span class="number">53</span>: log.error(<span class="string">"Error determining if user allowed from redis"</span>, e);</div><div class="line"><span class="number">54</span>: &#125;</div><div class="line"><span class="number">55</span>: <span class="keyword">return</span> Mono.just(<span class="keyword">new</span> Response(<span class="keyword">true</span>, -<span class="number">1</span>));</div><div class="line"><span class="number">56</span>: &#125;</div></pre></td></tr></table></figure><ul><li><code>id</code> 方法参数，令牌桶编号。一个令牌桶编号对应令牌桶。<ul><li>在本文场景中为请求限流<strong>键</strong>。</li></ul></li><li>第 3 行 ：获得 <code>burstCapacity</code> 令牌桶上限。</li><li>第 5 至 11 行 ：获得 <code>replenishRate</code> ，令牌桶填充平均速率，单位：秒。</li><li>第 15 行 ：获得令牌桶前缀，<code>request_rate_limiter.${id}</code> 。</li><li>第 18 行 ：获得令牌桶键数组 ：<ul><li><code>request_rate_limiter.${id}.tokens</code> ：令牌桶<strong>剩余</strong>令牌数。</li><li><code>request_rate_limiter.${id}.timestamp</code> ：令牌桶<strong>最后</strong>填充令牌时间，单位：秒。</li></ul></li><li><p>第 21 至 22 行 ：获得 Lua 脚本参数 ：</p><ul><li>第一个参数 ：<code>replenishRate</code> 。</li><li>第二个参数 ：<code>burstCapacity</code> 。</li><li><p>第三个参数 ：得到从 <code>1970-01-01 00:00:00</code> 开始的秒数。<strong>为什么在 Java 代码里获取，而不使用 Lua 在 Reids 里获取</strong>？</p><blockquote><p>FROM <a href="https://union-click.jd.com/jdc?d=pT3LH8" rel="external nofollow noopener noreferrer" target="_blank">《亿级流量网站架构核心技术》</a><br>因为 Redis 的限制（ Lua中有写操作不能使用带随机性质的读操作，如TIME ）不能在 Redis Lua中 使用 TIME 获取时间戳，因此只好从应用获取然后传入，在某些极端情况下（机器时钟不准的情况下），限流会存在一些小问题。</p><ul><li>涛哥这本书非常不错，推荐购买。</li></ul></blockquote></li><li><p>第四个参数 ：消耗令牌数量，默认 1 。</p></li></ul></li><li><p>第 24 行 ：调用 <code>ReactiveRedisTemplate#execute(RedisScript&lt;T&gt;, List&lt;K&gt;, List&lt;?&gt;)</code> 方法，执行 Redis Lua 脚本，获取令牌。返回结果为 <code>[是否获取令牌成功, 剩余令牌数]</code> ，其中，<code>1</code> 代表获取令牌<strong>成功</strong>，<code>0</code> 代表令牌获取<strong>失败</strong>。</p></li><li><p>第 25 行 ：当 Redis Lua 脚本过程中发生<strong>异常</strong>，忽略异常，返回 <code>Flux.just(Arrays.asList(1L, -1L))</code> ，即认为<strong>获取令牌成功</strong>。为什么？在 Redis 发生故障时，我们不希望限流器对 Reids 是<strong>强依赖</strong>，并且 Redis 发生故障的概率本身就很低。</p><blockquote><p>We don’t want a hard dependency on Redis to allow traffic.<br>Make sure to set an alert so you know if this is happening too much. Stripe’s observed failure rate is 0.01%.</p></blockquote></li><li><p>第 30 至 33 行 ：调用 <code>Flux#reduce(A, BiFunction&lt;A, ? super T, A&gt;)</code> 方法，将 <code>Flux&lt;List&lt;Long&gt;&gt;</code> 转换成 <code>Mono&lt;List&lt;Long&gt;&gt;</code> 。因为 <code>ReactiveRedisTemplate#execute(RedisScript&lt;T&gt;, List&lt;K&gt;, List&lt;?&gt;)</code> 方法的执行结果为 Flux ( 多次 )，实际在当前场景里，自行 Redis Lua 脚本只会返回<strong>一次</strong>数组，所以转换成 Mono (一次)。</p></li><li>第 35 至 45 行 ：调用 <code>Mono#map(Function&lt;? super T, ? extends R&gt;)</code> 方法，将 <code>Mono&lt;List&lt;Long&gt;&gt;</code> =&gt; <code>Mono&lt;Response&gt;</code> 。</li><li>第 47 至 55 行 ：当【第 15 至 24 行】代码部分执行发生异常时，例如 Redis 挂了，返回 <code>Flux.just(Arrays.asList(1L, -1L))</code> ，即认为<strong>获取令牌成功</strong>。</li></ul><h2 id="5-3-Redis-Lua-脚本"><a href="#5-3-Redis-Lua-脚本" class="headerlink" title="5.3 Redis Lua 脚本"></a>5.3 Redis Lua 脚本</h2><p><code>META-INF/scripts/request_rate_limiter.lua</code> ，Redis Lua 脚本，实现基于<strong>令牌桶算法</strong>实现限流。代码如下 ：</p><figure class="highlight lua"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">local</span> tokens_key = KEYS[<span class="number">1</span>]</div><div class="line"> <span class="number">2</span>: <span class="keyword">local</span> timestamp_key = KEYS[<span class="number">2</span>]</div><div class="line"> <span class="number">3</span>: </div><div class="line"> <span class="number">4</span>: <span class="keyword">local</span> rate = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</div><div class="line"> <span class="number">5</span>: <span class="keyword">local</span> capacity = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])</div><div class="line"> <span class="number">6</span>: <span class="keyword">local</span> now = <span class="built_in">tonumber</span>(ARGV[<span class="number">3</span>])</div><div class="line"> <span class="number">7</span>: <span class="keyword">local</span> requested = <span class="built_in">tonumber</span>(ARGV[<span class="number">4</span>])</div><div class="line"> <span class="number">8</span>: </div><div class="line"> <span class="number">9</span>: <span class="keyword">local</span> fill_time = capacity/rate</div><div class="line"><span class="number">10</span>: <span class="keyword">local</span> ttl = <span class="built_in">math</span>.<span class="built_in">floor</span>(fill_time*<span class="number">2</span>)</div><div class="line"><span class="number">11</span>: </div><div class="line"><span class="number">12</span>: <span class="keyword">local</span> last_tokens = <span class="built_in">tonumber</span>(redis.call(<span class="string">"get"</span>, tokens_key))</div><div class="line"><span class="number">13</span>: <span class="keyword">if</span> last_tokens == <span class="literal">nil</span> <span class="keyword">then</span></div><div class="line"><span class="number">14</span>:   last_tokens = capacity</div><div class="line"><span class="number">15</span>: <span class="keyword">end</span></div><div class="line"><span class="number">16</span>: </div><div class="line"><span class="number">17</span>: <span class="keyword">local</span> last_refreshed = <span class="built_in">tonumber</span>(redis.call(<span class="string">"get"</span>, timestamp_key))</div><div class="line"><span class="number">18</span>: <span class="keyword">if</span> last_refreshed == <span class="literal">nil</span> <span class="keyword">then</span></div><div class="line"><span class="number">19</span>:   last_refreshed = <span class="number">0</span></div><div class="line"><span class="number">20</span>: <span class="keyword">end</span></div><div class="line"><span class="number">21</span>: </div><div class="line"><span class="number">22</span>: <span class="keyword">local</span> delta = <span class="built_in">math</span>.<span class="built_in">max</span>(<span class="number">0</span>, now-last_refreshed)</div><div class="line"><span class="number">23</span>: <span class="keyword">local</span> filled_tokens = <span class="built_in">math</span>.<span class="built_in">min</span>(capacity, last_tokens+(delta*rate))</div><div class="line"><span class="number">24</span>: <span class="keyword">local</span> allowed = filled_tokens &gt;= requested</div><div class="line"><span class="number">25</span>: <span class="keyword">local</span> new_tokens = filled_tokens</div><div class="line"><span class="number">26</span>: <span class="keyword">local</span> allowed_num = <span class="number">0</span></div><div class="line"><span class="number">27</span>: <span class="keyword">if</span> allowed <span class="keyword">then</span></div><div class="line"><span class="number">28</span>:   new_tokens = filled_tokens - requested</div><div class="line"><span class="number">29</span>:   allowed_num = <span class="number">1</span></div><div class="line"><span class="number">30</span>: <span class="keyword">end</span></div><div class="line"><span class="number">31</span>: </div><div class="line"><span class="number">32</span>: redis.call(<span class="string">"setex"</span>, tokens_key, ttl, new_tokens)</div><div class="line"><span class="number">33</span>: redis.call(<span class="string">"setex"</span>, timestamp_key, ttl, now)</div><div class="line"><span class="number">34</span>: </div><div class="line"><span class="number">35</span>: <span class="keyword">return</span> &#123; allowed_num, new_tokens &#125;</div></pre></td></tr></table></figure><ul><li>第 1 至 2 行 ：KEYS 方法参数 ：<ul><li>第一个参数 ：<code>request_rate_limiter.${id}.tokens</code> ，令牌桶<strong>剩余</strong>令牌数。</li><li>第二个参数 ：<code>request_rate_limiter.${id}.timestamp</code> ，令牌桶<strong>最后</strong>填充令牌时间，单位：秒。</li></ul></li><li><p>第 4 至 7 行 ：ARGV 方法参数 ：</p><ul><li>第一个参数 ：<code>replenishRate</code> 。</li><li>第二个参数 ：<code>burstCapacity</code> 。</li><li>第三个参数 ：得到从 <code>1970-01-01 00:00:00</code> 开始的秒数。</li><li>第四个参数 ：消耗令牌数量，默认 1 。</li></ul></li><li><p>第 9 行 ：计算令牌桶填充<strong>满</strong>令牌需要多久时间，单位：秒。</p></li><li>第 10 行 ：计算 <code>request_rate_limiter.${id}.tokens</code> / <code>request_rate_limiter.${id}.timestamp</code> 的 <strong>ttl</strong> 。<code>* 2</code> 保证时间充足。</li><li>第 12 至 20 行 ：调用 <code>get</code> 命令，获得令牌桶<strong>剩余</strong>令牌数( <code>last_tokens</code> ) ，令牌桶<strong>最后</strong>填充令牌时间(<code>last_refreshed</code>) 。</li><li>第 22 至 23 行 ：填充令牌，计算<strong>新</strong>的令牌桶<strong>剩余</strong>令牌数( <code>filled_tokens</code> )。填充不超过令牌桶令牌<strong>上限</strong>。</li><li><p>第 24 至 30 行 ：获取令牌是否成功。</p><ul><li>若<strong>成功</strong>，令牌桶<strong>剩余</strong>令牌数(<code>new_tokens</code>) <strong>减</strong>消耗令牌数( <code>requested</code> )，并设置获取成功( <code>allowed_num = 1</code> ) 。</li><li>若<strong>失败</strong>，设置获取失败( <code>allowed_num = 0</code> ) 。</li></ul></li><li><p>第 32 至 33 行 ：设置令牌桶<strong>剩余</strong>令牌数( <code>new_tokens</code> ) ，令牌桶<strong>最后</strong>填充令牌时间(<code>now</code>) 。</p></li><li>第 35 行 ：返回数组结果，<code>[是否获取令牌成功, 剩余令牌数]</code> 。</li></ul><p><strong>Redis Lua 脚本不会有并发问题么</strong>？</p><blockquote><p>FROM <a href="https://union-click.jd.com/jdc?d=pT3LH8" rel="external nofollow noopener noreferrer" target="_blank">《亿级流量网站架构核心技术》</a><br>因 Redis 是单线程模型，因此是线程安全的。</p></blockquote><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>哇哈哈，过滤器全部完成。恩，当然后面需要在考虑一下，例如认证过滤器等等。</p><p><img src="http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_04_10/01.png" alt=""></p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Spring-Cloud-Gateway/filter-request-rate-limiter/&quot;&gt;http://www.iocoder.cn/Spring-Cloud-Gateway/fil
      
    
    </summary>
    
      <category term="Spring-Cloud-Gateway" scheme="http://www.iocoder.cn/categories/Spring-Cloud-Gateway/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.9) 之 HystrixGatewayFilterFactory 熔断</title>
    <link href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/"/>
    <id>http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/</id>
    <published>2020-04-04T16:00:00.000Z</published>
    <updated>2017-12-01T16:41:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/">http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Spring-Cloud-Gateway 2.0.X M4</strong>  </p><ul><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/">2. 环境搭建</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/">3. HystrixGatewayFilterFactory</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/">4. 注意事项</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>HystrixGatewayFilterFactory 的代码实现</strong>。</p><p>在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-factory/?self">《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.2) 之 GatewayFilterFactory 过滤器工厂》</a> 一文中，我们看到 Spring Cloud Gateway 提供了多种 GatewayFilterFactory 的实现，而 HystrixGatewayFilterFactory 也是其中的一种。</p><p>通过 HystrixGatewayFilterFactory ，可以创建 HystrixGatewayFilter ( 实际是内部匿名类，为了表述方便，下面继续这么称呼 ) 。</p><p>HystrixGatewayFilter 使用 <a href="https://github.com/Netflix/Hystrix" rel="external nofollow noopener noreferrer" target="_blank">Hystrix</a> ，实现基于 <strong>Route</strong> 级别的熔断功能。</p><p>这里，笔者一本正经的推荐下自己分享的 <a href="http://www.iocoder.cn/categories/Hystrix/?self">《Hystrix 源码解析系列》</a> ，简直业界良心。</p><hr><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2. 环境搭建"></a>2. 环境搭建</h1><p>第一步，以 <code>spring-cloud-gateway-sample</code> 项目为基础，在 <code>pom.xml</code> 文件添加依赖库。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure><p>第二步，在 <code>application.yml</code> 配置<strong>一个</strong> RouteDefinition 。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  cloud:</span></div><div class="line"><span class="attr">    gateway:</span></div><div class="line"><span class="attr">      routes:</span></div><div class="line">      <span class="comment"># =====================================</span></div><div class="line"><span class="attr">      - id:</span> <span class="string">default_path_to_httpbin</span></div><div class="line"><span class="attr">        uri:</span> <span class="attr">http://127.0.0.1:8081</span></div><div class="line"><span class="attr">        order:</span> <span class="number">10000</span></div><div class="line"><span class="attr">        predicates:</span></div><div class="line"><span class="bullet">        -</span> <span class="string">Path=/**</span></div><div class="line"><span class="attr">        filters:</span></div><div class="line"><span class="bullet">        -</span> <span class="string">Hystrix=myCommandName</span></div></pre></td></tr></table></figure><ul><li><code>- Hystrix=myCommandName</code> ，配置 HystrixGatewayFilterFactory ，并以 <code>myCommandName</code> 为 <strong>Hystrix Command 名字</strong>。</li></ul><p>第三步，配置完成，启动 <code>spring-cloud-gateway-sample</code> 项目。</p><h1 id="3-HystrixGatewayFilterFactory"><a href="#3-HystrixGatewayFilterFactory" class="headerlink" title="3. HystrixGatewayFilterFactory"></a>3. HystrixGatewayFilterFactory</h1><p><code>org.springframework.cloud.gateway.filter.factory.HystrixGatewayFilterFactory</code> ，熔断网关过滤器<strong>工厂</strong>。代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixGatewayFilterFactory</span> <span class="keyword">implements</span> <span class="title">GatewayFilterFactory</span> </span>&#123;</div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">4</span>: <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">argNames</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">5</span>: <span class="keyword">return</span> Arrays.asList(NAME_KEY);</div><div class="line"> <span class="number">6</span>: &#125;</div><div class="line"> <span class="number">7</span>: </div><div class="line"> <span class="number">8</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">9</span>: <span class="function"><span class="keyword">public</span> GatewayFilter <span class="title">apply</span><span class="params">(Tuple args)</span> </span>&#123;</div><div class="line"><span class="number">10</span>: <span class="comment">//<span class="doctag">TODO:</span> if no name is supplied, generate one from command id (useful for default filter)</span></div><div class="line"><span class="number">11</span>: <span class="keyword">final</span> String commandName = args.getString(NAME_KEY);</div><div class="line"><span class="number">12</span>: <span class="keyword">final</span> HystrixCommandGroupKey groupKey = HystrixCommandGroupKey.Factory.asKey(getClass().getSimpleName());</div><div class="line"><span class="number">13</span>: <span class="keyword">final</span> HystrixCommandKey commandKey = HystrixCommandKey.Factory.asKey(commandName);</div><div class="line"><span class="number">14</span>: </div><div class="line"><span class="number">15</span>: <span class="keyword">final</span> HystrixObservableCommand.Setter setter = HystrixObservableCommand.Setter</div><div class="line"><span class="number">16</span>: .withGroupKey(groupKey)</div><div class="line"><span class="number">17</span>: .andCommandKey(commandKey);</div><div class="line"><span class="number">18</span>: </div><div class="line"><span class="number">19</span>: <span class="keyword">return</span> (exchange, chain) -&gt; &#123;</div><div class="line"><span class="number">20</span>: RouteHystrixCommand command = <span class="keyword">new</span> RouteHystrixCommand(setter, exchange, chain);</div><div class="line"><span class="number">21</span>: </div><div class="line"><span class="number">22</span>: <span class="keyword">return</span> Mono.create(s -&gt; &#123;</div><div class="line"><span class="number">23</span>:     <span class="comment">// 使用 Hystrix Command Observable 订阅</span></div><div class="line"><span class="number">24</span>: Subscription sub = command.toObservable().subscribe(s::success, s::error, s::success);</div><div class="line"><span class="number">25</span>: <span class="comment">// Mono 取消时，取消 Hystrix Command Observable 的订阅，结束 Hystrix Command 的执行</span></div><div class="line"><span class="number">26</span>: s.onCancel(sub::unsubscribe);</div><div class="line"><span class="number">27</span>: &#125;).onErrorResume((Function&lt;Throwable, Mono&lt;Void&gt;&gt;) throwable -&gt; &#123;</div><div class="line"><span class="number">28</span>: <span class="keyword">if</span> (throwable <span class="keyword">instanceof</span> HystrixRuntimeException) &#123;</div><div class="line"><span class="number">29</span>: HystrixRuntimeException e = (HystrixRuntimeException) throwable;</div><div class="line"><span class="number">30</span>: <span class="keyword">if</span> (e.getFailureType() == TIMEOUT) &#123; <span class="comment">//<span class="doctag">TODO:</span> optionally set status</span></div><div class="line"><span class="number">31</span>: setResponseStatus(exchange, HttpStatus.GATEWAY_TIMEOUT);</div><div class="line"><span class="number">32</span>: <span class="keyword">return</span> exchange.getResponse().setComplete();</div><div class="line"><span class="number">33</span>: &#125;</div><div class="line"><span class="number">34</span>: &#125;</div><div class="line"><span class="number">35</span>: <span class="keyword">return</span> Mono.empty();</div><div class="line"><span class="number">36</span>: &#125;).then();</div><div class="line"><span class="number">37</span>: &#125;;</div><div class="line"><span class="number">38</span>: &#125;</div><div class="line"><span class="number">39</span>: &#125;</div></pre></td></tr></table></figure><ul><li><code>#argNames()</code> 方法，定义了 Tuple 参数的 Key 为 <code>name</code> 。</li><li><code>#apply()</code> 方法，创建 HystrixGatewayFilter 对象。</li><li>第 11 行 ：从 Tuple 参数获得 Hystrix Command 名字，例如上面举例的 RouteDefinition 时，<code>commandName = myCommandName</code> 。</li><li>第 12 行 ：创建 Hystrix Command 分组 Key 为 <code>HystrixGatewayFilterFactory</code> 。</li><li>第 13 行 ：创建 Hystrix Command Key 为 <code>commandName</code> 。</li><li>第 15 至 17 行 ：创建 HystrixObservableCommand.Setter 对象。</li><li>——— 第 19 至 37 行 ：<strong>创建 HystrixGatewayFilter 对象并返回</strong>。</li><li><p>第 20 行 ：创建 RouteHystrixCommand 对象。代码如下 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">RouteHystrixCommand</span> <span class="keyword">extends</span> <span class="title">HystrixObservableCommand</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ServerWebExchange exchange;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> GatewayFilterChain chain;</div><div class="line"></div><div class="line">RouteHystrixCommand(Setter setter, ServerWebExchange exchange, GatewayFilterChain chain) &#123;</div><div class="line"><span class="keyword">super</span>(setter);</div><div class="line"><span class="keyword">this</span>.exchange = exchange;</div><div class="line"><span class="keyword">this</span>.chain = chain;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> Observable&lt;Void&gt; <span class="title">construct</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> RxReactiveStreams.toObservable(<span class="keyword">this</span>.chain.filter(<span class="keyword">this</span>.exchange));</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>第 22 至 26 行 ：调用 <code>Mono#create(Consumer&lt;MonoSink&lt;T&gt;&gt;)</code> 方法，创建 Mono 对象。点击 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#create-java.util.function.Consumer-" rel="external nofollow noopener noreferrer" target="_blank">传送门</a> 查看该方法详细说明。因为 Hystrix 基于 RxJava ，而 GatewayFilter 基于 Reactor ( Mono 是其内部的一个类 )，通过这个方法，实现订阅的适配。<strong>未来，会实现 <a href="https://github.com/Netflix/Hystrix/issues/1089#issuecomment-180512000" rel="external nofollow noopener noreferrer" target="_blank">HystrixMonoCommand</a> 替换 HystrixObservableCommand ，从而统一订阅，去除适配代码</strong>。</p><ul><li>第 24 行 ：1）调用 <code>RouteHystrixCommand#toObservable()</code> 方法，内部会调用 <code>RouteHystrixCommand#construct()</code> 方法，获得执行 <code>this.chain.filter(this.exchange)</code> 的 Observable 。2）订阅 Observable ：成功或完成时，调用 <code>Mono#success(Object)</code> 方法，目前创建的 Mono 上没有相关的订阅；<strong>异常时</strong>，调用 <code>Mono#error(Object)</code> 方法，目前创建的 Mono 上调用 <code>Mongo#onErrorResume(Function&lt;Throwable, Mono&lt;Void&gt;&gt;))</code> 方法，进行订阅。</li><li>第 26 行 ：Mono 取消时，取消 Hystrix Command Observable 的订阅，结束 Hystrix Command 的执行。</li></ul></li><li>第 27 至 34 行 ：当 Hystrix Command <strong>执行超时</strong>时，设置响应 504 状态码，并回写客户端<strong>响应</strong>( <code>exchange.getResponse().setComplete()</code> ) 。</li><li>第 35 行 ：<strong>当 Hystrix Command 发生其他异常时，例如断路器打开，返回 <code>Mono.empty()</code> ，最终返回客户端 200 状态码，内容为空</strong>。</li><li>第 36 行 ：调用 <code>Mono#then()</code> 方法，<strong>参数为空</strong>，返回空 Mono ，不再向后发射数据。</li></ul><h1 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h1><ol><li>目前 Hystrix Command 执行超时时，返回客户端 504 状态码，如果使用 JSON 格式作为数据返回，则需要修改下该 HystrixGatewayFilter 的代码实现。</li><li><p>Hystrix 配置参数，目前只能<strong>全局</strong>配置，例如说 Hystrix 执行超时时间，配置如下 ：</p> <figure class="highlight yaml"><table><tr><td class="code"><pre><div class="line"><span class="attr">hystrix:</span></div><div class="line"><span class="attr">  command:</span></div><div class="line"><span class="attr">    default:</span></div><div class="line"><span class="attr">      execution:</span></div><div class="line"><span class="attr">        isolation:</span></div><div class="line"><span class="attr">          thread:</span></div><div class="line"><span class="attr">            timeoutInMilliseconds:</span> <span class="number">10000</span></div></pre></td></tr></table></figure><ul><li>如果想实现 Route / URL 级别的 Hystrix 配置参数，则需要修改下该 HystrixGatewayFilter 的代码实现。</li><li><a href="https://github.com/Netflix/Hystrix/wiki/Configuration#contents" rel="external nofollow noopener noreferrer" target="_blank">《Hystrix —— Configuration》</a> ，Hystrix 配置项，需要自取。</li></ul></li><li><p>当 Hystrix 熔断时，最终返回客户端 200 状态码，内容为空，此处建议该 HystrixGatewayFilter 的代码实现。</p></li></ol><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>嘿嘿嘿，写完熔断，准备限流过滤器走起。鸡冻！</p><p><img src="http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_04_05/01.png" alt=""></p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/&quot;&gt;http://www.iocoder.cn/Spring-Cloud-Gateway/filter-hystrix/&lt;
      
    
    </summary>
    
      <category term="Spring-Cloud-Gateway" scheme="http://www.iocoder.cn/categories/Spring-Cloud-Gateway/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.8) 之 WebClientHttpRoutingFilter</title>
    <link href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-web-client-http-routing/"/>
    <id>http://www.iocoder.cn/Spring-Cloud-Gateway/filter-web-client-http-routing/</id>
    <published>2020-03-31T16:00:00.000Z</published>
    <updated>2017-12-01T16:41:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-web-client-http-routing/">http://www.iocoder.cn/Spring-Cloud-Gateway/filter-web-client-http-routing/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Spring-Cloud-Gateway 2.0.X M4</strong>  </p><ul><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-web-client-http-routing/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-web-client-http-routing/">2. 环境配置</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-web-client-http-routing/">3. WebClientHttpRoutingFilter</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-web-client-http-routing/">4. WebClientWriteResponseFilter</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-web-client-http-routing/">5. 和 NettyRoutingFilter 对比</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-web-client-http-routing/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>WebClientHttpRoutingFilter 的代码实现</strong>。</p><p>WebClientHttpRoutingFilter ，Http <strong>路由</strong>网关过滤器。其根据 <code>http://</code> 或 <code>https://</code> 前缀( Scheme )过滤处理，使用基于 <code>org.springframework.cloud.gateway.filter.WebClient</code> 实现的 HttpClient 请求后端 Http 服务。</p><p>WebClientWriteResponseFilter ，与 WebClientHttpRoutingFilter <strong>成对使用</strong>的网关过滤器。其将 WebClientWriteResponseFilter 请求后端 Http 服务的<strong>响应</strong>写回客户端。</p><p>大体流程如下 ：</p><p><img src="http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_04_01/01.png" alt=""></p><h1 id="2-环境配置"><a href="#2-环境配置" class="headerlink" title="2. 环境配置"></a>2. 环境配置</h1><p>目前 WebClientHttpRoutingFilter / WebClientWriteResponseFilter 处于<strong>实验</strong>阶段，建议等正式发布在使用。</p><p>OK，下面我们来看看怎么配置环境。</p><p>第一步，在 NettyConfiguration 注释掉 <code>#routingFilter(...)</code> 和 <code>#nettyWriteResponseFilter()</code> 两个 Bean 方法。</p><p>第二步，在 GatewayAutoConfiguration 打开 <code>#webClientHttpRoutingFilter()</code> 和 <code>#webClientWriteResponseFilter()</code> 两个 Bean 方法。</p><p>第三步，配置完成，启动 Spring Cloud Gateway 。</p><h1 id="3-WebClientHttpRoutingFilter"><a href="#3-WebClientHttpRoutingFilter" class="headerlink" title="3. WebClientHttpRoutingFilter"></a>3. WebClientHttpRoutingFilter</h1><p><code>org.springframework.cloud.gateway.filter.WebClientHttpRoutingFilter</code> ，Http <strong>路由</strong>网关过滤器。</p><p><strong>构造方法</strong>，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebClientHttpRoutingFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> WebClient webClient;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">WebClientHttpRoutingFilter</span><span class="params">(WebClient webClient)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.webClient = webClient;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>webClient</code> 属性，默认情况下，使用 <code>org.springframework.web.reactive.function.client.DefaultWebClient</code> 实现类。通过该属性，<strong>请求后端的 Http 服务</strong>。</li></ul><hr><p><code>#getOrder()</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Ordered.LOWEST_PRECEDENCE;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>返回顺序为 <code>Integer.MAX_VALUE</code> 。在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-intro/?self">《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.1) 之 GatewayFilter 一览》「3. GlobalFilter」</a> ，我们列举了所有 GlobalFilter 的顺序。</li></ul><hr><p><code>#filter(ServerWebExchange, GatewayFilterChain)</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>: <span class="comment">// 获得 requestUrl</span></div><div class="line"> <span class="number">4</span>: URI requestUrl = exchange.getRequiredAttribute(GATEWAY_REQUEST_URL_ATTR);</div><div class="line"> <span class="number">5</span>: </div><div class="line"> <span class="number">6</span>: <span class="comment">// 判断是否能够处理</span></div><div class="line"> <span class="number">7</span>: String scheme = requestUrl.getScheme();</div><div class="line"> <span class="number">8</span>: <span class="keyword">if</span> (isAlreadyRouted(exchange) || (!scheme.equals(<span class="string">"http"</span>) &amp;&amp; !scheme.equals(<span class="string">"https"</span>))) &#123;</div><div class="line"> <span class="number">9</span>: <span class="keyword">return</span> chain.filter(exchange);</div><div class="line"><span class="number">10</span>: &#125;</div><div class="line"><span class="number">11</span>: </div><div class="line"><span class="number">12</span>: <span class="comment">// 设置已经路由</span></div><div class="line"><span class="number">13</span>: setAlreadyRouted(exchange);</div><div class="line"><span class="number">14</span>: </div><div class="line"><span class="number">15</span>: ServerHttpRequest request = exchange.getRequest();</div><div class="line"><span class="number">16</span>: </div><div class="line"><span class="number">17</span>: <span class="comment">//<span class="doctag">TODO:</span> support forms</span></div><div class="line"><span class="number">18</span>: <span class="comment">// Request Method</span></div><div class="line"><span class="number">19</span>: HttpMethod method = request.getMethod();</div><div class="line"><span class="number">20</span>: </div><div class="line"><span class="number">21</span>: <span class="comment">// Request</span></div><div class="line"><span class="number">22</span>: RequestBodySpec bodySpec = <span class="keyword">this</span>.webClient.method(method)</div><div class="line"><span class="number">23</span>: .uri(requestUrl)</div><div class="line"><span class="number">24</span>: .headers(httpHeaders -&gt; &#123;</div><div class="line"><span class="number">25</span>: httpHeaders.addAll(request.getHeaders());</div><div class="line"><span class="number">26</span>: httpHeaders.remove(HttpHeaders.HOST);</div><div class="line"><span class="number">27</span>: &#125;);</div><div class="line"><span class="number">28</span>: </div><div class="line"><span class="number">29</span>: <span class="comment">// Request Body</span></div><div class="line"><span class="number">30</span>: RequestHeadersSpec&lt;?&gt; headersSpec;</div><div class="line"><span class="number">31</span>: <span class="keyword">if</span> (requiresBody(method)) &#123;</div><div class="line"><span class="number">32</span>: headersSpec = bodySpec.body(BodyInserters.fromDataBuffers(request.getBody()));</div><div class="line"><span class="number">33</span>: &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">34</span>: headersSpec = bodySpec;</div><div class="line"><span class="number">35</span>: &#125;</div><div class="line"><span class="number">36</span>: </div><div class="line"><span class="number">37</span>: <span class="keyword">return</span> headersSpec.exchange()</div><div class="line"><span class="number">38</span>: <span class="comment">// .log("webClient route")</span></div><div class="line"><span class="number">39</span>: .flatMap(res -&gt; &#123;</div><div class="line"><span class="number">40</span>: ServerHttpResponse response = exchange.getResponse();</div><div class="line"><span class="number">41</span>: </div><div class="line"><span class="number">42</span>: <span class="comment">// Response Header</span></div><div class="line"><span class="number">43</span>: response.getHeaders().putAll(res.headers().asHttpHeaders());</div><div class="line"><span class="number">44</span>: </div><div class="line"><span class="number">45</span>: <span class="comment">// Response Status</span></div><div class="line"><span class="number">46</span>: response.setStatusCode(res.statusCode());</div><div class="line"><span class="number">47</span>: </div><div class="line"><span class="number">48</span>: <span class="comment">// 设置 Response 到 CLIENT_RESPONSE_ATTR</span></div><div class="line"><span class="number">49</span>: <span class="comment">// Defer committing the response until all route filters have run</span></div><div class="line"><span class="number">50</span>: <span class="comment">// Put client response as ServerWebExchange attribute and write response later NettyWriteResponseFilter</span></div><div class="line"><span class="number">51</span>: exchange.getAttributes().put(CLIENT_RESPONSE_ATTR, res);</div><div class="line"><span class="number">52</span>: <span class="keyword">return</span> chain.filter(exchange);</div><div class="line"><span class="number">53</span>: &#125;);</div><div class="line"><span class="number">54</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 4 行 ：获得 <code>requestUrl</code> 。</li><li><p>第 7 至 10 行 ：判断 ForwardRoutingFilter 是否能够处理该请求，需要满足两个条件 ：</p><ul><li><code>http://</code> 或者 <code>https://</code> 前缀( Scheme ) 。</li><li><p>调用 <code>ServerWebExchangeUtils#isAlreadyRouted(ServerWebExchange)</code> 方法，判断该请求暂未被其他 Routing 网关处理。代码如下 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAlreadyRouted</span><span class="params">(ServerWebExchange exchange)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> exchange.getAttributeOrDefault(GATEWAY_ALREADY_ROUTED_ATTR, <span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul></li></ul></li><li><p>第 13 行 ：设置该请求已经被处理。代码如下 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setAlreadyRouted</span><span class="params">(ServerWebExchange exchange)</span> </span>&#123;</div><div class="line">    exchange.getAttributes().put(GATEWAY_ALREADY_ROUTED_ATTR, <span class="keyword">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>第 17 行 ：TODO 【3025】 目前暂不支持 forms 参数</p></li><li>第 22 至 35 行 ：<strong>创建</strong>向后端服务的请求。<ul><li>第 22 行 ：设置 Method 属性。</li><li>第 24 至 27 行 ：设置 Header 属性。</li><li>第 30 至 35 行 ：设置 Body 属性。</li></ul></li><li>第 37 行 ：<strong>发起</strong>向后端服务的请求。</li><li>第 40 至 53 行 ：<strong>处理</strong>返回自后端服务的相应。<ul><li>第 43 行 ：设置 <code>response</code> 的 Header 属性。</li><li>第 46 行 ：设置 <code>response</code> 的 Status 属性。</li><li>第 51 行 ：设置 <code>res</code> 到 <code>CLIENT_RESPONSE_ATTR</code> 。后续 WebClientWriteResponseFilter 将响应<strong>写回</strong>给客户端。</li><li>第 52 行 ：提交过滤器链继续过滤。</li></ul></li></ul><h1 id="4-WebClientWriteResponseFilter"><a href="#4-WebClientWriteResponseFilter" class="headerlink" title="4. WebClientWriteResponseFilter"></a>4. WebClientWriteResponseFilter</h1><p><code>org.springframework.cloud.gateway.filter.WebClientWriteResponseFilter</code> ，Http 回写<strong>响应</strong>网关过滤器。</p><p><code>#getOrder()</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITE_RESPONSE_FILTER_ORDER = -<span class="number">1</span>;</div><div class="line">    </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> WRITE_RESPONSE_FILTER_ORDER;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>返回顺序为 <code>-1</code> 。在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-intro/?self">《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.1) 之 GatewayFilter 一览》「3. GlobalFilter」</a> ，我们列举了所有 GlobalFilter 的顺序。</li></ul><hr><p><code>#filter(ServerWebExchange, GatewayFilterChain)</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>: <span class="comment">// NOTICE: nothing in "pre" filter stage as CLIENT_RESPONSE_ATTR is not added</span></div><div class="line"> <span class="number">4</span>: <span class="comment">// until the WebHandler is run</span></div><div class="line"> <span class="number">5</span>: <span class="keyword">return</span> chain.filter(exchange).then(Mono.defer(() -&gt; &#123;</div><div class="line"> <span class="number">6</span>:     <span class="comment">// 获得 Response</span></div><div class="line"> <span class="number">7</span>: ClientResponse clientResponse = exchange.getAttribute(CLIENT_RESPONSE_ATTR);</div><div class="line"> <span class="number">8</span>: <span class="keyword">if</span> (clientResponse == <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">9</span>: <span class="keyword">return</span> Mono.empty();</div><div class="line"><span class="number">10</span>: &#125;</div><div class="line"><span class="number">11</span>: log.trace(<span class="string">"WebClientWriteResponseFilter start"</span>);</div><div class="line"><span class="number">12</span>: ServerHttpResponse response = exchange.getResponse();</div><div class="line"><span class="number">13</span>: </div><div class="line"><span class="number">14</span>: <span class="keyword">return</span> response.writeWith(clientResponse.body(BodyExtractors.toDataBuffers())).log(<span class="string">"webClient response"</span>);</div><div class="line"><span class="number">15</span>: &#125;));</div><div class="line"><span class="number">16</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 5 行 ：调用 <code>#then(Mono)</code> 方法，实现 <strong>After Filter</strong> 逻辑。</li><li>第 7 至 11 行 ：从 <code>CLIENT_RESPONSE_ATTR</code> 中，获得 ClientResponse 。</li><li>第 14 行 ：将 ClientResponse 写回给客户端。</li></ul><h1 id="5-和-NettyRoutingFilter-对比"><a href="#5-和-NettyRoutingFilter-对比" class="headerlink" title="5. 和 NettyRoutingFilter 对比"></a>5. 和 NettyRoutingFilter 对比</h1><p>在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-netty-routing/?self">《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.7) 之 NettyRoutingFilter》</a> 中，我们知道 NettyRoutingFilter / NettyWriteResponseFilter 和 WebClientHttpRoutingFilter / WebClientHttpRoutingFilter 实现<strong>一样</strong>的功能。</p><p>那么为什么要再实现一次呢？</p><p>TODO 【3001】</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>呼呼，主要的过滤器已经写完，后面熔断、限流过滤器的实现。</p><p><img src="http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_04_01/02.png" alt=""></p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Spring-Cloud-Gateway/filter-web-client-http-routing/&quot;&gt;http://www.iocoder.cn/Spring-Cloud-Gateway/
      
    
    </summary>
    
      <category term="Spring-Cloud-Gateway" scheme="http://www.iocoder.cn/categories/Spring-Cloud-Gateway/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.7) 之 NettyRoutingFilter</title>
    <link href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-netty-routing/"/>
    <id>http://www.iocoder.cn/Spring-Cloud-Gateway/filter-netty-routing/</id>
    <published>2020-03-27T16:00:00.000Z</published>
    <updated>2017-12-01T16:41:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-netty-routing/">http://www.iocoder.cn/Spring-Cloud-Gateway/filter-netty-routing/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Spring-Cloud-Gateway 2.0.X M4</strong>  </p><ul><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-netty-routing/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-netty-routing/">2. NettyRoutingFilter</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-netty-routing/">3. NettyWriteResponseFilter</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-netty-routing/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>NettyRoutingFilter 的代码实现</strong>。</p><p>NettyRoutingFilter ，Netty <strong>路由</strong>网关过滤器。其根据 <code>http://</code> 或 <code>https://</code> 前缀( Scheme )过滤处理，使用基于 Netty 实现的 HttpClient 请求后端 Http 服务。</p><p>NettyWriteResponseFilter ，与 NettyRoutingFilter <strong>成对使用</strong>的网关过滤器。其将 NettyRoutingFilter 请求后端 Http 服务的<strong>响应</strong>写回客户端。</p><p>大体流程如下 ：</p><p><img src="http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_03_28/01.png" alt=""></p><p>另外，Spring Cloud Gateway 实现了 WebClientHttpRoutingFilter / WebClientWriteResponseFilter ，功能上和 NettyRoutingFilter / NettyWriteResponseFilter <strong>相同</strong>，差别在于基于 <code>org.springframework.cloud.gateway.filter.WebClient</code> 实现的 HttpClient 请求后端 Http 服务。在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-web-client-http-routing?self">《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.8) 之 WebClientHttpRoutingFilter》</a> ，我们会详细解析。</p><hr><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-NettyRoutingFilter"><a href="#2-NettyRoutingFilter" class="headerlink" title="2. NettyRoutingFilter"></a>2. NettyRoutingFilter</h1><p><code>org.springframework.cloud.gateway.filter.NettyRoutingFilter</code> ，Netty <strong>路由</strong>网关过滤器。</p><p><strong>构造方法</strong>，代码如下 ：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class NettyRoutingFilter implements GlobalFilter, Ordered &#123;</div><div class="line"></div><div class="line">private final HttpClient httpClient;</div><div class="line"></div><div class="line">public NettyRoutingFilter(HttpClient httpClient) &#123;</div><div class="line">this.httpClient = httpClient;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>httpClient</code> 属性，基于 <strong>Netty</strong> 实现的 HttpClient 。通过该属性，<strong>请求后端的 Http 服务</strong>。</li></ul><hr><p><code>#getOrder()</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Ordered.LOWEST_PRECEDENCE;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>返回顺序为 <code>Integer.MAX_VALUE</code> 。在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-intro/?self">《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.1) 之 GatewayFilter 一览》「3. GlobalFilter」</a> ，我们列举了所有 GlobalFilter 的顺序。</li></ul><hr><p><code>#filter(ServerWebExchange, GatewayFilterChain)</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>: <span class="comment">// 获得 requestUrl</span></div><div class="line"> <span class="number">4</span>: URI requestUrl = exchange.getRequiredAttribute(GATEWAY_REQUEST_URL_ATTR);</div><div class="line"> <span class="number">5</span>: </div><div class="line"> <span class="number">6</span>: <span class="comment">// 判断是否能够处理</span></div><div class="line"> <span class="number">7</span>: String scheme = requestUrl.getScheme();</div><div class="line"> <span class="number">8</span>: <span class="keyword">if</span> (isAlreadyRouted(exchange) || (!scheme.equals(<span class="string">"http"</span>) &amp;&amp; !scheme.equals(<span class="string">"https"</span>))) &#123;</div><div class="line"> <span class="number">9</span>: <span class="keyword">return</span> chain.filter(exchange);</div><div class="line"><span class="number">10</span>: &#125;</div><div class="line"><span class="number">11</span>: </div><div class="line"><span class="number">12</span>: <span class="comment">// 设置已经路由</span></div><div class="line"><span class="number">13</span>: setAlreadyRouted(exchange);</div><div class="line"><span class="number">14</span>: </div><div class="line"><span class="number">15</span>: ServerHttpRequest request = exchange.getRequest();</div><div class="line"><span class="number">16</span>: </div><div class="line"><span class="number">17</span>: <span class="comment">// Request Method</span></div><div class="line"><span class="number">18</span>: <span class="keyword">final</span> HttpMethod method = HttpMethod.valueOf(request.getMethod().toString());</div><div class="line"><span class="number">19</span>: </div><div class="line"><span class="number">20</span>: <span class="comment">// 获得 url</span></div><div class="line"><span class="number">21</span>: <span class="keyword">final</span> String url = requestUrl.toString();</div><div class="line"><span class="number">22</span>: </div><div class="line"><span class="number">23</span>: <span class="comment">// Request Header</span></div><div class="line"><span class="number">24</span>: <span class="keyword">final</span> DefaultHttpHeaders httpHeaders = <span class="keyword">new</span> DefaultHttpHeaders();</div><div class="line"><span class="number">25</span>: request.getHeaders().forEach(httpHeaders::set);</div><div class="line"><span class="number">26</span>: </div><div class="line"><span class="number">27</span>: <span class="comment">// 请求</span></div><div class="line"><span class="number">28</span>: <span class="keyword">return</span> <span class="keyword">this</span>.httpClient.request(method, url, req -&gt; &#123;</div><div class="line"><span class="number">29</span>: <span class="keyword">final</span> HttpClientRequest proxyRequest = req.options(NettyPipeline.SendOptions::flushOnEach)</div><div class="line"><span class="number">30</span>: .failOnClientError(<span class="keyword">false</span>) <span class="comment">// // 是否请求失败，抛出异常</span></div><div class="line"><span class="number">31</span>: .headers(httpHeaders);</div><div class="line"><span class="number">32</span>: </div><div class="line"><span class="number">33</span>: <span class="comment">// Request Form</span></div><div class="line"><span class="number">34</span>: <span class="keyword">if</span> (MediaType.APPLICATION_FORM_URLENCODED.includes(request.getHeaders().getContentType())) &#123;</div><div class="line"><span class="number">35</span>: <span class="keyword">return</span> exchange.getFormData()</div><div class="line"><span class="number">36</span>: .flatMap(map -&gt; proxyRequest.sendForm(form -&gt; &#123;</div><div class="line"><span class="number">37</span>: <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;String&gt;&gt; entry: map.entrySet()) &#123;</div><div class="line"><span class="number">38</span>: <span class="keyword">for</span> (String value : entry.getValue()) &#123;</div><div class="line"><span class="number">39</span>: form.attr(entry.getKey(), value);</div><div class="line"><span class="number">40</span>: &#125;</div><div class="line"><span class="number">41</span>: &#125;</div><div class="line"><span class="number">42</span>: &#125;).then())</div><div class="line"><span class="number">43</span>: .then(chain.filter(exchange));</div><div class="line"><span class="number">44</span>: &#125;</div><div class="line"><span class="number">45</span>: </div><div class="line"><span class="number">46</span>: <span class="comment">// Request Body</span></div><div class="line"><span class="number">47</span>: <span class="keyword">return</span> proxyRequest.sendHeaders() <span class="comment">//I shouldn't need this</span></div><div class="line"><span class="number">48</span>: .send(request.getBody()</div><div class="line"><span class="number">49</span>: .map(DataBuffer::asByteBuffer) <span class="comment">// Flux&lt;DataBuffer&gt; =&gt; ByteBuffer</span></div><div class="line"><span class="number">50</span>: .map(Unpooled::wrappedBuffer)); <span class="comment">// ByteBuffer =&gt; Flux&lt;DataBuffer&gt;</span></div><div class="line"><span class="number">51</span>: &#125;).doOnNext(res -&gt; &#123;</div><div class="line"><span class="number">52</span>: ServerHttpResponse response = exchange.getResponse();</div><div class="line"><span class="number">53</span>: <span class="comment">// Response Header</span></div><div class="line"><span class="number">54</span>: <span class="comment">// put headers and status so filters can modify the response</span></div><div class="line"><span class="number">55</span>: HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</div><div class="line"><span class="number">56</span>: res.responseHeaders().forEach(entry -&gt; headers.add(entry.getKey(), entry.getValue()));</div><div class="line"><span class="number">57</span>: response.getHeaders().putAll(headers);</div><div class="line"><span class="number">58</span>: </div><div class="line"><span class="number">59</span>: <span class="comment">// Response Status</span></div><div class="line"><span class="number">60</span>: response.setStatusCode(HttpStatus.valueOf(res.status().code()));</div><div class="line"><span class="number">61</span>: </div><div class="line"><span class="number">62</span>: <span class="comment">// 设置 Response 到 CLIENT_RESPONSE_ATTR</span></div><div class="line"><span class="number">63</span>: <span class="comment">// Defer committing the response until all route filters have run</span></div><div class="line"><span class="number">64</span>: <span class="comment">// Put client response as ServerWebExchange attribute and write response later NettyWriteResponseFilter</span></div><div class="line"><span class="number">65</span>: exchange.getAttributes().put(CLIENT_RESPONSE_ATTR, res);</div><div class="line"><span class="number">66</span>: &#125;).then(chain.filter(exchange));</div><div class="line"><span class="number">67</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 4 行 ：获得 <code>requestUrl</code> 。</li><li><p>第 7 至 10 行 ：判断 ForwardRoutingFilter 是否能够处理该请求，需要满足两个条件 ：</p><ul><li><code>http://</code> 或者 <code>https://</code> 前缀( Scheme ) 。</li><li><p>调用 <code>ServerWebExchangeUtils#isAlreadyRouted(ServerWebExchange)</code> 方法，判断该请求暂未被其他 Routing 网关处理。代码如下 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAlreadyRouted</span><span class="params">(ServerWebExchange exchange)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> exchange.getAttributeOrDefault(GATEWAY_ALREADY_ROUTED_ATTR, <span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul></li></ul></li><li><p>第 13 行 ：设置该请求已经被处理。代码如下 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setAlreadyRouted</span><span class="params">(ServerWebExchange exchange)</span> </span>&#123;</div><div class="line">    exchange.getAttributes().put(GATEWAY_ALREADY_ROUTED_ATTR, <span class="keyword">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>第 18 行 ：创建 <strong>Netty Request Method</strong> 对象。<code>request#getMethod()</code> 返回的不是 <code>io.netty.handler.codec.http.HttpMethod</code> ，所以需要进行转换。</p></li><li>第 21 行 ：获得 <code>url</code> 。</li><li>第 24 至 25 行 ：创建  <strong>Netty Request Header</strong> 对象( <code>io.netty.handler.codec.http.DefaultHttpHeaders</code> )，将请求的 Header 设置给它。</li><li>——— 第 28 至 50 行 ：调用 <code>HttpClient#request(HttpMethod, String, Function)</code> 方法，请求后端 Http 服务。</li><li><p>第 29 至 31 行 ：创建 <strong>Netty Request</strong> 对象( <code>reactor.ipc.netty.http.client.HttpClientRequest</code> )。</p><ul><li>第 29 行 ：TODO 【3024】 NettyPipeline.SendOptions::flushOnEach</li><li><p>第 30 行 ：设置请求失败( 后端服务返回响应状体码 <code>&gt;= 400</code> )时，不抛出异常。相关代码如下 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// HttpClientOperations#checkResponseCode(HttpResponse response)</span></div><div class="line"><span class="comment">// ... 省略无关代码</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> (code &gt;= <span class="number">400</span>) &#123;</div><div class="line"><span class="keyword">if</span> (clientError) &#123;</div><div class="line"><span class="keyword">if</span> (log.isDebugEnabled()) &#123;</div><div class="line">log.debug(<span class="string">"&#123;&#125; Received Request Error, stop reading: &#123;&#125;"</span>,</div><div class="line">channel(),</div><div class="line">response.toString());</div><div class="line">&#125;</div><div class="line">Exception ex = <span class="keyword">new</span> HttpClientException(uri(), response);</div><div class="line">parentContext().fireContextError(ex);</div><div class="line">receive().subscribe();</div><div class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>通过设置 <code>clientError = false</code> ，第 51 行可以调用 <code>Mono#doNext(Consumer)</code> 方法，<strong>统一订阅处理</strong>返回的 <code>reactor.ipc.netty.http.client.HttpClientResponse</code> 对象。</li></ul></li><li><p>第 31 行 ：设置 <strong>Netty Request</strong> 对象的 Header 。</p></li></ul></li><li><p>第 34 至 44 行 ：【TODO 3025】目前是一个 BUG ，在 2.0.X 版本修复。见 <a href="FormIntegrationTests">FormIntegrationTests#formUrlencodedWorks()</a> 单元测试的注释说明。</p></li><li><p>第 47 至 50 行 ：请求后端的 Http 服务。</p><ul><li>第 47 行 ：发送请求 Header 。</li><li>第 48 至 50 行 ：发送请求 Body 。其中中间的 <code>#map(...)</code> 的过程为 <code>Flux&lt;DataBuffer&gt; =&gt; ByteBuffer =&gt; Flux&lt;DataBuffer&gt;</code> 。</li></ul></li><li><p>——— 第 51 至 65 行 ：请求后端 Http 服务<strong>完成</strong>，将 <strong>Netty Response</strong> 赋值给响应 <code>response</code> 。</p></li><li>第 53 至 57 行 ：创建 <code>org.springframework.http.HttpHeaders</code> 对象，将 <strong>Netty Response Header</strong> 设置给它，而后设置回给响应 <code>response</code> 。</li><li>第 60 行 ：设置响应 <code>response</code> 的状态码。</li><li>第 65 行 ：设置 <strong>Netty Response</strong> 到 <code>CLIENT_RESPONSE_ATTR</code> 。后续 NettyWriteResponseFilter 将 <strong>Netty Response</strong> 写回给客户端。</li><li>——— 第 66 行 ：提交过滤器链继续过滤。</li></ul><h1 id="3-NettyWriteResponseFilter"><a href="#3-NettyWriteResponseFilter" class="headerlink" title="3. NettyWriteResponseFilter"></a>3. NettyWriteResponseFilter</h1><p><code>org.springframework.cloud.gateway.filter.NettyWriteResponseFilter</code> ，Netty 回写<strong>响应</strong>网关过滤器。</p><p><code>#getOrder()</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITE_RESPONSE_FILTER_ORDER = -<span class="number">1</span>;</div><div class="line">    </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> WRITE_RESPONSE_FILTER_ORDER;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>返回顺序为 <code>-1</code> 。在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-intro/?self">《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.1) 之 GatewayFilter 一览》「3. GlobalFilter」</a> ，我们列举了所有 GlobalFilter 的顺序。</li></ul><hr><p><code>#filter(ServerWebExchange, GatewayFilterChain)</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>: <span class="comment">// NOTICE: nothing in "pre" filter stage as CLIENT_RESPONSE_ATTR is not added</span></div><div class="line"> <span class="number">4</span>: <span class="comment">// until the WebHandler is run</span></div><div class="line"> <span class="number">5</span>: <span class="keyword">return</span> chain.filter(exchange).then(Mono.defer(() -&gt; &#123;</div><div class="line"> <span class="number">6</span>:     <span class="comment">// 获得 Response</span></div><div class="line"> <span class="number">7</span>: HttpClientResponse clientResponse = exchange.getAttribute(CLIENT_RESPONSE_ATTR);</div><div class="line"> <span class="number">8</span>: <span class="comment">// HttpClientResponse clientResponse = getAttribute(exchange, CLIENT_RESPONSE_ATTR, HttpClientResponse.class);</span></div><div class="line"> <span class="number">9</span>: <span class="keyword">if</span> (clientResponse == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">10</span>: <span class="keyword">return</span> Mono.empty();</div><div class="line"><span class="number">11</span>: &#125;</div><div class="line"><span class="number">12</span>: log.trace(<span class="string">"NettyWriteResponseFilter start"</span>);</div><div class="line"><span class="number">13</span>: ServerHttpResponse response = exchange.getResponse();</div><div class="line"><span class="number">14</span>: </div><div class="line"><span class="number">15</span>: <span class="comment">// 将 Netty Response 写回给客户端。</span></div><div class="line"><span class="number">16</span>: NettyDataBufferFactory factory = (NettyDataBufferFactory) response.bufferFactory();</div><div class="line"><span class="number">17</span>: <span class="comment">//<span class="doctag">TODO:</span> what if it's not netty</span></div><div class="line"><span class="number">18</span>: <span class="keyword">final</span> Flux&lt;NettyDataBuffer&gt; body = clientResponse.receive()</div><div class="line"><span class="number">19</span>: .retain() <span class="comment">// ByteBufFlux =&gt; ByteBufFlux</span></div><div class="line"><span class="number">20</span>: .map(factory::wrap); <span class="comment">// ByteBufFlux  =&gt; Flux&lt;NettyDataBuffer&gt;</span></div><div class="line"><span class="number">21</span>: <span class="keyword">return</span> response.writeWith(body);</div><div class="line"><span class="number">22</span>: &#125;));</div><div class="line"><span class="number">23</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 5 行 ：调用 <code>#then(Mono)</code> 方法，实现 <strong>After Filter</strong> 逻辑。</li><li>第 7 至 11 行 ：从 <code>CLIENT_RESPONSE_ATTR</code> 中，获得 <strong>Netty Response</strong> 。</li><li>第 15 至 21 行 ：将 <strong>Netty Response</strong> 写回给客户端。因为 <code>org.springframework.http.server.reactive#writeWith(Publisher&lt;? extends DataBuffer&gt;)</code> 需要的参数类型是 <code>Publisher&lt;? extends DataBuffer&gt;</code> ，所以【第 18 至 20 行】的转换过程是 <code>ByteBufFlux =&gt; Flux&lt;NettyDataBuffer&gt;</code> 。<ul><li>第 19 行 ：TODO 【3024】ByteBufFlux#retain() </li></ul></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>下一篇 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-web-client-http-routing">《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.8) 之 WebClientHttpRoutingFilter》</a> 走起！</p><p><img src="http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_03_28/02.png" alt=""></p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Spring-Cloud-Gateway/filter-netty-routing/&quot;&gt;http://www.iocoder.cn/Spring-Cloud-Gateway/filter-net
      
    
    </summary>
    
      <category term="Spring-Cloud-Gateway" scheme="http://www.iocoder.cn/categories/Spring-Cloud-Gateway/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.6) 之 WebSocketRoutingFilter</title>
    <link href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-websocket-routing/"/>
    <id>http://www.iocoder.cn/Spring-Cloud-Gateway/filter-websocket-routing/</id>
    <published>2020-03-24T16:00:00.000Z</published>
    <updated>2017-12-01T16:41:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-websocket-routing/">http://www.iocoder.cn/Spring-Cloud-Gateway/filter-websocket-routing/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Spring-Cloud-Gateway 2.0.X M4</strong>  </p><ul><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-websocket-routing/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-websocket-routing/">2. 环境搭建</a></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-websocket-routing/">3. WebsocketRoutingFilter</a><ul><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-websocket-routing/">3.1 ProxyWebSocketHandler</a></li></ul></li><li><a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-websocket-routing/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>WebsocketRoutingFilter 的代码实现</strong>。</p><p>WebsocketRoutingFilter ，Websocket <strong>路由</strong>网关过滤器。其根据 <code>ws://</code> / <code>wss://</code> 前缀( Scheme )过滤处理，<strong>代理后端 Websocket 服务</strong>，提供给客户端连接。如下图 ：</p><p><img src="http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_03_25/01.png" alt=""></p><ul><li>目前<strong>一个</strong> RouteDefinition 只能指定<strong>一个</strong>后端 WebSocket 服务。官方正在计划在 LoadBalancerClientFilter 上实现 Websocket 的负载均衡功能。也就说，未来<strong>一个</strong> RouteDefinition 能够指定<strong>多个</strong>后端 WebSocket 服务。</li></ul><p>Websocket 的 RouteDefinition 配置如下 ：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><div class="line"><span class="attr">cloud:</span></div><div class="line"><span class="attr">    gateway:</span></div><div class="line"><span class="attr">      routes:</span></div><div class="line"><span class="attr">      - id:</span> <span class="string">websocket_test</span></div><div class="line"><span class="attr">        uri:</span> <span class="attr">ws://localhost:9000</span></div><div class="line"><span class="attr">        order:</span> <span class="number">8000</span></div><div class="line"><span class="attr">        predicates:</span></div><div class="line"><span class="bullet">        -</span> <span class="string">Path=/echo</span></div></pre></td></tr></table></figure><ul><li><code>uri</code> 使用 <code>ws://</code> 或者 <code>wss://</code> 为前缀。</li></ul><hr><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><h1 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2. 环境搭建"></a>2. 环境搭建</h1><p>在解析源码之前，我们先以 <a href="https://github.com/websockets/wscat" rel="external nofollow noopener noreferrer" target="_blank">wscat</a>  搭建一个 WebSocket 服务。</p><p>第一步，安装 wscat 。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">npm install -g wscat</div></pre></td></tr></table></figure><p>第二步，启动 wscat 。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">wscat --listen 9000</div></pre></td></tr></table></figure><p>第三步，连接 wscat 。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">wscat --listen 9000</div></pre></td></tr></table></figure><p>第四步，配置 RouteDefinition ，并启动 Spring Cloud Gateway 。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">cloud:</div><div class="line">    gateway:</div><div class="line">      routes:</div><div class="line">      - id: websocket_test</div><div class="line">        uri: ws://localhost:9000</div><div class="line">        order: 8000</div><div class="line">        predicates:</div><div class="line">        - Path=/echo</div></pre></td></tr></table></figure><p>第五步，通过 Gateway 连接 wscat 。</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">wscat --connect ws://localhost:8080/echo</div></pre></td></tr></table></figure><p>大功告成。</p><p>注意，wscat 同一时间仅允许一个客户端连接。</p><h1 id="3-WebsocketRoutingFilter"><a href="#3-WebsocketRoutingFilter" class="headerlink" title="3. WebsocketRoutingFilter"></a>3. WebsocketRoutingFilter</h1><p><code>org.springframework.cloud.gateway.filter.WebsocketRoutingFilter</code> ，Websocket <strong>路由</strong>网关过滤器。</p><p><strong>构造方法</strong>，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebsocketRoutingFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SEC_WEBSOCKET_PROTOCOL = <span class="string">"Sec-WebSocket-Protocol"</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> WebSocketClient webSocketClient;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> WebSocketService webSocketService;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">WebsocketRoutingFilter</span><span class="params">(WebSocketClient webSocketClient)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>(webSocketClient, <span class="keyword">new</span> HandshakeWebSocketService());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">WebsocketRoutingFilter</span><span class="params">(WebSocketClient webSocketClient,</span></span></div><div class="line"><span class="function"><span class="params">WebSocketService webSocketService)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.webSocketClient = webSocketClient;</div><div class="line"><span class="keyword">this</span>.webSocketService = webSocketService;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>webSocketClient</code> 属性，在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/init/?self">《Spring-Cloud-Gateway 源码解析 —— 网关初始化》「5.2 初始化 NettyConfiguration」</a> 一文中，我们可以看到使用的是 <code>org.springframework.web.reactive.socket.client.ReactorNettyWebSocketClient</code> 实现类。通过该属性，<strong>连接后端【被代理】的 WebSocket 服务</strong>。</li><li><code>webSocketService</code> 属性，在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/init/?self">《Spring-Cloud-Gateway 源码解析 —— 网关初始化》「5.3 初始化 GlobalFilter」</a> 一文中，我们可以看到使用的是 <code>org.springframework.web.reactive.socket.server.support.HandshakeWebSocketService</code> 实现类。通过该属性，处理客户端发起的连接请求( Handshake Request ) 。</li></ul><hr><p><code>#getOrder()</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Ordered.LOWEST_PRECEDENCE;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>返回顺序为 <code>Integer.MAX_VALUE</code> 。在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-intro/?self">《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.1) 之 GatewayFilter 一览》「3. GlobalFilter」</a> ，我们列举了所有 GlobalFilter 的顺序。</li></ul><hr><p><code>#filter(ServerWebExchange, GatewayFilterChain)</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>: <span class="comment">// 获得 requestUrl</span></div><div class="line"> <span class="number">4</span>: URI requestUrl = exchange.getRequiredAttribute(GATEWAY_REQUEST_URL_ATTR);</div><div class="line"> <span class="number">5</span>: </div><div class="line"> <span class="number">6</span>: <span class="comment">// 判断是否能够处理</span></div><div class="line"> <span class="number">7</span>: String scheme = requestUrl.getScheme();</div><div class="line"> <span class="number">8</span>: <span class="keyword">if</span> (isAlreadyRouted(exchange) || (!scheme.equals(<span class="string">"ws"</span>) &amp;&amp; !scheme.equals(<span class="string">"wss"</span>))) &#123;</div><div class="line"> <span class="number">9</span>: <span class="keyword">return</span> chain.filter(exchange);</div><div class="line"><span class="number">10</span>: &#125;</div><div class="line"><span class="number">11</span>: </div><div class="line"><span class="number">12</span>: <span class="comment">// 设置已经路由</span></div><div class="line"><span class="number">13</span>: setAlreadyRouted(exchange);</div><div class="line"><span class="number">14</span>: </div><div class="line"><span class="number">15</span>: <span class="comment">// 处理连接请求</span></div><div class="line"><span class="number">16</span>: <span class="keyword">return</span> <span class="keyword">this</span>.webSocketService.handleRequest(exchange,</div><div class="line"><span class="number">17</span>: <span class="keyword">new</span> ProxyWebSocketHandler(requestUrl, <span class="keyword">this</span>.webSocketClient, exchange.getRequest().getHeaders()));</div><div class="line"><span class="number">18</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 4 行 ：获得 <code>requestUrl</code> 。</li><li><p>第 7 至 10 行 ：判断 ForwardRoutingFilter 是否能够处理该请求，需要满足两个条件 ：</p><ul><li><code>ws://</code> 或者 <code>wss://</code> 前缀( Scheme ) 。</li><li><p>调用 <code>ServerWebExchangeUtils#isAlreadyRouted(ServerWebExchange)</code> 方法，判断该请求暂未被其他 Routing 网关处理。代码如下 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAlreadyRouted</span><span class="params">(ServerWebExchange exchange)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> exchange.getAttributeOrDefault(GATEWAY_ALREADY_ROUTED_ATTR, <span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>x</li></ul></li></ul></li><li><p>第 13 行 ：设置该请求已经被处理。代码如下 ：</p>  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setAlreadyRouted</span><span class="params">(ServerWebExchange exchange)</span> </span>&#123;</div><div class="line">    exchange.getAttributes().put(GATEWAY_ALREADY_ROUTED_ATTR, <span class="keyword">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>第 15 至 16 行 ：调用 <code>WebSocketService#hanldeRequest(ServerWebExchange, WebSocketHandler)</code> 方法，处理客户端发起的连接请求( Handshake Request ) 。这个方法的实现不在本文范围内，但是良心如笔者，大概讲下涉及到的类 ：</p><ul><li>主要逻辑在 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-webflux/src/main/java/org/springframework/web/reactive/socket/server/upgrade/ReactorNettyRequestUpgradeStrategy.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>org.springframework.web.reactive.socket.server.upgrade.ReactorNettyRequestUpgradeStrategy</code></a> 类里。</li><li>【第一步】 ReactorNettyRequestUpgradeStrategy 调用 <a href="https://github.com/reactor/reactor-netty/blob/master/src/main/java/reactor/ipc/netty/http/server/HttpServerWSOperations.java" rel="external nofollow noopener noreferrer" target="_blank"><code>reactor.ipc.netty.http.server.HttpServerWSOperations</code></a> ，处理客户端发起的连接请求。处理成功，告知客户端连接成功。</li><li>【第二步】ReactorNettyRequestUpgradeStrategy 调用 <a href="https://github.com/spring-projects/spring-framework/blob/8f69b5ff23d6835eee89a26c0e1e3e63a64a21a0/spring-webflux/src/main/java/org/springframework/web/reactive/socket/WebSocketHandler.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.springframework.web.reactive.socket.server.upgrade.ReactorNettyRequestUpgradeStrategy</code></a> <strong>接口</strong>的 <code>#handle(WebSocketSession)</code> 方法，处理客户端 WebSocket Session 。ProxyWebSocketHandler 是 WebSocketHandler 的<strong>实现类</strong>，在 <a href="#">「3.1 ProxyWebSocketHandler」</a> 来详细解析 <code>#handle(WebSocketSession)</code> 实现了什么逻辑。</li></ul></li></ul><h2 id="3-1-ProxyWebSocketHandler"><a href="#3-1-ProxyWebSocketHandler" class="headerlink" title="3.1 ProxyWebSocketHandler"></a>3.1 ProxyWebSocketHandler</h2><p><code>org.springframework.cloud.gateway.filter.WebsocketRoutingFilter.ProxyWebSocketHandler</code> ，<strong>代理</strong>后端 WebSocket 服务处理器。</p><p><strong>构造方法</strong>，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyWebSocketHandler</span> <span class="keyword">implements</span> <span class="title">WebSocketHandler</span> </span>&#123;</div><div class="line"> <span class="number">2</span>: </div><div class="line"> <span class="number">3</span>: <span class="keyword">private</span> <span class="keyword">final</span> WebSocketClient client;</div><div class="line"> <span class="number">4</span>: <span class="keyword">private</span> <span class="keyword">final</span> URI url;</div><div class="line"> <span class="number">5</span>: <span class="keyword">private</span> <span class="keyword">final</span> HttpHeaders headers;</div><div class="line"> <span class="number">6</span>: <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; subProtocols;</div><div class="line"> <span class="number">7</span>: </div><div class="line"> <span class="number">8</span>: <span class="function"><span class="keyword">public</span> <span class="title">ProxyWebSocketHandler</span><span class="params">(URI url, WebSocketClient client, HttpHeaders headers)</span> </span>&#123;</div><div class="line"> <span class="number">9</span>: <span class="keyword">this</span>.client = client;</div><div class="line"><span class="number">10</span>: <span class="keyword">this</span>.url = url;</div><div class="line"><span class="number">11</span>: <span class="keyword">this</span>.headers = <span class="keyword">new</span> HttpHeaders();<span class="comment">//headers;</span></div><div class="line"><span class="number">12</span>: <span class="comment">//<span class="doctag">TODO:</span> better strategy to filter these headers?</span></div><div class="line"><span class="number">13</span>: headers.entrySet().forEach(header -&gt; &#123;</div><div class="line"><span class="number">14</span>: <span class="keyword">if</span> (!header.getKey().toLowerCase().startsWith(<span class="string">"sec-websocket"</span>)</div><div class="line"><span class="number">15</span>: &amp;&amp; !header.getKey().equalsIgnoreCase(<span class="string">"upgrade"</span>)</div><div class="line"><span class="number">16</span>: &amp;&amp; !header.getKey().equalsIgnoreCase(<span class="string">"connection"</span>)) &#123;</div><div class="line"><span class="number">17</span>: <span class="keyword">this</span>.headers.addAll(header.getKey(), header.getValue());</div><div class="line"><span class="number">18</span>: &#125;</div><div class="line"><span class="number">19</span>: &#125;);</div><div class="line"><span class="number">20</span>: List&lt;String&gt; protocols = headers.get(SEC_WEBSOCKET_PROTOCOL);</div><div class="line"><span class="number">21</span>: <span class="keyword">if</span> (protocols != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">22</span>: <span class="keyword">this</span>.subProtocols = protocols;</div><div class="line"><span class="number">23</span>: &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">24</span>: <span class="keyword">this</span>.subProtocols = Collections.emptyList();</div><div class="line"><span class="number">25</span>: &#125;</div><div class="line"><span class="number">26</span>: &#125;</div><div class="line"><span class="number">27</span>: &#125;</div></pre></td></tr></table></figure><ul><li><code>client</code> 属性，在 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/init/?self">《Spring-Cloud-Gateway 源码解析 —— 网关初始化》「5.2 初始化 NettyConfiguration」</a> 一文中，我们可以看到使用的是 <code>org.springframework.web.reactive.socket.client.ReactorNettyWebSocketClient</code> 实现类。通过该属性，<strong>连接后端【被代理】的 WebSocket 服务</strong>。</li><li><code>url</code> 属性，后端【被代理】的 WebSocket 服务的地址。</li><li><code>header</code> 属性，请求头，在 <a href="http://blog.csdn.net/baiye_xing/article/details/73938360" rel="external nofollow noopener noreferrer" target="_blank">《 【计网】HTTP与WebSocket的区别》</a> 有详细解析，包括为什么【第 14 至 18 行】的代码这样处理。</li><li><code>subProtocols</code> 属性，最终通信使用的协议。</li></ul><hr><p><code>#handle(WebSocketSession)</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">2</span>: <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">handle</span><span class="params">(WebSocketSession session)</span> </span>&#123;</div><div class="line"> <span class="number">3</span>: <span class="comment">// pass headers along so custom headers can be sent through</span></div><div class="line"> <span class="number">4</span>: <span class="keyword">return</span> client.execute(url, <span class="keyword">this</span>.headers, <span class="keyword">new</span> WebSocketHandler() &#123;</div><div class="line"> <span class="number">5</span>: <span class="meta">@Override</span></div><div class="line"> <span class="number">6</span>: <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">handle</span><span class="params">(WebSocketSession proxySession)</span> </span>&#123;</div><div class="line"> <span class="number">7</span>: <span class="comment">// Use retain() for Reactor Netty</span></div><div class="line"> <span class="number">8</span>: <span class="comment">// 转发消息 客户端 =》后端服务</span></div><div class="line"> <span class="number">9</span>: Mono&lt;Void&gt; proxySessionSend = proxySession</div><div class="line"><span class="number">10</span>: .send(session.receive().doOnNext(WebSocketMessage::retain));</div><div class="line"><span class="number">11</span>: <span class="comment">// 转发消息 后端服务=》客户端</span></div><div class="line"><span class="number">12</span>: <span class="comment">// .log("proxySessionSend", Level.FINE);</span></div><div class="line"><span class="number">13</span>: Mono&lt;Void&gt; serverSessionSend = session</div><div class="line"><span class="number">14</span>: .send(proxySession.receive().doOnNext(WebSocketMessage::retain));</div><div class="line"><span class="number">15</span>: <span class="comment">// .log("sessionSend", Level.FINE);</span></div><div class="line"><span class="number">16</span>: </div><div class="line"><span class="number">17</span>: <span class="comment">// </span></div><div class="line"><span class="number">18</span>: <span class="keyword">return</span> Mono.when(proxySessionSend, serverSessionSend).then();</div><div class="line"><span class="number">19</span>: &#125;</div><div class="line"><span class="number">20</span>: </div><div class="line"><span class="number">21</span>: <span class="comment">/**</span></div><div class="line"><span class="comment">22:  * Copy subProtocols so they are available downstream.</span></div><div class="line"><span class="comment">23:  * <span class="doctag">@return</span></span></div><div class="line"><span class="comment">24:  */</span></div><div class="line"><span class="number">25</span>: <span class="meta">@Override</span></div><div class="line"><span class="number">26</span>: <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getSubProtocols</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">27</span>: <span class="keyword">return</span> ProxyWebSocketHandler.<span class="keyword">this</span>.subProtocols;</div><div class="line"><span class="number">28</span>: &#125;</div><div class="line"><span class="number">29</span>: &#125;);</div><div class="line"><span class="number">30</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 6 行 ：调用 <code>WebSocketClient#execute(URI, HttpHeaders, WebSocketHandler)</code> 方法，<strong>连接后端【被代理】的 WebSocket 服务</strong>。连接成功后，回调 WebSocketHandler 实现的内部类的 <code>#handle(WebSocketSession)</code> 方法。</li><li>WebSocketHandler 实现的内部类 <ul><li>第 9 至 10 行 ：转发消息，客户端 <code>=&gt;</code> 后端服务。</li><li>第 13 至 14 行 ：转发消息，后端服务 <code>=&gt;</code> 客户端。</li><li>第 18 行 ：调用 <code>Mono#when()</code> 方法，合并 <code>proxySessionSend</code> / <code>serverSessionSend</code> 两个 Mono 。调用 <code>Mono#then()</code> 方法，<strong>参数为空</strong>，合并的 Mono 不发射数据出来。RxJava 和 Reactor 类似，可以参考 <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/And.html" rel="external nofollow noopener noreferrer" target="_blank">《ReactiveX文档中文翻译 —— And/Then/When》</a> 学习下 <code>when / and / then</code> 操作符。</li><li>下图可以帮助理解下这个类的用途 ：<img src="http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_03_25/01.png" alt=""></li></ul></li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>😈 限于对 Reactor 和 Netty 了解不够深入，写的不够透彻。回头深入理解下它们。</p><p><img src="http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_03_25/03.png" alt=""></p><p>胖友，分享一波朋友圈可好！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要: 原创出处 &lt;a href=&quot;http://www.iocoder.cn/Spring-Cloud-Gateway/filter-websocket-routing/&quot;&gt;http://www.iocoder.cn/Spring-Cloud-Gateway/filter
      
    
    </summary>
    
      <category term="Spring-Cloud-Gateway" scheme="http://www.iocoder.cn/categories/Spring-Cloud-Gateway/"/>
    
    
  </entry>
  
</feed>
