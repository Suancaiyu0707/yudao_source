<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="google-site-verification" content="GkJ68PCnxM9Ih7Zm9v8p91FOCV7ymNCO2KdGbflLh3E"><meta name="360-site-verification" content="dd6547587641bfede036f7c79561e8a0"><meta name="shenma-site-verification" content="fd96cf3751972c9b05f8471d2ccadddc_1496951214"><meta name="msvalidate.01" content="1D38B05050A977F6FDEDA481198343F1"><meta name="sogou_site_verification" content="MpPsku240L"><title>Hystrix 源码解析 —— 命令合并执行 | 芋道源码 —— 纯源码解析博客</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=3,minimum-scale=1"><meta name="author" content="芋道源码"><meta name="description" content="摘要: 原创出处 http://www.iocoder.cn/Hystrix/command-collapser-execute/ 「芋道源码」欢迎转载，保留摘要，谢谢！
本文主要基于 Hystrix 1.5.X 版本  

1. 概述
2. HystrixCollapser
2.1 构造方法
2."><meta name="keywords" content="Java,架构,后端,服务端,RocketMQ,MyCAT,分布式消息队列,分布式存储,技术博客,Sharding-JDBC,分库分表"><link rel="alternate" href="atom.xml" title="芋道源码 —— 纯源码解析博客" type="application/atom+xml"><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/style.css"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?9e70e3362807c1bd185a79655b307027";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script>!function(){var t="http:"==document.location.protocol?"http://js.passport.qihucdn.com/11.0.1.js?f05b61dd54bbc38386611a5238672938":"https://jspassport.ssl.qhimg.com/11.0.1.js?f05b61dd54bbc38386611a5238672938";document.write('<script src="'+t+'" id="sozz"><\/script>')}()</script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></head></html><body><header><div><div id="textlogo"><h1 class="site-name"><a href="/" title="芋道源码 —— 纯源码解析博客">芋道源码 —— 纯源码解析博客</a></h1><a class="blog-motto">愿半生编码，如一生老友！</a></div><div class="navbar"><a class="navbutton navmobile" href="#" title="菜单"></a></div><nav class="animated"><ul><ul><li><a href="/">文章</a></li><li><a href="/2018-meet-you">知识星球</a></li><li><a href="https://github.com/YunaiV" rel="external nofollow noopener noreferrer" target="_blank">Github</a></li><li><a href="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31_bak.jpg">微信公众号</a></li><li><a href="/categories/%E5%B7%A5%E4%BD%9C%E5%86%85%E6%8E%A8/">工作内推</a></li><li><a href="/link_url">友链</a></li></ul></ul></nav></div></header><div id="container"><div id="main" class="post" itemscope="" itemprop="blogPost"><article itemprop="articleBody"><header class="article-info clearfix"><h1 itemprop="name"><a href="/Hystrix/command-collapser-execute/" title="Hystrix 源码解析 —— 命令合并执行" itemprop="url">Hystrix 源码解析 —— 命令合并执行</a></h1><p class="article-author"></p><p class="article-time">总阅读量:<span id="busuanzi_value_page_pv"></span>次</p></header><div class="article-content"><p>摘要: 原创出处 <a href="http://www.iocoder.cn/Hystrix/command-collapser-execute/">http://www.iocoder.cn/Hystrix/command-collapser-execute/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 Hystrix 1.5.X 版本</strong></p><ul><li><a href="http://www.iocoder.cn/Hystrix/command-collapser-execute/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-collapser-execute/">2. HystrixCollapser</a><ul><li><a href="http://www.iocoder.cn/Hystrix/command-collapser-execute/">2.1 构造方法</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-collapser-execute/">2.2 执行命令方式</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-collapser-execute/">2.3 核心方法</a></li></ul></li><li><a href="http://www.iocoder.cn/Hystrix/command-collapser-execute/">3. RequestCollapserFactory</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-collapser-execute/">4. RequestCollapser</a><ul><li><a href="http://www.iocoder.cn/Hystrix/command-collapser-execute/">4.1 构造方法</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-collapser-execute/">4.2 RequestBatch</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-collapser-execute/">4.3 #submitRequest(arg)</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-collapser-execute/">4.4 #createNewBatchAndExecutePreviousIfNeeded(previousBatch)</a></li></ul></li><li><a href="http://www.iocoder.cn/Hystrix/command-collapser-execute/">5. CollapserTimer</a><ul><li><a href="http://www.iocoder.cn/Hystrix/command-collapser-execute/">5.1 RealCollapserTimer</a></li><li><a href="http://www.iocoder.cn/Hystrix/command-collapser-execute/">5.2 CollapsedTask</a></li></ul></li><li><a href="http://www.iocoder.cn/Hystrix/command-collapser-execute/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Hystrix 命令合并执行</strong>。</p><p>在 <a href="http://youdang.github.io/2016/02/05/translate-hystrix-wiki-how-it-works/#请求合并" rel="external nofollow noopener noreferrer" target="_blank">《【翻译】Hystrix文档-实现原理》「请求合并」</a> 中，对 Hystrix 命令合并执行的<strong>概念</strong>、<strong>原理</strong>、<strong>使用场景</strong>、<strong>优缺点</strong>已经做了非常详细透彻的分享，所以胖友可以先认真阅读学习下。</p><p>命令合并执行整体流程如下图 ：</p><blockquote><p>FROM <a href="http://youdang.github.io/2016/02/05/translate-hystrix-wiki-how-it-works/#请求合并" rel="external nofollow noopener noreferrer" target="_blank">《【翻译】Hystrix文档-实现原理》「请求合并」</a><br><img src="http://www.iocoder.cn/images/Hystrix/2018_11_04/01.jpeg" alt=""></p></blockquote><ul><li>第一步，提交<strong>单个</strong>命令请求到请求队列( RequestQueue )</li><li>第二部，定时任务( TimerTask ) <strong>固定周期</strong>从请求队列获取<strong>多个</strong>命令执行，合并执行。</li></ul><p>在官方提供的示例中，我们通过 <a href="https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-examples/src/main/java/com/netflix/hystrix/examples/basic/CommandCollapserGetValueForKey.java" rel="external nofollow noopener noreferrer" target="_blank">CommandCollapserGetValueForKey</a> 熟悉命令合并执行的使用。</p><hr><p><strong>推荐 Spring Cloud 书籍</strong>：</p><ul><li>请支持正版。下载盗版，<strong>等于主动编写低级 BUG</strong> 。</li><li>程序猿DD —— <a href="https://union-click.jd.com/jdc?d=505Twi" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud微服务实战》</a></li><li>周立 —— <a href="https://union-click.jd.com/jdc?d=k3sAaK" rel="external nofollow noopener noreferrer" target="_blank">《Spring Cloud与Docker微服务架构实战》</a></li><li>两书齐买，京东包邮。</li></ul><p><strong>推荐 Spring Cloud 视频</strong>：</p><ul><li><a href="https://segmentfault.com/ls/1650000011063780?r=bPN0Ir" rel="external nofollow noopener noreferrer" target="_blank">Java 微服务实践 - Spring Boot</a></li><li><a href="https://segmentfault.com/ls/1650000011386794?r=bPN0Ir" rel="external nofollow noopener noreferrer" target="_blank">Java 微服务实践 - Spring Cloud</a></li><li><a href="https://segmentfault.com/ls/1650000011387052?r=bPN0Ir" rel="external nofollow noopener noreferrer" target="_blank">Java 微服务实践 - Spring Boot / Spring Cloud</a></li></ul><h1 id="2-HystrixCollapser"><a href="#2-HystrixCollapser" class="headerlink" title="2. HystrixCollapser"></a>2. HystrixCollapser</h1><p><code>com.netflix.hystrix.HystrixCollapser</code> ，<strong>命令</strong>合并器<strong>抽象父类</strong>。</p><blockquote><p>NOTE ：<code>com.netflix.hystrix.HystrixObservableCollapser</code> ，<strong>另一种</strong>命令合并器<strong>抽象父类</strong>，本文暂不解析。</p></blockquote><h2 id="2-1-构造方法"><a href="#2-1-构造方法" class="headerlink" title="2.1 构造方法"></a>2.1 构造方法</h2><p>HystrixCollapser <strong>构造方法</strong>，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixCollapser</span>&lt;<span class="title">BatchReturnType</span>, <span class="title">ResponseType</span>, <span class="title">RequestArgumentType</span>&gt;</span></div><div class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">HystrixExecutable</span>&lt;<span class="title">ResponseType</span>&gt;, <span class="title">HystrixObservable</span>&lt;<span class="title">ResponseType</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RequestCollapserFactory&lt;BatchReturnType, ResponseType, RequestArgumentType&gt; collapserFactory;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HystrixRequestCache requestCache;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HystrixCollapserBridge&lt;BatchReturnType, ResponseType, RequestArgumentType&gt; collapserInstanceWrapper;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HystrixCollapserMetrics metrics;</div><div class="line">    </div><div class="line">    <span class="comment">/* package for tests */</span> HystrixCollapser(HystrixCollapserKey collapserKey, Scope scope, CollapserTimer timer, HystrixCollapserProperties.Setter propertiesBuilder, HystrixCollapserMetrics metrics) &#123;</div><div class="line">        <span class="keyword">if</span> (collapserKey == <span class="keyword">null</span> || collapserKey.name().trim().equals(<span class="string">""</span>)) &#123;</div><div class="line">            String defaultKeyName = getDefaultNameFromClass(getClass());</div><div class="line">            collapserKey = HystrixCollapserKey.Factory.asKey(defaultKeyName);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        HystrixCollapserProperties properties = HystrixPropertiesFactory.getCollapserProperties(collapserKey, propertiesBuilder);</div><div class="line">        <span class="keyword">this</span>.collapserFactory = <span class="keyword">new</span> RequestCollapserFactory&lt;BatchReturnType, ResponseType, RequestArgumentType&gt;(collapserKey, scope, timer, properties);</div><div class="line">        <span class="keyword">this</span>.requestCache = HystrixRequestCache.getInstance(collapserKey, HystrixPlugins.getInstance().getConcurrencyStrategy());</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (metrics == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">this</span>.metrics = HystrixCollapserMetrics.getInstance(collapserKey, properties);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">this</span>.metrics = metrics;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> HystrixCollapser&lt;BatchReturnType, ResponseType, RequestArgumentType&gt; self = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">         <span class="comment">/* strategy: HystrixMetricsPublisherCollapser */</span></div><div class="line">        HystrixMetricsPublisherFactory.createOrRetrievePublisherForCollapser(collapserKey, <span class="keyword">this</span>.metrics, properties);</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * Used to pass public method invocation to the underlying implementation in a separate package while leaving the methods 'protected' in this class.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        collapserInstanceWrapper = <span class="keyword">new</span> HystrixCollapserBridge&lt;BatchReturnType, ResponseType, RequestArgumentType&gt;() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="keyword">public</span> Collection&lt;Collection&lt;CollapsedRequest&lt;ResponseType, RequestArgumentType&gt;&gt;&gt; shardRequests(Collection&lt;CollapsedRequest&lt;ResponseType, RequestArgumentType&gt;&gt; requests) &#123;</div><div class="line">                Collection&lt;Collection&lt;CollapsedRequest&lt;ResponseType, RequestArgumentType&gt;&gt;&gt; shards = self.shardRequests(requests);</div><div class="line">                self.metrics.markShards(shards.size());</div><div class="line">                <span class="keyword">return</span> shards;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;BatchReturnType&gt; <span class="title">createObservableCommand</span><span class="params">(Collection&lt;CollapsedRequest&lt;ResponseType, RequestArgumentType&gt;&gt; requests)</span> </span>&#123;</div><div class="line">                <span class="keyword">final</span> HystrixCommand&lt;BatchReturnType&gt; command = self.createCommand(requests);</div><div class="line"></div><div class="line">                command.markAsCollapsedCommand(<span class="keyword">this</span>.getCollapserKey(), requests.size());</div><div class="line">                self.metrics.markBatch(requests.size());</div><div class="line"></div><div class="line">                <span class="keyword">return</span> command.toObservable();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;Void&gt; <span class="title">mapResponseToRequests</span><span class="params">(Observable&lt;BatchReturnType&gt; batchResponse, <span class="keyword">final</span> Collection&lt;CollapsedRequest&lt;ResponseType, RequestArgumentType&gt;&gt; requests)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> batchResponse.single().doOnNext(<span class="keyword">new</span> Action1&lt;BatchReturnType&gt;() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(BatchReturnType batchReturnType)</span> </span>&#123;</div><div class="line">                        <span class="comment">// this is a blocking call in HystrixCollapser</span></div><div class="line">                        self.mapResponseToRequests(batchReturnType, requests);</div><div class="line">                    &#125;</div><div class="line">                &#125;).ignoreElements().cast(Void.class);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> HystrixCollapserKey <span class="title">getCollapserKey</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> self.getCollapserKey();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>BatchReturnType <strong>泛型</strong>，<strong>多个</strong>命令合并执行返回结果类型。</li><li>ResponseType <strong>泛型</strong>，<strong>单个</strong>命令执行返回结果类型。</li><li>RequestArgumentType <strong>泛型</strong>，<strong>单个</strong>命令参数类型。</li><li><code>collapserFactory</code> 属性，RequestCollapser <strong>工厂</strong>，在 <a href="#">「3. RequestCollapserFactory」</a> 详细解析。</li><li><code>requestCache</code> 属性，TODO 【2012】【请求上下文】</li><li><code>collapserInstanceWrapper</code> 属性，<strong>命令</strong>合并器包装器。<ul><li><code>com.netflix.hystrix.collapser.HystrixCollapserBridge</code> <strong>接口</strong>，点击 <a href="https://github.com/YunaiV/Hystrix/blob/dc176978c2beb2465ba4edb37d0024e388f15d5d/hystrix-core/src/main/java/com/netflix/hystrix/collapser/HystrixCollapserBridge.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看代码。</li><li>HystrixCollapserBridge ，为 RequestBatch <strong>透明</strong>调用 HystrixCollapser 或 HystrixObservableCollapser 的方法不同的实现。参见 <a href="http://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/bridge.html" rel="external nofollow noopener noreferrer" target="_blank">《桥接模式》</a> 。</li></ul></li><li><code>metrics</code> 属性，TODO 【2002】【metrics】</li></ul><h2 id="2-2-执行命令方式"><a href="#2-2-执行命令方式" class="headerlink" title="2.2 执行命令方式"></a>2.2 执行命令方式</h2><p>在 <a href="http://www.iocoder.cn/Hystrix/command-execute-mode/?self">《Hystrix 源码解析 —— 执行命令方式》</a> 中，我们已经看了 HystrixCommand 提供的<strong>四种</strong>执行命令方式。</p><p>HystrixCollapser 类似于 HystrixCommand ，也提供<strong>四种</strong>相同的执行命令方式，其中如下三种方式代码基本<strong>类似</strong>，我们就给下<strong>传送门</strong>，就不重复啰嗦了 ：</p><ul><li><code>#observe()</code> 方法 ：<a href="https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java#L336" rel="external nofollow noopener noreferrer" target="_blank">传送门</a> 。</li><li><code>#queue()</code> 方法 ：<a href="https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java#L456" rel="external nofollow noopener noreferrer" target="_blank">传送门</a> 。</li><li><code>#execute()</code> 方法 ：<a href="https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java#L426" rel="external nofollow noopener noreferrer" target="_blank">传送门</a> 。</li></ul><p>下面一起来看看 <code>#toObservable()</code> 方法的实现，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> Observable&lt;ResponseType&gt; <span class="title">toObservable</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// when we callback with the data we want to do the work</span></div><div class="line"> <span class="number">3</span>:     <span class="comment">// on a separate thread than the one giving us the callback</span></div><div class="line"> <span class="number">4</span>:     <span class="keyword">return</span> toObservable(Schedulers.computation());</div><div class="line"> <span class="number">5</span>: &#125;</div><div class="line"> <span class="number">6</span>: </div><div class="line"> <span class="number">7</span>: <span class="function"><span class="keyword">public</span> Observable&lt;ResponseType&gt; <span class="title">toObservable</span><span class="params">(Scheduler observeOn)</span> </span>&#123;</div><div class="line"> <span class="number">8</span>:     <span class="keyword">return</span> Observable.defer(<span class="keyword">new</span> Func0&lt;Observable&lt;ResponseType&gt;&gt;() &#123;</div><div class="line"> <span class="number">9</span>:         <span class="meta">@Override</span></div><div class="line"><span class="number">10</span>:         <span class="function"><span class="keyword">public</span> Observable&lt;ResponseType&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="number">11</span>:             <span class="comment">// // 缓存开关、缓存KEY</span></div><div class="line"><span class="number">12</span>:             <span class="keyword">final</span> <span class="keyword">boolean</span> isRequestCacheEnabled = getProperties().requestCacheEnabled().get();</div><div class="line"><span class="number">13</span>:             <span class="keyword">final</span> String cacheKey = getCacheKey();</div><div class="line"><span class="number">14</span>: </div><div class="line"><span class="number">15</span>:             <span class="comment">// 优先从缓存中获取</span></div><div class="line"><span class="number">16</span>:             <span class="comment">/* try from cache first */</span></div><div class="line"><span class="number">17</span>:             <span class="keyword">if</span> (isRequestCacheEnabled) &#123;</div><div class="line"><span class="number">18</span>:                 HystrixCachedObservable&lt;ResponseType&gt; fromCache = requestCache.get(cacheKey);</div><div class="line"><span class="number">19</span>:                 <span class="keyword">if</span> (fromCache != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">20</span>:                     metrics.markResponseFromCache();</div><div class="line"><span class="number">21</span>:                     <span class="keyword">return</span> fromCache.toObservable();</div><div class="line"><span class="number">22</span>:                 &#125;</div><div class="line"><span class="number">23</span>:             &#125;</div><div class="line"><span class="number">24</span>: </div><div class="line"><span class="number">25</span>:             <span class="comment">// 获得 RequestCollapser</span></div><div class="line"><span class="number">26</span>:             RequestCollapser&lt;BatchReturnType, ResponseType, RequestArgumentType&gt; requestCollapser = collapserFactory.getRequestCollapser(collapserInstanceWrapper);</div><div class="line"><span class="number">27</span>: </div><div class="line"><span class="number">28</span>:             <span class="comment">// 提交 命令请求</span></div><div class="line"><span class="number">29</span>:             Observable&lt;ResponseType&gt; response = requestCollapser.submitRequest(getRequestArgument());</div><div class="line"><span class="number">30</span>: </div><div class="line"><span class="number">31</span>:             <span class="comment">// 获得 缓存Observable</span></div><div class="line"><span class="number">32</span>:             <span class="keyword">if</span> (isRequestCacheEnabled &amp;&amp; cacheKey != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">33</span>:                 HystrixCachedObservable&lt;ResponseType&gt; toCache = HystrixCachedObservable.from(response);</div><div class="line"><span class="number">34</span>:                 HystrixCachedObservable&lt;ResponseType&gt; fromCache = requestCache.putIfAbsent(cacheKey, toCache);</div><div class="line"><span class="number">35</span>:                 <span class="keyword">if</span> (fromCache == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">36</span>:                     <span class="keyword">return</span> toCache.toObservable();</div><div class="line"><span class="number">37</span>:                 &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">38</span>:                     toCache.unsubscribe(); <span class="comment">// 取消订阅</span></div><div class="line"><span class="number">39</span>:                     <span class="keyword">return</span> fromCache.toObservable();</div><div class="line"><span class="number">40</span>:                 &#125;</div><div class="line"><span class="number">41</span>:             &#125;</div><div class="line"><span class="number">42</span>: </div><div class="line"><span class="number">43</span>:             <span class="comment">// 获得 非缓存Observable</span></div><div class="line"><span class="number">44</span>:             <span class="keyword">return</span> response;</div><div class="line"><span class="number">45</span>:         &#125;</div><div class="line"><span class="number">46</span>:     &#125;);</div><div class="line"><span class="number">47</span>: &#125;</div></pre></td></tr></table></figure><ul><li><code>observeOn</code> 方法参数，实际方法暂未用到，跳过无视。</li><li>第 11 至 13 行 ：缓存存开关、KEY 。</li><li>【<em>反向</em>】第 32 至 41 行 ：获得【缓存 Observable】。这块代码和 <code>AbstractCommand#toObservavle(...)</code> 类似，在 <a href="http://www.iocoder.cn/Hystrix/command-execute-result-cache/?self">《Hystrix 源码解析 —— 执行结果缓存》「4. AbstractCommand#toObservavle(…)」</a> 有详细解析。</li><li>【<em>反向</em>】第 44 行 ：获得【非缓存 Observable】。</li><li>注意 ：返回的 Observable ，很可能命令实际并未执行，或者说并未执行完成，此时在 <code>#queue()</code> / <code>#execute()</code> 方法，通过 BlockingObservable <strong>阻塞</strong>等待执行完成。BlockingObservable 在 <a href="http://www.iocoder.cn/RxJava/blocking-observable/?self">《RxJava 源码解析 —— BlockingObservable》</a> 有详细解析。</li><li>第 26 行 ：调用 <code>RequestCollapserFactory#getRequestCollapser()</code> ，获得 RequestCollapser 。在 <a href="#">「3. RequestCollapserFactory」</a> 详细解析。</li><li>第 29 行 ：提交<strong>单个</strong>命令请求到请求队列( RequestQueue )，即<strong>命令合并执行整体流程第一步</strong>。在 <a href="#">「4. RequestCollapser」</a> 详细解析。</li></ul><h2 id="2-3-核心方法"><a href="#2-3-核心方法" class="headerlink" title="2.3 核心方法"></a>2.3 核心方法</h2><ul><li><p><code>#getRequestArgument(...)</code> <strong>抽象</strong>方法，获得<strong>单个</strong>命令参数。代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> RequestArgumentType <span class="title">getRequestArgument</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure></li></ul><hr><ul><li><p><code>#createCommand(...)</code> <strong>抽象</strong>方法，将<strong>多个</strong>命令请求<strong>合并</strong>，创建<strong>一个</strong> HystrixCommand 。代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> HystrixCommand&lt;BatchReturnType&gt; <span class="title">createCommand</span><span class="params">(Collection&lt;CollapsedRequest&lt;ResponseType, RequestArgumentType&gt;&gt; requests)</span></span>;</div></pre></td></tr></table></figure></li></ul><hr><ul><li><p><code>#mapResponseToRequests(...)</code> <strong>抽象</strong>方法，将<strong>一个</strong> HystrixCommand 的执行结果，<strong>映射</strong>回对应的命令请求们。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">mapResponseToRequests</span><span class="params">(BatchReturnType batchResponse, Collection&lt;CollapsedRequest&lt;ResponseType, RequestArgumentType&gt;&gt; requests)</span></span>;</div></pre></td></tr></table></figure></li></ul><hr><ul><li><p><code>#shardRequests(...)</code> 方法，将<strong>多个</strong>命令请求<strong>分片</strong>成 <strong>N</strong> 个【<strong>多个</strong>命令请求】。默认实现下，不进行分片。代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">protected</span> Collection&lt;Collection&lt;CollapsedRequest&lt;ResponseType, RequestArgumentType&gt;&gt;&gt; shardRequests(Collection&lt;CollapsedRequest&lt;ResponseType, RequestArgumentType&gt;&gt; requests) &#123;</div><div class="line">    <span class="keyword">return</span> Collections.singletonList(requests);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><hr><ul><li><p>在<strong>未重写</strong> <code>#shardRequests(...)</code> 的情况下，整体方法流程如下 ：</p><p><img src="http://www.iocoder.cn/images/Hystrix/2018_11_04/02.png" alt=""></p></li><li><p>在<strong>重写</strong> <code>#shardRequests(...)</code> 的情况下，整体方法流程如下 ：</p><p><img src="http://www.iocoder.cn/images/Hystrix/2018_11_04/03.png" alt=""></p><ul><li>本图中命令请求分片仅仅是例子，实际根据重写的逻辑不同而不同。</li></ul></li></ul><h1 id="3-RequestCollapserFactory"><a href="#3-RequestCollapserFactory" class="headerlink" title="3. RequestCollapserFactory"></a>3. RequestCollapserFactory</h1><p><code>com.netflix.hystrix.collapser.RequestCollapserFactory</code> ，RequestCollapser <strong>工厂</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestCollapserFactory</span>&lt;<span class="title">BatchReturnType</span>, <span class="title">ResponseType</span>, <span class="title">RequestArgumentType</span>&gt; </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CollapserTimer timer;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HystrixCollapserKey collapserKey;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HystrixCollapserProperties properties;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HystrixConcurrencyStrategy concurrencyStrategy;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Scope scope;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RequestCollapserFactory</span><span class="params">(HystrixCollapserKey collapserKey, Scope scope, CollapserTimer timer, HystrixCollapserProperties properties)</span> </span>&#123;</div><div class="line">         <span class="comment">/* strategy: ConcurrencyStrategy */</span></div><div class="line">        <span class="keyword">this</span>.concurrencyStrategy = HystrixPlugins.getInstance().getConcurrencyStrategy();</div><div class="line">        <span class="keyword">this</span>.timer = timer;</div><div class="line">        <span class="keyword">this</span>.scope = scope;</div><div class="line">        <span class="keyword">this</span>.collapserKey = collapserKey;</div><div class="line">        <span class="keyword">this</span>.properties = properties;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><ul><li><code>timer</code> 属性，命令合并器的定时器，在 <a href="#">「5. CollapserTimer」</a> 详细解析。</li><li><code>collapserKey</code> 属性，命令合并器标识，实现类似 HystrixThreadPoolKey 。<ul><li>HystrixCollapserKey ，点击 <a href="https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapserKey.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看代码。</li><li>HystrixThreadPoolKey ，在 <a href="http://www.iocoder.cn/Hystrix/command-execute-second-isolation-strategy/?self">《Hystrix 源码解析 —— 命令执行（二）之执行隔离策略》「3. HystrixThreadPoolKey」</a> 有详细解析。</li></ul></li><li><code>properties</code> 属性，命令合并器属性配置。</li><li><code>concurrencyStrategy</code> 属性，并发策略，在 <a href="http://www.iocoder.cn/Hystrix/command-execute-second-isolation-strategy/?self">《Hystrix 源码解析 —— 命令执行（二）之执行隔离策略》「4. HystrixConcurrencyStrategy」</a> 有详细解析。</li><li><p><code>scope</code> 属性，命令请求作用域。目前有两种作用域 ：</p><ul><li><p><code>REQUEST</code> ：请求上下文( HystrixRequestContext )。</p><blockquote><p>Typically this means that requests within a single user-request (ie. HTTP request) are collapsed.<br>No interaction with other user requests.<br>1 queue per user request.</p></blockquote></li><li><p><code>GLOBAL</code> ：全局。</p><blockquote><p>Requests from any thread (ie. all HTTP requests) within the JVM will be collapsed.<br>1 queue for entire app.</p></blockquote></li></ul></li></ul><hr><p>调用 <code>#getRequestCollapser()</code> 方法，获得 RequestCollapser 。代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> RequestCollapser&lt;BatchReturnType, ResponseType, RequestArgumentType&gt; <span class="title">getRequestCollapser</span><span class="params">(HystrixCollapserBridge&lt;BatchReturnType, ResponseType, RequestArgumentType&gt; commandCollapser)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (Scopes.REQUEST == Scopes.valueOf(getScope().name())) &#123;</div><div class="line">       <span class="keyword">return</span> getCollapserForUserRequest(commandCollapser);</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Scopes.GLOBAL == Scopes.valueOf(getScope().name())) &#123;</div><div class="line">       <span class="keyword">return</span> getCollapserForGlobalScope(commandCollapser);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       logger.warn(<span class="string">"Invalid Scope: &#123;&#125;  Defaulting to REQUEST scope."</span>, getScope());</div><div class="line">       <span class="keyword">return</span> getCollapserForUserRequest(commandCollapser);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>根据 <code>scope</code> 不同，调用两个不同方法，获得 RequestCollapser 。这两个方法大体逻辑相同，优先从<strong>缓存</strong>中查找满足条件的 RequestCollapser 返回；若不存在，则创建满足条件的 RequestCollapser 添加到<strong>缓存</strong>并返回。<ul><li><code>REQUEST</code> ：调用 <code>#getCollapserForUserRequest()</code> 方法，TODO 【2012】【请求上下文】。</li><li><code>GLOBAL</code> ：调用 <code>#getCollapserForGlobalScope()</code> 方法，点击 <a href="https://github.com/YunaiV/Hystrix/blob/dc176978c2beb2465ba4edb37d0024e388f15d5d/hystrix-core/src/main/java/com/netflix/hystrix/collapser/RequestCollapserFactory.java#L97" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看<strong>中文注释</strong>的代码。</li></ul></li></ul><h1 id="4-RequestCollapser"><a href="#4-RequestCollapser" class="headerlink" title="4. RequestCollapser"></a>4. RequestCollapser</h1><p><code>com.netflix.hystrix.collapser.RequestCollapser</code> ，<strong>命令请求</strong>合并器。主要用于 ：</p><ul><li>提交<strong>单个</strong>命令请求到请求队列( RequestQueue )。</li><li>接收<strong>来自定时任务</strong>提交的<strong>多个</strong>命令，合并执行。</li></ul><h2 id="4-1-构造方法"><a href="#4-1-构造方法" class="headerlink" title="4.1 构造方法"></a>4.1 构造方法</h2><p>RequestCollapser <strong>构造方法</strong>，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestCollapser</span>&lt;<span class="title">BatchReturnType</span>, <span class="title">ResponseType</span>, <span class="title">RequestArgumentType</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HystrixCollapserBridge&lt;BatchReturnType, ResponseType, RequestArgumentType&gt; commandCollapser;</div><div class="line">    <span class="comment">// batch can be null once shutdown</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;RequestBatch&lt;BatchReturnType, ResponseType, RequestArgumentType&gt;&gt; batch = <span class="keyword">new</span> AtomicReference&lt;RequestBatch&lt;BatchReturnType, ResponseType, RequestArgumentType&gt;&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;Reference&lt;TimerListener&gt;&gt; timerListenerReference = <span class="keyword">new</span> AtomicReference&lt;Reference&lt;TimerListener&gt;&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean timerListenerRegistered = <span class="keyword">new</span> AtomicBoolean();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CollapserTimer timer;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HystrixCollapserProperties properties;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HystrixConcurrencyStrategy concurrencyStrategy;</div><div class="line">    </div><div class="line">    RequestCollapser(HystrixCollapserBridge&lt;BatchReturnType, ResponseType, RequestArgumentType&gt; commandCollapser, HystrixCollapserProperties properties, CollapserTimer timer, HystrixConcurrencyStrategy concurrencyStrategy) &#123;</div><div class="line">        <span class="keyword">this</span>.commandCollapser = commandCollapser; <span class="comment">// the command with implementation of abstract methods we need </span></div><div class="line">        <span class="keyword">this</span>.concurrencyStrategy = concurrencyStrategy;</div><div class="line">        <span class="keyword">this</span>.properties = properties;</div><div class="line">        <span class="keyword">this</span>.timer = timer;</div><div class="line">        batch.set(<span class="keyword">new</span> RequestBatch&lt;BatchReturnType, ResponseType, RequestArgumentType&gt;(properties, commandCollapser, properties.maxRequestsInBatch().get()));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>commandCollapser</code> 属性，<strong>命令</strong>合并器包装器。</li><li><code>batch</code> 属性，RequestBatch，<strong>即是本文一直说的请求队列</strong>。在 <a href="#">「4.2 RequestBatch」</a> 也会详细解析。</li><li><code>timerListenerReference</code> 属性，<strong>注册</strong>在命令合并器的定时器的监听器。每个 RequestCollapser <strong>独有一个</strong>监听器。该监听器( 实际上会使用该监听器创建定时任务 )<strong>固定周期</strong>从请求队列获取<strong>多个</strong>命令执行，提交 RequestCollapser 合并执行。在 <a href="#">「5. CollapserTimer」</a> 也会详细解析。</li><li><code>timerListenerRegistered</code> 属性，<code>timerListenerReference</code> 是否已经注册。</li><li><code>timer</code> 属性，命令合并器的定时器。</li><li><code>properties</code> 属性，命令合并器属性配置。</li><li><code>concurrencyStrategy</code> 属性，并发策略。</li></ul><h2 id="4-2-RequestBatch"><a href="#4-2-RequestBatch" class="headerlink" title="4.2 RequestBatch"></a>4.2 RequestBatch</h2><p><code>com.netflix.hystrix.collapser.RequestBatch</code> ，命令请求队列。提供如下功能 ：</p><ul><li>命令请求的添加</li><li>命令请求的移除</li><li>命令请求的<strong>批量执行</strong>。笔者把 RequestBatch 解释成 “命令请求队列”，主要方便大家理解。<ul><li>那可能有胖友有疑问，为啥该功能不在 RequestCollapser 直接实现，这样 RequestBatch 成为纯粹的队列呢？在 <a href="#">「4.4 #createNewBatchAndExecutePreviousIfNeeded(previousBatch)」</a> 详细解析。</li></ul></li></ul><p>RequestBatch <strong>构造方法</strong>，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestBatch</span>&lt;<span class="title">BatchReturnType</span>, <span class="title">ResponseType</span>, <span class="title">RequestArgumentType</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HystrixCollapserBridge&lt;BatchReturnType, ResponseType, RequestArgumentType&gt; commandCollapser;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxBatchSize;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean batchStarted = <span class="keyword">new</span> AtomicBoolean();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;RequestArgumentType, CollapsedRequest&lt;ResponseType, RequestArgumentType&gt;&gt; argumentMap =</div><div class="line">            <span class="keyword">new</span> ConcurrentHashMap&lt;RequestArgumentType, CollapsedRequest&lt;ResponseType, RequestArgumentType&gt;&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HystrixCollapserProperties properties;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> ReentrantReadWriteLock batchLock = <span class="keyword">new</span> ReentrantReadWriteLock();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RequestBatch</span><span class="params">(HystrixCollapserProperties properties, HystrixCollapserBridge&lt;BatchReturnType, ResponseType, RequestArgumentType&gt; commandCollapser, <span class="keyword">int</span> maxBatchSize)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.properties = properties;</div><div class="line">        <span class="keyword">this</span>.commandCollapser = commandCollapser;</div><div class="line">        <span class="keyword">this</span>.maxBatchSize = maxBatchSize;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>commandCollapser</code> 属性，<strong>命令</strong>合并器包装器。</li><li><code>maxBatchSize</code> 属性，队列最大长度。</li><li><code>batchStarted</code> 属性，执行是否开始。</li><li><code>argumentMap</code> 属性，命令请求参数映射( <strong>队列</strong> )。</li><li><code>properties</code> 属性，命令合并器属性配置。</li><li><code>batchLock</code> 属性，<code>argumentMap</code> 操作的<strong>读写锁</strong>。</li></ul><p>RequestBatch 实现队列具体的操作方法，在 <a href="#">「4.3 #submitRequest(arg)」</a>/<a href="#">「4.4 #createNewBatchAndExecutePreviousIfNeeded(previousBatch)」</a> 一起解析。</p><h2 id="4-3-submitRequest-arg"><a href="#4-3-submitRequest-arg" class="headerlink" title="4.3 #submitRequest(arg)"></a>4.3 #submitRequest(arg)</h2><p>在 <code>#toObservable()</code> 方法里，调用 <code>#submitRequest(arg)</code> 方法，提交<strong>单个</strong>命令请求到 RequestBatch 。代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> Observable&lt;ResponseType&gt; <span class="title">submitRequest</span><span class="params">(<span class="keyword">final</span> RequestArgumentType arg)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">/*</span></div><div class="line"><span class="comment"> 3:      * We only want the timer ticking if there are actually things to do so we register it the first time something is added.</span></div><div class="line"><span class="comment"> 4:      */</span></div><div class="line"> <span class="number">5</span>:     <span class="keyword">if</span> (!timerListenerRegistered.get() &amp;&amp; timerListenerRegistered.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</div><div class="line"> <span class="number">6</span>:         <span class="comment">/* schedule the collapsing task to be executed every x milliseconds (x defined inside CollapsedTask) */</span></div><div class="line"> <span class="number">7</span>:         timerListenerReference.set(timer.addListener(<span class="keyword">new</span> CollapsedTask()));</div><div class="line"> <span class="number">8</span>:     &#125;</div><div class="line"> <span class="number">9</span>: </div><div class="line"><span class="number">10</span>:     <span class="comment">// loop until succeed (compare-and-set spin-loop)</span></div><div class="line"><span class="number">11</span>:     <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line"><span class="number">12</span>:         <span class="comment">// 获得 RequestBatch</span></div><div class="line"><span class="number">13</span>:         <span class="keyword">final</span> RequestBatch&lt;BatchReturnType, ResponseType, RequestArgumentType&gt; b = batch.get();</div><div class="line"><span class="number">14</span>:         <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">15</span>:             <span class="keyword">return</span> Observable.error(<span class="keyword">new</span> IllegalStateException(<span class="string">"Submitting requests after collapser is shutdown"</span>));</div><div class="line"><span class="number">16</span>:         &#125;</div><div class="line"><span class="number">17</span>: </div><div class="line"><span class="number">18</span>:         <span class="comment">// 添加到 RequestBatch</span></div><div class="line"><span class="number">19</span>:         <span class="keyword">final</span> Observable&lt;ResponseType&gt; response;</div><div class="line"><span class="number">20</span>:         <span class="keyword">if</span> (arg != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">21</span>:             response = b.offer(arg);</div><div class="line"><span class="number">22</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">23</span>:             response = b.offer( (RequestArgumentType) NULL_SENTINEL);</div><div class="line"><span class="number">24</span>:         &#125;</div><div class="line"><span class="number">25</span>: </div><div class="line"><span class="number">26</span>:         <span class="comment">// 添加成功，返回 Observable</span></div><div class="line"><span class="number">27</span>:         <span class="comment">// it will always get an Observable unless we hit the max batch size</span></div><div class="line"><span class="number">28</span>:         <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">29</span>:             <span class="keyword">return</span> response;</div><div class="line"><span class="number">30</span>:         &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">31</span>:             <span class="comment">// 添加失败，执行 RequestBatch ，并创建新的 RequestBatch</span></div><div class="line"><span class="number">32</span>:             <span class="comment">// this batch can't accept requests so create a new one and set it if another thread doesn't beat us</span></div><div class="line"><span class="number">33</span>:             createNewBatchAndExecutePreviousIfNeeded(b);</div><div class="line"><span class="number">34</span>:         &#125;</div><div class="line"><span class="number">35</span>:     &#125;</div><div class="line"><span class="number">36</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 5 至 8 行 ：当 RequestCollapser 的监听任务( CollapsedTask )还未创建，进行初始化。</li><li>第 11 至 35 行 ：<strong>死循环</strong>，直到提交<strong>单个</strong>命令请求到 RequestBatch <strong>成功</strong>。<ul><li>第 13 至 16 行 ：获得 RequestBatch 。从目前代码看下来，除非 RequestCollapser 被 <code>#shutdown()</code> 后才会出现为 <code>null</code> 的情况。</li><li>第 19 至 24 行 ：调动 <code>RequestBatch#offer(...)</code> 方法，提交<strong>单个</strong>命令请求到 RequestBatch ，并获得 Observable 。这里对 <code>arg == null</code> 做了特殊处理，因为 <code>RequestBatch.argumentMap</code> 是 ConcurrentHashMap ，不允许值为 <code>null</code> 。另外，<code>RequestBatch#offer(...)</code> 方法的实现代码，在结束了当前方法，详细解析。</li><li>第 28 至 29 行 ：添加成功，返回 Observable 。</li><li>第 30 至 34 行 ：添加失败，执行当前 RequestBatch 的<strong>多个</strong>命令合并执行，并创建<strong>新的</strong> RequestBatch 。在 <a href="#">「4.4 #createNewBatchAndExecutePreviousIfNeeded(previousBatch)」</a> 详细解析。</li></ul></li></ul><hr><p><code>RequestBatch#offer(...)</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"> <span class="number">1</span>: <span class="function"><span class="keyword">public</span> Observable&lt;ResponseType&gt;  <span class="title">offer</span><span class="params">(RequestArgumentType arg)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>:     <span class="comment">// 执行已经开始，添加失败</span></div><div class="line"> <span class="number">3</span>:     <span class="comment">/* short-cut - if the batch is started we reject the offer */</span></div><div class="line"> <span class="number">4</span>:     <span class="keyword">if</span> (batchStarted.get()) &#123;</div><div class="line"> <span class="number">5</span>:         <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"> <span class="number">6</span>:     &#125;</div><div class="line"> <span class="number">7</span>: </div><div class="line"> <span class="number">8</span>:     <span class="comment">/*</span></div><div class="line"><span class="comment"> 9:      * The 'read' just means non-exclusive even though we are writing.</span></div><div class="line"><span class="comment">10:      */</span></div><div class="line"><span class="number">11</span>:     <span class="keyword">if</span> (batchLock.readLock().tryLock()) &#123;</div><div class="line"><span class="number">12</span>:         <span class="keyword">try</span> &#123;</div><div class="line"><span class="number">13</span>:             <span class="comment">// 执行已经开始，添加失败</span></div><div class="line"><span class="number">14</span>:             <span class="comment">/* double-check now that we have the lock - if the batch is started we reject the offer */</span></div><div class="line"><span class="number">15</span>:             <span class="keyword">if</span> (batchStarted.get()) &#123;</div><div class="line"><span class="number">16</span>:                 <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"><span class="number">17</span>:             &#125;</div><div class="line"><span class="number">18</span>: </div><div class="line"><span class="number">19</span>:             <span class="comment">// 超过队列最大长度，添加失败</span></div><div class="line"><span class="number">20</span>:             <span class="keyword">if</span> (argumentMap.size() &gt;= maxBatchSize) &#123;</div><div class="line"><span class="number">21</span>:                 <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"><span class="number">22</span>:             &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">23</span>:                 <span class="comment">// 创建 CollapsedRequestSubject ，并添加到队列</span></div><div class="line"><span class="number">24</span>:                 CollapsedRequestSubject&lt;ResponseType, RequestArgumentType&gt; collapsedRequest = <span class="keyword">new</span> CollapsedRequestSubject&lt;ResponseType, RequestArgumentType&gt;(arg, <span class="keyword">this</span>);</div><div class="line"><span class="number">25</span>:                 <span class="keyword">final</span> CollapsedRequestSubject&lt;ResponseType, RequestArgumentType&gt; existing = (CollapsedRequestSubject&lt;ResponseType, RequestArgumentType&gt;) argumentMap.putIfAbsent(arg, collapsedRequest);</div><div class="line"><span class="number">26</span>:                 <span class="comment">/**</span></div><div class="line"><span class="comment">27:                  * If the argument already exists in the batch, then there are 2 options:</span></div><div class="line"><span class="comment">28:                  * A) If request caching is ON (the default): only keep 1 argument in the batch and let all responses</span></div><div class="line"><span class="comment">29:                  * be hooked up to that argument</span></div><div class="line"><span class="comment">30:                  * B) If request caching is OFF: return an error to all duplicate argument requests</span></div><div class="line"><span class="comment">31:                  *</span></div><div class="line"><span class="comment">32:                  * This maintains the invariant that each batch has no duplicate arguments.  This prevents the impossible</span></div><div class="line"><span class="comment">33:                  * logic (in a user-provided mapResponseToRequests for HystrixCollapser and the internals of HystrixObservableCollapser)</span></div><div class="line"><span class="comment">34:                  * of trying to figure out which argument of a set of duplicates should get attached to a response.</span></div><div class="line"><span class="comment">35:                  *</span></div><div class="line"><span class="comment">36:                  * See https://github.com/Netflix/Hystrix/pull/1176 for further discussion.</span></div><div class="line"><span class="comment">37:                  */</span></div><div class="line"><span class="number">38</span>:                 <span class="keyword">if</span> (existing != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">39</span>:                     <span class="keyword">boolean</span> requestCachingEnabled = properties.requestCacheEnabled().get();</div><div class="line"><span class="number">40</span>:                     <span class="keyword">if</span> (requestCachingEnabled) &#123;</div><div class="line"><span class="number">41</span>:                         <span class="keyword">return</span> existing.toObservable();</div><div class="line"><span class="number">42</span>:                     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">43</span>:                         <span class="keyword">return</span> Observable.error(<span class="keyword">new</span> IllegalArgumentException(<span class="string">"Duplicate argument in collapser batch : ["</span> + arg + <span class="string">"]  This is not supported.  Please turn request-caching on for HystrixCollapser:"</span> + commandCollapser.getCollapserKey().name() + <span class="string">" or prevent duplicates from making it into the batch!"</span>));</div><div class="line"><span class="number">44</span>:                     &#125;</div><div class="line"><span class="number">45</span>:                 &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">46</span>:                     <span class="keyword">return</span> collapsedRequest.toObservable();</div><div class="line"><span class="number">47</span>:                 &#125;</div><div class="line"><span class="number">48</span>: </div><div class="line"><span class="number">49</span>:             &#125;</div><div class="line"><span class="number">50</span>:         &#125; <span class="keyword">finally</span> &#123;</div><div class="line"><span class="number">51</span>:             batchLock.readLock().unlock();</div><div class="line"><span class="number">52</span>:         &#125;</div><div class="line"><span class="number">53</span>:     &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">54</span>:         <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"><span class="number">55</span>:     &#125;</div><div class="line"><span class="number">56</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 4 至 6 行 ：执行已经开始，添加失败。在 <code>RequestBatch#executeBatchIfNotAlreadyStarted(...)</code> 方法的开头，优先 <strong>CAS</strong> 使 <code>batchStarted = true</code> 。</li><li>第 11 行 ：获得<strong>读锁</strong>。<code>The &#39;read&#39; just means non-exclusive even though we are writing.</code> ，即使该方法实际在做<strong>“写操作”</strong>，不排他，线程安全，所以可以使用读锁。</li><li>第 15 至 17 行 ：<code>double-check</code>，执行已经开始，添加失败。在 <code>RequestBatch#executeBatchIfNotAlreadyStarted(...)</code> 方法，优先 <strong>CAS</strong> 使 <code>batchStarted = true</code>，再获取<strong>写锁</strong>，所以会出现该情况。</li><li>第 20 至 21 行 ：超过队列最大长度，添加失败。</li><li><p>第 24 至 25 行 ：创建 <code>com.netflix.hystrix.collapser.CollapsedRequestSubject</code> ，并将<strong>它</strong>添加到队列( <code>argumentMap</code> ) 。</p><ul><li>CollapsedRequestSubject 实现 <code>com.netflix.hystrix.HystrixCollapser.CollapsedRequest</code> <strong>接口</strong>，定义了批量命令执行的<strong>请求</strong>，不仅限于获得请求参数( <code>#getArgument()</code> 方法 )，也包括对批量命令执行结束后，每个<strong>请求</strong>的结果设置( <code>#setResponse(...)</code>/<code>#emitResponse(...)</code>/<code>#setException(...)</code>/<code>#setComplete()</code> 方法 )，点击 <a href="https://github.com/YunaiV/Hystrix/blob/dc176978c2beb2465ba4edb37d0024e388f15d5d/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java#L512" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看该接口的代码。</li><li><p>CollapsedRequestSubject <strong>构造方法</strong>，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/* package */</span><span class="class"><span class="keyword">class</span> <span class="title">CollapsedRequestSubject</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">CollapsedRequest</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 参数</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> R argument;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 结果( response ) 是否设置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> AtomicBoolean valueSet = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 可回放的 ReplaySubject</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReplaySubject&lt;T&gt; subject = ReplaySubject.create();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 带订阅数量的 ReplaySubject</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Observable&lt;T&gt; subjectWithAccounting;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 订阅数量</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> outstandingSubscriptions = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CollapsedRequestSubject</span><span class="params">(<span class="keyword">final</span> R arg, <span class="keyword">final</span> RequestBatch&lt;?, T, R&gt; containingBatch)</span> </span>&#123;</div><div class="line">        <span class="comment">// 设置 argument</span></div><div class="line">        <span class="keyword">if</span> (arg == RequestCollapser.NULL_SENTINEL) &#123;</div><div class="line">            <span class="keyword">this</span>.argument = <span class="keyword">null</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">this</span>.argument = arg;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 设置 带订阅数量的 ReplaySubject</span></div><div class="line">        <span class="keyword">this</span>.subjectWithAccounting = subject</div><div class="line">                .doOnSubscribe(<span class="keyword">new</span> Action0() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">                        outstandingSubscriptions++;</div><div class="line">                    &#125;</div><div class="line">                &#125;)</div><div class="line">                .doOnUnsubscribe(<span class="keyword">new</span> Action0() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">                        outstandingSubscriptions--;</div><div class="line">                        <span class="keyword">if</span> (outstandingSubscriptions == <span class="number">0</span>) &#123;</div><div class="line">                            containingBatch.remove(arg);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>argument</code> 属性，<strong>单个</strong>命令请求参数。</li><li><code>valueSet</code> 属性，结果( Response ) 是否设置，通过 <code>#setResponse()</code>/<code>#emitResponse()</code> 方法设置。</li><li><code>subject</code> 属性，<strong>可回放执行结果</strong>的 Subject 。此处使用 ReplaySubject 的主要目的，当 HystrixCollapser 开启<strong>缓存</strong>功能时，通过回放执行结果，在 <a href="http://www.iocoder.cn/Hystrix/command-execute-result-cache/?self">《Hystrix 源码解析 —— 执行结果缓存》「5. HystrixCachedObservable」</a> 也有相同的实现。另外，这里有一点要注意下，ReplaySubject 并<strong>没有</strong>向任何 Observable 订阅结果，<strong>而是通过 <code>#setResponse()</code>/<code>#emitResponse()</code> 方法设置结果</strong>。</li><li><code>outstandingSubscriptions</code> 属性，订阅数量。</li><li><code>subjectWithAccounting</code> 属性，带订阅数量的 ReplaySubject 。当取消订阅时，调用 <code>RequestBatch#remove(arg)</code> 方法，移除<strong>单个</strong>命令请求。</li></ul></li></ul></li><li><p>第 38 至 47 行 ：返回 Observable 。</p><ul><li>当 <code>argumentMap</code> 已经存在 <code>arg</code> 对应的 Observable 时，必须开启缓存 ( <code>HystrixCollapserProperties.requestCachingEnabled = true</code> ) 功能。原因是，如果在<strong>相同的</strong> <code>arg</code> ，并且未开启缓存，同时<strong>第 43 行</strong>实现的是 <code>collapsedRequest.toObservable()</code> ，那么<strong>相同的</strong> <code>arg</code> 将有<strong>多个</strong> Observable 执行命令，此时 <code>HystrixCollapserBridge#mapResponseToRequests(...)</code> 方法无法将执行( Response )赋值到 <code>arg</code> 对应的命令请求( CollapsedRequestSubject ) 。更多讨论，见 <a href="https://github.com/Netflix/Hystrix/pull/1176" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/Netflix/Hystrix/pull/1176</a> 。</li><li>回过头看 <code>HystrixCollapser#toObservable()</code> 方法的<strong>第 32 至 41 行的代码</strong>，这里也有对<strong>缓存</strong>功能，是不是<strong>重复</strong>了呢？<code>argumentMap</code> 针对的是 RequestBatch 级的缓存，HystrixCollapser : RequestCollapser : RequestBatch 是 <code>1 : 1 : N</code> 的关系，通过 <code>HystrixCollapser#toObservable()</code> 对缓存的处理逻辑，保证 RequestBatch 切换后，<strong>依然有缓存</strong>。</li></ul></li></ul><hr><p><code>RequestBatch#remove()</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/* package-private */</span> <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(RequestArgumentType arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (batchStarted.get()) &#123;</div><div class="line">        <span class="comment">//nothing we can do</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (batchLock.readLock().tryLock()) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">/* double-check now that we have the lock - if the batch is started, deleting is useless */</span></div><div class="line">            <span class="keyword">if</span> (batchStarted.get()) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            argumentMap.remove(arg);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            batchLock.readLock().unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>当 RequestBatch 开始执行，不允许移除<strong>单个</strong>命令请求。</li></ul><h2 id="4-4-createNewBatchAndExecutePreviousIfNeeded-previousBatch"><a href="#4-4-createNewBatchAndExecutePreviousIfNeeded-previousBatch" class="headerlink" title="4.4 #createNewBatchAndExecutePreviousIfNeeded(previousBatch)"></a>4.4 #createNewBatchAndExecutePreviousIfNeeded(previousBatch)</h2><p>本小节建议在 <a href="#">「5. CollapserTimer」</a> 后，再回过头看。</p><p><code>#createNewBatchAndExecutePreviousIfNeeded(previousBatch)</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="number">1</span>: <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createNewBatchAndExecutePreviousIfNeeded</span><span class="params">(RequestBatch&lt;BatchReturnType, ResponseType, RequestArgumentType&gt; previousBatch)</span> </span>&#123;</div><div class="line"><span class="number">2</span>:     <span class="keyword">if</span> (previousBatch == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">3</span>:         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Trying to start null batch which means it was shutdown already."</span>);</div><div class="line"><span class="number">4</span>:     &#125;</div><div class="line"><span class="number">5</span>:     <span class="keyword">if</span> (batch.compareAndSet(previousBatch, <span class="keyword">new</span> RequestBatch&lt;BatchReturnType, ResponseType, RequestArgumentType&gt;(properties, commandCollapser, properties.maxRequestsInBatch().get()))) &#123;</div><div class="line"><span class="number">6</span>:         <span class="comment">// this thread won so trigger the previous batch</span></div><div class="line"><span class="number">7</span>:         previousBatch.executeBatchIfNotAlreadyStarted();</div><div class="line"><span class="number">8</span>:     &#125;</div><div class="line"><span class="number">9</span>: &#125;</div></pre></td></tr></table></figure><ul><li>第 5 行 ：通过 <strong>CAS</strong> 修改 <code>batch</code> ，保证并发情况下的线程安全。同时注意，此处也进行了<strong>新的</strong> RequestBatch ，切换掉<strong>老的</strong> RequestBatch 。</li><li>第 6 行 ：使用<strong>老的</strong> RequestBatch ，调用 <code>RequestBatch#executeBatchIfNotAlreadyStarted()</code> 方法，命令合并执行。</li></ul><hr><p><code>RequestBatch#executeBatchIfNotAlreadyStarted()</code> 方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">  <span class="number">1</span>: <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeBatchIfNotAlreadyStarted</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="number">2</span>:     <span class="comment">/*</span></div><div class="line"><span class="comment">  3:      * - check that we only execute once since there's multiple paths to do so (timer, waiting thread or max batch size hit)</span></div><div class="line"><span class="comment">  4:      * - close the gate so 'offer' can no longer be invoked and we turn those threads away so they create a new batch</span></div><div class="line"><span class="comment">  5:      */</span></div><div class="line">  <span class="number">6</span>:     <span class="comment">// 设置 执行已经开始</span></div><div class="line">  <span class="number">7</span>:     <span class="keyword">if</span> (batchStarted.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</div><div class="line">  <span class="number">8</span>:         <span class="comment">// 获得 写锁</span></div><div class="line">  <span class="number">9</span>:         <span class="comment">/* wait for 'offer'/'remove' threads to finish before executing the batch so 'requests' is complete */</span></div><div class="line"> <span class="number">10</span>:         batchLock.writeLock().lock();</div><div class="line"> <span class="number">11</span>: </div><div class="line"> <span class="number">12</span>:         <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">13</span>:             <span class="comment">// 将多个命令请求分片成 N 个【多个命令请求】。</span></div><div class="line"> <span class="number">14</span>:             <span class="comment">// shard batches</span></div><div class="line"> <span class="number">15</span>:             Collection&lt;Collection&lt;CollapsedRequest&lt;ResponseType, RequestArgumentType&gt;&gt;&gt; shards = commandCollapser.shardRequests(argumentMap.values());</div><div class="line"> <span class="number">16</span>:             <span class="comment">// for each shard execute its requests </span></div><div class="line"> <span class="number">17</span>:             <span class="keyword">for</span> (<span class="keyword">final</span> Collection&lt;CollapsedRequest&lt;ResponseType, RequestArgumentType&gt;&gt; shardRequests : shards) &#123;</div><div class="line"> <span class="number">18</span>:                 <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">19</span>:                     <span class="comment">// 将多个命令请求合并，创建一个 HystrixCommand</span></div><div class="line"> <span class="number">20</span>:                     <span class="comment">// create a new command to handle this batch of requests</span></div><div class="line"> <span class="number">21</span>:                     Observable&lt;BatchReturnType&gt; o = commandCollapser.createObservableCommand(shardRequests);</div><div class="line"> <span class="number">22</span>: </div><div class="line"> <span class="number">23</span>:                     <span class="comment">// 将一个 HystrixCommand 的执行结果，映射回对应的命令请求们</span></div><div class="line"> <span class="number">24</span>:                     commandCollapser.mapResponseToRequests(o, shardRequests).doOnError(<span class="keyword">new</span> Action1&lt;Throwable&gt;() &#123;</div><div class="line"> <span class="number">25</span>: </div><div class="line"> <span class="number">26</span>:                         <span class="comment">/**</span></div><div class="line"><span class="comment"> 27:                          * This handles failed completions</span></div><div class="line"><span class="comment"> 28:                          */</span></div><div class="line"> <span class="number">29</span>:                         <span class="meta">@Override</span></div><div class="line"> <span class="number">30</span>:                         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line"> <span class="number">31</span>:                             <span class="comment">// handle Throwable in case anything is thrown so we don't block Observers waiting for onError/onCompleted</span></div><div class="line"> <span class="number">32</span>:                             Exception ee;</div><div class="line"> <span class="number">33</span>:                             <span class="keyword">if</span> (e <span class="keyword">instanceof</span> Exception) &#123;</div><div class="line"> <span class="number">34</span>:                                 ee = (Exception) e;</div><div class="line"> <span class="number">35</span>:                             &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="number">36</span>:                                 ee = <span class="keyword">new</span> RuntimeException(<span class="string">"Throwable caught while executing batch and mapping responses."</span>, e);</div><div class="line"> <span class="number">37</span>:                             &#125;</div><div class="line"> <span class="number">38</span>:                             logger.debug(<span class="string">"Exception mapping responses to requests."</span>, e);</div><div class="line"> <span class="number">39</span>:                             <span class="comment">// if a failure occurs we want to pass that exception to all of the Futures that we've returned</span></div><div class="line"> <span class="number">40</span>:                             <span class="keyword">for</span> (CollapsedRequest&lt;ResponseType, RequestArgumentType&gt; request : argumentMap.values()) &#123;</div><div class="line"> <span class="number">41</span>:                                 <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">42</span>:                                     ((CollapsedRequestSubject&lt;ResponseType, RequestArgumentType&gt;) request).setExceptionIfResponseNotReceived(ee);</div><div class="line"> <span class="number">43</span>:                                 &#125; <span class="keyword">catch</span> (IllegalStateException e2) &#123;</div><div class="line"> <span class="number">44</span>:                                     <span class="comment">// if we have partial responses set in mapResponseToRequests</span></div><div class="line"> <span class="number">45</span>:                                     <span class="comment">// then we may get IllegalStateException as we loop over them</span></div><div class="line"> <span class="number">46</span>:                                     <span class="comment">// so we'll log but continue to the rest</span></div><div class="line"> <span class="number">47</span>:                                     logger.error(<span class="string">"Partial success of 'mapResponseToRequests' resulted in IllegalStateException while setting Exception. Continuing ... "</span>, e2);</div><div class="line"> <span class="number">48</span>:                                 &#125;</div><div class="line"> <span class="number">49</span>:                             &#125;</div><div class="line"> <span class="number">50</span>:                         &#125;</div><div class="line"> <span class="number">51</span>: </div><div class="line"> <span class="number">52</span>:                     &#125;).doOnCompleted(<span class="keyword">new</span> Action0() &#123;</div><div class="line"> <span class="number">53</span>: </div><div class="line"> <span class="number">54</span>:                         <span class="comment">/**</span></div><div class="line"><span class="comment"> 55:                          * This handles successful completions</span></div><div class="line"><span class="comment"> 56:                          */</span></div><div class="line"> <span class="number">57</span>:                         <span class="meta">@Override</span></div><div class="line"> <span class="number">58</span>:                         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line"> <span class="number">59</span>:                             <span class="comment">// check that all requests had setResponse or setException invoked in case 'mapResponseToRequests' was implemented poorly</span></div><div class="line"> <span class="number">60</span>:                             Exception e = <span class="keyword">null</span>;</div><div class="line"> <span class="number">61</span>:                             <span class="keyword">for</span> (CollapsedRequest&lt;ResponseType, RequestArgumentType&gt; request : shardRequests) &#123;</div><div class="line"> <span class="number">62</span>:                                 <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">63</span>:                                    e = ((CollapsedRequestSubject&lt;ResponseType, RequestArgumentType&gt;) request).setExceptionIfResponseNotReceived(e,<span class="string">"No response set by "</span> + commandCollapser.getCollapserKey().name() + <span class="string">" 'mapResponseToRequests' implementation."</span>);</div><div class="line"> <span class="number">64</span>:                                 &#125; <span class="keyword">catch</span> (IllegalStateException e2) &#123;</div><div class="line"> <span class="number">65</span>:                                     logger.debug(<span class="string">"Partial success of 'mapResponseToRequests' resulted in IllegalStateException while setting 'No response set' Exception. Continuing ... "</span>, e2);</div><div class="line"> <span class="number">66</span>:                                 &#125;</div><div class="line"> <span class="number">67</span>:                             &#125;</div><div class="line"> <span class="number">68</span>:                         &#125;</div><div class="line"> <span class="number">69</span>: </div><div class="line"> <span class="number">70</span>:                     &#125;).subscribe();</div><div class="line"> <span class="number">71</span>:                     </div><div class="line"> <span class="number">72</span>:                 &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"> <span class="number">73</span>:                     <span class="comment">// 异常</span></div><div class="line"> <span class="number">74</span>:                     logger.error(<span class="string">"Exception while creating and queueing command with batch."</span>, e);</div><div class="line"> <span class="number">75</span>:                     <span class="comment">// if a failure occurs we want to pass that exception to all of the Futures that we've returned</span></div><div class="line"> <span class="number">76</span>:                     <span class="keyword">for</span> (CollapsedRequest&lt;ResponseType, RequestArgumentType&gt; request : shardRequests) &#123;</div><div class="line"> <span class="number">77</span>:                         <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">78</span>:                             request.setException(e);</div><div class="line"> <span class="number">79</span>:                         &#125; <span class="keyword">catch</span> (IllegalStateException e2) &#123;</div><div class="line"> <span class="number">80</span>:                             logger.debug(<span class="string">"Failed trying to setException on CollapsedRequest"</span>, e2);</div><div class="line"> <span class="number">81</span>:                         &#125;</div><div class="line"> <span class="number">82</span>:                     &#125;</div><div class="line"> <span class="number">83</span>:                 &#125;</div><div class="line"> <span class="number">84</span>:             &#125;</div><div class="line"> <span class="number">85</span>: </div><div class="line"> <span class="number">86</span>:         &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"> <span class="number">87</span>:             <span class="comment">// 异常</span></div><div class="line"> <span class="number">88</span>:             logger.error(<span class="string">"Exception while sharding requests."</span>, e);</div><div class="line"> <span class="number">89</span>:             <span class="comment">// same error handling as we do around the shards, but this is a wider net in case the shardRequest method fails</span></div><div class="line"> <span class="number">90</span>:             <span class="keyword">for</span> (CollapsedRequest&lt;ResponseType, RequestArgumentType&gt; request : argumentMap.values()) &#123;</div><div class="line"> <span class="number">91</span>:                 <span class="keyword">try</span> &#123;</div><div class="line"> <span class="number">92</span>:                     request.setException(e);</div><div class="line"> <span class="number">93</span>:                 &#125; <span class="keyword">catch</span> (IllegalStateException e2) &#123;</div><div class="line"> <span class="number">94</span>:                     logger.debug(<span class="string">"Failed trying to setException on CollapsedRequest"</span>, e2);</div><div class="line"> <span class="number">95</span>:                 &#125;</div><div class="line"> <span class="number">96</span>:             &#125;</div><div class="line"> <span class="number">97</span>:         &#125; <span class="keyword">finally</span> &#123;</div><div class="line"> <span class="number">98</span>:             batchLock.writeLock().unlock();</div><div class="line"> <span class="number">99</span>:         &#125;</div><div class="line"><span class="number">100</span>:     &#125;</div><div class="line"><span class="number">101</span>: &#125;</div></pre></td></tr></table></figure><ul><li>代码看起来是有点长哈，请对照着官方示例 <a href="https://github.com/YunaiV/Hystrix/blob/2655a1323a7b77fc65f31de82b40331797dc018d/hystrix-examples/src/main/java/com/netflix/hystrix/examples/basic/CommandCollapserGetValueForKey.java" rel="external nofollow noopener noreferrer" target="_blank">CommandCollapserGetValueForKey</a> 一起看，临门一脚了，胖友！</li><li>第 7 行 ：通过 <strong>CAS</strong> 修改 <code>batchStarted</code> ，保证并发情况下的线程安全。</li><li>第 10 行 ：获得<strong>写锁</strong>。等待调用 <code>#offer(...)</code>/<code>#remove(...)</code> 方法的线程执行完成，以保证命令合并执行时，不再有新的请求添加或移除。</li><li>第 15 行 ：调用 <code>HystrixCollapserBridge#shardRequests(...)</code> 方法，将<strong>多个</strong>命令请求<strong>分片</strong>成 <strong>N</strong> 个【<strong>多个</strong>命令请求】。默认实现下，不进行分片。点击 <a href="https://github.com/YunaiV/Hystrix/blob/dc176978c2beb2465ba4edb37d0024e388f15d5d/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java#L146" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看代码。</li><li>第 17 行 ：循环 <strong>N</strong> 个【<strong>多个</strong>命令请求】。</li><li>第 21 行 ：调用 <code>HystrixCollapserBridge#createObservableCommand(...)</code> 方法，将<strong>多个</strong>命令请求<strong>合并</strong>，创建<strong>一个</strong> HystrixCommand 。点击 <a href="https://github.com/YunaiV/Hystrix/blob/dc176978c2beb2465ba4edb37d0024e388f15d5d/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java#L156" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看代码。</li><li>第 24 行 ：调用 <code>HystrixCollapserBridge#mapResponseToRequests(...)</code> 方法，将<strong>一个</strong> HystrixCommand 的执行结果，<strong>映射</strong>回对应的命令请求们。点击 <a href="https://github.com/YunaiV/Hystrix/blob/dc176978c2beb2465ba4edb37d0024e388f15d5d/hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java#L166" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 查看代码。<ul><li><code>Observable#single()</code> 方法，如果 Observable 终止时只发射了一个值，返回那个值，否则抛出异常。在 <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/First.html#single" rel="external nofollow noopener noreferrer" target="_blank">《ReactiveX文档中文翻译》「single」</a> 有相关分享。</li><li><code>Observable#ignoreElements()</code> 方法，抑制原始 Observable 发射的所有数据，只允许它的终止通知（<code>#onError()</code> 或 <code>#onCompleted()</code>）通过。在 <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/IgnoreElements.html" rel="external nofollow noopener noreferrer" target="_blank">《ReactiveX文档中文翻译》「IgnoreElements」</a> 有相关分享。也推荐点击 <a href="https://github.com/ReactiveX/RxJava/blob/6db98f8750f580995657f83b5620b579c97e6a06/src/main/java/rx/internal/operators/OperatorIgnoreElements.java" rel="external nofollow noopener noreferrer" target="_blank"><code>rx.internal.operators.OperatorIgnoreElements</code></a> 看下源码，可能更加易懂。</li><li><code>Observable#cast()</code> 方法，将原始 Observable 发射的每一项数据都强制转换为一个指定的类型，然后再发射数据，它是 <code>map</code> 的一个特殊版本。在 <a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Map.html#cast" rel="external nofollow noopener noreferrer" target="_blank">《ReactiveX文档中文翻译》「cast」</a> 有相关分享。也推荐点击 <a href="https://github.com/ReactiveX/RxJava/blob/6db98f8750f580995657f83b5620b579c97e6a06/src/main/java/rx/internal/operators/OperatorCast.java" rel="external nofollow noopener noreferrer" target="_blank"><code>rx.internal.operators.OperatorCast</code></a> 看下源码，可能更加易懂。</li><li>使用 <code>Observable#ignoreElements()</code>/<code>Observable#cast()</code> 方法，用于将 Observable 变成不再继续向下发射数据项，只给现有方法里 <code>Observable#doNext()</code> 处理数据项，调用 <code>HystrixCollapser#mapResponseToRequests(...)</code> 方法。</li><li>点击 <a href="https://github.com/YunaiV/Hystrix/blob/dc176978c2beb2465ba4edb37d0024e388f15d5d/hystrix-core/src/main/java/com/netflix/hystrix/collapser/CollapsedRequestSubject.java#L101" rel="external nofollow noopener noreferrer" target="_blank">链接</a> ，查看 <code>CollapsedRequestSubject#setResponse(response)</code> 方法的代码。</li></ul></li><li>第 24 至 50 行 ：调用 <code>Observable#doError(Action1)</code> 方法，当命令合并执行发生异常时，设置<strong>每个</strong> CollapsedRequestSubject 的执行结果为异常。<ul><li>点击 <a href="https://github.com/YunaiV/Hystrix/blob/dc176978c2beb2465ba4edb37d0024e388f15d5d/hystrix-core/src/main/java/com/netflix/hystrix/collapser/CollapsedRequestSubject.java#L137" rel="external nofollow noopener noreferrer" target="_blank">链接</a>，查看 <code>CollapsedRequestSubject#setResponse(response)</code> 方法的代码。</li></ul></li><li>第 52 至 68 行 ：调用 <code>Observable#doOnCompleted(Action0)</code> 方法，当命令合并执行完成时，检查<strong>每个</strong> CollapsedRequestSubject 是否都有返回结果。设置没有返回结果的 CollapsedRequestSubject 的执行结果为异常。一般情况下，是用户实现 <code>HystrixCollapser#mapResponseToRequests(...)</code> 方法存在 BUG 。另外，如果不设置，将导致无结果的<strong>单个</strong>命令请求<strong>无限阻塞</strong>。</li><li>第 70 行 ：调用 <code>Observable#subscribe()</code> 方法，<strong>触发</strong> HystrixCommand 执行。</li><li>第 72 至 96 行 ：发生异常，设置<strong>每个</strong> CollapsedRequestSubject 的执行结果为异常。<ul><li>点击 <a href="https://github.com/YunaiV/Hystrix/blob/dc176978c2beb2465ba4edb37d0024e388f15d5d/hystrix-core/src/main/java/com/netflix/hystrix/collapser/CollapsedRequestSubject.java#L170" rel="external nofollow noopener noreferrer" target="_blank">链接</a>，查看 <code>CollapsedRequestSubject#setException(response)</code> 方法的代码。</li></ul></li><li>第 97 至 99 行 ：释放<strong>写锁</strong>。</li></ul><h1 id="5-CollapserTimer"><a href="#5-CollapserTimer" class="headerlink" title="5. CollapserTimer"></a>5. CollapserTimer</h1><p><code>com.netflix.hystrix.collapser.CollapserTimer</code> ，命令合并器的定时器<strong>接口</strong>，定义了<strong>提交定时监听器，生成定时任务</strong>的接口方法，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CollapserTimer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function">Reference&lt;TimerListener&gt; <span class="title">addListener</span><span class="params">(TimerListener collapseTask)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="5-1-RealCollapserTimer"><a href="#5-1-RealCollapserTimer" class="headerlink" title="5.1 RealCollapserTimer"></a>5.1 RealCollapserTimer</h2><p><code>com.netflix.hystrix.collapser.RealCollapserTimer</code> ，命令合并器的定时器<strong>实现类</strong>，代码如下 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealCollapserTimer</span> <span class="keyword">implements</span> <span class="title">CollapserTimer</span> </span>&#123;</div><div class="line">    <span class="comment">/* single global timer that all collapsers will schedule their tasks on */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HystrixTimer timer = HystrixTimer.getInstance();</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Reference&lt;TimerListener&gt; <span class="title">addListener</span><span class="params">(TimerListener collapseTask)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> timer.addTimerListener(collapseTask);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>实际上，使用的是 HystrixTimer 提供的单例。在 <a href="http://www.iocoder.cn/Hystrix/command-execute-third-timeout/?self">《Hystrix 源码解析 —— 执行结果缓存》「3. HystrixTimer<br>」</a> 有详细解析。</li></ul><h2 id="5-2-CollapsedTask"><a href="#5-2-CollapsedTask" class="headerlink" title="5.2 CollapsedTask"></a>5.2 CollapsedTask</h2><p><code>com.netflix.hystrix.collapser.RequestCollapser.CollapsedTask</code> ，定时任务，固定周期( 可配，默认 <code>HystrixCollapserProperties.timerDelayInMilliseconds = 10ms</code> ) 轮询其对应的<strong>一个</strong> RequestCollapser <strong>当前</strong> RequestBatch 。若有命令需要执行，则提交 RequestCollapser 合并执行。</p><p>代码比较简单，点击 <a href="https://github.com/YunaiV/Hystrix/blob/dc176978c2beb2465ba4edb37d0024e388f15d5d/hystrix-core/src/main/java/com/netflix/hystrix/collapser/RequestCollapser.java#L138" rel="external nofollow noopener noreferrer" target="_blank">链接</a> 直接看代码。</p><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p><img src="http://www.iocoder.cn/images/Architecture/2017_12_29/01.png" alt="知识星球"></p><p>T T 一开始把命令合并执行，理解成类似线程池批量执行任务，怎么看官方示例，怎么奇怪。有一样的同学，一起泪目 + 握爪下。</p><p>本文有点点长，实在不想拆分成多篇。</p><p>恩，另外部分地方写的不够清晰，欢迎一起讨论和优化。</p><p>胖友，分享一波朋友圈可好！</p></div><footer class="article-footer clearfix"><div class="article-categories"><span></span> <a class="article-category-link" href="/categories/Hystrix/">Hystrix</a></div><div class="article-share" id="share"><div data-url="http://www.iocoder.cn/Hystrix/command-collapser-execute/" data-title="Hystrix 源码解析 —— 命令合并执行 | 芋道源码 —— 纯源码解析博客" data-tsina="null" class="share clearfix"></div></div></footer></article><nav class="article-nav clearfix"><div class="prev"><a href="/Hystrix/circuit-breaker/" title="Hystrix 源码解析 —— 断路器 HystrixCircuitBreaker"><strong>PREVIOUS:</strong><br><span>Hystrix 源码解析 —— 断路器 HystrixCircuitBreaker</span></a></div><div class="next"><a href="/Hystrix/command-execute-fourth-fallback/" title="Hystrix 源码解析 —— 请求执行（四）之失败回退逻辑"><strong>NEXT:</strong><br><span>Hystrix 源码解析 —— 请求执行（四）之失败回退逻辑</span></a></div></nav></div><div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div><div id="toc" class="toc-aside"><strong class="toc-title">文章目录</strong><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-概述"><span class="toc-number">1.</span> <span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-HystrixCollapser"><span class="toc-number">2.</span> <span class="toc-text">2. HystrixCollapser</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-构造方法"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-执行命令方式"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 执行命令方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-核心方法"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 核心方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-RequestCollapserFactory"><span class="toc-number">3.</span> <span class="toc-text">3. RequestCollapserFactory</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-RequestCollapser"><span class="toc-number">4.</span> <span class="toc-text">4. RequestCollapser</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-构造方法"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-RequestBatch"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 RequestBatch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-submitRequest-arg"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 #submitRequest(arg)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-createNewBatchAndExecutePreviousIfNeeded-previousBatch"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 #createNewBatchAndExecutePreviousIfNeeded(previousBatch)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-CollapserTimer"><span class="toc-number">5.</span> <span class="toc-text">5. CollapserTimer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-RealCollapserTimer"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 RealCollapserTimer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-CollapsedTask"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 CollapsedTask</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#666-彩蛋"><span class="toc-number">6.</span> <span class="toc-text">666. 彩蛋</span></a></li></ol></div><div id="asidepart"><aside class="clearfix"><div id="authorInfo"><div><img width="100%" src="/images/common/wechat_mp_2017_07_31_bak.jpg"></div><div class="social-list"></div></div><div class="categorieslist"><p class="asidetitle">微信公众号福利：芋道源码</p><ul><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">0. 阅读源码葵花宝典</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">1. RocketMQ / MyCAT / Sharding-JDBC 详细中文注释源码</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">2. 您对于源码的疑问每条留言都将得到认真回复</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">3. 新的源码解析文章实时收到通知，每周六十点更新</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">4. 认真的源码交流微信群</a></li></ul></div><div class="categorieslist"><p class="asidetitle">分类</p><ul><li><a href="/categories/Elastic-Job-Cloud/" title="Elastic-Job-Cloud">Elastic-Job-Cloud<sup>6</sup></a></li><li><a href="/categories/Elastic-Job-Lite/" title="Elastic-Job-Lite">Elastic-Job-Lite<sup>16</sup></a></li><li><a href="/categories/Eureka/" title="Eureka">Eureka<sup>23</sup></a></li><li><a href="/categories/Hystrix/" title="Hystrix">Hystrix<sup>9</sup></a></li><li><a href="/categories/MyCAT/" title="MyCAT">MyCAT<sup>9</sup></a></li><li><a href="/categories/RocketMQ/" title="RocketMQ">RocketMQ<sup>14</sup></a></li><li><a href="/categories/RxJava/" title="RxJava">RxJava<sup>5</sup></a></li><li><a href="/categories/Sharding-JDBC/" title="Sharding-JDBC">Sharding-JDBC<sup>18</sup></a></li><li><a href="/categories/SkyWalking/" title="SkyWalking">SkyWalking<sup>35</sup></a></li><li><a href="/categories/Spring-Cloud-Gateway/" title="Spring-Cloud-Gateway">Spring-Cloud-Gateway<sup>24</sup></a></li><li><a href="/categories/TCC-Transaction/" title="TCC-Transaction">TCC-Transaction<sup>7</sup></a></li><li><a href="/categories/工作内推/" title="工作内推">工作内推<sup>2</sup></a></li><li><a href="/categories/芋道源码的周八/" title="芋道源码的周八">芋道源码的周八<sup>12</sup></a></li></ul></div><div id="authorInfo2"><div><img width="100%" src="/images/common/zsxq/02.png"></div></div></aside></div></div><footer><div id="footer"><img src="http://www.iocoder.cn/images/common/wechat_mp_simple.png" style="display:none"><p class="copyright">© 2018 <a href="http://www.iocoder.cn" target="_blank" title="芋道源码">芋道源码</a> && <span style="display:inline" id="busuanzi_container_site_uv">总访客数 <span id="busuanzi_value_site_uv" font="微软雅黑"></span> 次</span> && <span style="display:inline" id="busuanzi_container_site_pv">总访问量 <span id="busuanzi_value_site_pv" font="微软雅黑"></span> 次</span> && Hosted by <a href="https://pages.coding.me" style="font-weight:700" rel="external nofollow noopener noreferrer" target="_blank">Coding Pages</a></p></div><div class="copyright">沪ICP备17037075号-1</div></footer><script src="/js/jquery-2.1.0.min.js"></script><script type="text/javascript">$(document).ready(function(){function e(){"number"==typeof window.innerWidth?n=window.innerWidth:document.documentElement&&document.documentElement.clientWidth&&(n=document.documentElement.clientWidth)}$(".navbar").click(function(){$("header nav").toggleClass("shownav")});var n=0,s=$("#main"),a=$("#asidepart"),o=$(".closeaside"),d=$(".openaside");$(window).resize(function(){e(),n>=1024?$("header nav").removeClass("shownav"):(s.removeClass("moveMain"),a.css("display","block").removeClass("fadeOut"),d.css("display","none"),$("#toc.toc-aside").css("display","none"))}),o.click(function(){a.addClass("fadeOut").css("display","none"),d.css("display","block").addClass("fadeIn"),s.addClass("moveMain")}),d.click(function(){d.css("display","none").removeClass("beforeFadeIn"),a.css("display","block").removeClass("fadeOut").addClass("fadeIn"),s.removeClass("moveMain")}),$(window).scroll(function(){d.css("top",Math.max(80,260-$(this).scrollTop()))})})</script><script type="text/javascript">$(document).ready(function(){var a=$(".article-content>iframe"),t=$(".article-content>embed"),n=$("#toc");$("article h2"),ah=$("article h2"),ta=$("#toc.toc-aside"),o=$(".openaside"),c=$(".closeaside"),a.length>0&&a.wrap('<div class="video-container" />'),t.length>0&&t.wrap('<div class="video-container" />'),0==ah.length?n.css("display","none"):(c.click(function(){ta.css("display","block").addClass("fadeIn")}),o.click(function(){ta.css("display","none")}),$(window).scroll(function(){ta.css("top",Math.max(140,320-$(this).scrollTop()))}))})</script><script type="text/javascript">$(document).ready(function(){var t=$(".share"),a=t.attr("data-url"),e=encodeURIComponent(a),r=['<a href="#" class="overlay" id="qrcode"></a>','<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url='+e+'"/></div>','<a href="#textlogo" class="article-back-to-top" title="Top"></a>','<a href="https://www.facebook.com/sharer.php?u='+e+'" class="article-share-facebook" target="_blank" title="Facebook"></a>','<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>','<a href="https://twitter.com/intent/tweet?url='+e+'" class="article-share-twitter" target="_blank" title="Twitter"></a>','<a href="http://service.weibo.com/share/share.php?title='+t.attr("data-title")+"&url="+e+"&ralateUid="+t.attr("data-tsina")+'&searchPic=true&style=number" class="article-share-weibo" target="_blank" title="Weibo"></a>','<span title="Share to"></span>'].join("");t.append(r),$(".article-share-qrcode").click(function(){var t=$("#qrcode-pic").attr("data-src");$("#qrcode-pic").attr("src",t),$("#qrcode-pic").load(function(){$(".qrcode strong").text(" ")})})})</script><link rel="stylesheet" href="/alert/css/alert.css"><script src="/alert/js/alert.js"></script><script src="/js/jquery.cookie.js"></script><script src="/js/util.js"></script><script type="text/javascript">!function(e,a,t,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=a.createElement(t),s=a.getElementsByTagName(t)[0],o.async=1,o.src="//www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s)}(window,document,"script",0,"ga"),ga("create","UA-107572620-1","auto"),ga("send","pageview")</script></body>