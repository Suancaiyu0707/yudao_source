
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">

    <meta name="google-site-verification" content="GkJ68PCnxM9Ih7Zm9v8p91FOCV7ymNCO2KdGbflLh3E">
    <meta name="360-site-verification" content="dd6547587641bfede036f7c79561e8a0">
    <meta name="shenma-site-verification" content="fd96cf3751972c9b05f8471d2ccadddc_1496951214">
    <meta name="msvalidate.01" content="1D38B05050A977F6FDEDA481198343F1">
    <meta name="sogou_site_verification" content="MpPsku240L">

  
    <title>Elastic-Job-Cloud 源码分析 —— 作业调度（一） | 芋道源码 —— 纯源码解析BLOG</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="芋道源码">
    
    <meta name="description" content="摘要: 原创出处 http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/ 「芋道源码」欢迎转载，保留摘要，谢谢！
本文基于 Elastic-Job V2.1.5 版本分享

1. 概述
2. 作业执行类型
3">
    

    
    <meta name="keywords" content="Java,架构,后端,服务端,RocketMQ,MyCAT,分布式消息队列,分布式存储,技术博客,Sharding-JDBC,分库分表">
    

    
    
    <link rel="alternate" href="atom.xml" title="芋道源码 —— 纯源码解析BLOG" type="application/atom+xml">
    
    
    <link rel="icon" href="/images/favicon.ico">
    
    
    <link rel="stylesheet" href="/css/style.css">
    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            var _bdId ='9e70e3362807c1bd185a79655b307027';
             hm.src = "//hm.baidu.com/hm.js?" + _bdId;
             var s = document.getElementsByTagName("script")[0]; 
             s.parentNode.insertBefore(hm, s);
        })();
    </script>
    

    <!-- 百度站长-被动推送 -->
    <script>
        (function(){
            var bp = document.createElement('script');
            var curProtocol = window.location.protocol.split(':')[0];
            if (curProtocol === 'https') {
                bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
            }
            else {
                bp.src = 'http://push.zhanzhang.baidu.com/push.js';
            }
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(bp, s);
        })();
    </script>

    <!-- 360搜索-自动收录 -->
    <script>
        (function(){
            var src = (document.location.protocol == "http:") ? "http://js.passport.qihucdn.com/11.0.1.js?f05b61dd54bbc38386611a5238672938":"https://jspassport.ssl.qhimg.com/11.0.1.js?f05b61dd54bbc38386611a5238672938";
            document.write('<script src="' + src + '" id="sozz"><\/script>');
        })();
    </script>

    <!-- 不蒜子统计 -->
    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</head>
</html>
  <body>
    <header>
      <div>
    
    <div id="textlogo">
        <h1 class="site-name"><a href="/" title="芋道源码 —— 纯源码解析BLOG">芋道源码 —— 纯源码解析BLOG</a></h1>
        <a class="blog-motto">
            
            愿半生编码，如一生老友！
            
        </a>
    </div>
    <div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
        </a></div>
    <nav class="animated">
        <ul>
            <ul>
                
                <li><a href="/">文章</a></li>
                
                <li><a href="/2018-meet-you">知识星球</a></li>
                
                <li><a href="https://github.com/YunaiV" rel="external nofollow noopener noreferrer" target="_blank">Github</a></li>
                
                <li><a href="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31_bak.jpg">微信公众号</a></li>
                
                <li><a href="/categories/%E5%B7%A5%E4%BD%9C%E5%86%85%E6%8E%A8/">工作内推</a></li>
                
                <li><a href="/link_url">友链</a></li>
                
                <!--<li>-->
                    <!---->
                        <!--<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">-->
                            <!--<label>Search</label>-->
                            <!--<input type="text" id="search" name="q" autocomplete="off" maxlength="20"-->
                                   <!--placeholder="搜索"/>-->
                            <!--<input type="hidden" name="q" value="site:www.iocoder.cn">-->
                        <!--</form>-->
                        <!---->
                <!--</li>-->
            </ul>
    </ul></nav>
</div>

    </header>
    <div id="container">

        <div id="main" class="post" itemscope="" itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/Elastic-Job/cloud-job-scheduler-and-executor-first/" title="Elastic-Job-Cloud 源码分析 —— 作业调度（一）" itemprop="url">Elastic-Job-Cloud 源码分析 —— 作业调度（一）</a>
  </h1>
  <p class="article-author">
      <!--By-->
    <!---->
      <!--<a href="http://www.iocoder.cn" title="芋道源码">芋道源码</a>-->
    <!---->
  </p>
  <p class="article-time">
    <!--<time datetime="2017-12-20T16:00:00.000Z" itemprop="datePublished">2017-12-21</time>-->
    <!--更新日期:<time datetime="2017-10-12T05:34:21.000Z" itemprop="dateModified">2017-10-12</time>-->
    <!---->
      总阅读量:<span id="busuanzi_value_page_pv"></span>次
  </p>
</header>
	<div class="article-content">
		
		
		<p>摘要: 原创出处 <a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/">http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p>
<p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p>
<ul>
<li><a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/">1. 概述</a></li>
<li><a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/">2. 作业执行类型</a></li>
<li><a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/">3. Producer 发布任务</a><ul>
<li><a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/">3.1 常驻作业</a></li>
<li><a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/">3.2 瞬时作业</a><ul>
<li><a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/">3.2.1 TransientProducerScheduler</a></li>
<li><a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/">3.2.2 注册瞬时作业</a></li>
<li><a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/">3.2.3 ProducerJob</a></li>
</ul>
</li>
<li><a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/">3.3 小结</a></li>
</ul>
</li>
<li><a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/">4. TaskLaunchScheduledService 提交任务</a><ul>
<li><a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/">4.1 创建 Fenzo 任务请求</a></li>
<li><a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/">4.2 AppConstraintEvaluator</a></li>
<li><a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/">4.3 将任务请求分配到 Mesos Offer</a></li>
<li><a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/">4.4 创建 Mesos 任务信息</a><ul>
<li><a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/">4.4.1 创建单个 Mesos 任务信息</a></li>
</ul>
</li>
<li><a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/">4.5 将任务运行时上下文放入运行时队列</a></li>
<li><a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/">4.6 从队列中删除已运行的作业</a></li>
<li><a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/">4.7 提交任务给 Mesos</a></li>
</ul>
</li>
<li><a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/">5. TaskExecutor 执行任务</a><ul>
<li><a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/">5.1 TaskThread</a></li>
<li><a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/">5.2 DaemonTaskScheduler</a></li>
</ul>
</li>
<li><a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/">6. SchedulerEngine 处理任务的状态变更</a></li>
<li><a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/">666. 彩蛋</a></li>
</ul>
<hr>
<p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Cloud 调度主流程</strong>。对应到 Elastic-Job-Lite 源码解析文章如下：</p>
<ul>
<li><a href="http://www.iocoder.cn/Elastic-Job/job-init/?self">《Elastic-Job-Lite 源码分析 —— 作业初始化》</a></li>
<li><a href="http://www.iocoder.cn/Elastic-Job/job-execute/?self">《Elastic-Job-Lite 源码分析 —— 作业执行》</a></li>
<li><a href="http://www.iocoder.cn/Elastic-Job/job-sharding/">《Elastic-Job-Lite 源码分析 —— 作业分片》</a></li>
</ul>
<p>如果你阅读过以下文章，有助于对本文的理解：</p>
<ul>
<li><a href="http://www.infoq.com/cn/news/2016/09/Mesos-Elastic-Job-Cloud" rel="external nofollow noopener noreferrer" target="_blank">《基于Mesos的当当作业云Elastic Job Cloud》</a></li>
<li><a href="https://segmentfault.com/a/1190000007723430" rel="external nofollow noopener noreferrer" target="_blank">《由浅入深 | 如何优雅地写一个Mesos Framework》</a></li>
</ul>
<p>😈 另外，笔者假设你已经对 <strong><a href="http://www.iocoder.cn/categories/Elastic-Job/?self">《Elastic-Job-Lite 源码分析系列》</a></strong> 有一定的了解。</p>
<p>本文涉及到主体类的类图如下( <a href="http://www.iocoder.cn/images/Elastic-Job/2017_12_21/01.png">打开大图</a> )：</p>
<p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_21/01.png" alt=""></p>
<blockquote>
<p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p>
</blockquote>
<p>Elastic-Job-Cloud 基于 Mesos 实现分布式作业调度，或者说 Elastic-Job-Cloud 是 Mesos 上的 框架( Framework )。</p>
<p>一个 Mesos 框架由两部分组成：</p>
<ul>
<li>控制器部分，称为调度器( Scheduler )。</li>
<li>工作单元部分，称为执行器( Executor )。</li>
</ul>
<p>Elastic-Job-Cloud 由两个项目组成：</p>
<ul>
<li>Elastic-Job-Cloud-Scheduler，实现调度器，实现类为 <code>com.dangdang.ddframe.job.cloud.scheduler.mesos.SchedulerEngine</code>。</li>
<li>Elastic-Job-Cloud-Executor，实现执行器，实现类为 <code>com.dangdang.ddframe.job.cloud.executor.TaskExecutor</code>。</li>
</ul>
<p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_21/11.png" alt=""></p>
<p>本文略微<strong>“啰嗦”</strong>，请保持<strong>耐心</strong>。搭配<a href="http://product.dangdang.com/24187450.html" rel="external nofollow noopener noreferrer" target="_blank">《用Mesos框架构建分布式应用》</a>一起阅读，理解难度降低 99%。OK，开始我们的 Cloud 之旅。</p>
<h1 id="2-作业执行类型"><a href="#2-作业执行类型" class="headerlink" title="2. 作业执行类型"></a>2. 作业执行类型</h1><p>在 Elastic-Job-Cloud，作业执行分成两种类型：</p>
<ul>
<li>常驻作业</li>
</ul>
<blockquote>
<p>常驻作业是作业一旦启动，无论运行与否均占用系统资源；<br>常驻作业适合初始化时间长、触发间隔短、实时性要求高的作业，要求资源配备充足。</p>
</blockquote>
<ul>
<li>瞬时作业</li>
</ul>
<blockquote>
<p>瞬时作业是在作业启动时占用资源，运行完成后释放资源。<br>瞬时作业适合初始化时间短、触发间隔长、允许延迟的作业，一般用于资源不太充分，或作业要求的资源多，适合资源错峰使用的场景。</p>
</blockquote>
<p>Elastic-Job-Cloud 不同于 Elastic-Job-Lite 去中心化执行调度，转变为 <strong>Mesos Framework 的中心节点调度</strong>。这里不太理解，没关系，下文看到具体代码就能明白了。</p>
<p>常驻作业、瞬时作业在调度中会略有不同，大体<strong>粗略</strong>流程如下：</p>
<p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_21/02.png" alt=""></p>
<p>下面，我们针对每个过程一节一节解析。</p>
<h1 id="3-Producer-发布任务"><a href="#3-Producer-发布任务" class="headerlink" title="3. Producer 发布任务"></a>3. Producer 发布任务</h1><p>在上文<a href="http://www.iocoder.cn/Elastic-Job/cloud-job-config/?self">《Elastic-Job-Cloud 源码分析 —— 作业配置》的「3.1.1 操作云作业配置」</a>可以看到添加云作业配置后，Elastic-Job-Cloud-Scheduler 会执行<strong>作业调度</strong>，实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ProducerManager.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 调度作业.</span></div><div class="line"><span class="comment">* </span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> jobConfig 作业配置</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(<span class="keyword">final</span> CloudJobConfiguration jobConfig)</span> </span>&#123;</div><div class="line">   <span class="comment">// 应用 或 作业 被禁用，不调度</span></div><div class="line">   <span class="keyword">if</span> (disableAppService.isDisabled(jobConfig.getAppName()) || disableJobService.isDisabled(jobConfig.getJobName())) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (CloudJobExecutionType.TRANSIENT == jobConfig.getJobExecutionType()) &#123; <span class="comment">// 瞬时作业</span></div><div class="line">       transientProducerScheduler.register(jobConfig);</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (CloudJobExecutionType.DAEMON == jobConfig.getJobExecutionType()) &#123; <span class="comment">// 常驻作业</span></div><div class="line">       readyService.addDaemon(jobConfig.getJobName());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>瞬时作业和常驻作业在调度上会有一定的不同。</li>
</ul>
<h2 id="3-1-常驻作业"><a href="#3-1-常驻作业" class="headerlink" title="3.1 常驻作业"></a>3.1 常驻作业</h2><p>常驻作业在调度时，直接添加到待执行作业队列。What？岂不是马上就运行了！No No No，答案在「5. TaskExecutor 执行任务」，这里先打住。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ReadyService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 将常驻作业放入待执行队列.</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> jobName 作业名称</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDaemon</span><span class="params">(<span class="keyword">final</span> String jobName)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (regCenter.getNumChildren(ReadyNode.ROOT) &gt; env.getFrameworkConfiguration().getJobStateQueueSize()) &#123;</div><div class="line">       log.warn(<span class="string">"Cannot add daemon job, caused by read state queue size is larger than &#123;&#125;."</span>, env.getFrameworkConfiguration().getJobStateQueueSize());</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   Optional&lt;CloudJobConfiguration&gt; cloudJobConfig = configService.load(jobName);</div><div class="line">   <span class="keyword">if</span> (!cloudJobConfig.isPresent() || CloudJobExecutionType.DAEMON != cloudJobConfig.get().getJobExecutionType() || runningService.isJobRunning(jobName)) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 添加到待执行队列</span></div><div class="line">   regCenter.persist(ReadyNode.getReadyJobNodePath(jobName), <span class="string">"1"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ReadyNode.java</span></div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadyNode</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ROOT = StateNode.ROOT + <span class="string">"/ready"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String READY_JOB = ROOT + <span class="string">"/%s"</span>; <span class="comment">// %s = $&#123;JOB_NAME&#125;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>ReadyService，待执行作业队列服务，提供对待执行作业队列的各种操作方法。</li>
<li><p><strong>待执行作业队列</strong>存储在注册中心( Zookeeper )的<strong>持久</strong>数据节点 <code>/${NAMESPACE}/state/ready/${JOB_NAME}</code>，存储值为待执行次数。例如此处，待执行次数为 <code>1</code>。使用 zkClient 查看如下：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 4] ls /elastic-job-cloud/state/ready</div><div class="line">[test_job_simple]</div><div class="line">[zk: localhost:2181(CONNECTED) 5] get /elastic-job-cloud/state/ready/test_job_simple</div><div class="line">1</div></pre></td></tr></table></figure>
</li>
<li><p>在运维平台，我们可以看到待执行作业队列：</p>
<p>  <img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_21/10.png" alt="">    </p>
</li>
<li><p>从官方的 RoadMap 来看，<strong>待执行作业队列</strong>未来会使用 Redis 存储以提高性能。</p>
<blockquote>
<p>FROM <a href="http://elasticjob.io/docs/elastic-job-cloud/03-design/roadmap/" rel="external nofollow noopener noreferrer" target="_blank">http://elasticjob.io/docs/elastic-job-cloud/03-design/roadmap/</a><br>Redis Based Queue Improvement</p>
</blockquote>
</li>
</ul>
<h2 id="3-2-瞬时作业"><a href="#3-2-瞬时作业" class="headerlink" title="3.2 瞬时作业"></a>3.2 瞬时作业</h2><p>瞬时作业在调度时，使用<strong>发布瞬时作业任务的调度器</strong>( TransientProducerScheduler )调度作业。当瞬时作业到达作业执行时间，添加到待执行作业队列。</p>
<h3 id="3-2-1-TransientProducerScheduler"><a href="#3-2-1-TransientProducerScheduler" class="headerlink" title="3.2.1 TransientProducerScheduler"></a>3.2.1 TransientProducerScheduler</h3><p>TransientProducerScheduler，发布瞬时作业任务的调度器，基于 Quartz 实现对瞬时作业的调度。初始化代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TransientProducerScheduler.java</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">   scheduler = getScheduler();</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       scheduler.start();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SchedulerException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> Scheduler <span class="title">getScheduler</span><span class="params">()</span> </span>&#123;</div><div class="line">   StdSchedulerFactory factory = <span class="keyword">new</span> StdSchedulerFactory();</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       factory.initialize(getQuartzProperties());</div><div class="line">       <span class="keyword">return</span> factory.getScheduler();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SchedulerException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> Properties <span class="title">getQuartzProperties</span><span class="params">()</span> </span>&#123;</div><div class="line">   Properties result = <span class="keyword">new</span> Properties();</div><div class="line">   result.put(<span class="string">"org.quartz.threadPool.class"</span>, SimpleThreadPool.class.getName());</div><div class="line">   result.put(<span class="string">"org.quartz.threadPool.threadCount"</span>, Integer.toString(Runtime.getRuntime().availableProcessors() * <span class="number">2</span>)); <span class="comment">// 线程池数量</span></div><div class="line">   result.put(<span class="string">"org.quartz.scheduler.instanceName"</span>, <span class="string">"ELASTIC_JOB_CLOUD_TRANSIENT_PRODUCER"</span>);</div><div class="line">   result.put(<span class="string">"org.quartz.plugin.shutdownhook.class"</span>, ShutdownHookPlugin.class.getName());</div><div class="line">   result.put(<span class="string">"org.quartz.plugin.shutdownhook.cleanShutdown"</span>, Boolean.TRUE.toString());</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-2-2-注册瞬时作业"><a href="#3-2-2-注册瞬时作业" class="headerlink" title="3.2.2 注册瞬时作业"></a>3.2.2 注册瞬时作业</h3><p>调用 <code>TransientProducerScheduler#register(...)</code> 方法，注册瞬时作业。实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TransientProducerScheduler.java</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> TransientProducerRepository repository;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> CloudJobConfiguration jobConfig)</span> </span>&#123;</div><div class="line">   String cron = jobConfig.getTypeConfig().getCoreConfig().getCron();</div><div class="line">   <span class="comment">// 添加 cron 作业集合</span></div><div class="line">   JobKey jobKey = buildJobKey(cron);</div><div class="line">   repository.put(jobKey, jobConfig.getJobName());</div><div class="line">   <span class="comment">// 调度 作业</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">if</span> (!scheduler.checkExists(jobKey)) &#123;</div><div class="line">           scheduler.scheduleJob(buildJobDetail(jobKey), buildTrigger(jobKey.getName()));</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SchedulerException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用 <code>#buildJobKey(...)</code> 方法，创建 Quartz JobKey。你会发现很有意思的使用的是 <code>cron</code> 参数作为主键。Why？在看下 <code>!scheduler.checkExists(jobKey)</code> 处，相同 JobKey( <code>cron</code> ) 的作业不重复注册到 Quartz Scheduler。Why？此处是一个优化，相同 <code>cron</code> 使用同一个 Quartz Job，Elastic-Job-Cloud-Scheduler 可能会注册大量的瞬时作业，如果一个瞬时作业创建一个 Quartz Job 太过浪费，特别是 <code>cron</code> 每分钟、每5分钟、每小时、每天已经覆盖了大量的瞬时作业的情况。因此，相同 <code>cron</code> 使用同一个 Quartz Job。</li>
<li><p>调用 <code>TransientProducerRepository#put(...)</code> 以 Quartz JobKey 为主键聚合作业。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransientProducerRepository</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * cron 作业集合</span></div><div class="line"><span class="comment">     * key：作业Key</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;JobKey, List&lt;String&gt;&gt; cronTasks = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>, <span class="number">1</span>);</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">final</span> JobKey jobKey, <span class="keyword">final</span> String jobName)</span> </span>&#123;</div><div class="line">        remove(jobName);</div><div class="line">        List&lt;String&gt; taskList = cronTasks.get(jobKey);</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == taskList) &#123;</div><div class="line">            taskList = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</div><div class="line">            taskList.add(jobName);</div><div class="line">            cronTasks.put(jobKey, taskList);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!taskList.contains(jobName)) &#123;</div><div class="line">            taskList.add(jobName);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>调用 <code>#buildJobDetail(...)</code> 创建 Quartz Job 信息。实现代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> JobDetail <span class="title">buildJobDetail</span><span class="params">(<span class="keyword">final</span> JobKey jobKey)</span> </span>&#123;</div><div class="line">    JobDetail result = JobBuilder.newJob(ProducerJob.class) <span class="comment">// ProducerJob.java</span></div><div class="line">            .withIdentity(jobKey).build();</div><div class="line">    result.getJobDataMap().put(<span class="string">"repository"</span>, repository);</div><div class="line">    result.getJobDataMap().put(<span class="string">"readyService"</span>, readyService);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>JobBuilder#newJob(...)</code> 的参数是 ProducerJob，下文会讲解到。</li>
</ul>
</li>
<li><p>调用 <code>#buildTrigger(...)</code> 创建 Quartz Trigger。实现代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Trigger <span class="title">buildTrigger</span><span class="params">(<span class="keyword">final</span> String cron)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> TriggerBuilder.newTrigger()</div><div class="line">           .withIdentity(cron)</div><div class="line">           .withSchedule(CronScheduleBuilder.cronSchedule(cron) <span class="comment">// cron</span></div><div class="line">           .withMisfireHandlingInstructionDoNothing())</div><div class="line">           .build();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-2-3-ProducerJob"><a href="#3-2-3-ProducerJob" class="headerlink" title="3.2.3 ProducerJob"></a>3.2.3 ProducerJob</h3><p>ProducerJob，当 Quartz Job 到达 <code>cron</code> 执行时间( 即作业执行时间)，将相应的瞬时作业添加到待执行作业队列。实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</div><div class="line">        </div><div class="line">   <span class="keyword">private</span> TransientProducerRepository repository;</div><div class="line">   </div><div class="line">   <span class="keyword">private</span> ReadyService readyService;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</div><div class="line">       List&lt;String&gt; jobNames = repository.get(context.getJobDetail().getKey());</div><div class="line">       <span class="keyword">for</span> (String each : jobNames) &#123;</div><div class="line">           readyService.addTransient(each);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>调用 <code>TransientProducerRepository#get(...)</code> 方法，获得该 Job 对应的作业集合。实现代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransientProducerRepository</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * cron 作业集合</span></div><div class="line"><span class="comment">     * key：作业Key</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;JobKey, List&lt;String&gt;&gt; cronTasks = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>, <span class="number">1</span>);</div><div class="line">    </div><div class="line">    <span class="function">List&lt;String&gt; <span class="title">get</span><span class="params">(<span class="keyword">final</span> JobKey jobKey)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; result = cronTasks.get(jobKey);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span> == result ? Collections.&lt;String&gt;emptyList() : result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>调用 <code>ReadyService#addTransient(...)</code> 方法，添加瞬时作业到待执行作业队列。实现代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 将瞬时作业放入待执行队列.</span></div><div class="line"><span class="comment">* </span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> jobName 作业名称</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTransient</span><span class="params">(<span class="keyword">final</span> String jobName)</span> </span>&#123;</div><div class="line">   <span class="comment">//</span></div><div class="line">   <span class="keyword">if</span> (regCenter.getNumChildren(ReadyNode.ROOT) &gt; env.getFrameworkConfiguration().getJobStateQueueSize()) &#123;</div><div class="line">       log.warn(<span class="string">"Cannot add transient job, caused by read state queue size is larger than &#123;&#125;."</span>, env.getFrameworkConfiguration().getJobStateQueueSize());</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">//</span></div><div class="line">   Optional&lt;CloudJobConfiguration&gt; cloudJobConfig = configService.load(jobName);</div><div class="line">   <span class="keyword">if</span> (!cloudJobConfig.isPresent() || CloudJobExecutionType.TRANSIENT != cloudJobConfig.get().getJobExecutionType()) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// </span></div><div class="line">   String readyJobNode = ReadyNode.getReadyJobNodePath(jobName);</div><div class="line">   String times = regCenter.getDirectly(readyJobNode);</div><div class="line">   <span class="keyword">if</span> (cloudJobConfig.get().getTypeConfig().getCoreConfig().isMisfire()) &#123;</div><div class="line">       regCenter.persist(readyJobNode, Integer.toString(<span class="keyword">null</span> == times ? <span class="number">1</span> : Integer.parseInt(times) + <span class="number">1</span>));</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       regCenter.persist(ReadyNode.getReadyJobNodePath(jobName), <span class="string">"1"</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>添加瞬时作业到待执行作业队列</strong> 和 <strong>添加常驻作业到待执行作业队列</strong>基本是一致的。</li>
<li>当作业配置允许 <code>misfire</code>，则不断累积作业可执行次数。</li>
</ul>
</li>
</ul>
<h2 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h2><p>无论是常驻作业还是瞬时作业，都会加入到<strong>待执行作业队列</strong>。目前我们看到瞬时作业的每次调度是 TransientProducerScheduler 负责。那么常驻作业的每次调度呢？「5. TaskExecutor 执行任务」会看到它的调度，这是 Elastic-Job-Cloud 设计巧妙有趣的地方。</p>
<h1 id="4-TaskLaunchScheduledService-提交任务"><a href="#4-TaskLaunchScheduledService-提交任务" class="headerlink" title="4. TaskLaunchScheduledService 提交任务"></a>4. TaskLaunchScheduledService 提交任务</h1><p>TaskLaunchScheduledService，任务提交调度服务。它继承 Guava AbstractScheduledService 实现定时将待执行作业队列的作业提交到 Mesos 进行调度执行。实现<strong>定时</strong>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskLaunchScheduledService</span> <span class="keyword">extends</span> <span class="title">AbstractScheduledService</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">serviceName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"task-launch-processor"</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Scheduler <span class="title">scheduler</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Scheduler.newFixedDelaySchedule(<span class="number">2</span>, <span class="number">10</span>, TimeUnit.SECONDS);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">runOneIteration</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">// .... 省略代码</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// ... 省略部分方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>每 10 秒执行提交任务( <code>#runOneIteration()</code> )。对 Guava AbstractScheduledService 不了解的同学，可以阅读完本文后 Google 下。因为是通过每 10 秒轮询的方式提交任务，所以<strong>瞬时作业</strong>的执行时间不是非常严格，存在略有延迟，这个实际在使用需要注意的。那<strong>常驻作业</strong>呢，看完本文，你就会知道答案。</li>
</ul>
<p><code>#runOneIteration()</code> 方法相对比较复杂，我们一块一块拆解，<strong>耐心</strong>理解。实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">runOneIteration</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       System.out.println(<span class="string">"runOneIteration:"</span> + <span class="keyword">new</span> Date());</div><div class="line">       <span class="comment">// 创建 Fenzo 任务请求</span></div><div class="line">       LaunchingTasks launchingTasks = <span class="keyword">new</span> LaunchingTasks(facadeService.getEligibleJobContext());</div><div class="line">       List&lt;TaskRequest&gt; taskRequests = launchingTasks.getPendingTasks();</div><div class="line">       <span class="comment">// 获取所有正在运行的云作业App https://github.com/Netflix/Fenzo/wiki/Constraints</span></div><div class="line">       <span class="keyword">if</span> (!taskRequests.isEmpty()) &#123;</div><div class="line">           AppConstraintEvaluator.getInstance().loadAppRunningState();</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 将任务请求分配到 Mesos Offer</span></div><div class="line">       Collection&lt;VMAssignmentResult&gt; vmAssignmentResults = taskScheduler.scheduleOnce(taskRequests, LeasesQueue.getInstance().drainTo()).getResultMap().values();</div><div class="line">       <span class="comment">// 创建 Mesos 任务请求</span></div><div class="line">       List&lt;TaskContext&gt; taskContextsList = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">// 任务运行时上下文集合</span></div><div class="line">       Map&lt;List&lt;Protos.OfferID&gt;, List&lt;Protos.TaskInfo&gt;&gt; offerIdTaskInfoMap = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// Mesos 任务信息集合</span></div><div class="line">       <span class="keyword">for</span> (VMAssignmentResult each: vmAssignmentResults) &#123;</div><div class="line">           List&lt;VirtualMachineLease&gt; leasesUsed = each.getLeasesUsed();</div><div class="line">           List&lt;Protos.TaskInfo&gt; taskInfoList = <span class="keyword">new</span> ArrayList&lt;&gt;(each.getTasksAssigned().size() * <span class="number">10</span>);</div><div class="line">           taskInfoList.addAll(getTaskInfoList(</div><div class="line">                   launchingTasks.getIntegrityViolationJobs(vmAssignmentResults), <span class="comment">// 获得作业分片不完整的作业集合</span></div><div class="line">                   each, leasesUsed.get(<span class="number">0</span>).hostname(), leasesUsed.get(<span class="number">0</span>).getOffer()));</div><div class="line">           <span class="keyword">for</span> (Protos.TaskInfo taskInfo : taskInfoList) &#123;</div><div class="line">               taskContextsList.add(TaskContext.from(taskInfo.getTaskId().getValue()));</div><div class="line">           &#125;</div><div class="line">           offerIdTaskInfoMap.put(getOfferIDs(leasesUsed), <span class="comment">// 获得 Offer ID 集合</span></div><div class="line">                   taskInfoList);</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 遍历任务运行时上下文</span></div><div class="line">       <span class="keyword">for</span> (TaskContext each : taskContextsList) &#123;</div><div class="line">           <span class="comment">// 将任务运行时上下文放入运行时队列</span></div><div class="line">           facadeService.addRunning(each);</div><div class="line">           <span class="comment">// 发布作业状态追踪事件(State.TASK_STAGING)</span></div><div class="line">           jobEventBus.post(createJobStatusTraceEvent(each));</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 从队列中删除已运行的作业</span></div><div class="line">       facadeService.removeLaunchTasksFromQueue(taskContextsList);</div><div class="line">       <span class="comment">// 提交任务给 Mesos</span></div><div class="line">       <span class="keyword">for</span> (Entry&lt;List&lt;OfferID&gt;, List&lt;TaskInfo&gt;&gt; each : offerIdTaskInfoMap.entrySet()) &#123;</div><div class="line">           schedulerDriver.launchTasks(each.getKey(), each.getValue());</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</div><div class="line">       log.error(<span class="string">"Launch task error"</span>, throwable);</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       <span class="comment">// 清理 AppConstraintEvaluator 所有正在运行的云作业App</span></div><div class="line">       AppConstraintEvaluator.getInstance().clearAppRunningState();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-1-创建-Fenzo-任务请求"><a href="#4-1-创建-Fenzo-任务请求" class="headerlink" title="4.1 创建 Fenzo 任务请求"></a>4.1 创建 Fenzo 任务请求</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// #runOneIteration()</span></div><div class="line">LaunchingTasks launchingTasks = <span class="keyword">new</span> LaunchingTasks(facadeService.getEligibleJobContext());</div><div class="line">List&lt;TaskRequest&gt; taskRequests = launchingTasks.getPendingTasks();</div></pre></td></tr></table></figure>
<ul>
<li><p>调用 <code>FacadeService#getEligibleJobContext()</code> 方法，获取有资格运行的作业。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// FacadeService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获取有资格运行的作业.</span></div><div class="line"><span class="comment">* </span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 作业上下文集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> Collection&lt;JobContext&gt; <span class="title">getEligibleJobContext</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 从失效转移队列中获取所有有资格执行的作业上下文</span></div><div class="line">   Collection&lt;JobContext&gt; failoverJobContexts = failoverService.getAllEligibleJobContexts();</div><div class="line">   <span class="comment">// 从待执行队列中获取所有有资格执行的作业上下文</span></div><div class="line">   Collection&lt;JobContext&gt; readyJobContexts = readyService.getAllEligibleJobContexts(failoverJobContexts);</div><div class="line">   <span class="comment">// 合并</span></div><div class="line">   Collection&lt;JobContext&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(failoverJobContexts.size() + readyJobContexts.size());</div><div class="line">   result.addAll(failoverJobContexts);</div><div class="line">   result.addAll(readyJobContexts);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用 <code>FailoverService#getAllEligibleJobContexts()</code> 方法，从<strong>失效转移队列</strong>中获取所有有资格执行的作业上下文。<strong>TaskLaunchScheduledService 提交的任务还可能来自失效转移队列</strong>。本文暂时不解析失效转移队列相关实现，避免增加复杂度影响大家的理解，在<a href="http://www.iocoder.cn/Elastic-Job/cloud-job-failover/?self">《Elastic-Job-Cloud 源码分析 —— 作业失效转移》</a>详细解析。</li>
<li><p>调用 <code>ReadyService#getAllEligibleJobContexts(...)</code> 方法，从<strong>待执行队列</strong>中获取所有有资格执行的作业上下文。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ReadyService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 从待执行队列中获取所有有资格执行的作业上下文.</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> ineligibleJobContexts 无资格执行的作业上下文</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 有资格执行的作业上下文集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> Collection&lt;JobContext&gt; <span class="title">getAllEligibleJobContexts</span><span class="params">(<span class="keyword">final</span> Collection&lt;JobContext&gt; ineligibleJobContexts)</span> </span>&#123;</div><div class="line">   <span class="comment">// 不存在 待执行队列</span></div><div class="line">   <span class="keyword">if</span> (!regCenter.isExisted(ReadyNode.ROOT)) &#123;</div><div class="line">       <span class="keyword">return</span> Collections.emptyList();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 无资格执行的作业上下文 转换成 无资格执行的作业集合</span></div><div class="line">   Collection&lt;String&gt; ineligibleJobNames = Collections2.transform(ineligibleJobContexts, <span class="keyword">new</span> Function&lt;JobContext, String&gt;() &#123;</div><div class="line">       </div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(<span class="keyword">final</span> JobContext input)</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> input.getJobConfig().getJobName();</div><div class="line">       &#125;</div><div class="line">   &#125;);</div><div class="line">   <span class="comment">// 获取 待执行队列 有资格执行的作业上下文</span></div><div class="line">   List&lt;String&gt; jobNames = regCenter.getChildrenKeys(ReadyNode.ROOT);</div><div class="line">   List&lt;JobContext&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(jobNames.size());</div><div class="line">   <span class="keyword">for</span> (String each : jobNames) &#123;</div><div class="line">       <span class="keyword">if</span> (ineligibleJobNames.contains(each)) &#123;</div><div class="line">           <span class="keyword">continue</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 排除 作业配置 不存在的作业</span></div><div class="line">       Optional&lt;CloudJobConfiguration&gt; jobConfig = configService.load(each);</div><div class="line">       <span class="keyword">if</span> (!jobConfig.isPresent()) &#123;</div><div class="line">           regCenter.remove(ReadyNode.getReadyJobNodePath(each));</div><div class="line">           <span class="keyword">continue</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (!runningService.isJobRunning(each)) &#123; <span class="comment">// 排除 运行中 的作业</span></div><div class="line">           result.add(JobContext.from(jobConfig.get(), ExecutionType.READY));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li></li>
</ul>
</li>
<li><p>JobContext，作业运行上下文。实现代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobContext.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobContext</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CloudJobConfiguration jobConfig;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Integer&gt; assignedShardingItems;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutionType type;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 通过作业配置创建作业运行上下文.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> jobConfig 作业配置</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> type 执行类型</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 作业运行上下文</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JobContext <span class="title">from</span><span class="params">(<span class="keyword">final</span> CloudJobConfiguration jobConfig, <span class="keyword">final</span> ExecutionType type)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> shardingTotalCount = jobConfig.getTypeConfig().getCoreConfig().getShardingTotalCount();</div><div class="line">        <span class="comment">// 分片项</span></div><div class="line">        List&lt;Integer&gt; shardingItems = <span class="keyword">new</span> ArrayList&lt;&gt;(shardingTotalCount);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shardingTotalCount; i++) &#123;</div><div class="line">            shardingItems.add(i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JobContext(jobConfig, shardingItems, type);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>LaunchingTasks，分配任务行为包。创建 LaunchingTasks 代码如下：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LaunchingTasks</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 作业上下文集合</span></div><div class="line"><span class="comment">     * key：作业名</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, JobContext&gt; eligibleJobContextsMap;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LaunchingTasks</span><span class="params">(<span class="keyword">final</span> Collection&lt;JobContext&gt; eligibleJobContexts)</span> </span>&#123;</div><div class="line">        eligibleJobContextsMap = <span class="keyword">new</span> HashMap&lt;&gt;(eligibleJobContexts.size(), <span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span> (JobContext each : eligibleJobContexts) &#123;</div><div class="line">            eligibleJobContextsMap.put(each.getJobConfig().getJobName(), each);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>调用 <code>LaunchingTasks#getPendingTasks()</code> 方法，获得待执行任务集合。<strong>这里要注意，每个作业如果有多个分片，则会生成多个待执行任务，即此处完成了作业分片</strong>。实现代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LaunchingTasks.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获得待执行任务</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 待执行任务</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function">List&lt;TaskRequest&gt; <span class="title">getPendingTasks</span><span class="params">()</span> </span>&#123;</div><div class="line">   List&lt;TaskRequest&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(eligibleJobContextsMap.size() * <span class="number">10</span>);</div><div class="line">   <span class="keyword">for</span> (JobContext each : eligibleJobContextsMap.values()) &#123;</div><div class="line">       result.addAll(createTaskRequests(each));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 创建待执行任务集合</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> jobContext 作业运行上下文</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 待执行任务集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> Collection&lt;TaskRequest&gt; <span class="title">createTaskRequests</span><span class="params">(<span class="keyword">final</span> JobContext jobContext)</span> </span>&#123;</div><div class="line">   Collection&lt;TaskRequest&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(jobContext.getAssignedShardingItems().size());</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> each : jobContext.getAssignedShardingItems()) &#123;</div><div class="line">       result.add(<span class="keyword">new</span> JobTaskRequest(<span class="keyword">new</span> TaskContext(jobContext.getJobConfig().getJobName(), Collections.singletonList(each), jobContext.getType()), jobContext.getJobConfig()));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// TaskContext.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskContext</span> </span>&#123;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 任务编号</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">private</span> String id;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 任务元信息</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> MetaInfo metaInfo;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 执行类型</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ExecutionType type;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * Mesos Slave 编号</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">private</span> String slaveId;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 是否闲置</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="meta">@Setter</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> idle;</div><div class="line">   </div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MetaInfo</span> </span>&#123;</div><div class="line"></div><div class="line">       <span class="comment">/**</span></div><div class="line"><span class="comment">        * 作业名</span></div><div class="line"><span class="comment">        */</span></div><div class="line">       <span class="keyword">private</span> <span class="keyword">final</span> String jobName;</div><div class="line">       <span class="comment">/**</span></div><div class="line"><span class="comment">        * 作业分片项</span></div><div class="line"><span class="comment">        */</span></div><div class="line">       <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Integer&gt; shardingItems;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="comment">// ... 省略部分方法</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// JobTaskRequest.JAVA</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobTaskRequest</span> <span class="keyword">implements</span> <span class="title">TaskRequest</span> </span>&#123;</div><div class="line">    </div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> TaskContext taskContext;</div><div class="line">       </div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> CloudJobConfiguration jobConfig;</div><div class="line">       </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">return</span> taskContext.getId();</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getCPUs</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> jobConfig.getCpuCount();</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getMemory</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">return</span> jobConfig.getMemoryMB();</div><div class="line">   &#125;</div><div class="line"> </div><div class="line">   <span class="comment">// ... 省略部分方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用 <code>#createTaskRequests(...)</code> 方法，<strong>将单个作业按照其作业分片总数拆分成一个或多个待执行任务集合</strong>。</li>
<li>TaskContext，任务运行时上下文。</li>
<li>JobTaskRequest，作业任务请求对象。       </li>
</ul>
</li>
<li>因为对象有点多，我们来贴一个 <code>LaunchingTasks#getPendingTasks()</code> 方法的返回结果。<br>  <img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_21/03.png" alt=""></li>
</ul>
<p><strong>友情提示，代码可能比较多，请耐心观看。</strong></p>
<h2 id="4-2-AppConstraintEvaluator"><a href="#4-2-AppConstraintEvaluator" class="headerlink" title="4.2 AppConstraintEvaluator"></a>4.2 AppConstraintEvaluator</h2><p>在说 AppConstraintEvaluator 之前，我们先一起了<strong>简单</strong>解下 <a href="https://github.com/Netflix/Fenzo/wiki" rel="external nofollow noopener noreferrer" target="_blank">Netflix Fenzo</a>。</p>
<blockquote>
<p>FROM <a href="http://dockone.io/article/636" rel="external nofollow noopener noreferrer" target="_blank">http://dockone.io/article/636</a><br>Fenzo是一个在Mesos框架上应用的通用任务调度器。它可以让你通过实现各种优化策略的插件，来优化任务调度，同时这也有利于集群的自动缩放。</p>
</blockquote>
<p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_21/05.png" alt=""></p>
<p>Elastic-Job-Cloud-Scheduler 基于 Fenzo 实现对 Mesos 的弹性资源分配。</p>
<p>例如，AppConstraintEvaluator，App 目标 Mesos Slave 适配度限制器，选择 Slave 时需要考虑其上是否运行有 App 的 Executor，如果没有运行 Executor 需要将其资源消耗考虑进适配计算算法中。它是 <a href="https://github.com/Netflix/Fenzo/blob/5de0e0861def4a655be35a9624e67318a6c0afac/fenzo-core/src/main/java/com/netflix/fenzo/ConstraintEvaluator.java" rel="external nofollow noopener noreferrer" target="_blank">Fenzo ConstraintEvaluator 接口</a> 在 Elastic-Job-Cloud-Scheduler 的自定义任务约束实现。通过这个任务约束，在下文调用 <code>TaskScheduler#scheduleOnce(...)</code> 方法调度任务所需资源时，会将 AppConstraintEvaluator 考虑进去。</p>
<p>那么作业任务请求( JobTaskRequest ) 是怎么关联上 AppConstraintEvaluator 的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobTaskRequest.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobTaskRequest</span> <span class="keyword">implements</span> <span class="title">TaskRequest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> List&lt;? extends ConstraintEvaluator&gt; getHardConstraints() &#123;</div><div class="line">        <span class="keyword">return</span> Collections.singletonList(AppConstraintEvaluator.getInstance());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><a href="https://github.com/Netflix/Fenzo/blob/20d71b5c3213063fc938cd2841dc7569601d1d99/fenzo-core/src/main/java/com/netflix/fenzo/TaskRequest.java" rel="external nofollow noopener noreferrer" target="_blank">Fenzo TaskRequest 接口</a> 是 Fenzo 的任务请求接口，通过实现 <code>#getHardConstraints()</code> 方法，关联上 TaskRequest 和 ConstraintEvaluator。</li>
</ul>
<p>关联上之后，任务匹配 Mesos Slave 资源时，调用 <code>ConstraintEvaluator#evaluate(...)</code> 实现方法判断是否符合约束：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConstraintEvaluator</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isSuccessful;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String failureReason;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Inspects a target to decide whether or not it meets the constraints appropriate to a particular task.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> taskRequest a description of the task to be assigned</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> targetVM a description of the host that is a potential match for the task</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> taskTrackerState the current status of tasks and task assignments in the system at large</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> a successful Result if the target meets the constraints enforced by this constraint evaluator, or</span></div><div class="line"><span class="comment">     *         an unsuccessful Result otherwise</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">evaluate</span><span class="params">(TaskRequest taskRequest, VirtualMachineCurrentState targetVM,</span></span></div><div class="line"><span class="function"><span class="params">                           TaskTrackerState taskTrackerState)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OK，简单了解结束，有兴趣了解更多的同学，请点击<a href="https://github.com/Netflix/Fenzo/wiki/Constraints" rel="external nofollow noopener noreferrer" target="_blank">《Fenzo Wiki —— Constraints》</a>。下面来看看 Elastic-Job-Cloud-Scheduler 自定义实现的任务约束 AppConstraintEvaluator。</p>
<hr>
<p>调用 <code>AppConstraintEvaluator#loadAppRunningState()</code> 方法，加载当前运行中的<strong>云作业App</strong>，为 <code>AppConstraintEvaluator#evaluate(...)</code> 方法提供该数据。代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AppConstraintEvaluator.java</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; runningApps = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">loadAppRunningState</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">for</span> (MesosStateService.ExecutorStateInfo each : facadeService.loadExecutorInfo()) &#123;</div><div class="line">           runningApps.add(each.getId());</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> JSONException | UniformInterfaceException | ClientHandlerException e) &#123;</div><div class="line">       clearAppRunningState();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>调用 <code>FacadeService#loadExecutorInfo()</code> 方法，从 Mesos 获取所有正在运行的 Mesos 执行器( Executor )的信息。执行器和云作业App有啥关系？<strong>每个云作业App 即是一个 Elastic-Job-Cloud-Executor 实例。</strong>。<code>FacadeService#loadExecutorInfo()</code> 方法这里就不展开了，有兴趣的同学自己看下，主要是对 Mesos 的 API操作，我们来看下 <code>runningApps</code> 的结果：</p>
<p>  <img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_21/04.png" alt=""></p>
</li>
</ul>
<hr>
<p>调用 <code>TaskScheduler#scheduleOnce(...)</code> 方法调度提交任务所需资源时，会调用 <code>ConstraintEvaluator#loadAppRunningState()</code> 检查分配的资源是否符合任务的约束条件。<code>AppConstraintEvaluator#loadAppRunningState()</code> 实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AppConstraintEvaluator.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">evaluate</span><span class="params">(<span class="keyword">final</span> TaskRequest taskRequest, <span class="keyword">final</span> VirtualMachineCurrentState targetVM, <span class="keyword">final</span> TaskTrackerState taskTrackerState)</span> </span>&#123;</div><div class="line">   <span class="keyword">double</span> assigningCpus = <span class="number">0.0</span>d;</div><div class="line">   <span class="keyword">double</span> assigningMemoryMB = <span class="number">0.0</span>d;</div><div class="line">   <span class="keyword">final</span> String slaveId = targetVM.getAllCurrentOffers().iterator().next().getSlaveId().getValue();</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 判断当前分配的 Mesos Slave 是否运行着该作业任务请求对应的云作业App</span></div><div class="line">       <span class="keyword">if</span> (isAppRunningOnSlave(taskRequest.getId(), slaveId)) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">true</span>, <span class="string">""</span>);</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 判断当前分配的 Mesos Slave 启动云作业App 是否超过资源限制</span></div><div class="line">       Set&lt;String&gt; calculatedApps = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">// 已计算作业App集合</span></div><div class="line">       List&lt;TaskRequest&gt; taskRequests = <span class="keyword">new</span> ArrayList&lt;&gt;(targetVM.getTasksCurrentlyAssigned().size() + <span class="number">1</span>);</div><div class="line">       taskRequests.add(taskRequest);</div><div class="line">       <span class="keyword">for</span> (TaskAssignmentResult each : targetVM.getTasksCurrentlyAssigned()) &#123; <span class="comment">// 当前已经分配作业请求</span></div><div class="line">           taskRequests.add(each.getRequest());</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">for</span> (TaskRequest each : taskRequests) &#123;</div><div class="line">           assigningCpus += each.getCPUs();</div><div class="line">           assigningMemoryMB += each.getMemory();</div><div class="line">           <span class="keyword">if</span> (isAppRunningOnSlave(each.getId(), slaveId)) &#123; <span class="comment">// 作业App已经启动</span></div><div class="line">               <span class="keyword">continue</span>;</div><div class="line">           &#125;</div><div class="line">           CloudAppConfiguration assigningAppConfig = getAppConfiguration(each.getId());</div><div class="line">           <span class="keyword">if</span> (!calculatedApps.add(assigningAppConfig.getAppName())) &#123; <span class="comment">// 是否已经计算该App</span></div><div class="line">               <span class="keyword">continue</span>;</div><div class="line">           &#125;</div><div class="line">           assigningCpus += assigningAppConfig.getCpuCount();</div><div class="line">           assigningMemoryMB += assigningAppConfig.getMemoryMB();</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> LackConfigException ex) &#123;</div><div class="line">       log.warn(<span class="string">"Lack config, disable &#123;&#125;"</span>, getName(), ex);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">true</span>, <span class="string">""</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (assigningCpus &gt; targetVM.getCurrAvailableResources().cpuCores()) &#123; <span class="comment">// cpu</span></div><div class="line">       log.debug(<span class="string">"Failure &#123;&#125; &#123;&#125; cpus:&#123;&#125;/&#123;&#125;"</span>, taskRequest.getId(), slaveId, assigningCpus, targetVM.getCurrAvailableResources().cpuCores());</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">false</span>, String.format(<span class="string">"cpu:%s/%s"</span>, assigningCpus, targetVM.getCurrAvailableResources().cpuCores()));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (assigningMemoryMB &gt; targetVM.getCurrAvailableResources().memoryMB()) &#123; <span class="comment">// memory</span></div><div class="line">       log.debug(<span class="string">"Failure &#123;&#125; &#123;&#125; mem:&#123;&#125;/&#123;&#125;"</span>, taskRequest.getId(), slaveId, assigningMemoryMB, targetVM.getCurrAvailableResources().memoryMB());</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">false</span>, String.format(<span class="string">"mem:%s/%s"</span>, assigningMemoryMB, targetVM.getCurrAvailableResources().memoryMB()));</div><div class="line">   &#125;</div><div class="line">   log.debug(<span class="string">"Success &#123;&#125; &#123;&#125; cpus:&#123;&#125;/&#123;&#125; mem:&#123;&#125;/&#123;&#125;"</span>, taskRequest.getId(), slaveId, assigningCpus, targetVM.getCurrAvailableResources()</div><div class="line">           .cpuCores(), assigningMemoryMB, targetVM.getCurrAvailableResources().memoryMB());</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">true</span>, String.format(<span class="string">"cpus:%s/%s mem:%s/%s"</span>, assigningCpus, targetVM.getCurrAvailableResources()</div><div class="line">           .cpuCores(), assigningMemoryMB, targetVM.getCurrAvailableResources().memoryMB()));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用 <code>#isAppRunningOnSlave()</code> 方法，判断当前分配的 Mesos Slave 是否运行着该作业任务请求对应的云作业App。若云作业App未运行，则该作业任务请求提交给 Mesos 后，该 Mesos Slave 会启动该云作业 App，App 本身会占用一定的 <code>CloudAppConfiguration#cpu</code> 和 <code>CloudAppConfiguration#memory</code>，计算时需要统计，避免超过当前 Mesos Slave 剩余 <code>cpu</code> 和 <code>memory</code>。</li>
<li>当计算符合约束时，返回 <code>Result(true, ...)</code>；否则，返回 <code>Result(false, ...)</code>。</li>
<li>TODO 异常为啥返回true。</li>
</ul>
<h2 id="4-3-将任务请求分配到-Mesos-Offer"><a href="#4-3-将任务请求分配到-Mesos-Offer" class="headerlink" title="4.3 将任务请求分配到 Mesos Offer"></a>4.3 将任务请求分配到 Mesos Offer</h2><p>我们先<strong>简单</strong>了解下 Elastic-Job-Cloud-Scheduler 实现的 Mesos Scheduler 类 <code>com.dangdang.ddframe.job.cloud.scheduler.mesos.SchedulerEngine</code>。调度器的主要职责之一：<strong>在接受到的 Offer 上启动任务</strong>。SchedulerEngine 接收到资源 Offer，先存储到资源预占队列( LeasesQueue )，等到作业被调度需要启动任务时进行使用。存储到资源预占队列实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulerEngine</span> <span class="keyword">implements</span> <span class="title">Scheduler</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resourceOffers</span><span class="params">(<span class="keyword">final</span> SchedulerDriver schedulerDriver, <span class="keyword">final</span> List&lt;Protos.Offer&gt; offers)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Protos.Offer offer: offers) &#123;</div><div class="line">            log.trace(<span class="string">"Adding offer &#123;&#125; from host &#123;&#125;"</span>, offer.getId(), offer.getHostname());</div><div class="line">            LeasesQueue.getInstance().offer(offer);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>org.apache.mesos.Scheduler</code>，Mesos 调度器<strong>接口</strong>，实现该接口成为自定义 Mesos 调度器。</li>
<li><p>实现 <code>#resourceOffers(...)</code> 方法，有新的资源 Offer 时，会进行调用。在 SchedulerEngine 会调用 <code>#offer(...)</code> 方法，存储 Offer 到资源预占队列，实现代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LeasesQueue</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 单例</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> LeasesQueue INSTANCE = <span class="keyword">new</span> LeasesQueue();</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;VirtualMachineLease&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获取实例.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 单例对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LeasesQueue <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> INSTANCE;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 添加资源至队列预占.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> offer 资源</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(<span class="keyword">final</span> Protos.Offer offer)</span> </span>&#123;</div><div class="line">        queue.offer(<span class="keyword">new</span> VMLeaseObject(offer));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ... 省略 #drainTo() 方法，下文解析。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>VMLeaseObject，<a href="#">Netflix Fenzo</a> 对 Mesos Offer 的抽象包装，点击<a href="https://github.com/Netflix/Fenzo/blob/faa8a4dd411fff1792c9d788d1288a11e3635ba7/fenzo-core/src/main/java/com/netflix/fenzo/plugins/VMLeaseObject.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a>查看实现代码，马上会看到它的用途。</li>
</ul>
</li>
</ul>
<p>另外，可能有同学对 Mesos Offer 理解比较生涩，Offer 定义如下：</p>
<blockquote>
<p>FROM <a href="https://segmentfault.com/a/1190000007723430" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000007723430</a><br>Offer是Mesos资源的抽象，比如说有多少CPU、多少memory，disc是多少，都放在Offer里，打包给一个Framework，然后Framework来决定到底怎么用这个Offer。</p>
</blockquote>
<hr>
<p>OK，知识铺垫完成，回到本小节的重心：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// #runOneIteration()</span></div><div class="line">Collection&lt;VMAssignmentResult&gt; vmAssignmentResults = taskScheduler.scheduleOnce(taskRequests, LeasesQueue.getInstance().drainTo()).getResultMap().values();</div><div class="line"></div><div class="line"><span class="comment">// LeasesQueue.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LeasesQueue</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;VirtualMachineLease&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;VirtualMachineLease&gt; <span class="title">drainTo</span><span class="params">()</span> </span>&#123;</div><div class="line">        List&lt;VirtualMachineLease&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(queue.size());</div><div class="line">        queue.drainTo(result);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用 <code>TaskScheduler#scheduleOnce(...)</code> 方法，将任务请求分配到 Mesos Offer。通过 Fenzo TaskScheduler 实现对多个任务分配到多个 Mesos Offer 的<strong>合理优化分配</strong>。这是一个相对复杂的问题。为什么这么说呢？</p>
<blockquote>
<p>FROM <a href="http://product.dangdang.com/24187450.html" rel="external nofollow noopener noreferrer" target="_blank">《Mesos 框架构建分布式应用》</a> P76<br>将任务匹配到 offer 上，首次适配通常是最好的算法。你可能会想，如果在更多的工作里尝试计算出匹配该 offer 的优化组合，可能比首次适配更能高效地利用 offer。这绝对是正确的，但是要考虑如下这些方面：对于启动所有等待运行的任务来说，集群里要么有充足的资源要么没有。如果资源很多，那么首次适配肯定一直都能保证每个任务的启动。如果资源不够，怎么都无法启动所有任务。因此，编写代码选择接下来会运行哪个任务是很自然的，这样才能保证服务的质量。只有当资源刚够用时，才需要更为精细的打包算法。不幸的是，这里的问题 —— 通常称为背包问题( Knapsack problem ) —— 是一个众所周知的 NP 完全问题。NP 完全问题指的是需要相当长时间才能找到最优解决方案的问题，并且没有任何已知道技巧能够快速解决这类问题。</p>
</blockquote>
<p>举个简单的例子，只考虑 <code>memory</code> 资源情况下，有一台 Slave 内存为 8GB ，现在要运行三个 1GB 的作业和 5GB 的作业。其中 5GB 的作业在 1GB 运行多次之后才执行。 </p>
<p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_21/06.png" alt=""></p>
<p>实际情况会比图更加复杂的多的多。通过使用 Fenzo ，可以很方便的，并且令人满意的分配。为了让你对 Fenzo 有更加透彻的理解，这里再引用一段对其的介绍：</p>
<blockquote>
<p>FROM <a href="http://product.dangdang.com/24187450.html" rel="external nofollow noopener noreferrer" target="_blank">《Mesos 框架构建分布式应用》</a> P80<br><strong>调用库函数 Fenzo</strong><br>Fenzo 是 Nettflix 在 2015 年夏天发布的库函数。Fenzo 为基于 java 的调度器提供了完整的解决方案，完成 offer 缓冲，多任务启动，以及软和硬约束条件的匹配。就算不是所有的，也是很多调度器都能够受益于使用 Fenzo 来完成计算任务分配，而不用自己编写 offer 缓冲、打包和放置路由等。</p>
</blockquote>
<p>下面，来看两次 <code>TaskScheduler#scheduleOnce(...)</code> 的返回：</p>
<ul>
<li>第一次调度：<img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_21/07.png" alt=""></li>
<li>第二次调度：<img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_21/08.png" alt=""></li>
<li><p><code>com.netflix.fenzo.VMAssignmentResult</code>，每台主机分配任务结果。实现代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VMAssignmentResult</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 主机</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String hostname;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 使用的 Mesos Offer</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;VirtualMachineLease&gt; leasesUsed;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 分配的任务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;TaskAssignmentResult&gt; tasksAssigned;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>受限于笔者的能力，建议你可以在阅读如下文章，更透彻的理解 TaskScheduler ：</p>
<ul>
<li><a href="https://github.com/Netflix/Fenzo/wiki/How-to-use-Fenzo" rel="external nofollow noopener noreferrer" target="_blank">《Fenzo Wiki —— Constraints》</a></li>
<li><a href="https://github.com/Netflix/Fenzo/wiki/Building-Your-Scheduler" rel="external nofollow noopener noreferrer" target="_blank">《Fenzo Wiki —— Building Your Scheduler》</a></li>
<li><a href="https://github.com/Netflix/Fenzo/wiki/Scheduling-Tasks" rel="external nofollow noopener noreferrer" target="_blank">《Fenzo Wiki —— Scheduling Tasks》</a></li>
<li><a href="https://github.com/Netflix/Fenzo/wiki/Insights#how-to-learn-which-tasks-are-assigned-to-which-hosts" rel="external nofollow noopener noreferrer" target="_blank">《Fenzo Wiki —— How to Learn Which Tasks Are Assigned to Which Hosts》</a></li>
</ul>
<h2 id="4-4-创建-Mesos-任务信息"><a href="#4-4-创建-Mesos-任务信息" class="headerlink" title="4.4 创建 Mesos 任务信息"></a>4.4 创建 Mesos 任务信息</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// #runOneIteration()</span></div><div class="line">List&lt;TaskContext&gt; taskContextsList = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">// 任务运行时上下文集合</span></div><div class="line">Map&lt;List&lt;Protos.OfferID&gt;, List&lt;Protos.TaskInfo&gt;&gt; offerIdTaskInfoMap = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// Mesos 任务信息集合</span></div><div class="line"><span class="keyword">for</span> (VMAssignmentResult each: vmAssignmentResults) &#123;</div><div class="line">    List&lt;VirtualMachineLease&gt; leasesUsed = each.getLeasesUsed();</div><div class="line">    List&lt;Protos.TaskInfo&gt; taskInfoList = <span class="keyword">new</span> ArrayList&lt;&gt;(each.getTasksAssigned().size() * <span class="number">10</span>);</div><div class="line">    taskInfoList.addAll(getTaskInfoList(</div><div class="line">            launchingTasks.getIntegrityViolationJobs(vmAssignmentResults), <span class="comment">// 获得作业分片不完整的作业集合</span></div><div class="line">            each, leasesUsed.get(<span class="number">0</span>).hostname(), leasesUsed.get(<span class="number">0</span>).getOffer()));</div><div class="line">    <span class="keyword">for</span> (Protos.TaskInfo taskInfo : taskInfoList) &#123;</div><div class="line">        taskContextsList.add(TaskContext.from(taskInfo.getTaskId().getValue()));</div><div class="line">    &#125;</div><div class="line">    offerIdTaskInfoMap.put(getOfferIDs(leasesUsed), <span class="comment">// 获得 Offer ID 集合</span></div><div class="line">            taskInfoList);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p><code>offerIdTaskInfoMap</code>，Mesos 任务信息集合。key 和 value 都为相同 Mesos Slave Offer 和 任务。为什么？调用 <code>SchedulerDriver#launchTasks(...)</code> 方法提交<strong>一次</strong>任务时，必须保证所有任务和 Offer 在相同 Mesos Slave 上。</p>
<blockquote>
<p>FROM FROM <a href="http://product.dangdang.com/24187450.html" rel="external nofollow noopener noreferrer" target="_blank">《Mesos 框架构建分布式应用》</a> P61<br><strong>组合 offer</strong><br>latchTasks 接受 offer 列表为输入，这就允许用户将一些相同 slave 的 offer 组合起来，从而将这些 offer 的资源放到池里。它还能接受任务列表为输入，这样就能够启动适合给定 offer 的足够多的任务。注意所有任务和 offer 都必须是同一台 slave —— 如果不在同一台 slave 上，launchTasks 就会失败。如果想在多台 slave 上启动任务，多次调用 latchTasks 即可。</p>
</blockquote>
</li>
<li><p>调用 <code>LaunchingTasks#getIntegrityViolationJobs(...)</code> 方法，获得作业分片不完整的作业集合。<strong>一个作业有多个分片，因为 Mesos Offer 不足，导致有部分分片不能执行，则整个作业都不进行执行</strong>。代码实现如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LaunchingTasks.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获得作业分片不完整的作业集合</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> vmAssignmentResults 主机分配任务结果集合</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 作业分片不完整的作业集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function">Collection&lt;String&gt; <span class="title">getIntegrityViolationJobs</span><span class="params">(<span class="keyword">final</span> Collection&lt;VMAssignmentResult&gt; vmAssignmentResults)</span> </span>&#123;</div><div class="line">   Map&lt;String, Integer&gt; assignedJobShardingTotalCountMap = getAssignedJobShardingTotalCountMap(vmAssignmentResults);</div><div class="line">   Collection&lt;String&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(assignedJobShardingTotalCountMap.size(), <span class="number">1</span>);</div><div class="line">   <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : assignedJobShardingTotalCountMap.entrySet()) &#123;</div><div class="line">       JobContext jobContext = eligibleJobContextsMap.get(entry.getKey());</div><div class="line">       <span class="keyword">if</span> (ExecutionType.FAILOVER != jobContext.getType() <span class="comment">// 不包括 FAILOVER 执行类型的作业</span></div><div class="line">               &amp;&amp; !entry.getValue().equals(jobContext.getJobConfig().getTypeConfig().getCoreConfig().getShardingTotalCount())) &#123;</div><div class="line">           log.warn(<span class="string">"Job &#123;&#125; is not assigned at this time, because resources not enough to run all sharding instances."</span>, entry.getKey());</div><div class="line">           result.add(entry.getKey());</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获得每个作业分片数集合</span></div><div class="line"><span class="comment">* key：作业名</span></div><div class="line"><span class="comment">* value：分片总数</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> vmAssignmentResults 主机分配任务结果集合</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 每个作业分片数集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> Map&lt;String, Integer&gt; <span class="title">getAssignedJobShardingTotalCountMap</span><span class="params">(<span class="keyword">final</span> Collection&lt;VMAssignmentResult&gt; vmAssignmentResults)</span> </span>&#123;</div><div class="line">   Map&lt;String, Integer&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;(eligibleJobContextsMap.size(), <span class="number">1</span>);</div><div class="line">   <span class="keyword">for</span> (VMAssignmentResult vmAssignmentResult: vmAssignmentResults) &#123;</div><div class="line">       <span class="keyword">for</span> (TaskAssignmentResult tasksAssigned: vmAssignmentResult.getTasksAssigned()) &#123;</div><div class="line">           String jobName = TaskContext.from(tasksAssigned.getTaskId()).getMetaInfo().getJobName();</div><div class="line">           <span class="keyword">if</span> (result.containsKey(jobName)) &#123;</div><div class="line">               result.put(jobName, result.get(jobName) + <span class="number">1</span>);</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               result.put(jobName, <span class="number">1</span>);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>调用 <code>#getTaskInfoList(...)</code> 方法，创建<strong>单个主机</strong>的 Mesos 任务信息集合。实现代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> List&lt;Protos.TaskInfo&gt; getTaskInfoList(<span class="keyword">final</span> Collection&lt;String&gt; integrityViolationJobs, <span class="keyword">final</span> VMAssignmentResult vmAssignmentResult, <span class="keyword">final</span> String hostname, <span class="keyword">final</span> Protos.Offer offer) &#123;</div><div class="line">   List&lt;Protos.TaskInfo&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(vmAssignmentResult.getTasksAssigned().size());</div><div class="line">   <span class="keyword">for</span> (TaskAssignmentResult each: vmAssignmentResult.getTasksAssigned()) &#123;</div><div class="line">       TaskContext taskContext = TaskContext.from(each.getTaskId());</div><div class="line">       String jobName = taskContext.getMetaInfo().getJobName();</div><div class="line">       <span class="keyword">if</span> (!integrityViolationJobs.contains(jobName) <span class="comment">// 排除作业分片不完整的任务</span></div><div class="line">               &amp;&amp; !facadeService.isRunning(taskContext) <span class="comment">// 排除正在运行中的任务</span></div><div class="line">               &amp;&amp; !facadeService.isJobDisabled(jobName)) &#123; <span class="comment">// 排除被禁用的任务</span></div><div class="line">           <span class="comment">// 创建 Mesos 任务</span></div><div class="line">           Protos.TaskInfo taskInfo = getTaskInfo(offer, each);</div><div class="line">           <span class="keyword">if</span> (<span class="keyword">null</span> != taskInfo) &#123;</div><div class="line">               result.add(taskInfo);</div><div class="line">               <span class="comment">// 添加任务主键和主机名称的映射</span></div><div class="line">               facadeService.addMapping(taskInfo.getTaskId().getValue(), hostname);</div><div class="line">               <span class="comment">// 通知 TaskScheduler 主机分配了这个任务</span></div><div class="line">               taskScheduler.getTaskAssigner().call(each.getRequest(), hostname);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用 <code>#getTaskInfo(...)</code> 方法，创建单个 Mesos 任务，在<a href="#">「4.4.1 创建单个 Mesos 任务信息」</a>详细解析。</li>
<li><p>调用 <code>FacadeService#addMapping(...)</code> 方法，添加任务主键和主机名称的映射。通过该映射，可以根据任务主键查询到对应的主机名。实现代码如下：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// FacadeService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 添加任务主键和主机名称的映射.</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> taskId 任务主键</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> hostname 主机名称</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMapping</span><span class="params">(<span class="keyword">final</span> String taskId, <span class="keyword">final</span> String hostname)</span> </span>&#123;</div><div class="line">   runningService.addMapping(taskId, hostname);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// RunningService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 任务主键和主机名称的映射</span></div><div class="line"><span class="comment">* key: 任务主键</span></div><div class="line"><span class="comment">* value: 主机名称</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, String&gt; TASK_HOSTNAME_MAPPER = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(TASK_INITIAL_SIZE);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMapping</span><span class="params">(<span class="keyword">final</span> String taskId, <span class="keyword">final</span> String hostname)</span> </span>&#123;</div><div class="line">   TASK_HOSTNAME_MAPPER.putIfAbsent(taskId, hostname);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>调用 <code>TaskScheduler#getTaskAssigner()#call(...)</code> 方法，通知 TaskScheduler 任务被<strong>确认</strong>分配到这个主机。TaskScheduler 做任务和 Offer 的匹配，对哪些任务运行在哪些主机是有依赖的，不然怎么做匹配优化呢。在<a href="https://github.com/Netflix/Fenzo/wiki/How-to-use-Fenzo#notify-the-scheduler-of-assigns-and-unassigns-of-tasks" rel="external nofollow noopener noreferrer" target="_blank">《Fenzo Wiki —— Notify the Scheduler of Assigns and UnAssigns of Tasks》</a>可以进一步了解。</p>
</li>
</ul>
</li>
<li><p>调用 <code>#getOfferIDs(...)</code> 方法，获得 Offer ID 集合。实现代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> List&lt;Protos.OfferID&gt; getOfferIDs(<span class="keyword">final</span> List&lt;VirtualMachineLease&gt; leasesUsed) &#123;</div><div class="line">   List&lt;Protos.OfferID&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">   <span class="keyword">for</span> (VirtualMachineLease virtualMachineLease: leasesUsed) &#123;</div><div class="line">       result.add(virtualMachineLease.getOffer().getId());</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-4-1-创建单个-Mesos-任务信息"><a href="#4-4-1-创建单个-Mesos-任务信息" class="headerlink" title="4.4.1 创建单个 Mesos 任务信息"></a>4.4.1 创建单个 Mesos 任务信息</h3><p>调用 <code>#getTaskInfo()</code> 方法，创建单个 Mesos 任务信息。实现代码如下：</p>
<p><strong>如下会涉及大量的 Mesos API</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> Protos.<span class="function">TaskInfo <span class="title">getTaskInfo</span><span class="params">(<span class="keyword">final</span> Protos.Offer offer, <span class="keyword">final</span> TaskAssignmentResult taskAssignmentResult)</span> </span>&#123;</div><div class="line">   <span class="comment">// 校验 作业配置 是否存在</span></div><div class="line">   TaskContext taskContext = TaskContext.from(taskAssignmentResult.getTaskId());</div><div class="line">   Optional&lt;CloudJobConfiguration&gt; jobConfigOptional = facadeService.load(taskContext.getMetaInfo().getJobName());</div><div class="line">   <span class="keyword">if</span> (!jobConfigOptional.isPresent()) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line">   CloudJobConfiguration jobConfig = jobConfigOptional.get();</div><div class="line">   <span class="comment">// 校验 作业配置 是否存在</span></div><div class="line">   Optional&lt;CloudAppConfiguration&gt; appConfigOptional = facadeService.loadAppConfig(jobConfig.getAppName());</div><div class="line">   <span class="keyword">if</span> (!appConfigOptional.isPresent()) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div><div class="line">   CloudAppConfiguration appConfig = appConfigOptional.get();</div><div class="line">   <span class="comment">// 设置 Mesos Slave ID</span></div><div class="line">   taskContext.setSlaveId(offer.getSlaveId().getValue());</div><div class="line">   <span class="comment">// 获得 分片上下文集合</span></div><div class="line">   ShardingContexts shardingContexts = getShardingContexts(taskContext, appConfig, jobConfig);</div><div class="line">   <span class="comment">// 瞬时的脚本作业，使用 Mesos 命令行执行，无需使用执行器</span></div><div class="line">   <span class="keyword">boolean</span> isCommandExecutor = CloudJobExecutionType.TRANSIENT == jobConfig.getJobExecutionType() &amp;&amp; JobType.SCRIPT == jobConfig.getTypeConfig().getJobType();</div><div class="line">   String script = appConfig.getBootstrapScript();</div><div class="line">   <span class="keyword">if</span> (isCommandExecutor) &#123;</div><div class="line">       script = ((ScriptJobConfiguration) jobConfig.getTypeConfig()).getScriptCommandLine();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 创建 启动命令</span></div><div class="line">   Protos.CommandInfo.URI uri = buildURI(appConfig, isCommandExecutor);</div><div class="line">   Protos.CommandInfo command = buildCommand(uri, script, shardingContexts, isCommandExecutor);</div><div class="line">   <span class="comment">// 创建 Mesos 任务信息</span></div><div class="line">   <span class="keyword">if</span> (isCommandExecutor) &#123;</div><div class="line">       <span class="keyword">return</span> buildCommandExecutorTaskInfo(taskContext, jobConfig, shardingContexts, offer, command);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">return</span> buildCustomizedExecutorTaskInfo(taskContext, appConfig, jobConfig, shardingContexts, offer, command);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>调用 <code>#getShardingContexts(...)</code> 方法， 获得分片上下文集合。实现代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> ShardingContexts <span class="title">getShardingContexts</span><span class="params">(<span class="keyword">final</span> TaskContext taskContext, <span class="keyword">final</span> CloudAppConfiguration appConfig, <span class="keyword">final</span> CloudJobConfiguration jobConfig)</span> </span>&#123;</div><div class="line">   Map&lt;Integer, String&gt; shardingItemParameters = <span class="keyword">new</span> ShardingItemParameters(jobConfig.getTypeConfig().getCoreConfig().getShardingItemParameters()).getMap();</div><div class="line">   Map&lt;Integer, String&gt; assignedShardingItemParameters = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">1</span>, <span class="number">1</span>);</div><div class="line">   <span class="keyword">int</span> shardingItem = taskContext.getMetaInfo().getShardingItems().get(<span class="number">0</span>); <span class="comment">// 单个作业分片</span></div><div class="line">   assignedShardingItemParameters.put(shardingItem, shardingItemParameters.containsKey(shardingItem) ? shardingItemParameters.get(shardingItem) : <span class="string">""</span>);</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ShardingContexts(taskContext.getId(), jobConfig.getJobName(), jobConfig.getTypeConfig().getCoreConfig().getShardingTotalCount(),</div><div class="line">           jobConfig.getTypeConfig().getCoreConfig().getJobParameter(), assignedShardingItemParameters, appConfig.getEventTraceSamplingCount());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>当任务为<strong>瞬时</strong>的<strong>脚本</strong>作业时，使用 Mesos Slave 命令行调用即可，无需使用 Elastic-Job-Cloud-Executor。</p>
</li>
<li><p>调用 <code>#buildURI(...)</code> 方法，创建执行器的二进制文件下载地址。试下代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> Protos.CommandInfo.<span class="function">URI <span class="title">buildURI</span><span class="params">(<span class="keyword">final</span> CloudAppConfiguration appConfig, <span class="keyword">final</span> <span class="keyword">boolean</span> isCommandExecutor)</span> </span>&#123;</div><div class="line">   Protos.CommandInfo.URI.Builder result = Protos.CommandInfo.URI.newBuilder()</div><div class="line">           .setValue(appConfig.getAppURL())</div><div class="line">           .setCache(appConfig.isAppCacheEnable()); <span class="comment">// cache</span></div><div class="line">   <span class="keyword">if</span> (isCommandExecutor &amp;&amp; !SupportedExtractionType.isExtraction(appConfig.getAppURL())) &#123;</div><div class="line">       result.setExecutable(<span class="keyword">true</span>); <span class="comment">// 是否可执行</span></div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       result.setExtract(<span class="keyword">true</span>); <span class="comment">// 是否需要解压</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result.build();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>云作业应用配置 <code>CloudAppConfiguration.appURL</code> ，通过 Mesos 实现文件的下载。</li>
<li><p>云作业应用配置 <code>CloudAppConfiguration.appCacheEnable</code>，应用文件下载是否缓存。</p>
<blockquote>
<p>FROM <a href="http://product.dangdang.com/24187450.html" rel="external nofollow noopener noreferrer" target="_blank">《Mesos 框架构建分布式应用》</a> P99<br><strong>Fetcher 缓存</strong><br>Mesos 0.23 里发布称为 fetcher 缓存的新功能。fetcher 缓存确保每个 artifact 在每个 slave 只会下载一次，即使多个执行器请求同一个 artifact，也只需要等待单词下载完成即可。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>调用 <code>#buildCommand(...)</code> 方法，创建执行器启动命令。实现代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> Protos.<span class="function">CommandInfo <span class="title">buildCommand</span><span class="params">(<span class="keyword">final</span> Protos.CommandInfo.URI uri, <span class="keyword">final</span> String script, <span class="keyword">final</span> ShardingContexts shardingContexts, <span class="keyword">final</span> <span class="keyword">boolean</span> isCommandExecutor)</span> </span>&#123;</div><div class="line">   Protos.CommandInfo.Builder result = Protos.CommandInfo.newBuilder().addUris(uri).setShell(<span class="keyword">true</span>);</div><div class="line">   <span class="keyword">if</span> (isCommandExecutor) &#123;</div><div class="line">       CommandLine commandLine = CommandLine.parse(script);</div><div class="line">       commandLine.addArgument(GsonFactory.getGson().toJson(shardingContexts), <span class="keyword">false</span>);</div><div class="line">       result.setValue(Joiner.on(<span class="string">" "</span>).join(commandLine.getExecutable(), Joiner.on(<span class="string">" "</span>).join(commandLine.getArguments())));</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       result.setValue(script);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result.build();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>调用 <code>#buildCommandExecutorTaskInfo(...)</code> 方法，为<strong>瞬时</strong>的<strong>脚本</strong>作业创建 Mesos 任务信息。实现代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> Protos.<span class="function">TaskInfo <span class="title">buildCommandExecutorTaskInfo</span><span class="params">(<span class="keyword">final</span> TaskContext taskContext, <span class="keyword">final</span> CloudJobConfiguration jobConfig, <span class="keyword">final</span> ShardingContexts shardingContexts,</span></span></div><div class="line"><span class="function"><span class="params">                                                    <span class="keyword">final</span> Protos.Offer offer, <span class="keyword">final</span> Protos.CommandInfo command)</span> </span>&#123;</div><div class="line">   Protos.TaskInfo.Builder result = Protos.TaskInfo.newBuilder().setTaskId(Protos.TaskID.newBuilder().setValue(taskContext.getId()).build())</div><div class="line">           .setName(taskContext.getTaskName()).setSlaveId(offer.getSlaveId())</div><div class="line">           .addResources(buildResource(<span class="string">"cpus"</span>, jobConfig.getCpuCount(), offer.getResourcesList()))</div><div class="line">           .addResources(buildResource(<span class="string">"mem"</span>, jobConfig.getMemoryMB(), offer.getResourcesList()))</div><div class="line">           .setData(ByteString.copyFrom(<span class="keyword">new</span> TaskInfoData(shardingContexts, jobConfig).serialize())); <span class="comment">//</span></div><div class="line">   <span class="keyword">return</span> result.setCommand(command).build();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>调用 <code>#buildCustomizedExecutorTaskInfo(...)</code> 方法，创建 Mesos 任务信息。实现代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> Protos.<span class="function">TaskInfo <span class="title">buildCustomizedExecutorTaskInfo</span><span class="params">(<span class="keyword">final</span> TaskContext taskContext, <span class="keyword">final</span> CloudAppConfiguration appConfig, <span class="keyword">final</span> CloudJobConfiguration jobConfig, </span></span></div><div class="line"><span class="function"><span class="params">                                                       <span class="keyword">final</span> ShardingContexts shardingContexts, <span class="keyword">final</span> Protos.Offer offer, <span class="keyword">final</span> Protos.CommandInfo command)</span> </span>&#123;</div><div class="line">   Protos.TaskInfo.Builder result = Protos.TaskInfo.newBuilder().setTaskId(Protos.TaskID.newBuilder().setValue(taskContext.getId()).build())</div><div class="line">           .setName(taskContext.getTaskName()).setSlaveId(offer.getSlaveId())</div><div class="line">           .addResources(buildResource(<span class="string">"cpus"</span>, jobConfig.getCpuCount(), offer.getResourcesList()))</div><div class="line">           .addResources(buildResource(<span class="string">"mem"</span>, jobConfig.getMemoryMB(), offer.getResourcesList()))</div><div class="line">           .setData(ByteString.copyFrom(<span class="keyword">new</span> TaskInfoData(shardingContexts, jobConfig).serialize()));</div><div class="line">   <span class="comment">// ExecutorInfo</span></div><div class="line">   Protos.ExecutorInfo.Builder executorBuilder = Protos.ExecutorInfo.newBuilder().setExecutorId(Protos.ExecutorID.newBuilder()</div><div class="line">           .setValue(taskContext.getExecutorId(jobConfig.getAppName()))) <span class="comment">// 执行器 ID</span></div><div class="line">           .setCommand(command)</div><div class="line">           .addResources(buildResource(<span class="string">"cpus"</span>, appConfig.getCpuCount(), offer.getResourcesList()))</div><div class="line">           .addResources(buildResource(<span class="string">"mem"</span>, appConfig.getMemoryMB(), offer.getResourcesList()));</div><div class="line">   <span class="keyword">if</span> (env.getJobEventRdbConfiguration().isPresent()) &#123;</div><div class="line">       executorBuilder.setData(ByteString.copyFrom(SerializationUtils.serialize(env.getJobEventRdbConfigurationMap()))).build();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result.setExecutor(executorBuilder.build()).build();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>调用 <code>Protos.ExecutorInfo.Builder#setValue(...)</code> 方法，设置<strong>执行器编号</strong>。大多数在 Mesos 实现的执行器，一个任务对应一个执行器。而 Elastic-Job-Cloud-Executor 不同于大多数在 Mesos 上的执行器，一个执行器可以对应多个作业。什么意思？在一个 Mesos Slave，<strong>相同</strong>作业应用，只会启动一个 Elastic-Job-Cloud-Scheduler。当该执行器不存在时，启动一个。当该执行器已经存在，复用该执行器。那么是如何实现该功能的呢？<strong>相同</strong>作业应用，在同一个 Mesos Slave，使用相同执行器编号。实现代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 获取任务执行器主键.</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> appName 应用名称</span></div><div class="line"><span class="comment"> * <span class="doctag">@return</span> 任务执行器主键</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getExecutorId</span><span class="params">(<span class="keyword">final</span> String appName)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Joiner.on(DELIMITER).join(appName, slaveId);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="4-5-将任务运行时上下文放入运行时队列"><a href="#4-5-将任务运行时上下文放入运行时队列" class="headerlink" title="4.5 将任务运行时上下文放入运行时队列"></a>4.5 将任务运行时上下文放入运行时队列</h2><p>调用 <code>FacadeService#addRunning(...)</code> 方法，将任务运行时上下文放入运行时队列。实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// FacadeService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 将任务运行时上下文放入运行时队列.</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> taskContext 任务运行时上下文</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addRunning</span><span class="params">(<span class="keyword">final</span> TaskContext taskContext)</span> </span>&#123;</div><div class="line">   runningService.add(taskContext);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// RunningService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 将任务运行时上下文放入运行时队列.</span></div><div class="line"><span class="comment">* </span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> taskContext 任务运行时上下文</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">final</span> TaskContext taskContext)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (!configurationService.load(taskContext.getMetaInfo().getJobName()).isPresent()) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 添加到运行中的任务集合</span></div><div class="line">   getRunningTasks(taskContext.getMetaInfo().getJobName()).add(taskContext);</div><div class="line">   <span class="comment">// 判断是否为常驻任务</span></div><div class="line">   <span class="keyword">if</span> (!isDaemon(taskContext.getMetaInfo().getJobName())) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 添加到运行中队列</span></div><div class="line">   String runningTaskNodePath = RunningNode.getRunningTaskNodePath(taskContext.getMetaInfo().toString());</div><div class="line">   <span class="keyword">if</span> (!regCenter.isExisted(runningTaskNodePath)) &#123;</div><div class="line">       regCenter.persist(runningTaskNodePath, taskContext.getId());</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// RunningNode.java</span></div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunningNode</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ROOT = StateNode.ROOT + <span class="string">"/running"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RUNNING_JOB = ROOT + <span class="string">"/%s"</span>; <span class="comment">// %s = $&#123;JOB_NAME&#125;</span></div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RUNNING_TASK = RUNNING_JOB + <span class="string">"/%s"</span>; <span class="comment">// %s = $&#123;TASK_META_INFO&#125;。$&#123;TASK_META_INFO&#125;=$&#123;JOB_NAME&#125;@-@$&#123;ITEM_ID&#125;。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>RunningService，任务运行时服务，提供对运行中的任务集合、运行中作业队列的各种操作方法。</li>
<li><p>调用 <code>#getRunningTasks()</code> 方法，获得<strong>运行中的任务集合</strong>，并将当前任务添加到其中。实现代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Collection&lt;TaskContext&gt; <span class="title">getRunningTasks</span><span class="params">(<span class="keyword">final</span> String jobName)</span> </span>&#123;</div><div class="line">   Set&lt;TaskContext&gt; taskContexts = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</div><div class="line">   Collection&lt;TaskContext&gt; result = RUNNING_TASKS.putIfAbsent(jobName, taskContexts);</div><div class="line">   <span class="keyword">return</span> <span class="keyword">null</span> == result ? taskContexts : result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  在运维平台，我们可以看到当前任务正在运行中：</p>
<p>  <img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_21/09.png" alt=""></p>
</li>
<li><p>常驻作业会存储在<strong>运行中作业队列</strong>。运行中作业队列存储在注册中心( Zookeeper )的<strong>持久</strong>数据节点 <code>/${NAMESPACE}/state/running/${JOB_NAME}/${TASK_META_INFO}</code>，存储值为任务编号。使用 zkClient 查看如下： </p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 14] ls /elastic-job-cloud/state/running/test_job_simple</div><div class="line">[test_job_simple@-@0, test_job_simple@-@1, test_job_simple@-@2]</div><div class="line">[zk: localhost:2181(CONNECTED) 15] get /elastic-job-cloud/state/running/test_job_simple/test_job_simple@-@0</div><div class="line">test_job_simple@-@0@-@READY@-@400197d9-76ca-464b-b2f0-e0fba5c2a598-S0@-@9780ed12-9612-45e3-ac14-feb2911896ff</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4-6-从队列中删除已运行的作业"><a href="#4-6-从队列中删除已运行的作业" class="headerlink" title="4.6 从队列中删除已运行的作业"></a>4.6 从队列中删除已运行的作业</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// #runOneIteration()</span></div><div class="line">facadeService.removeLaunchTasksFromQueue(taskContextsList);</div><div class="line"></div><div class="line"><span class="comment">// FacadeService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 从队列中删除已运行的作业.</span></div><div class="line"><span class="comment">* </span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> taskContexts 任务上下文集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeLaunchTasksFromQueue</span><span class="params">(<span class="keyword">final</span> List&lt;TaskContext&gt; taskContexts)</span> </span>&#123;</div><div class="line">   List&lt;TaskContext&gt; failoverTaskContexts = <span class="keyword">new</span> ArrayList&lt;&gt;(taskContexts.size());</div><div class="line">   Collection&lt;String&gt; readyJobNames = <span class="keyword">new</span> HashSet&lt;&gt;(taskContexts.size(), <span class="number">1</span>);</div><div class="line">   <span class="keyword">for</span> (TaskContext each : taskContexts) &#123;</div><div class="line">       <span class="keyword">switch</span> (each.getType()) &#123;</div><div class="line">           <span class="keyword">case</span> FAILOVER:</div><div class="line">               failoverTaskContexts.add(each);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> READY:</div><div class="line">               readyJobNames.add(each.getMetaInfo().getJobName());</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">default</span>:</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 从失效转移队列中删除相关任务</span></div><div class="line">   failoverService.remove(Lists.transform(failoverTaskContexts, <span class="keyword">new</span> Function&lt;TaskContext, TaskContext.MetaInfo&gt;() &#123;</div><div class="line">       </div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="keyword">public</span> TaskContext.<span class="function">MetaInfo <span class="title">apply</span><span class="params">(<span class="keyword">final</span> TaskContext input)</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> input.getMetaInfo();</div><div class="line">       &#125;</div><div class="line">   &#125;));</div><div class="line">   <span class="comment">// 从待执行队列中删除相关作业</span></div><div class="line">   readyService.remove(readyJobNames);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-7-提交任务给-Mesos"><a href="#4-7-提交任务给-Mesos" class="headerlink" title="4.7 提交任务给 Mesos"></a>4.7 提交任务给 Mesos</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// #runOneIteration()</span></div><div class="line"><span class="keyword">for</span> (Entry&lt;List&lt;OfferID&gt;, List&lt;TaskInfo&gt;&gt; each : offerIdTaskInfoMap.entrySet()) &#123;</div><div class="line">   schedulerDriver.launchTasks(each.getKey(), each.getValue());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用 <code>SchedulerDriver#launchTasks(...)</code> 方法，提交任务给 Mesos Master。由 Mesos Master 调度任务给 Mesos Slave。Mesos Slave 提交执行器执行任务。</li>
</ul>
<h1 id="5-TaskExecutor-执行任务"><a href="#5-TaskExecutor-执行任务" class="headerlink" title="5. TaskExecutor 执行任务"></a>5. TaskExecutor 执行任务</h1><p>TaskExecutor，实现了 Mesos Executor 接口 <code>org.apache.mesos.Executor</code>。执行器的主要职责之一：<strong>执行调度器所请求的任务</strong>。TaskExecutor 接收到 Mesos Slave 提交的任务，调用 <code>#launchTask(...)</code> 方法，处理任务。实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DaemonTaskScheduler.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">launchTask</span><span class="params">(<span class="keyword">final</span> ExecutorDriver executorDriver, <span class="keyword">final</span> Protos.TaskInfo taskInfo)</span> </span>&#123;</div><div class="line">   executorService.submit(<span class="keyword">new</span> TaskThread(executorDriver, taskInfo));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用 <code>ExecutorService#submit(...)</code> 方法，提交 TaskThread 到线程池，执行任务。</li>
</ul>
<h2 id="5-1-TaskThread"><a href="#5-1-TaskThread" class="headerlink" title="5.1 TaskThread"></a>5.1 TaskThread</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@RequiredArgsConstructor</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">   </div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ExecutorDriver executorDriver;</div><div class="line">   </div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> TaskInfo taskInfo;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="comment">// 更新 Mesos 任务状态，运行中。</span></div><div class="line">       executorDriver.sendStatusUpdate(Protos.TaskStatus.newBuilder().setTaskId(taskInfo.getTaskId()).setState(Protos.TaskState.TASK_RUNNING).build());</div><div class="line">       <span class="comment">//</span></div><div class="line">       Map&lt;String, Object&gt; data = SerializationUtils.deserialize(taskInfo.getData().toByteArray());</div><div class="line">       ShardingContexts shardingContexts = (ShardingContexts) data.get(<span class="string">"shardingContext"</span>);</div><div class="line">       <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">       JobConfigurationContext jobConfig = <span class="keyword">new</span> JobConfigurationContext((Map&lt;String, String&gt;) data.get(<span class="string">"jobConfigContext"</span>));</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           <span class="comment">// 获得 分布式作业</span></div><div class="line">           ElasticJob elasticJob = getElasticJobInstance(jobConfig);</div><div class="line">           <span class="comment">// 调度器提供内部服务的门面对象</span></div><div class="line">           <span class="keyword">final</span> CloudJobFacade jobFacade = <span class="keyword">new</span> CloudJobFacade(shardingContexts, jobConfig, jobEventBus);</div><div class="line">           <span class="comment">// 执行作业</span></div><div class="line">           <span class="keyword">if</span> (jobConfig.isTransient()) &#123;</div><div class="line">               <span class="comment">// 执行作业</span></div><div class="line">               JobExecutorFactory.getJobExecutor(elasticJob, jobFacade).execute();</div><div class="line">               <span class="comment">// 更新 Mesos 任务状态，已完成。</span></div><div class="line">               executorDriver.sendStatusUpdate(Protos.TaskStatus.newBuilder().setTaskId(taskInfo.getTaskId()).setState(Protos.TaskState.TASK_FINISHED).build());</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="comment">// 初始化 常驻作业调度器</span></div><div class="line">               <span class="keyword">new</span> DaemonTaskScheduler(elasticJob, jobConfig, jobFacade, executorDriver, taskInfo.getTaskId()).init();</div><div class="line">           &#125;</div><div class="line">           <span class="comment">// CHECKSTYLE:OFF</span></div><div class="line">       &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable ex) &#123;</div><div class="line">           <span class="comment">// CHECKSTYLE:ON</span></div><div class="line">           log.error(<span class="string">"Elastic-Job-Cloud-Executor error"</span>, ex);</div><div class="line">           executorDriver.sendStatusUpdate(Protos.TaskStatus.newBuilder().setTaskId(taskInfo.getTaskId()).setState(Protos.TaskState.TASK_ERROR).setMessage(ExceptionUtil.transform(ex)).build());</div><div class="line">           executorDriver.stop();</div><div class="line">           <span class="keyword">throw</span> ex;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>从 <code>TaskInfo.data</code> 属性中，可以获得提交任务附带的数据，例如分片上下文集合( ShardingContexts )，内部的作业配置上下文( JobConfigurationContext )。</li>
<li><p>调用 <code>#getElasticJobInstance()</code> 方法，获得任务需要执行的分布式作业( Elastic-Job )。实现代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> ElasticJob <span class="title">getElasticJobInstance</span><span class="params">(<span class="keyword">final</span> JobConfigurationContext jobConfig)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!Strings.isNullOrEmpty(jobConfig.getBeanName()) &amp;&amp; !Strings.isNullOrEmpty(jobConfig.getApplicationContext())) &#123; <span class="comment">// spring 环境</span></div><div class="line">      <span class="keyword">return</span> getElasticJobBean(jobConfig);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> getElasticJobClass(jobConfig);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 从 Spring 容器中获得作业对象</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> jobConfig 作业配置</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 作业对象</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> ElasticJob <span class="title">getElasticJobBean</span><span class="params">(<span class="keyword">final</span> JobConfigurationContext jobConfig)</span> </span>&#123;</div><div class="line">  String applicationContextFile = jobConfig.getApplicationContext();</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">null</span> == applicationContexts.get(applicationContextFile)) &#123;</div><div class="line">      <span class="keyword">synchronized</span> (applicationContexts) &#123;</div><div class="line">          <span class="keyword">if</span> (<span class="keyword">null</span> == applicationContexts.get(applicationContextFile)) &#123;</div><div class="line">              applicationContexts.put(applicationContextFile, <span class="keyword">new</span> ClassPathXmlApplicationContext(applicationContextFile));</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> (ElasticJob) applicationContexts.get(applicationContextFile).getBean(jobConfig.getBeanName());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 创建作业对象</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> jobConfig 作业配置</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 作业对象</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> ElasticJob <span class="title">getElasticJobClass</span><span class="params">(<span class="keyword">final</span> JobConfigurationContext jobConfig)</span> </span>&#123;</div><div class="line">  String jobClass = jobConfig.getTypeConfig().getJobClass();</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">      Class&lt;?&gt; elasticJobClass = Class.forName(jobClass);</div><div class="line">      <span class="keyword">if</span> (!ElasticJob.class.isAssignableFrom(elasticJobClass)) &#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(<span class="string">"Elastic-Job: Class '%s' must implements ElasticJob interface."</span>, jobClass);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (elasticJobClass != ScriptJob.class) &#123;</div><div class="line">          <span class="keyword">return</span> (ElasticJob) elasticJobClass.newInstance();</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> ReflectiveOperationException ex) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(<span class="string">"Elastic-Job: Class '%s' initialize failure, the error message is '%s'."</span>, jobClass, ex.getMessage());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>当作业是<strong>瞬时</strong>作业时，调用 <code>AbstractElasticJobExecutor#execute(...)</code> 执行作业逻辑，并调用 <code>ExecutorDriver#sendStatusUpdate(...)</code> 发送状态，更新 Mesos 任务已完成( Protos.TaskState.TASK_FINISHED )。<code>AbstractElasticJobExecutor#execute(...)</code> 实现代码，在 Elastic-Job-Lite 和 Elastic-Job-Cloud 基本一致，在<a href="http://www.iocoder.cn/Elastic-Job/job-execute/?self">《Elastic-Job-Lite 源码分析 —— 作业执行》</a>有详细解析。</li>
<li>当作业是<strong>常驻</strong>作业时，调用 <code>DaemonTaskScheduler#init()</code> 方法，初始化作业调度，在「5.2 DaemonTaskScheduler」详细解析。</li>
</ul>
</li>
</ul>
<h2 id="5-2-DaemonTaskScheduler"><a href="#5-2-DaemonTaskScheduler" class="headerlink" title="5.2 DaemonTaskScheduler"></a>5.2 DaemonTaskScheduler</h2><p><strong>瞬时</strong>作业，通过 Elastic-Job-Cloud-Scheduler 调度任务，提交 Elastic-Job-Cloud-Executor 执行后，等待 Elastic-Job-Scheduler 进行下次调度。</p>
<p><strong>常驻</strong>作业，通过 Elastic-Job-Scheduler 提交 Elastic-Job-Cloud-Executor 进行调度。Elastic-Job-Cloud-Executor 使用 DaemonTaskScheduler 不断对常驻作业进行调度而无需 Elastic-Job-Cloud-Scheduler 参与其中。</p>
<p>这就是<strong>瞬时</strong>作业和<strong>常驻</strong>作业不同之处。</p>
<p>DaemonTaskScheduler，常驻作业调度器。调用 <code>DaemonTaskScheduler#init()</code> 方法，对<strong>一个</strong>作业初始化调度，实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 初始化作业.</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// Quartz JobDetail</span></div><div class="line">   JobDetail jobDetail = JobBuilder.newJob(DaemonJob.class)</div><div class="line">           .withIdentity(jobRootConfig.getTypeConfig().getCoreConfig().getJobName()).build();</div><div class="line">   jobDetail.getJobDataMap().put(ELASTIC_JOB_DATA_MAP_KEY, elasticJob);</div><div class="line">   jobDetail.getJobDataMap().put(JOB_FACADE_DATA_MAP_KEY, jobFacade);</div><div class="line">   jobDetail.getJobDataMap().put(EXECUTOR_DRIVER_DATA_MAP_KEY, executorDriver);</div><div class="line">   jobDetail.getJobDataMap().put(TASK_ID_DATA_MAP_KEY, taskId);</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       scheduleJob(initializeScheduler(), jobDetail, taskId.getValue(), jobRootConfig.getTypeConfig().getCoreConfig().getCron());</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SchedulerException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> Scheduler <span class="title">initializeScheduler</span><span class="params">()</span> <span class="keyword">throws</span> SchedulerException </span>&#123;</div><div class="line">   StdSchedulerFactory factory = <span class="keyword">new</span> StdSchedulerFactory();</div><div class="line">   factory.initialize(getBaseQuartzProperties());</div><div class="line">   <span class="keyword">return</span> factory.getScheduler();</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> Properties <span class="title">getBaseQuartzProperties</span><span class="params">()</span> </span>&#123;</div><div class="line">   Properties result = <span class="keyword">new</span> Properties();</div><div class="line">   result.put(<span class="string">"org.quartz.threadPool.class"</span>, org.quartz.simpl.SimpleThreadPool.class.getName());</div><div class="line">   result.put(<span class="string">"org.quartz.threadPool.threadCount"</span>, <span class="string">"1"</span>); <span class="comment">// 线程数：1</span></div><div class="line">   result.put(<span class="string">"org.quartz.scheduler.instanceName"</span>, taskId.getValue());</div><div class="line">   <span class="keyword">if</span> (!jobRootConfig.getTypeConfig().getCoreConfig().isMisfire()) &#123;</div><div class="line">       result.put(<span class="string">"org.quartz.jobStore.misfireThreshold"</span>, <span class="string">"1"</span>);</div><div class="line">   &#125;</div><div class="line">   result.put(<span class="string">"org.quartz.plugin.shutdownhook.class"</span>, ShutdownHookPlugin.class.getName());</div><div class="line">   result.put(<span class="string">"org.quartz.plugin.shutdownhook.cleanShutdown"</span>, Boolean.TRUE.toString());</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleJob</span><span class="params">(<span class="keyword">final</span> Scheduler scheduler, <span class="keyword">final</span> JobDetail jobDetail, <span class="keyword">final</span> String triggerIdentity, <span class="keyword">final</span> String cron)</span> </span>&#123;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">if</span> (!scheduler.checkExists(jobDetail.getKey())) &#123;</div><div class="line">           scheduler.scheduleJob(jobDetail, createTrigger(triggerIdentity, cron));</div><div class="line">       &#125;</div><div class="line">       scheduler.start();</div><div class="line">       RUNNING_SCHEDULERS.putIfAbsent(scheduler.getSchedulerName(), scheduler);</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SchedulerException ex) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(ex);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> CronTrigger <span class="title">createTrigger</span><span class="params">(<span class="keyword">final</span> String triggerIdentity, <span class="keyword">final</span> String cron)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> TriggerBuilder.newTrigger()</div><div class="line">           .withIdentity(triggerIdentity)</div><div class="line">           .withSchedule(CronScheduleBuilder.cronSchedule(cron)</div><div class="line">           .withMisfireHandlingInstructionDoNothing())</div><div class="line">           .build();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>DaemonTaskScheduler 基于 Quartz 实现作业调度。这里大家看下源码，就不啰嗦解释啦。</li>
<li>JobBuilder#newJob(…) 的参数是 DaemonJob，下文会讲解到。 </li>
</ul>
<p><strong>DaemonJob 实现代码</strong>如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</div><div class="line">   </div><div class="line">   <span class="meta">@Setter</span></div><div class="line">   <span class="keyword">private</span> ElasticJob elasticJob;</div><div class="line">   </div><div class="line">   <span class="meta">@Setter</span></div><div class="line">   <span class="keyword">private</span> JobFacade jobFacade;</div><div class="line">   </div><div class="line">   <span class="meta">@Setter</span></div><div class="line">   <span class="keyword">private</span> ExecutorDriver executorDriver;</div><div class="line">    </div><div class="line">   <span class="meta">@Setter</span></div><div class="line">   <span class="keyword">private</span> Protos.TaskID taskId;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</div><div class="line">       ShardingContexts shardingContexts = jobFacade.getShardingContexts();</div><div class="line">       <span class="keyword">int</span> jobEventSamplingCount = shardingContexts.getJobEventSamplingCount();</div><div class="line">       <span class="keyword">int</span> currentJobEventSamplingCount = shardingContexts.getCurrentJobEventSamplingCount();</div><div class="line">       <span class="keyword">if</span> (jobEventSamplingCount &gt; <span class="number">0</span> &amp;&amp; ++currentJobEventSamplingCount &lt; jobEventSamplingCount) &#123;</div><div class="line">           shardingContexts.setCurrentJobEventSamplingCount(currentJobEventSamplingCount);</div><div class="line">           <span class="comment">//</span></div><div class="line">           jobFacade.getShardingContexts().setAllowSendJobEvent(<span class="keyword">false</span>);</div><div class="line">           <span class="comment">// 执行作业</span></div><div class="line">           JobExecutorFactory.getJobExecutor(elasticJob, jobFacade).execute();</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="comment">//</span></div><div class="line">           jobFacade.getShardingContexts().setAllowSendJobEvent(<span class="keyword">true</span>);</div><div class="line">           <span class="comment">//</span></div><div class="line">           executorDriver.sendStatusUpdate(Protos.TaskStatus.newBuilder().setTaskId(taskId).setState(Protos.TaskState.TASK_RUNNING).setMessage(<span class="string">"BEGIN"</span>).build());</div><div class="line">           <span class="comment">// 执行作业</span></div><div class="line">           JobExecutorFactory.getJobExecutor(elasticJob, jobFacade).execute();</div><div class="line">           <span class="comment">//</span></div><div class="line">           executorDriver.sendStatusUpdate(Protos.TaskStatus.newBuilder().setTaskId(taskId).setState(Protos.TaskState.TASK_RUNNING).setMessage(<span class="string">"COMPLETE"</span>).build());</div><div class="line">           <span class="comment">// </span></div><div class="line">           shardingContexts.setCurrentJobEventSamplingCount(<span class="number">0</span>);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用 <code>AbstractElasticJobExecutor#execute(...)</code> 执行作业逻辑。<code>AbstractElasticJobExecutor#execute(...)</code> 实现代码，在 Elastic-Job-Lite 和 Elastic-Job-Cloud 基本一致，在<a href="http://www.iocoder.cn/Elastic-Job/job-execute/?self">《Elastic-Job-Lite 源码分析 —— 作业执行》</a>有详细解析。</li>
<li><p><code>jobEventSamplingCount</code> 来自应用配置 (<code>CloudAppConfiguration.eventTraceSamplingCount</code>) 属性，常驻作业事件采样率统计条数，默认采样全部记录。为避免数据量过大，可对频繁调度的常驻作业配置采样率，即作业每执行N次，才会记录作业执行及追踪相关数据。</p>
<p>当满足采样条件时，调用 <code>ShardingContexts#setAllowSendJobEvent(true)</code>，标记<strong>要</strong>记录作业事件。否则，调用 <code>ShardingContexts#setAllowSendJobEvent(false)</code>，标记<strong>不</strong>记录作业时间。作业事件追踪在<a href="http://www.iocoder.cn/Elastic-Job/job-event-trace/?self">《Elastic-Job-Lite 源码分析 —— 作业事件追踪》</a>有详细解析。</p>
<p>另外，当满足采样调试时，也会调用 <code>ExecutorDriver#sendStatusUpdate(...)</code> 方法，更新 Mesos 任务状态为运行中，并附带 <code>&quot;BEGIN&quot;</code> 或 <code>&quot;COMPLETE&quot;</code> 消息。</p>
</li>
</ul>
<h1 id="6-SchedulerEngine-处理任务的状态变更"><a href="#6-SchedulerEngine-处理任务的状态变更" class="headerlink" title="6. SchedulerEngine 处理任务的状态变更"></a>6. SchedulerEngine 处理任务的状态变更</h1><p>Mesos 调度器的职责之一，<strong>处理任务的状态，特别是响应任务和故障</strong>。因此在 Elastic-Job-Cloud-Executor 调用 <code>ExecutorDriver#sendStatusUpdate(...)</code> 方法，更新 Mesos 任务状态时，触发调用 Elastic-Job-Cloud-Scheduler 的 SchedulerEngine 的 <code>#statusUpdate(...)</code> 方法，实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">statusUpdate</span><span class="params">(<span class="keyword">final</span> SchedulerDriver schedulerDriver, <span class="keyword">final</span> Protos.TaskStatus taskStatus)</span> </span>&#123;</div><div class="line">   String taskId = taskStatus.getTaskId().getValue();</div><div class="line">   TaskContext taskContext = TaskContext.from(taskId);</div><div class="line">   String jobName = taskContext.getMetaInfo().getJobName();</div><div class="line">   log.trace(<span class="string">"call statusUpdate task state is: &#123;&#125;, task id is: &#123;&#125;"</span>, taskStatus.getState(), taskId);</div><div class="line">   jobEventBus.post(<span class="keyword">new</span> JobStatusTraceEvent(jobName, taskContext.getId(), taskContext.getSlaveId(), Source.CLOUD_SCHEDULER, </div><div class="line">           taskContext.getType(), String.valueOf(taskContext.getMetaInfo().getShardingItems()), State.valueOf(taskStatus.getState().name()), taskStatus.getMessage()));</div><div class="line">   <span class="keyword">switch</span> (taskStatus.getState()) &#123;</div><div class="line">       <span class="keyword">case</span> TASK_RUNNING:</div><div class="line">           <span class="keyword">if</span> (!facadeService.load(jobName).isPresent()) &#123;</div><div class="line">               schedulerDriver.killTask(Protos.TaskID.newBuilder().setValue(taskId).build());</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">if</span> (<span class="string">"BEGIN"</span>.equals(taskStatus.getMessage())) &#123;</div><div class="line">               facadeService.updateDaemonStatus(taskContext, <span class="keyword">false</span>);</div><div class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"COMPLETE"</span>.equals(taskStatus.getMessage())) &#123;</div><div class="line">               facadeService.updateDaemonStatus(taskContext, <span class="keyword">true</span>);</div><div class="line">               statisticManager.taskRunSuccessfully();</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       <span class="keyword">case</span> TASK_FINISHED:</div><div class="line">           facadeService.removeRunning(taskContext);</div><div class="line">           unAssignTask(taskId);</div><div class="line">           statisticManager.taskRunSuccessfully();</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       <span class="keyword">case</span> TASK_KILLED:</div><div class="line">           log.warn(<span class="string">"task id is: &#123;&#125;, status is: &#123;&#125;, message is: &#123;&#125;, source is: &#123;&#125;"</span>, taskId, taskStatus.getState(), taskStatus.getMessage(), taskStatus.getSource());</div><div class="line">           facadeService.removeRunning(taskContext);</div><div class="line">           facadeService.addDaemonJobToReadyQueue(jobName);</div><div class="line">           unAssignTask(taskId);</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       <span class="keyword">case</span> TASK_LOST:</div><div class="line">       <span class="keyword">case</span> TASK_DROPPED:</div><div class="line">       <span class="keyword">case</span> TASK_GONE:</div><div class="line">       <span class="keyword">case</span> TASK_GONE_BY_OPERATOR:</div><div class="line">       <span class="keyword">case</span> TASK_FAILED:</div><div class="line">       <span class="keyword">case</span> TASK_ERROR:</div><div class="line">           log.warn(<span class="string">"task id is: &#123;&#125;, status is: &#123;&#125;, message is: &#123;&#125;, source is: &#123;&#125;"</span>, taskId, taskStatus.getState(), taskStatus.getMessage(), taskStatus.getSource());</div><div class="line">           facadeService.removeRunning(taskContext);</div><div class="line">           facadeService.recordFailoverTask(taskContext);</div><div class="line">           unAssignTask(taskId);</div><div class="line">           statisticManager.taskRunFailed();</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       <span class="keyword">case</span> TASK_UNKNOWN:</div><div class="line">       <span class="keyword">case</span> TASK_UNREACHABLE:</div><div class="line">           log.error(<span class="string">"task id is: &#123;&#125;, status is: &#123;&#125;, message is: &#123;&#125;, source is: &#123;&#125;"</span>, taskId, taskStatus.getState(), taskStatus.getMessage(), taskStatus.getSource());</div><div class="line">           statisticManager.taskRunFailed();</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">       <span class="keyword">default</span>:</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>当更新 Mesos 任务状态为 <code>TASK_RUNNING</code> 时，根据附带消息为 <code>&quot;BEGIN&quot;</code> 或 <code>&quot;COMPLETE&quot;</code>，分别调用 <code>FacadeService#updateDaemonStatus(false / true)</code> 方法，更新作业闲置状态。实现代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// FacadeService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 更新常驻作业运行状态.</span></div><div class="line"><span class="comment">* </span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> taskContext 任务运行时上下文</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> isIdle 是否空闲</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateDaemonStatus</span><span class="params">(<span class="keyword">final</span> TaskContext taskContext, <span class="keyword">final</span> <span class="keyword">boolean</span> isIdle)</span> </span>&#123;</div><div class="line">   runningService.updateIdle(taskContext, isIdle);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">// RunningService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 更新作业闲置状态.</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> taskContext 任务运行时上下文</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> isIdle 是否闲置</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateIdle</span><span class="params">(<span class="keyword">final</span> TaskContext taskContext, <span class="keyword">final</span> <span class="keyword">boolean</span> isIdle)</span> </span>&#123;</div><div class="line">   <span class="keyword">synchronized</span> (RUNNING_TASKS) &#123;</div><div class="line">       Optional&lt;TaskContext&gt; taskContextOptional = findTask(taskContext);</div><div class="line">       <span class="keyword">if</span> (taskContextOptional.isPresent()) &#123;</div><div class="line">           taskContextOptional.get().setIdle(isIdle);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           add(taskContext);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  若作业配置不存在时，调用 <code>SchedulerDriver#killTask(...)</code> 方法，杀死该 Mesos 任务。在<a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-second/?self">《Elastic-Job-Cloud 源码分析 —— 作业调度（二）》</a>进一步解析。</p>
</li>
<li><p>当更新 Mesos 任务状态为 <code>TASK_FINISHED</code> 时，调用 <code>FacadeService#removeRunning(...)</code> 方法，将任务从运行时队列删除。实现代码如下：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// FacadeService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 将任务从运行时队列删除.</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> taskContext 任务运行时上下文</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeRunning</span><span class="params">(<span class="keyword">final</span> TaskContext taskContext)</span> </span>&#123;</div><div class="line">   runningService.remove(taskContext);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// RunningService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 将任务从运行时队列删除.</span></div><div class="line"><span class="comment">* </span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> taskContext 任务运行时上下文</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">final</span> TaskContext taskContext)</span> </span>&#123;</div><div class="line">   <span class="comment">// 移除运行中的任务集合</span></div><div class="line">   getRunningTasks(taskContext.getMetaInfo().getJobName()).remove(taskContext);</div><div class="line">   <span class="comment">// 判断是否为常驻任务</span></div><div class="line">   <span class="keyword">if</span> (!isDaemonOrAbsent(taskContext.getMetaInfo().getJobName())) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 将任务从运行时队列删除</span></div><div class="line">   regCenter.remove(RunningNode.getRunningTaskNodePath(taskContext.getMetaInfo().toString()));</div><div class="line">   String jobRootNode = RunningNode.getRunningJobNodePath(taskContext.getMetaInfo().getJobName());</div><div class="line">   <span class="keyword">if</span> (regCenter.isExisted(jobRootNode) &amp;&amp; regCenter.getChildrenKeys(jobRootNode).isEmpty()) &#123;</div><div class="line">       regCenter.remove(jobRootNode);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>当该作业对应的所有 Mesos 任务状态都更新为 <code>TASK_FINISHED</code> 后，作业可以再次被 Elastic-Job-Cloud-Scheduler 调度。</p>
<p>调用 <code>#unAssignTask(...)</code> 方法，通知 TaskScheduler 任务被<strong>确认</strong>未分配到这个主机。TaskScheduler 做任务和 Offer 的匹配，对哪些任务运行在哪些主机是有依赖的，不然怎么做匹配优化呢。在<a href="https://github.com/Netflix/Fenzo/wiki/How-to-use-Fenzo#notify-the-scheduler-of-assigns-and-unassigns-of-tasks" rel="external nofollow noopener noreferrer" target="_blank">《Fenzo Wiki —— Notify the Scheduler of Assigns and UnAssigns of Tasks》</a>可以进一步了解。实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unAssignTask</span><span class="params">(<span class="keyword">final</span> String taskId)</span> </span>&#123;</div><div class="line">    String hostname = facadeService.popMapping(taskId);</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != hostname) &#123;</div><div class="line">        taskScheduler.getTaskUnAssigner().call(TaskContext.getIdForUnassignedSlave(taskId), hostname);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>当更新 Mesos 任务状态为 <code>TASK_KILLED</code> 时，调用 <code>FacadeService#addDaemonJobToReadyQueue(...)</code> 方法，将常驻作业放入待执行队列。<strong>为什么要将常驻作业放入待执行队列呢？</strong>被 Kill 掉的作业后续要继续调度执行，如果不加入待执行队列，TaskLaunchScheduledService 就无法提交作业给 Elastic-Job-Cloud-Executor 继续调度执行。</p>
<p>  另外会调用 <code>FacadeService#removeRunning(...)</code>、<code>#unAssignTask(...)</code> 方法。</p>
</li>
<li><p>当更新 Mesos 任务状态为 <code>TASK_ERROR</code> 等等时，调用 <code>FacadeService#recordFailoverTask(...)</code> 方法，在 <a href="http://www.iocoder.cn/Elastic-Job/cloud-job-failover/?self">《Elastic-Job-Cloud 源码分析 —— 作业失效转移》</a>详细解析。</p>
<p>  另外会调用 <code>FacadeService#removeRunning(...)</code> 和 <code>#unAssignTask(...)</code> 方法。</p>
</li>
</ul>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>旁白君：真的真的真的，好长好长好长啊。但是真的真的真的，干货！<br>芋道君：那必须的！</p>
<p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_12_21/12.png" alt=""></p>
<p>道友，赶紧上车，分享一波朋友圈！</p>
  
	</div>
		<footer class="article-footer clearfix">


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Elastic-Job-Cloud/">Elastic-Job-Cloud</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/" data-title="Elastic-Job-Cloud 源码分析 —— 作业调度（一） | 芋道源码 —— 纯源码解析BLOG" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev">
 <a href="/Elastic-Job/cloud-job-scheduler-and-executor-second/" title="Elastic-Job-Cloud 源码分析 —— 作业调度（二）">
  <strong>PREVIOUS:</strong><br>
  <span>
  Elastic-Job-Cloud 源码分析 —— 作业调度（二）</span>
</a>
</div>


<div class="next">
<a href="/Architecture/books-recommended/" title="源码圈 300 胖友的书单整理（最后更新时间：2017.09.22）">
 <strong>NEXT:</strong><br> 
 <span>源码圈 300 胖友的书单整理（最后更新时间：2017.09.22）
</span>
</a>
</div>

</nav>

	

</div>  
        <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="toc" class="toc-aside">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-概述"><span class="toc-number">1.</span> <span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-作业执行类型"><span class="toc-number">2.</span> <span class="toc-text">2. 作业执行类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Producer-发布任务"><span class="toc-number">3.</span> <span class="toc-text">3. Producer 发布任务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-常驻作业"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 常驻作业</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-瞬时作业"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 瞬时作业</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-TransientProducerScheduler"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1 TransientProducerScheduler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-注册瞬时作业"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2 注册瞬时作业</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-ProducerJob"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.2.3 ProducerJob</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-小结"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-TaskLaunchScheduledService-提交任务"><span class="toc-number">4.</span> <span class="toc-text">4. TaskLaunchScheduledService 提交任务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-创建-Fenzo-任务请求"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 创建 Fenzo 任务请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-AppConstraintEvaluator"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 AppConstraintEvaluator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-将任务请求分配到-Mesos-Offer"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 将任务请求分配到 Mesos Offer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-创建-Mesos-任务信息"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 创建 Mesos 任务信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-创建单个-Mesos-任务信息"><span class="toc-number">4.4.1.</span> <span class="toc-text">4.4.1 创建单个 Mesos 任务信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-将任务运行时上下文放入运行时队列"><span class="toc-number">4.5.</span> <span class="toc-text">4.5 将任务运行时上下文放入运行时队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-从队列中删除已运行的作业"><span class="toc-number">4.6.</span> <span class="toc-text">4.6 从队列中删除已运行的作业</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-提交任务给-Mesos"><span class="toc-number">4.7.</span> <span class="toc-text">4.7 提交任务给 Mesos</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-TaskExecutor-执行任务"><span class="toc-number">5.</span> <span class="toc-text">5. TaskExecutor 执行任务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-TaskThread"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 TaskThread</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-DaemonTaskScheduler"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 DaemonTaskScheduler</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-SchedulerEngine-处理任务的状态变更"><span class="toc-number">6.</span> <span class="toc-text">6. SchedulerEngine 处理任务的状态变更</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#666-彩蛋"><span class="toc-number">7.</span> <span class="toc-text">666. 彩蛋</span></a></li></ol>
</div>

<div id="asidepart">
    <!--<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>-->
    <aside class="clearfix">
        <div id="authorInfo">
            <!---->
            <!--<div class="author-logo"></div>-->
            <!---->

            <div> <img width="100%" src="/images/common/wechat_mp_2017_07_31_bak.jpg"> </div>

            <div class="social-list">
                
                
                
                
                
            </div>
        </div>

        
        <div class="categorieslist">
    <p class="asidetitle">微信公众号福利：芋道源码</p>
    <ul>

        <li> <a href="/images/common/wechat_mp_2017_07_31_bak.jpg"> 0. 阅读源码葵花宝典 </a></li>

        <li> <a href="/images/common/wechat_mp_2017_07_31_bak.jpg"> 1. RocketMQ / MyCAT / Sharding-JDBC 详细中文注释源码 </a> </li>

        <li> <a href="/images/common/wechat_mp_2017_07_31_bak.jpg"> 2. 您对于源码的疑问每条留言都将得到认真回复 </a> </li>

        <li> <a href="/images/common/wechat_mp_2017_07_31_bak.jpg"> 3. 新的源码解析文章实时收到通知，每周六十点更新 </a> </li>

        <li> <a href="/images/common/wechat_mp_2017_07_31_bak.jpg">4. 认真的源码交流微信群 </a> </li>


    </ul>
</div>
        
        
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
            
			    <li><a href="/categories/Docker/" title="Docker">Docker<sup>2</sup></a></li>
            
		
            
			    <li><a href="/categories/Dubbo/" title="Dubbo">Dubbo<sup>1</sup></a></li>
            
		
            
			    <li><a href="/categories/Elastic-Job-Cloud/" title="Elastic-Job-Cloud">Elastic-Job-Cloud<sup>6</sup></a></li>
            
		
            
			    <li><a href="/categories/Elastic-Job-Lite/" title="Elastic-Job-Lite">Elastic-Job-Lite<sup>16</sup></a></li>
            
		
            
			    <li><a href="/categories/Eureka/" title="Eureka">Eureka<sup>23</sup></a></li>
            
		
            
			    <li><a href="/categories/Happylifeplat-TCC/" title="Happylifeplat-TCC">Happylifeplat-TCC<sup>1</sup></a></li>
            
		
            
			    <li><a href="/categories/Hystrix/" title="Hystrix">Hystrix<sup>9</sup></a></li>
            
		
            
			    <li><a href="/categories/JUC/" title="JUC">JUC<sup>1</sup></a></li>
            
		
            
			    <li><a href="/categories/MyCAT/" title="MyCAT">MyCAT<sup>9</sup></a></li>
            
		
            
			    <li><a href="/categories/Nginx/" title="Nginx">Nginx<sup>1</sup></a></li>
            
		
            
			    <li><a href="/categories/RocketMQ/" title="RocketMQ">RocketMQ<sup>14</sup></a></li>
            
		
            
			    <li><a href="/categories/RxJava/" title="RxJava">RxJava<sup>5</sup></a></li>
            
		
            
			    <li><a href="/categories/Sharding-JDBC/" title="Sharding-JDBC">Sharding-JDBC<sup>18</sup></a></li>
            
		
            
			    <li><a href="/categories/SkyWalking/" title="SkyWalking">SkyWalking<sup>20</sup></a></li>
            
		
            
			    <li><a href="/categories/Spring/" title="Spring">Spring<sup>1</sup></a></li>
            
		
            
			    <li><a href="/categories/Spring-Cloud-Gateway/" title="Spring-Cloud-Gateway">Spring-Cloud-Gateway<sup>24</sup></a></li>
            
		
            
			    <li><a href="/categories/Spring-MVC/" title="Spring-MVC">Spring-MVC<sup>1</sup></a></li>
            
		
            
			    <li><a href="/categories/Spring-Security/" title="Spring-Security">Spring-Security<sup>1</sup></a></li>
            
		
            
			    <li><a href="/categories/TCC-Transaction/" title="TCC-Transaction">TCC-Transaction<sup>7</sup></a></li>
            
		
            
			    <li><a href="/categories/TiKV/" title="TiKV">TiKV<sup>2</sup></a></li>
            
		
            
			    <li><a href="/categories/工作内推/" title="工作内推">工作内推<sup>3</sup></a></li>
            
		
            
			    <li><a href="/categories/技术杂文/" title="技术杂文">技术杂文<sup>5</sup></a></li>
            
		
		</ul>
</div>

        
    </aside>
</div>
    </div>
    <footer><div id="footer">
    <img src="http://www.iocoder.cn/images/common/wechat_mp_simple.png" style="display: none">
    
            <p class="copyright"> © 2017 
		
		<a href="http://www.iocoder.cn" target="_blank" title="芋道源码">芋道源码</a>
		
            && <span style="display: inline;" id="busuanzi_container_site_uv">总访客数 <span id="busuanzi_value_site_uv" font="微软雅黑"></span> 次</span>
            && <span style="display: inline;" id="busuanzi_container_site_pv">总访问量 <span id="busuanzi_value_site_pv" font="微软雅黑"></span> 次</span>
            <!--&& Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a>-->
            <!--&& Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> && Theme by <a href="http://gengbiao.me" target="_blank" title="coney">coney</a>-->
            </p></div>
            <div class="copyright">沪ICP备17037075号-1</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>






<link rel="stylesheet" href="/alert/css/alert.css">
<script src="/alert/js/alert.js"></script>
<script src="/js/jquery.cookie.js"></script>
<script src="/js/util.js"></script>





<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-107572620-1', 'auto');  
ga('send', 'pageview');
</script>

  </body>


