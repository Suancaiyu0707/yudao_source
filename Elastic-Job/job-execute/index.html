<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="google-site-verification" content="GkJ68PCnxM9Ih7Zm9v8p91FOCV7ymNCO2KdGbflLh3E"><meta name="360-site-verification" content="dd6547587641bfede036f7c79561e8a0"><meta name="shenma-site-verification" content="fd96cf3751972c9b05f8471d2ccadddc_1496951214"><meta name="msvalidate.01" content="1D38B05050A977F6FDEDA481198343F1"><meta name="sogou_site_verification" content="MpPsku240L"><title>Elastic-Job-Lite 源码分析 —— 作业执行 | 芋道源码 —— 纯源码解析博客</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=3,minimum-scale=1"><meta name="author" content="芋道源码"><meta name="description" content="摘要: 原创出处 http://www.iocoder.cn/Elastic-Job/job-execute/ 「芋道源码」欢迎转载，保留摘要，谢谢！
本文基于 Elastic-Job V2.1.5 版本分享

1. 概述
2. Lite调度作业
3. 执行器创建
3.1 加载作业配置
3.2 获取"><meta name="keywords" content="Java,架构,后端,服务端,RocketMQ,MyCAT,分布式消息队列,分布式存储,技术博客,Sharding-JDBC,分库分表"><link rel="alternate" href="atom.xml" title="芋道源码 —— 纯源码解析博客" type="application/atom+xml"><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/style.css"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?9e70e3362807c1bd185a79655b307027";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script>!function(){var t="http:"==document.location.protocol?"http://js.passport.qihucdn.com/11.0.1.js?f05b61dd54bbc38386611a5238672938":"https://jspassport.ssl.qhimg.com/11.0.1.js?f05b61dd54bbc38386611a5238672938";document.write('<script src="'+t+'" id="sozz"><\/script>')}()</script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></head></html><body><header><div><div id="textlogo"><h1 class="site-name"><a href="/" title="芋道源码 —— 纯源码解析博客">芋道源码 —— 纯源码解析博客</a></h1><a class="blog-motto">愿半生编码，如一生老友！</a></div><div class="navbar"><a class="navbutton navmobile" href="#" title="菜单"></a></div><nav class="animated"><ul><ul><li><a href="/">文章</a></li><li><a href="/2018-meet-you">知识星球</a></li><li><a href="https://github.com/YunaiV" rel="external nofollow noopener noreferrer" target="_blank">Github</a></li><li><a href="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31_bak.jpg">微信公众号</a></li><li><a href="/categories/%E5%B7%A5%E4%BD%9C%E5%86%85%E6%8E%A8/">工作内推</a></li><li><a href="/link_url">友链</a></li></ul></ul></nav></div></header><div id="container"><div id="main" class="post" itemscope="" itemprop="blogPost"><article itemprop="articleBody"><header class="article-info clearfix"><h1 itemprop="name"><a href="/Elastic-Job/job-execute/" title="Elastic-Job-Lite 源码分析 —— 作业执行" itemprop="url">Elastic-Job-Lite 源码分析 —— 作业执行</a></h1><p class="article-author"></p><p class="article-time">总阅读量:<span id="busuanzi_value_page_pv"></span>次</p></header><div class="article-content"><p>摘要: 原创出处 <a href="http://www.iocoder.cn/Elastic-Job/job-execute/">http://www.iocoder.cn/Elastic-Job/job-execute/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p><ul><li><a href="http://www.iocoder.cn/Elastic-Job/job-execute/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Elastic-Job/job-execute/">2. Lite调度作业</a></li><li><a href="http://www.iocoder.cn/Elastic-Job/job-execute/">3. 执行器创建</a><ul><li><a href="http://www.iocoder.cn/Elastic-Job/job-execute/">3.1 加载作业配置</a></li><li><a href="http://www.iocoder.cn/Elastic-Job/job-execute/">3.2 获取作业执行线程池</a></li><li><a href="http://www.iocoder.cn/Elastic-Job/job-execute/">3.3 获取作业异常执行器</a></li></ul></li><li><a href="http://www.iocoder.cn/Elastic-Job/job-execute/">4. 执行器执行</a><ul><li><a href="http://www.iocoder.cn/Elastic-Job/job-execute/">4.1 检查作业执行环境</a></li><li><a href="http://www.iocoder.cn/Elastic-Job/job-execute/">4.2 获取当前作业服务器的分片上下文</a></li><li><a href="http://www.iocoder.cn/Elastic-Job/job-execute/">4.3 发布作业状态追踪事件</a></li><li><a href="http://www.iocoder.cn/Elastic-Job/job-execute/">4.4 跳过正在运行中的被错过执行的作业</a></li><li><a href="http://www.iocoder.cn/Elastic-Job/job-execute/">4.5 执行作业执行前的方法</a></li><li><a href="http://www.iocoder.cn/Elastic-Job/job-execute/">4.6 执行普通触发的作业</a><ul><li><a href="http://www.iocoder.cn/Elastic-Job/job-execute/">4.6.1 简单作业执行器</a></li><li><a href="http://www.iocoder.cn/Elastic-Job/job-execute/">4.6.2 数据流作业执行器</a></li><li><a href="http://www.iocoder.cn/Elastic-Job/job-execute/">4.6.3 脚本作业执行器</a></li></ul></li><li><a href="http://www.iocoder.cn/Elastic-Job/job-execute/">4.7 执行被错过触发的作业</a></li><li><a href="http://www.iocoder.cn/Elastic-Job/job-execute/">4.8 执行作业失效转移</a></li><li><a href="http://www.iocoder.cn/Elastic-Job/job-execute/">4.9 执行作业执行后的方法</a></li></ul></li><li><a href="http://www.iocoder.cn/Elastic-Job/job-execute/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Lite 作业执行</strong>。</p><p>涉及到主要类的类图如下( <a href="http://www.iocoder.cn/images/Elastic-Job/2017_09_23/01.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_09_23/01.png" alt=""></p><ul><li><strong>黄色</strong>的类在 <code>elastic-job-common-core</code> 项目里，为 Elastic-Job-Lite、Elastic-Job-Cloud <strong>公用</strong>作业执行类。</li></ul><blockquote><p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p></blockquote><h1 id="2-Lite调度作业"><a href="#2-Lite调度作业" class="headerlink" title="2. Lite调度作业"></a>2. Lite调度作业</h1><p>Lite调度作业( LiteJob )，作业被调度后，调用 <code>#execute()</code> 执行作业。</p><p><strong>为什么是 LiteJob 作为入口呢？</strong></p><p>在<a href="http://www.iocoder.cn/Elastic-Job/job-init/?self">《Elastic-Job-Lite 源码分析 —— 作业初始化》的「3.2.3」创建作业调度控制器</a>里，我们可以看到 Quartz 的 JobDetail 创建代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">JobDetail result = JobBuilder.newJob(LiteJob.class).withIdentity(liteJobConfig.getJobName()).build();</div></pre></td></tr></table></figure><p><code>#newJob()</code> 里的参数是 LiteJob，因此，每次 Quartz 到达调度时间时，会创建该对象进行作业执行。</p><hr><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LiteJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Setter</span></div><div class="line">    <span class="keyword">private</span> ElasticJob elasticJob;</div><div class="line">    </div><div class="line">    <span class="meta">@Setter</span></div><div class="line">    <span class="keyword">private</span> JobFacade jobFacade;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</div><div class="line">        JobExecutorFactory.getJobExecutor(elasticJob, jobFacade).execute();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>LiteJob 通过 JobExecutorFactory 获得到作业执行器( AbstractElasticJobExecutor )，并进行执行：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobExecutorFactory</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获取作业执行器.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> elasticJob 分布式弹性作业</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> jobFacade 作业内部服务门面服务</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 作业执行器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractElasticJobExecutor <span class="title">getJobExecutor</span><span class="params">(<span class="keyword">final</span> ElasticJob elasticJob, <span class="keyword">final</span> JobFacade jobFacade)</span> </span>&#123;</div><div class="line">        <span class="comment">// ScriptJob</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == elasticJob) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ScriptJobExecutor(jobFacade);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// SimpleJob</span></div><div class="line">        <span class="keyword">if</span> (elasticJob <span class="keyword">instanceof</span> SimpleJob) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleJobExecutor((SimpleJob) elasticJob, jobFacade);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// DataflowJob</span></div><div class="line">        <span class="keyword">if</span> (elasticJob <span class="keyword">instanceof</span> DataflowJob) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DataflowJobExecutor((DataflowJob) elasticJob, jobFacade);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> JobConfigurationException(<span class="string">"Cannot support job type '%s'"</span>, elasticJob.getClass().getCanonicalName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>JobExecutorFactory，作业执行器工厂，根据不同的作业类型，返回对应的<strong>作业执行器</strong>。</li></ul></li></ul><table><thead><tr><th style="text-align:left">作业</th><th style="text-align:left">作业接口</th><th style="text-align:left">执行器</th></tr></thead><tbody><tr><td style="text-align:left">简单作业</td><td style="text-align:left">SimpleJob</td><td style="text-align:left">SimpleJobExecutor</td></tr><tr><td style="text-align:left">数据流作业</td><td style="text-align:left">DataflowJob</td><td style="text-align:left">DataflowJobExecutor</td></tr><tr><td style="text-align:left">脚本作业</td><td style="text-align:left">ScriptJob</td><td style="text-align:left">ScriptJobExecutor</td></tr></tbody></table><h1 id="3-执行器创建"><a href="#3-执行器创建" class="headerlink" title="3. 执行器创建"></a>3. 执行器创建</h1><p>AbstractElasticJobExecutor，作业执行器抽象类。不同作业执行器都继承该类，创建的过程是一致的。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractElasticJobExecutor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 作业门面对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Getter</span>(AccessLevel.PROTECTED)</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobFacade jobFacade;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 作业配置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Getter</span>(AccessLevel.PROTECTED)</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobRootConfiguration jobRootConfig;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 作业名称</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String jobName;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 作业执行线程池</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executorService;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 作业异常处理器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobExceptionHandler jobExceptionHandler;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 分片错误信息集合</span></div><div class="line"><span class="comment">     * key：分片序号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, String&gt; itemErrorMessages;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractElasticJobExecutor</span><span class="params">(<span class="keyword">final</span> JobFacade jobFacade)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.jobFacade = jobFacade;</div><div class="line">        <span class="comment">// 加载 作业配置</span></div><div class="line">        jobRootConfig = jobFacade.loadJobRootConfiguration(<span class="keyword">true</span>);</div><div class="line">        jobName = jobRootConfig.getTypeConfig().getCoreConfig().getJobName();</div><div class="line">        <span class="comment">// 获取 作业执行线程池</span></div><div class="line">        executorService = ExecutorServiceHandlerRegistry.getExecutorServiceHandler(jobName, (ExecutorServiceHandler) getHandler(JobProperties.JobPropertiesEnum.EXECUTOR_SERVICE_HANDLER));</div><div class="line">        <span class="comment">// 获取 作业异常处理器</span></div><div class="line">        jobExceptionHandler = (JobExceptionHandler) getHandler(JobProperties.JobPropertiesEnum.JOB_EXCEPTION_HANDLER);</div><div class="line">        <span class="comment">// 设置 分片错误信息集合</span></div><div class="line">        itemErrorMessages = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(jobRootConfig.getTypeConfig().getCoreConfig().getShardingTotalCount(), <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// SimpleJobExecutor.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleJobExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractElasticJobExecutor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 简单作业实现</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SimpleJob simpleJob;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleJobExecutor</span><span class="params">(<span class="keyword">final</span> SimpleJob simpleJob, <span class="keyword">final</span> JobFacade jobFacade)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(jobFacade);</div><div class="line">        <span class="keyword">this</span>.simpleJob = simpleJob;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// DataflowJobExecutor.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DataflowJobExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractElasticJobExecutor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 数据流作业对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DataflowJob&lt;Object&gt; dataflowJob;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DataflowJobExecutor</span><span class="params">(<span class="keyword">final</span> DataflowJob&lt;Object&gt; dataflowJob, <span class="keyword">final</span> JobFacade jobFacade)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(jobFacade);</div><div class="line">        <span class="keyword">this</span>.dataflowJob = dataflowJob;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ScriptJobExecutor.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ScriptJobExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractElasticJobExecutor</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScriptJobExecutor</span><span class="params">(<span class="keyword">final</span> JobFacade jobFacade)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(jobFacade);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3-1-加载作业配置"><a href="#3-1-加载作业配置" class="headerlink" title="3.1 加载作业配置"></a>3.1 加载作业配置</h2><p>从<strong>缓存</strong>中读取作业配置。在<a href="http://www.iocoder.cn/Elastic-Job/job-config/?self">《Elastic-Job-Lite 源码分析 —— 作业配置》的「3.1」读取作业配置</a> 已经解析。</p><h2 id="3-2-获取作业执行线程池"><a href="#3-2-获取作业执行线程池" class="headerlink" title="3.2 获取作业执行线程池"></a>3.2 获取作业执行线程池</h2><p>作业每次执行时，可能分配到<strong>多个分片项</strong>，需要使用线程池实现<strong>并行</strong>执行。考虑到不同作业之间的隔离性，通过<strong>一个作业一个线程池</strong>实现。线程池服务处理器注册表( ExecutorServiceHandlerRegistry ) 获取作业线程池( <code>#getExecutorServiceHandler(....)</code> )代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorServiceHandlerRegistry</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 线程池集合</span></div><div class="line"><span class="comment">     * key：作业名字</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, ExecutorService&gt; REGISTRY = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获取线程池服务.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> jobName 作业名称</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> executorServiceHandler 线程池服务处理器</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 线程池服务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">getExecutorServiceHandler</span><span class="params">(<span class="keyword">final</span> String jobName, <span class="keyword">final</span> ExecutorServiceHandler executorServiceHandler)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!REGISTRY.containsKey(jobName)) &#123;</div><div class="line">            REGISTRY.put(jobName, executorServiceHandler.createExecutorService(jobName));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> REGISTRY.get(jobName);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>ExecutorServiceHandlerRegistry 使用 ExecutorServiceHandler 创建线程池。ExecutorServiceHandler 本身是个<strong>接口</strong>，默认使用 DefaultExecutorServiceHandler 实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ExecutorServiceHandler.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorServiceHandler</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 创建线程池服务对象.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> jobName 作业名</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 线程池服务对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">ExecutorService <span class="title">createExecutorService</span><span class="params">(<span class="keyword">final</span> String jobName)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// DefaultExecutorServiceHandler.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultExecutorServiceHandler</span> <span class="keyword">implements</span> <span class="title">ExecutorServiceHandler</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">createExecutorService</span><span class="params">(<span class="keyword">final</span> String jobName)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExecutorServiceObject(<span class="string">"inner-job-"</span> + jobName, Runtime.getRuntime().availableProcessors() * <span class="number">2</span>).createExecutorService();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>调用 ExecutorServiceObject 的 <code>#createExecutorService(....)</code> 方法创建线程池：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorServiceObject</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor threadPoolExecutor;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecutorServiceObject</span><span class="params">(<span class="keyword">final</span> String namingPattern, <span class="keyword">final</span> <span class="keyword">int</span> threadSize)</span> </span>&#123;</div><div class="line">        workQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</div><div class="line">        threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(threadSize, threadSize, <span class="number">5L</span>, TimeUnit.MINUTES, workQueue, </div><div class="line">                <span class="keyword">new</span> BasicThreadFactory.Builder().namingPattern(Joiner.on(<span class="string">"-"</span>).join(namingPattern, <span class="string">"%s"</span>)).build());</div><div class="line">        threadPoolExecutor.allowCoreThreadTimeOut(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 创建线程池服务对象.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 线程池服务对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">createExecutorService</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> MoreExecutors.listeningDecorator(MoreExecutors.getExitingExecutorService(threadPoolExecutor));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>MoreExecutors#listeningDecorator(...)</code> 在<a href="http://www.iocoder.cn/Sharding-JDBC/sql-execute/?self">《Sharding-JDBC 源码分析 —— SQL 执行》</a> 已经解析。</li><li><p><code>MoreExecutors#getExitingExecutorService(...)</code> 方法逻辑：将 ThreadPoolExecutor 转换成 ExecutorService，并增加 JVM 关闭钩子，实现 <strong>120s</strong> 等待任务完成：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">service.shutdown();</div><div class="line">service.awaitTermination(terminationTimeout, timeUnit);</div></pre></td></tr></table></figure></li></ul></li></ul><p><strong>如何实现自定义 ExecutorServiceHandler ?</strong></p><p>先看下 AbstractElasticJobExecutor 是如何获得<strong>每个作业</strong>的 ExecutorServiceHandler ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获得【自定义】处理器</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> jobPropertiesEnum 作业属性枚举</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 处理器</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getHandler</span><span class="params">(<span class="keyword">final</span> JobProperties.JobPropertiesEnum jobPropertiesEnum)</span> </span>&#123;</div><div class="line">   String handlerClassName = jobRootConfig.getTypeConfig().getCoreConfig().getJobProperties().get(jobPropertiesEnum);</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       Class&lt;?&gt; handlerClass = Class.forName(handlerClassName);</div><div class="line">       <span class="keyword">if</span> (jobPropertiesEnum.getClassType().isAssignableFrom(handlerClass)) &#123; <span class="comment">// 必须是接口实现，才使用【自定义】</span></div><div class="line">           <span class="keyword">return</span> handlerClass.newInstance();</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> getDefaultHandler(jobPropertiesEnum, handlerClassName);</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> ReflectiveOperationException ex) &#123;</div><div class="line">       <span class="keyword">return</span> getDefaultHandler(jobPropertiesEnum, handlerClassName);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获得【默认】处理器</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> jobPropertiesEnum 作业属性枚举</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> handlerClassName 处理器类名</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 处理器</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getDefaultHandler</span><span class="params">(<span class="keyword">final</span> JobProperties.JobPropertiesEnum jobPropertiesEnum, <span class="keyword">final</span> String handlerClassName)</span> </span>&#123;</div><div class="line">   log.warn(<span class="string">"Cannot instantiation class '&#123;&#125;', use default '&#123;&#125;' class."</span>, handlerClassName, jobPropertiesEnum.getKey());</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">return</span> Class.forName(jobPropertiesEnum.getDefaultValue()).newInstance();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> JobSystemException(e);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>每个处理器都会对应一个 JobPropertiesEnum，使用枚举获得处理器。优先从 <code>JobProperties.map</code> 获取<strong>自定义</strong>的处理器实现类，如果不符合条件( 未实现正确接口 或者 创建处理器失败 )，使用<strong>默认</strong>的处理器实现。</li><li>每个作业可以配置<strong>不同</strong>的处理器，在<a href="http://www.iocoder.cn/Elastic-Job/job-config/?self">《Elastic-Job-Lite 源码分析 —— 作业配置》的「2.2.2」作业核心配置</a> 已经解析。</li></ul><h2 id="3-3-获取作业异常执行器"><a href="#3-3-获取作业异常执行器" class="headerlink" title="3.3 获取作业异常执行器"></a>3.3 获取作业异常执行器</h2><p>获取作业异常执行器( JobExceptionHandler )和 ExecutorServiceHandler( ExecutorServiceHandler )<strong>相同</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ExecutorServiceHandler.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JobExceptionHandler</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 处理作业异常.</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> jobName 作业名称</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> cause 异常原因</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleException</span><span class="params">(String jobName, Throwable cause)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// DefaultJobExceptionHandler.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultJobExceptionHandler</span> <span class="keyword">implements</span> <span class="title">JobExceptionHandler</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleException</span><span class="params">(<span class="keyword">final</span> String jobName, <span class="keyword">final</span> Throwable cause)</span> </span>&#123;</div><div class="line">        log.error(String.format(<span class="string">"Job '%s' exception occur in job processing"</span>, jobName), cause);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>默认实现 DefaultJobExceptionHandler <strong>打印异常日志，不会抛出异常</strong>。</li></ul><h1 id="4-执行器执行"><a href="#4-执行器执行" class="headerlink" title="4. 执行器执行"></a>4. 执行器执行</h1><p>执行逻辑主流程如下图( <a href="http://www.iocoder.cn/images/Elastic-Job/2017_09_23/02.png">打开大图</a> )：</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2017_09_23/02.png" alt=""></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 检查 作业执行环境</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       jobFacade.checkJobExecutionEnvironment();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> JobExecutionEnvironmentException cause) &#123;</div><div class="line">       jobExceptionHandler.handleException(jobName, cause);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 获取 当前作业服务器的分片上下文</span></div><div class="line">   ShardingContexts shardingContexts = jobFacade.getShardingContexts();</div><div class="line">   <span class="comment">// 发布作业状态追踪事件(State.TASK_STAGING)</span></div><div class="line">   <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">       jobFacade.postJobStatusTraceEvent(shardingContexts.getTaskId(), State.TASK_STAGING, String.format(<span class="string">"Job '%s' execute begin."</span>, jobName));</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 跳过 存在运行中的被错过作业</span></div><div class="line">   <span class="keyword">if</span> (jobFacade.misfireIfRunning(shardingContexts.getShardingItemParameters().keySet())) &#123;</div><div class="line">       <span class="comment">// 发布作业状态追踪事件(State.TASK_FINISHED)</span></div><div class="line">       <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">           jobFacade.postJobStatusTraceEvent(shardingContexts.getTaskId(), State.TASK_FINISHED, String.format(</div><div class="line">                   <span class="string">"Previous job '%s' - shardingItems '%s' is still running, misfired job will start after previous job completed."</span>, jobName, </div><div class="line">                   shardingContexts.getShardingItemParameters().keySet()));</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 执行 作业执行前的方法</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       jobFacade.beforeJobExecuted(shardingContexts);</div><div class="line">       <span class="comment">//CHECKSTYLE:OFF</span></div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable cause) &#123;</div><div class="line">       <span class="comment">//CHECKSTYLE:ON</span></div><div class="line">       jobExceptionHandler.handleException(jobName, cause);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 执行 普通触发的作业</span></div><div class="line">   execute(shardingContexts, JobExecutionEvent.ExecutionSource.NORMAL_TRIGGER);</div><div class="line">   <span class="comment">// 执行 被跳过触发的作业</span></div><div class="line">   <span class="keyword">while</span> (jobFacade.isExecuteMisfired(shardingContexts.getShardingItemParameters().keySet())) &#123;</div><div class="line">       jobFacade.clearMisfire(shardingContexts.getShardingItemParameters().keySet());</div><div class="line">       execute(shardingContexts, JobExecutionEvent.ExecutionSource.MISFIRE);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 执行 作业失效转移</span></div><div class="line">   jobFacade.failoverIfNecessary();</div><div class="line">   <span class="comment">// 执行 作业执行后的方法</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       jobFacade.afterJobExecuted(shardingContexts);</div><div class="line">       <span class="comment">//CHECKSTYLE:OFF</span></div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable cause) &#123;</div><div class="line">       <span class="comment">//CHECKSTYLE:ON</span></div><div class="line">       jobExceptionHandler.handleException(jobName, cause);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>代码步骤比较多，我们一步一步往下看。</p><h2 id="4-1-检查作业执行环境"><a href="#4-1-检查作业执行环境" class="headerlink" title="4.1 检查作业执行环境"></a>4.1 检查作业执行环境</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkJobExecutionEnvironment</span><span class="params">()</span> <span class="keyword">throws</span> JobExecutionEnvironmentException </span>&#123;</div><div class="line">   configService.checkMaxTimeDiffSecondsTolerable();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>ConfigService#checkMaxTimeDiffSecondsTolerable()</code> 方法校验本机时间是否合法，在<a href="http://www.iocoder.cn/Elastic-Job/job-config/?self">《Elastic-Job-Lite 源码分析 —— 作业配置》的「3.3」校验本机时间是否合法</a> 已经解析。</li><li>当校验本机时间不合法时，抛出异常。若使用 DefaultJobExceptionHandler 作为异常处理，<strong>只打印日志，不会终止作业执行</strong>。如果你的作业对时间精准度有比较高的要求，期望作业<strong>终止</strong>执行，可以自定义 JobExceptionHandler 实现对异常的处理。</li></ul><h2 id="4-2-获取当前作业服务器的分片上下文"><a href="#4-2-获取当前作业服务器的分片上下文" class="headerlink" title="4.2 获取当前作业服务器的分片上下文"></a>4.2 获取当前作业服务器的分片上下文</h2><p>调用 <code>LiteJobFacade#getShardingContexts()</code> 方法获取当前作业服务器的分片上下文。通过这个方法，作业获得<strong>其所分配执行的分片项</strong>，在<a href="http://www.iocoder.cn/Elastic-Job/job-sharding/?self">《Elastic-Job-Lite 源码解析 —— 作业分片》</a>详细分享。</p><h2 id="4-3-发布作业状态追踪事件"><a href="#4-3-发布作业状态追踪事件" class="headerlink" title="4.3 发布作业状态追踪事件"></a>4.3 发布作业状态追踪事件</h2><p>调用 <code>LiteJobFacade#postJobStatusTraceEvent()</code> 方法发布作业状态追踪事件，在<a href="http://www.iocoder.cn/Elastic-Job/job-event-trace/?self">《Elastic-Job-Lite 源码解析 —— 作业事件追踪》</a>详细分享。</p><h2 id="4-4-跳过正在运行中的被错过执行的作业"><a href="#4-4-跳过正在运行中的被错过执行的作业" class="headerlink" title="4.4 跳过正在运行中的被错过执行的作业"></a>4.4 跳过正在运行中的被错过执行的作业</h2><p>该逻辑和<strong>「4.7」执行被错过执行的作业</strong>，一起解析，可以整体性的理解 Elastic-Job-Lite 对被错过执行( misfired )的作业处理。</p><h2 id="4-5-执行作业执行前的方法"><a href="#4-5-执行作业执行前的方法" class="headerlink" title="4.5 执行作业执行前的方法"></a>4.5 执行作业执行前的方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeJobExecuted</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (ElasticJobListener each : elasticJobListeners) &#123;</div><div class="line">       each.beforeJobExecuted(shardingContexts);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用作业监听器执行作业<strong>执行前</strong>的方法，在<a href="http://www.iocoder.cn/Elastic-Job/job-listener/?self">《Elastic-Job-Lite 源码解析 —— 作业监听器》</a>详细分享。</li></ul><h2 id="4-6-执行普通触发的作业"><a href="#4-6-执行普通触发的作业" class="headerlink" title="4.6 执行普通触发的作业"></a>4.6 执行普通触发的作业</h2><p>这个小节的标题不太准确，其他<strong>作业来源</strong>( ExecutionSource )也是执行这样的逻辑。本小节执行作业会经历 4 个方法，方法<strong>顺序</strong>往下调用，我们逐个来看。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 执行多个作业的分片</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> shardingContexts 分片上下文集合</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> executionSource 执行来源</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts, <span class="keyword">final</span> JobExecutionEvent.ExecutionSource executionSource)</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 执行多个作业的分片</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> shardingContexts 分片上下文集合</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> executionSource 执行来源</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts, <span class="keyword">final</span> JobExecutionEvent.ExecutionSource executionSource)</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 执行单个作业的分片</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> shardingContexts 分片上下文集合</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> item 分片序号</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> startEvent 执行事件(开始)</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts, <span class="keyword">final</span> <span class="keyword">int</span> item, <span class="keyword">final</span> JobExecutionEvent startEvent)</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 执行单个作业的分片【子类实现】</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> shardingContext 分片上下文集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(ShardingContext shardingContext)</span></span>;</div></pre></td></tr></table></figure><p>ps：<strong>作业事件</strong>相关逻辑，先统一跳过，在<a href="http://www.iocoder.cn/Elastic-Job/job-event-trace/?self">《Elastic-Job-Lite 源码解析 —— 作业事件追踪》</a>详细分享。</p><hr><p><strong>private void execute(shardingContexts, executionSource)</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts, <span class="keyword">final</span> JobExecutionEvent.ExecutionSource executionSource)</span> </span>&#123;</div><div class="line">   <span class="comment">// 无可执行的分片，发布作业状态追踪事件(State.TASK_FINISHED)</span></div><div class="line">   <span class="keyword">if</span> (shardingContexts.getShardingItemParameters().isEmpty()) &#123;</div><div class="line">       <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">           jobFacade.postJobStatusTraceEvent(shardingContexts.getTaskId(), State.TASK_FINISHED, String.format(<span class="string">"Sharding item for job '%s' is empty."</span>, jobName));</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 注册作业启动信息</span></div><div class="line">   jobFacade.registerJobBegin(shardingContexts);</div><div class="line">   <span class="comment">// 发布作业状态追踪事件(State.TASK_RUNNING)</span></div><div class="line">   String taskId = shardingContexts.getTaskId();</div><div class="line">   <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">       jobFacade.postJobStatusTraceEvent(taskId, State.TASK_RUNNING, <span class="string">""</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">//</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       process(shardingContexts, executionSource);</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       <span class="comment">// TODO 考虑增加作业失败的状态，并且考虑如何处理作业失败的整体回路</span></div><div class="line">       <span class="comment">// 注册作业完成信息</span></div><div class="line">       jobFacade.registerJobCompleted(shardingContexts);</div><div class="line">       <span class="comment">// 根据是否有异常，发布作业状态追踪事件(State.TASK_FINISHED / State.TASK_ERROR)</span></div><div class="line">       <span class="keyword">if</span> (itemErrorMessages.isEmpty()) &#123;</div><div class="line">           <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">               jobFacade.postJobStatusTraceEvent(taskId, State.TASK_FINISHED, <span class="string">""</span>);</div><div class="line">           &#125;</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">               jobFacade.postJobStatusTraceEvent(taskId, State.TASK_ERROR, itemErrorMessages.toString());</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>方法参数 <code>executionSource</code> 代表执行来源( ExecutionSource )，一共有三种：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ExecutionSource &#123;</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 普通触发执行</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   NORMAL_TRIGGER,</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 被错过执行</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   MISFIRE,</div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 失效转移执行</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   FAILOVER</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>调用 <code>LiteJobFacade#registerJobBegin(...)</code> 方法注册作业<strong>启动</strong>信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerJobBegin</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts)</span> </span>&#123;</div><div class="line">   executionService.registerJobBegin(shardingContexts);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ExecutionService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerJobBegin</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts)</span> </span>&#123;</div><div class="line">   JobRegistry.getInstance().setJobRunning(jobName, <span class="keyword">true</span>);</div><div class="line">   <span class="keyword">if</span> (!configService.load(<span class="keyword">true</span>).isMonitorExecution()) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> each : shardingContexts.getShardingItemParameters().keySet()) &#123;</div><div class="line">       jobNodeStorage.fillEphemeralJobNode(ShardingNode.getRunningNode(each), <span class="string">""</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>仅当作业配置设置<strong>监控作业运行时状态</strong>( <code>LiteJobConfiguration.monitorExecution = true</code> )时，记录作业运行状态。</li><li>调用 <code>JobNodeStorage#fillEphemeralJobNode(...)</code> 方法记录<strong>分配的作业分片项</strong>正在运行中。如何记录的，在<a href="http://www.iocoder.cn/Elastic-Job/job-storage/?self">《Elastic-Job-Lite 源码解析 —— 作业数据存储》</a>详细分享。</li></ul></li><li><p>调用 <code>LiteJobFacade#registerJobCompleted(...)</code> 方法注册作业<strong>完成</strong>信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerJobCompleted</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts)</span> </span>&#123;</div><div class="line">   executionService.registerJobCompleted(shardingContexts);</div><div class="line">   <span class="keyword">if</span> (configService.load(<span class="keyword">true</span>).isFailover()) &#123;</div><div class="line">       failoverService.updateFailoverComplete(shardingContexts.getShardingItemParameters().keySet());</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ExecutionService.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 注册作业完成信息.</span></div><div class="line"><span class="comment">* </span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> shardingContexts 分片上下文</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerJobCompleted</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts)</span> </span>&#123;</div><div class="line">   JobRegistry.getInstance().setJobRunning(jobName, <span class="keyword">false</span>);</div><div class="line">   <span class="keyword">if</span> (!configService.load(<span class="keyword">true</span>).isMonitorExecution()) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> each : shardingContexts.getShardingItemParameters().keySet()) &#123;</div><div class="line">       jobNodeStorage.removeJobNodeIfExisted(ShardingNode.getRunningNode(each));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>仅当作业配置设置<strong>监控作业运行时状态</strong>( <code>LiteJobConfiguration.monitorExecution = true</code> )，移除作业运行状态。</li><li>调用 <code>JobNodeStorage#removeJobNodeIfExisted(...)</code> 方法<strong>移除分配的作业分片项</strong>正在运行中的标记，表示作业分片项不在运行中状态。</li><li>调用 <code>FailoverService#updateFailoverComplete(...)</code> 方法更新执行完毕失效转移的分片项状态，在<a href="http://www.iocoder.cn/Elastic-Job/job-failover/?self">《Elastic-Job-Lite 源码解析 —— 作业失效转移》</a>详细分享。</li></ul></li></ul><hr><p><strong>private void process(shardingContexts, executionSource)</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts, <span class="keyword">final</span> JobExecutionEvent.ExecutionSource executionSource)</span> </span>&#123;</div><div class="line">   Collection&lt;Integer&gt; items = shardingContexts.getShardingItemParameters().keySet();</div><div class="line">   <span class="comment">// 单分片，直接执行</span></div><div class="line">   <span class="keyword">if</span> (<span class="number">1</span> == items.size()) &#123;</div><div class="line">       <span class="keyword">int</span> item = shardingContexts.getShardingItemParameters().keySet().iterator().next();</div><div class="line">       JobExecutionEvent jobExecutionEvent =  <span class="keyword">new</span> JobExecutionEvent(shardingContexts.getTaskId(), jobName, executionSource, item);</div><div class="line">       <span class="comment">// 执行一个作业</span></div><div class="line">       process(shardingContexts, item, jobExecutionEvent);</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 多分片，并行执行</span></div><div class="line">   <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(items.size());</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">final</span> <span class="keyword">int</span> each : items) &#123;</div><div class="line">       <span class="keyword">final</span> JobExecutionEvent jobExecutionEvent = <span class="keyword">new</span> JobExecutionEvent(shardingContexts.getTaskId(), jobName, executionSource, each);</div><div class="line">       <span class="keyword">if</span> (executorService.isShutdown()) &#123;</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line">       executorService.submit(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">           </div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                   <span class="comment">// 执行一个作业</span></div><div class="line">                   process(shardingContexts, each, jobExecutionEvent);</div><div class="line">               &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                   latch.countDown();</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 等待多分片全部完成</span></div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       latch.await();</div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> InterruptedException ex) &#123;</div><div class="line">       Thread.currentThread().interrupt();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>分配<strong>单</strong>分片项时，直接执行，无需使用线程池，性能更优。</li><li>分配<strong>多</strong>分片项时，使用线程池<strong>并发</strong>执行，通过 CountDownLatch 实现等待分片项全部执行完成。</li></ul><hr><p><strong>private void process(shardingContexts, item, startEvent)</strong><br><strong>protected abstract void process(shardingContext)</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts, <span class="keyword">final</span> <span class="keyword">int</span> item, <span class="keyword">final</span> JobExecutionEvent startEvent)</span> </span>&#123;</div><div class="line">   <span class="comment">// 发布执行事件(开始)</span></div><div class="line">   <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">       jobFacade.postJobExecutionEvent(startEvent);</div><div class="line">   &#125;</div><div class="line">   log.trace(<span class="string">"Job '&#123;&#125;' executing, item is: '&#123;&#125;'."</span>, jobName, item);</div><div class="line">   JobExecutionEvent completeEvent;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 执行单个作业</span></div><div class="line">       process(<span class="keyword">new</span> ShardingContext(shardingContexts, item));</div><div class="line">       <span class="comment">// 发布执行事件(成功)</span></div><div class="line">       completeEvent = startEvent.executionSuccess();</div><div class="line">       log.trace(<span class="string">"Job '&#123;&#125;' executed, item is: '&#123;&#125;'."</span>, jobName, item);</div><div class="line">       <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</div><div class="line">           jobFacade.postJobExecutionEvent(completeEvent);</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// CHECKSTYLE:OFF</span></div><div class="line">   &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable cause) &#123;</div><div class="line">       <span class="comment">// CHECKSTYLE:ON</span></div><div class="line">       <span class="comment">// 发布执行事件(失败)</span></div><div class="line">       completeEvent = startEvent.executionFailure(cause);</div><div class="line">       jobFacade.postJobExecutionEvent(completeEvent);</div><div class="line">       <span class="comment">// 设置该分片执行异常信息</span></div><div class="line">       itemErrorMessages.put(item, ExceptionUtil.transform(cause));</div><div class="line">       <span class="comment">//</span></div><div class="line">       jobExceptionHandler.handleException(jobName, cause);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(ShardingContext shardingContext)</span></span>;</div></pre></td></tr></table></figure><ul><li>不同作业执行器实现类通过实现 <code>#process(shardingContext)</code> 抽象方法，实现对<strong>单个分片项</strong>作业的处理。</li><li>不同作业执行器实现类通过实现 <code>#process(shardingContext)</code> 抽象方法，实现对<strong>单个分片项</strong>作业的处理。</li><li>不同作业执行器实现类通过实现 <code>#process(shardingContext)</code> 抽象方法，实现对<strong>单个分片项</strong>作业的处理。</li></ul><h3 id="4-6-1-简单作业执行器"><a href="#4-6-1-简单作业执行器" class="headerlink" title="4.6.1 简单作业执行器"></a>4.6.1 简单作业执行器</h3><p>SimpleJobExecutor，简单作业执行器</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleJobExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractElasticJobExecutor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 简单作业实现</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SimpleJob simpleJob;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext)</span> </span>&#123;</div><div class="line">        simpleJob.execute(shardingContext);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>SimpleJob#execute()</code> 方法对单个分片项作业进行处理。</li></ul><h3 id="4-6-2-数据流作业执行器"><a href="#4-6-2-数据流作业执行器" class="headerlink" title="4.6.2 数据流作业执行器"></a>4.6.2 数据流作业执行器</h3><p>DataflowJobExecutor，数据流作业执行器。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DataflowJobExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractElasticJobExecutor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 数据流作业对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DataflowJob&lt;Object&gt; dataflowJob;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext)</span> </span>&#123;</div><div class="line">        DataflowJobConfiguration dataflowConfig = (DataflowJobConfiguration) getJobRootConfig().getTypeConfig();</div><div class="line">        <span class="keyword">if</span> (dataflowConfig.isStreamingProcess()) &#123; <span class="comment">// 流式处理数据</span></div><div class="line">            streamingExecute(shardingContext);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            oneOffExecute(shardingContext);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 流式处理</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> shardingContext 分片上下文</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">streamingExecute</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext)</span> </span>&#123;</div><div class="line">        List&lt;Object&gt; data = fetchData(shardingContext);</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != data &amp;&amp; !data.isEmpty()) &#123;</div><div class="line">            processData(shardingContext, data);</div><div class="line">            <span class="keyword">if</span> (!getJobFacade().isEligibleForJobRunning()) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            data = fetchData(shardingContext);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 一次处理</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> shardingContext 分片上下文</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">oneOffExecute</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext)</span> </span>&#123;</div><div class="line">        List&lt;Object&gt; data = fetchData(shardingContext);</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != data &amp;&amp; !data.isEmpty()) &#123;</div><div class="line">            processData(shardingContext, data);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>当作业配置设置流式处理数据( <code>DataflowJobConfiguration.streamingProcess = true</code> ) 时，调用 <code>#streamingExecute()</code> <strong>不断</strong>加载数据，<strong>不断</strong>处理数据，直到<strong>数据为空</strong> 或者 <strong>作业不适合继续运行</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEligibleForJobRunning</span><span class="params">()</span> </span>&#123;</div><div class="line">   LiteJobConfiguration liteJobConfig = configService.load(<span class="keyword">true</span>);</div><div class="line">   <span class="keyword">if</span> (liteJobConfig.getTypeConfig() <span class="keyword">instanceof</span> DataflowJobConfiguration) &#123;</div><div class="line">       <span class="keyword">return</span> !shardingService.isNeedSharding() <span class="comment">// 作业不需要重新分片</span></div><div class="line">               &amp;&amp; ((DataflowJobConfiguration) liteJobConfig.getTypeConfig()).isStreamingProcess();</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> !shardingService.isNeedSharding(); <span class="comment">// 作业不需要重新分片</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>作业需要重新分片，所以不适合继续流式数据处理。</p><blockquote><p>如果采用流式作业处理方式，建议processData处理数据后更新其状态，避免fetchData再次抓取到，从而使得作业永不停止。 流式数据处理参照TbSchedule设计，适用于不间歇的数据处理。</p></blockquote></li></ul></li><li><p>当作业配置<strong>不</strong>设置流式处理数据( <code>DataflowJobConfiguration.streamingProcess = false</code> ) 时，调用 <code>#oneOffExecute()</code> <strong>一次</strong>加载数据，<strong>一次</strong>处理数据。</p></li><li><p>调用 <code>#fetchData()</code> 方法加载数据；调用 <code>#processData(...)</code> 方法处理数据：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// DataflowJobExecutor.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 加载数据</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> shardingContext 分片上下文</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 数据</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> List&lt;Object&gt; <span class="title">fetchData</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> dataflowJob.fetchData(shardingContext);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 处理数据</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> shardingContext 分片上下文</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> data 数据</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processData</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext, <span class="keyword">final</span> List&lt;Object&gt; data)</span> </span>&#123;</div><div class="line">   dataflowJob.processData(shardingContext, data);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h3 id="4-6-3-脚本作业执行器"><a href="#4-6-3-脚本作业执行器" class="headerlink" title="4.6.3 脚本作业执行器"></a>4.6.3 脚本作业执行器</h3><p>ScriptJobExecutor，脚本作业执行器。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ScriptJobExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractElasticJobExecutor</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> String scriptCommandLine = ((ScriptJobConfiguration) getJobRootConfig().getTypeConfig()).getScriptCommandLine();</div><div class="line">        <span class="keyword">if</span> (Strings.isNullOrEmpty(scriptCommandLine)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JobConfigurationException(<span class="string">"Cannot find script command line for job '%s', job is not executed."</span>, shardingContext.getJobName());</div><div class="line">        &#125;</div><div class="line">        executeScript(shardingContext, scriptCommandLine);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 执行脚本</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> shardingContext 分片上下文</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> scriptCommandLine 执行脚本路径</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeScript</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext, <span class="keyword">final</span> String scriptCommandLine)</span> </span>&#123;</div><div class="line">        CommandLine commandLine = CommandLine.parse(scriptCommandLine);</div><div class="line">        <span class="comment">// JSON 格式传递参数</span></div><div class="line">        commandLine.addArgument(GsonFactory.getGson().toJson(shardingContext), <span class="keyword">false</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">new</span> DefaultExecutor().execute(commandLine);</div><div class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IOException ex) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JobConfigurationException(<span class="string">"Execute script failure."</span>, ex);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p><code>scriptCommandLine</code> 传递的是<strong>脚本路径</strong>。使用 <a href="https://commons.apache.org/proper/commons-exec/" rel="external nofollow noopener noreferrer" target="_blank">Apache Commons Exec</a> 工具包实现脚本调用：</p><blockquote><p>Script类型作业意为脚本类型作业，支持shell，python，perl等所有类型脚本。只需通过控制台或代码配置scriptCommandLine即可，无需编码。执行脚本路径可包含参数，参数传递完毕后，作业框架会自动追加最后一个参数为作业运行时信息。</p></blockquote></li><li><p>脚本参数传递使用 JSON 格式。</p></li></ul><h2 id="4-7-执行被错过触发的作业"><a href="#4-7-执行被错过触发的作业" class="headerlink" title="4.7 执行被错过触发的作业"></a>4.7 执行被错过触发的作业</h2><p>当作业执行过久，导致到达下次执行时间未进行下一次作业执行，Elastic-Job-Lite 会设置该作业分片项为被错过执行( misfired )。下一次作业执行时，会<strong>补充</strong>执行被错过执行的作业分片项。</p><p><strong>标记作业被错过执行</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobScheduler.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> Scheduler <span class="title">createScheduler</span><span class="params">()</span> </span>&#123;</div><div class="line">   Scheduler result;</div><div class="line">   <span class="comment">// 省略部分代码</span></div><div class="line">   result.getListenerManager().addTriggerListener(schedulerFacade.newJobTriggerListener());</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> Properties <span class="title">getBaseQuartzProperties</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 省略部分代码</span></div><div class="line">   result.put(<span class="string">"org.quartz.jobStore.misfireThreshold"</span>, <span class="string">"1"</span>);</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// JobScheduleController.class</span></div><div class="line"><span class="function"><span class="keyword">private</span> CronTrigger <span class="title">createTrigger</span><span class="params">(<span class="keyword">final</span> String cron)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> TriggerBuilder.newTrigger()</div><div class="line">           .withIdentity(triggerIdentity)</div><div class="line">           .withSchedule(CronScheduleBuilder.cronSchedule(cron)</div><div class="line">           .withMisfireHandlingInstructionDoNothing())</div><div class="line">           .build();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>org.quartz.jobStore.misfireThreshold</code> 设置最大允许超过 1 毫秒，作业分片项即被视为错过执行。</li><li><code>#withMisfireHandlingInstructionDoNothing()</code> 设置 Quartz 系统不会立刻再执行任务，而是等到距离目前时间最近的预计时间执行。<strong>重新执行被错过执行的作业交给 Elastic-Job-Lite 处理</strong>。</li><li><p>使用 TriggerListener 监听被错过执行的作业分片项：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// JobTriggerListener.java</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JobTriggerListener</span> <span class="keyword">extends</span> <span class="title">TriggerListenerSupport</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">triggerMisfired</span><span class="params">(<span class="keyword">final</span> Trigger trigger)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != trigger.getPreviousFireTime()) &#123;</div><div class="line">            executionService.setMisfire(shardingService.getLocalShardingItems());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ExecutionService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMisfire</span><span class="params">(<span class="keyword">final</span> Collection&lt;Integer&gt; items)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> each : items) &#123;</div><div class="line">       jobNodeStorage.createJobNodeIfNeeded(ShardingNode.getMisfireNode(each));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用 <code>#setMisfire(...)</code> 设置作业分片项被错过执行。</li></ul></li></ul><p><strong>跳过正在运行中的被错过执行的作业</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">misfireIfRunning</span><span class="params">(<span class="keyword">final</span> Collection&lt;Integer&gt; shardingItems)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> executionService.misfireIfHasRunningItems(shardingItems);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ExecutionService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">misfireIfHasRunningItems</span><span class="params">(<span class="keyword">final</span> Collection&lt;Integer&gt; items)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (!hasRunningItems(items)) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">   setMisfire(items);</div><div class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasRunningItems</span><span class="params">(<span class="keyword">final</span> Collection&lt;Integer&gt; items)</span> </span>&#123;</div><div class="line">   LiteJobConfiguration jobConfig = configService.load(<span class="keyword">true</span>);</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> == jobConfig || !jobConfig.isMonitorExecution()) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> each : items) &#123;</div><div class="line">       <span class="keyword">if</span> (jobNodeStorage.isJobNodeExisted(ShardingNode.getRunningNode(each))) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>当分配的作业分片项里存在<strong>任意一个分片正在运行</strong>中，设置分片项<strong>都</strong>被错过执行( <code>misfired</code> )，并不执行这些作业分片。如果不进行跳过，则可能导致<strong>同时</strong>运行某个作业分片。</li><li>该功能依赖作业配置<strong>监控作业运行时状态</strong>( <code>LiteJobConfiguration.monitorExecution = true</code> )时生效。</li></ul><p><strong>执行被错过执行的作业分片项</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// AbstractElasticJobExecutor.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// .... 省略部分代码</span></div><div class="line">   <span class="comment">// 执行 被跳过触发的作业</span></div><div class="line">   <span class="keyword">while</span> (jobFacade.isExecuteMisfired(shardingContexts.getShardingItemParameters().keySet())) &#123;</div><div class="line">       jobFacade.clearMisfire(shardingContexts.getShardingItemParameters().keySet());</div><div class="line">       execute(shardingContexts, JobExecutionEvent.ExecutionSource.MISFIRE);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// .... 省略部分代码</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExecuteMisfired</span><span class="params">(<span class="keyword">final</span> Collection&lt;Integer&gt; shardingItems)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> isEligibleForJobRunning() <span class="comment">// 合适继续运行</span></div><div class="line">           &amp;&amp; configService.load(<span class="keyword">true</span>).getTypeConfig().getCoreConfig().isMisfire() <span class="comment">// 作业配置开启作业被错过触发</span></div><div class="line">           &amp;&amp; !executionService.getMisfiredJobItems(shardingItems).isEmpty(); <span class="comment">// 所执行的作业分片存在被错过( misfired )</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearMisfire</span><span class="params">(<span class="keyword">final</span> Collection&lt;Integer&gt; shardingItems)</span> </span>&#123;</div><div class="line">   executionService.clearMisfire(shardingItems);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>清除分配的作业分片项被错过执行的标识，并执行作业分片项。</li><li>为什么此处使用 <strong>while(…)</strong>？<strong>防御性编程</strong>，<code>#isExecuteMisfired(...)</code> 判断使用<strong>内存缓存</strong>的数据，而该数据的更新依赖 Zookeeper 通知进行<strong>异步</strong>更新，可能因为各种情况，例如网络，数据可能未及时更新导致<strong>数据不一致</strong>。使用 <strong>while(…)</strong> 进行防御编程，保证<strong>内存缓存</strong>的数据已经更新。</li></ul><h2 id="4-8-执行作业失效转移"><a href="#4-8-执行作业失效转移" class="headerlink" title="4.8 执行作业失效转移"></a>4.8 执行作业失效转移</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failoverIfNecessary</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (configService.load(<span class="keyword">true</span>).isFailover()) &#123;</div><div class="line">       failoverService.failoverIfNecessary();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用作业失效转移服务( FailoverService )执行作业失效转移( <code>#failoverIfNecessary()</code> )，在<a href="http://www.iocoder.cn/Elastic-Job/job-failover/?self">《Elastic-Job-Lite 源码解析 —— 作业失效转移》</a>详细分享。</li></ul><h2 id="4-9-执行作业执行后的方法"><a href="#4-9-执行作业执行后的方法" class="headerlink" title="4.9 执行作业执行后的方法"></a>4.9 执行作业执行后的方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LiteJobFacade.java</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterJobExecuted</span><span class="params">(<span class="keyword">final</span> ShardingContexts shardingContexts)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (ElasticJobListener each : elasticJobListeners) &#123;</div><div class="line">       each.afterJobExecuted(shardingContexts);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>调用作业监听器执行作业<strong>执行后</strong>的方法，在<a href="http://www.iocoder.cn/Elastic-Job/job-listener/?self">《Elastic-Job-Lite 源码解析 —— 作业监听器》</a>详细分享。</li></ul><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p><img src="http://www.iocoder.cn/images/Architecture/2017_12_29/01.png" alt="知识星球"></p><p>呼！略长略长略长！</p><p>下面会更新如下两篇文章，为后续的主节点选举、失效转移、作业分片策略等文章做铺垫：</p><ul><li><a href="http://www.iocoder.cn/Elastic-Job/reg-center-zookeeper/?self">《Elastic-Job-Lite 源码解析 —— 注册中心》</a></li><li><a href="http://www.iocoder.cn/Elastic-Job/job-storage/?self">《Elastic-Job-Lite 源码解析 —— 作业数据存储》</a></li></ul><p>道友，赶紧上车，分享一波朋友圈！</p><p>啊啊啊，我好想马上拜读 Elastic-Job-Cloud。为了你们，我忍住了心碎。</p><p>旁白君：煞笔笔者已经偷偷在读了。<br>芋道君：旁白君，你大爷！</p></div><footer class="article-footer clearfix"><div class="article-categories"><span></span> <a class="article-category-link" href="/categories/Elastic-Job-Lite/">Elastic-Job-Lite</a></div><div class="article-share" id="share"><div data-url="http://www.iocoder.cn/Elastic-Job/job-execute/" data-title="Elastic-Job-Lite 源码分析 —— 作业执行 | 芋道源码 —— 纯源码解析博客" data-tsina="null" class="share clearfix"></div></div></footer></article><nav class="article-nav clearfix"><div class="prev"><a href="/Elastic-Job/reg-center-zookeeper/" title="Elastic-Job-Lite 源码分析 —— 注册中心"><strong>PREVIOUS:</strong><br><span>Elastic-Job-Lite 源码分析 —— 注册中心</span></a></div><div class="next"><a href="/Elastic-Job/job-init/" title="Elastic-Job-Lite 源码分析 —— 作业初始化"><strong>NEXT:</strong><br><span>Elastic-Job-Lite 源码分析 —— 作业初始化</span></a></div></nav></div><div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div><div id="toc" class="toc-aside"><strong class="toc-title">文章目录</strong><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-概述"><span class="toc-number">1.</span> <span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Lite调度作业"><span class="toc-number">2.</span> <span class="toc-text">2. Lite调度作业</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-执行器创建"><span class="toc-number">3.</span> <span class="toc-text">3. 执行器创建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-加载作业配置"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 加载作业配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-获取作业执行线程池"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 获取作业执行线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-获取作业异常执行器"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 获取作业异常执行器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-执行器执行"><span class="toc-number">4.</span> <span class="toc-text">4. 执行器执行</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-检查作业执行环境"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 检查作业执行环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-获取当前作业服务器的分片上下文"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 获取当前作业服务器的分片上下文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-发布作业状态追踪事件"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 发布作业状态追踪事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-跳过正在运行中的被错过执行的作业"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 跳过正在运行中的被错过执行的作业</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-执行作业执行前的方法"><span class="toc-number">4.5.</span> <span class="toc-text">4.5 执行作业执行前的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-执行普通触发的作业"><span class="toc-number">4.6.</span> <span class="toc-text">4.6 执行普通触发的作业</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-1-简单作业执行器"><span class="toc-number">4.6.1.</span> <span class="toc-text">4.6.1 简单作业执行器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-2-数据流作业执行器"><span class="toc-number">4.6.2.</span> <span class="toc-text">4.6.2 数据流作业执行器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-3-脚本作业执行器"><span class="toc-number">4.6.3.</span> <span class="toc-text">4.6.3 脚本作业执行器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-执行被错过触发的作业"><span class="toc-number">4.7.</span> <span class="toc-text">4.7 执行被错过触发的作业</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-执行作业失效转移"><span class="toc-number">4.8.</span> <span class="toc-text">4.8 执行作业失效转移</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-执行作业执行后的方法"><span class="toc-number">4.9.</span> <span class="toc-text">4.9 执行作业执行后的方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#666-彩蛋"><span class="toc-number">5.</span> <span class="toc-text">666. 彩蛋</span></a></li></ol></div><div id="asidepart"><aside class="clearfix"><div id="authorInfo"><div><img width="100%" src="/images/common/wechat_mp_2017_07_31_bak.jpg"></div><div class="social-list"></div></div><div class="categorieslist"><p class="asidetitle">微信公众号福利：芋道源码</p><ul><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">0. 阅读源码葵花宝典</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">1. RocketMQ / MyCAT / Sharding-JDBC 详细中文注释源码</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">2. 您对于源码的疑问每条留言都将得到认真回复</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">3. 新的源码解析文章实时收到通知，每周六十点更新</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">4. 认真的源码交流微信群</a></li></ul></div><div class="categorieslist"><p class="asidetitle">分类</p><ul><li><a href="/categories/Elastic-Job-Cloud/" title="Elastic-Job-Cloud">Elastic-Job-Cloud<sup>6</sup></a></li><li><a href="/categories/Elastic-Job-Lite/" title="Elastic-Job-Lite">Elastic-Job-Lite<sup>16</sup></a></li><li><a href="/categories/Eureka/" title="Eureka">Eureka<sup>23</sup></a></li><li><a href="/categories/Hystrix/" title="Hystrix">Hystrix<sup>9</sup></a></li><li><a href="/categories/MyCAT/" title="MyCAT">MyCAT<sup>9</sup></a></li><li><a href="/categories/RocketMQ/" title="RocketMQ">RocketMQ<sup>14</sup></a></li><li><a href="/categories/RxJava/" title="RxJava">RxJava<sup>5</sup></a></li><li><a href="/categories/Sharding-JDBC/" title="Sharding-JDBC">Sharding-JDBC<sup>18</sup></a></li><li><a href="/categories/SkyWalking/" title="SkyWalking">SkyWalking<sup>35</sup></a></li><li><a href="/categories/Spring-Cloud-Gateway/" title="Spring-Cloud-Gateway">Spring-Cloud-Gateway<sup>24</sup></a></li><li><a href="/categories/TCC-Transaction/" title="TCC-Transaction">TCC-Transaction<sup>7</sup></a></li><li><a href="/categories/工作内推/" title="工作内推">工作内推<sup>2</sup></a></li><li><a href="/categories/芋道源码的周八/" title="芋道源码的周八">芋道源码的周八<sup>12</sup></a></li></ul></div><div id="authorInfo2"><div><img width="100%" src="/images/common/zsxq/02.png"></div></div></aside></div></div><footer><div id="footer"><img src="http://www.iocoder.cn/images/common/wechat_mp_simple.png" style="display:none"><p class="copyright">© 2018 <a href="http://www.iocoder.cn" target="_blank" title="芋道源码">芋道源码</a> && <span style="display:inline" id="busuanzi_container_site_uv">总访客数 <span id="busuanzi_value_site_uv" font="微软雅黑"></span> 次</span> && <span style="display:inline" id="busuanzi_container_site_pv">总访问量 <span id="busuanzi_value_site_pv" font="微软雅黑"></span> 次</span> && Hosted by <a href="https://pages.coding.me" style="font-weight:700" rel="external nofollow noopener noreferrer" target="_blank">Coding Pages</a></p></div><div class="copyright">沪ICP备17037075号-1</div></footer><script src="/js/jquery-2.1.0.min.js"></script><script type="text/javascript">$(document).ready(function(){function e(){"number"==typeof window.innerWidth?n=window.innerWidth:document.documentElement&&document.documentElement.clientWidth&&(n=document.documentElement.clientWidth)}$(".navbar").click(function(){$("header nav").toggleClass("shownav")});var n=0,s=$("#main"),a=$("#asidepart"),o=$(".closeaside"),d=$(".openaside");$(window).resize(function(){e(),n>=1024?$("header nav").removeClass("shownav"):(s.removeClass("moveMain"),a.css("display","block").removeClass("fadeOut"),d.css("display","none"),$("#toc.toc-aside").css("display","none"))}),o.click(function(){a.addClass("fadeOut").css("display","none"),d.css("display","block").addClass("fadeIn"),s.addClass("moveMain")}),d.click(function(){d.css("display","none").removeClass("beforeFadeIn"),a.css("display","block").removeClass("fadeOut").addClass("fadeIn"),s.removeClass("moveMain")}),$(window).scroll(function(){d.css("top",Math.max(80,260-$(this).scrollTop()))})})</script><script type="text/javascript">$(document).ready(function(){var a=$(".article-content>iframe"),t=$(".article-content>embed"),n=$("#toc");$("article h2"),ah=$("article h2"),ta=$("#toc.toc-aside"),o=$(".openaside"),c=$(".closeaside"),a.length>0&&a.wrap('<div class="video-container" />'),t.length>0&&t.wrap('<div class="video-container" />'),0==ah.length?n.css("display","none"):(c.click(function(){ta.css("display","block").addClass("fadeIn")}),o.click(function(){ta.css("display","none")}),$(window).scroll(function(){ta.css("top",Math.max(140,320-$(this).scrollTop()))}))})</script><script type="text/javascript">$(document).ready(function(){var t=$(".share"),a=t.attr("data-url"),e=encodeURIComponent(a),r=['<a href="#" class="overlay" id="qrcode"></a>','<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url='+e+'"/></div>','<a href="#textlogo" class="article-back-to-top" title="Top"></a>','<a href="https://www.facebook.com/sharer.php?u='+e+'" class="article-share-facebook" target="_blank" title="Facebook"></a>','<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>','<a href="https://twitter.com/intent/tweet?url='+e+'" class="article-share-twitter" target="_blank" title="Twitter"></a>','<a href="http://service.weibo.com/share/share.php?title='+t.attr("data-title")+"&url="+e+"&ralateUid="+t.attr("data-tsina")+'&searchPic=true&style=number" class="article-share-weibo" target="_blank" title="Weibo"></a>','<span title="Share to"></span>'].join("");t.append(r),$(".article-share-qrcode").click(function(){var t=$("#qrcode-pic").attr("data-src");$("#qrcode-pic").attr("src",t),$("#qrcode-pic").load(function(){$(".qrcode strong").text(" ")})})})</script><link rel="stylesheet" href="/alert/css/alert.css"><script src="/alert/js/alert.js"></script><script src="/js/jquery.cookie.js"></script><script src="/js/util.js"></script><script type="text/javascript">!function(e,a,t,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=a.createElement(t),s=a.getElementsByTagName(t)[0],o.async=1,o.src="//www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s)}(window,document,"script",0,"ga"),ga("create","UA-107572620-1","auto"),ga("send","pageview")</script></body>