<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="google-site-verification" content="GkJ68PCnxM9Ih7Zm9v8p91FOCV7ymNCO2KdGbflLh3E"><meta name="360-site-verification" content="dd6547587641bfede036f7c79561e8a0"><meta name="shenma-site-verification" content="fd96cf3751972c9b05f8471d2ccadddc_1496951214"><meta name="msvalidate.01" content="1D38B05050A977F6FDEDA481198343F1"><meta name="sogou_site_verification" content="MpPsku240L"><title>Elastic-Job-Cloud 源码分析 —— 作业失效转移 | 芋道源码 —— 纯源码解析博客</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=3,minimum-scale=1"><meta name="author" content="芋道源码"><meta name="description" content="摘要: 原创出处 http://www.iocoder.cn/Elastic-Job/cloud-job-failover/ 「芋道源码」欢迎转载，保留摘要，谢谢！
本文基于 Elastic-Job V2.1.5 版本分享

1. 概述
2. 记录作业失效转移
3. 提交失效转移作业
666. 彩蛋"><meta name="keywords" content="Java,架构,后端,服务端,RocketMQ,MyCAT,分布式消息队列,分布式存储,技术博客,Sharding-JDBC,分库分表"><link rel="alternate" href="atom.xml" title="芋道源码 —— 纯源码解析博客" type="application/atom+xml"><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/style.css"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?9e70e3362807c1bd185a79655b307027";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script>!function(){var t="http:"==document.location.protocol?"http://js.passport.qihucdn.com/11.0.1.js?f05b61dd54bbc38386611a5238672938":"https://jspassport.ssl.qhimg.com/11.0.1.js?f05b61dd54bbc38386611a5238672938";document.write('<script src="'+t+'" id="sozz"><\/script>')}()</script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></head></html><body><header><div><div id="textlogo"><h1 class="site-name"><a href="/" title="芋道源码 —— 纯源码解析博客">芋道源码 —— 纯源码解析博客</a></h1><a class="blog-motto">愿半生编码，如一生老友！</a></div><div class="navbar"><a class="navbutton navmobile" href="#" title="菜单"></a></div><nav class="animated"><ul><ul><li><a href="/">文章</a></li><li><a href="/2018-meet-you">知识星球</a></li><li><a href="https://github.com/YunaiV" rel="external nofollow noopener noreferrer" target="_blank">Github</a></li><li><a href="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31_bak.jpg">微信公众号</a></li><li><a href="/categories/%E5%B7%A5%E4%BD%9C%E5%86%85%E6%8E%A8/">工作内推</a></li><li><a href="/link_url">友链</a></li></ul></ul></nav></div></header><div id="container"><div id="main" class="post" itemscope="" itemprop="blogPost"><article itemprop="articleBody"><header class="article-info clearfix"><h1 itemprop="name"><a href="/Elastic-Job/cloud-job-failover/" title="Elastic-Job-Cloud 源码分析 —— 作业失效转移" itemprop="url">Elastic-Job-Cloud 源码分析 —— 作业失效转移</a></h1><p class="article-author"></p><p class="article-time">总阅读量:<span id="busuanzi_value_page_pv"></span>次</p></header><div class="article-content"><p>摘要: 原创出处 http://www.iocoder.cn/Elastic-Job/cloud-job-failover/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文基于 Elastic-Job V2.1.5 版本分享</strong></p><ul><li><a href="http://www.iocoder.cn/Elastic-Job/cloud-job-failover/">1. 概述</a></li><li><a href="http://www.iocoder.cn/Elastic-Job/cloud-job-failover/">2. 记录作业失效转移</a></li><li><a href="http://www.iocoder.cn/Elastic-Job/cloud-job-failover/">3. 提交失效转移作业</a></li><li><a href="http://www.iocoder.cn/Elastic-Job/cloud-job-failover/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p>本文主要分享 <strong>Elastic-Job-Cloud 作业失效转移</strong>。对应到 Elastic-Job-Lite 源码解析文章为<a href="http://www.iocoder.cn/Elastic-Job/job-failover/?self">《Elastic-Job-Lite 作业作业失效转移》</a>。</p><p>你需要对<a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/?self">《Elastic-Job-Cloud 源码分析 —— 作业调度（一）》</a>有一定的了解。</p><p>当作业任务在 Elastic-Job-Cloud-Executor 异常崩溃时，该任务在下次调度之前不会被重新执行。开启失效转移功能后，该作业任务会立即被 Elastic-Job-Cloud-Scheduler 重新调度，提交 Elastic-Job-Cloud-Executor <strong>立即</strong>执行。</p><p>在 Elastic-Job-Cloud 里，我们了解到作业分成<strong>瞬时</strong>作业和<strong>常驻</strong>作业。实际上面失效转移的定义暂时只适用于<strong>瞬时</strong>作业。对于<strong>常驻</strong>作业，作业任务异常崩溃后，无论你是否开启失效转移功能，Elastic-Job-Cloud-Scheduler 会立刻提交 Elastic-Job-Cloud-Executor <strong>重新调度</strong>执行。</p><p><strong>为什么此处使用的是“重新调度”，而不是“立即执行”呢</strong>？目前版本 Elasitc-Job-Cloud 暂时不支持<strong>常驻</strong>作业的失效转移，当作业任务异常崩溃，本次执行<strong>不会重新执行</strong>，但是为了作业任务后续能够调度执行，所以再次提交 Elastic-Job-Cloud-Scheduler。</p><blockquote><p>你行好事会因为得到赞赏而愉悦<br>同理，开源项目贡献者会因为 Star 而更加有动力<br>为 Elastic-Job 点赞！<a href="https://github.com/dangdangdotcom/elastic-job/stargazers" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p></blockquote><p>OK，下面我们来看看作业失效转移的实现方式和作业任务异常崩溃的多重场景。</p><h1>2. 记录作业失效转移</h1><p>当作业任务异常崩溃时，Elastic-Job-Cloud-Scheduler 通过 Mesos 任务状态变更接口( <code>#statusUpdate()</code> )实现对任务状态的监听处理，实现代码如下：</p><p></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulerEngine</span> <span class="keyword">implements</span> <span class="title">Scheduler</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">statusUpdate</span><span class="params">(<span class="keyword">final</span> SchedulerDriver schedulerDriver, <span class="keyword">final</span> Protos.TaskStatus taskStatus)</span> </span>&#123;</div><div class="line">        String taskId = taskStatus.getTaskId().getValue();</div><div class="line">        TaskContext taskContext = TaskContext.from(taskId);</div><div class="line">        String jobName = taskContext.getMetaInfo().getJobName();</div><div class="line">        log.trace(<span class="string">"call statusUpdate task state is: &#123;&#125;, task id is: &#123;&#125;"</span>, taskStatus.getState(), taskId);</div><div class="line">        jobEventBus.post(<span class="keyword">new</span> JobStatusTraceEvent(jobName, taskContext.getId(), taskContext.getSlaveId(), Source.CLOUD_SCHEDULER, </div><div class="line">                taskContext.getType(), String.valueOf(taskContext.getMetaInfo().getShardingItems()), State.valueOf(taskStatus.getState().name()), taskStatus.getMessage()));</div><div class="line">        <span class="keyword">switch</span> (taskStatus.getState()) &#123;</div><div class="line">            <span class="keyword">case</span> TASK_RUNNING:</div><div class="line">                <span class="comment">// ... 省略无关代码</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> TASK_FINISHED:</div><div class="line">                <span class="comment">// ... 省略无关代码</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> TASK_KILLED:</div><div class="line">                <span class="comment">// ... 省略无关代码</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> TASK_LOST:</div><div class="line">            <span class="keyword">case</span> TASK_DROPPED:</div><div class="line">            <span class="keyword">case</span> TASK_GONE:</div><div class="line">            <span class="keyword">case</span> TASK_GONE_BY_OPERATOR:</div><div class="line">            <span class="keyword">case</span> TASK_FAILED: <span class="comment">// 执行作业任务被错误终止</span></div><div class="line">            <span class="keyword">case</span> TASK_ERROR: <span class="comment">// 任务错误</span></div><div class="line">                log.warn(<span class="string">"task id is: &#123;&#125;, status is: &#123;&#125;, message is: &#123;&#125;, source is: &#123;&#125;"</span>, taskId, taskStatus.getState(), taskStatus.getMessage(), taskStatus.getSource());</div><div class="line">                <span class="comment">// 将任务从运行时队列删除</span></div><div class="line">                facadeService.removeRunning(taskContext);</div><div class="line">                <span class="comment">// 记录失效转移队列</span></div><div class="line">                facadeService.recordFailoverTask(taskContext);</div><div class="line">                <span class="comment">// 通知 TaskScheduler 任务不分配在对应主机上</span></div><div class="line">                unAssignTask(taskId);</div><div class="line">                <span class="comment">// 统计</span></div><div class="line">                statisticManager.taskRunFailed();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> TASK_UNKNOWN:</div><div class="line">            <span class="keyword">case</span> TASK_UNREACHABLE:</div><div class="line">                log.error(<span class="string">"task id is: &#123;&#125;, status is: &#123;&#125;, message is: &#123;&#125;, source is: &#123;&#125;"</span>, taskId, taskStatus.getState(), taskStatus.getMessage(), taskStatus.getSource());</div><div class="line">                statisticManager.taskRunFailed();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>一共有 6 种状态判定为作业任务崩溃，我们来一个一个看看：</p><ul><li><p>TASK_DROPPED / TASK_GONE / TASK_GONE_BY_OPERATOR</p><p>这三个状态，笔者暂时不太了解，这里先引用一些资料，欢迎有了解的同学指教一下。</p><blockquote><p>FROM http://mesos.apache.org/api/latest/java/org/apache/mesos/Protos.TaskState.html<br><strong>TASK_DROPPED</strong>：The task failed to launch because of a transient error.<br><strong>TASK_GONE</strong>：The task is no longer running.<br><strong>TASK_GONE_BY_OPERATOR</strong>：The task was running on an agent that the master cannot contact; the operator has asserted that the agent has been shutdown, but this has not been directly confirmed by the master.</p><p>FROM http://mesos.apache.org/blog/mesos-1-1-0-released/<br>[MESOS-5344] - Experimental support for partition-aware Mesos frameworks. In previous Mesos releases, when an agent is partitioned from the master and then reregisters with the cluster, all tasks running on the agent are terminated and the agent is shutdown. In Mesos 1.1, partitioned agents will no longer be shutdown when they reregister with the master. By default, tasks running on such agents will still be killed (for backward compatibility); however, frameworks can opt-in to the new PARTITION_AWARE capability. If they do this, their tasks will not be killed when a partition is healed. This allows frameworks to define their own policies for how to handle partitioned tasks. Enabling the PARTITION_AWARE capability also introduces a new set of task states: TASK_UNREACHABLE, TASK_DROPPED, TASK_GONE, TASK_GONE_BY_OPERATOR, and TASK_UNKNOWN. <strong>These new states are intended to eventually replace the TASK_LOST state</strong>.</p></blockquote></li><li><p>TASK_FAILED</p><p>执行作业任务被<strong>错误</strong>终止。例如，执行器( Elastic-Job-Cloud-Executor )异常崩溃，或者被杀死。</p></li><li><p>TASK_ERROR</p><p>任务启动尝试失败错误。例如，执行器( Elastic-Job-Cloud-Executor ) 接收到的任务的作业配置不正确。实现代码如下：</p><p></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">    <span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 更新 Mesos 任务状态，运行中。</span></div><div class="line">    executorDriver.sendStatusUpdate(Protos.TaskStatus.newBuilder().setTaskId(taskInfo.getTaskId()).setState(Protos.TaskState.TASK_RUNNING).build());</div><div class="line">    <span class="comment">//</span></div><div class="line">    Map&lt;String, Object&gt; data = SerializationUtils.deserialize(taskInfo.getData().toByteArray());</div><div class="line">    ShardingContexts shardingContexts = (ShardingContexts) data.get(<span class="string">"shardingContext"</span>);</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    JobConfigurationContext jobConfig = <span class="keyword">new</span> JobConfigurationContext((Map&lt;String, String&gt;) data.get(<span class="string">"jobConfigContext"</span>));</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 获得 分布式作业</span></div><div class="line">        ElasticJob elasticJob = getElasticJobInstance(jobConfig);</div><div class="line">        <span class="comment">// 调度器提供内部服务的门面对象</span></div><div class="line">        <span class="keyword">final</span> CloudJobFacade jobFacade = <span class="keyword">new</span> CloudJobFacade(shardingContexts, jobConfig, jobEventBus);</div><div class="line">        <span class="comment">// 执行作业</span></div><div class="line">        <span class="keyword">if</span> (jobConfig.isTransient()) &#123;</div><div class="line">            <span class="comment">// 执行作业</span></div><div class="line">            JobExecutorFactory.getJobExecutor(elasticJob, jobFacade).execute();</div><div class="line">            <span class="comment">// 更新 Mesos 任务状态，已完成。</span></div><div class="line">            executorDriver.sendStatusUpdate(Protos.TaskStatus.newBuilder().setTaskId(taskInfo.getTaskId()).setState(Protos.TaskState.TASK_FINISHED).build());</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 初始化 常驻作业调度器</span></div><div class="line">            <span class="keyword">new</span> DaemonTaskScheduler(elasticJob, jobConfig, jobFacade, executorDriver, taskInfo.getTaskId()).init();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// CHECKSTYLE:OFF</span></div><div class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable ex) &#123;</div><div class="line">        <span class="comment">// CHECKSTYLE:ON</span></div><div class="line">        log.error(<span class="string">"Elastic-Job-Cloud-Executor error"</span>, ex);</div><div class="line">        <span class="comment">// 更新 Mesos 任务状态，错误。</span></div><div class="line">        executorDriver.sendStatusUpdate(Protos.TaskStatus.newBuilder().setTaskId(taskInfo.getTaskId()).setState(Protos.TaskState.TASK_ERROR).setMessage(ExceptionUtil.transform(ex)).build());</div><div class="line">        <span class="comment">// 停止自己</span></div><div class="line">        executorDriver.stop();</div><div class="line">        <span class="keyword">throw</span> ex;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><ul><li><p>调用 <code>#getElasticJobInstance()</code> 方法，因为任务的作业配置不正确抛出<strong>异常</strong>。例如，任务类不存在；Spring 的 配置文件不存在；Spring 容器初始化出错；Spring Bean 对象初始化或获取出错；以及等等。</p></li><li><p><strong>瞬时</strong>作业，调用 <code>AbstractElasticJobExecutor#execute(...)</code> 方法，发生<strong>异常</strong>，并且<strong>异常被抛出</strong>。默认情况下，AbstractElasticJobExecutor 内部使用 DefaultJobExceptionHandler 处理发生的异常，<strong>不会抛出异常</strong>，实现代码如下：</p><p></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultJobExceptionHandler</span> <span class="keyword">implements</span> <span class="title">JobExceptionHandler</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleException</span><span class="params">(<span class="keyword">final</span> String jobName, <span class="keyword">final</span> Throwable cause)</span> </span>&#123;</div><div class="line">        log.error(String.format(<span class="string">"Job '%s' exception occur in job processing"</span>, jobName), cause);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><ul><li></li></ul></li><li><p><strong>常驻</strong>作业，调用 <code>DaemonTaskScheduler#(...)</code> 方法，初始化发生<strong>异常</strong>。</p></li><li><p>因为上述的种种异常，调用 <code>ExecutorDriver#sendStatusUpdate(...)</code>，更新 Mesos 任务状态为 TASK_ERROR。另外，调用 <code>ExecutorDriver#stop()</code> 方法，关闭自己。<strong>这意味着，一个执行器上如果存在一个作业任务发生 TASK_ERROR，其他作业任务即使是正常的，也会更新作业任务状态为 TASK_FAILED</strong>。这块千万要注意。</p></li></ul></li><li><p>TASK_LOST</p><p>执行作业任务的 Elastic-Job-Cloud-Executor 所在的 Mesos Slave 与 Mesos Master 因为<strong>网络问题或 Mesos Slave 崩溃</strong>引起丢失连接，<strong>可能</strong>导致其上的所有作业任务状态变为 TASK_LOST。</p><p><strong>当 Slave 宕机后重启，导致 TASK_LOST 时，Mesos又是怎么来处理的呢？</strong></p><blockquote><p>FROM http://dockone.io/article/2513<br>在 Master 和 Slave 之间，一般都是由 Master 主动向每一个 Slave 发送Ping消息，如果在设定时间内（flag.slave_ping_timeout，默认15s）没有收到Slave 的回复，并且达到一定次数（flag.max_slave_ping_timeouts，默认次数为5），那么 Master 会操作以下几个步骤：</p><ol><li>将该 Slave 从 Master 中删除，此时该 Slave 的资源将不会再分配给Scheduler。</li><li>遍历该 Slave 上运行的所有任务，向对应的 Framework 发送任务的 Task_Lost 状态更新，同时把这些任务从Master中删除。</li><li>遍历该 Slave 上的所有 Executor，并删除。</li><li>触发 Rescind Offer，把这个 Slave 上已经分配给 Scheduler 的 Offer 撤销。</li><li>把这个 Slave 从 Master 的 Replicated log 中删除（Mesos Master 依赖 Replicated log 中的部分持久化集群配置信息进行 failer over / recovery）。</li></ol></blockquote><ul><li>必须 Slave 进行重启，因为对执行器的相关操作只能通过 Mesos Slave，即 <strong>Scheduler &lt;=&gt; Mesos Master &lt;=&gt; Mesos Slave &lt;=&gt; Executor</strong>。如果 Slave 一直不进行重启，执行器会一直运行，除非有另外的机制，<strong>通知</strong>到执行器。</li></ul><p>But..................<br>笔者尝试如上流程，使用 <code>kill -9</code> 模拟 Mesos Slave 异常崩溃，等待 Mesos Master 发现 Mesos Slave 已经关闭，<strong>重启 Mesos Slave</strong>，结果执行器( Elastic-Job-Cloud-Executor )未关闭，调度器( Elastic-Job-Cloud-Scheduler )并未收到任务的 TASK_LOST。？？？什么情况？？？翻查如下文档：</p><ul><li><a href="http://mesos.apache.org/documentation/latest/high-availability-framework-guide/" rel="external nofollow noopener noreferrer" target="_blank">《Mesos 官方文档 —— high-availability-framework-guide》</a>搜索标题 &quot;Dealing with Partitioned or Failed Agents&quot;。</li><li><a href="http://mesos.apache.org/documentation/latest/agent-recovery/" rel="external nofollow noopener noreferrer" target="_blank">《Mesos 官方文档 —— agent-recovery》</a>搜索关标题 &quot;Agent Recovery&quot;。</li></ul><p>因为 Elastic-Job-Cloud-Scheduler 注册到 Mesos Master 时，开启了 <code>checkpoint</code> 和 <code>PARTITION_AWARE</code>。开启 <code>checkpoint</code> 后，Mesos Slave 会将记录<strong>检查点</strong>信息， Mesos Slave 重启后，会读取检查点检查信息，**重新连接上( 不会关闭 )**运行在它上面的执行器( Elastic-Job-Cloud-Scheduler )。开启 <code>PARTITION_AWARE</code> 后，TASK_LOST 会被区分成 TASK_UNREACHABLE, TASK_DROPPED, TASK_GONE, TASK_GONE_BY_OPERATOR, and TASK_UNKNOWN。表现如下：</p><ul><li><code>kill -9</code> 模拟 Mesos Slave 异常崩溃，等待 Mesos Master 发现 Mesos Slave 已经关闭</li><li>调度器( Elastic-Job-Cloud-Scheduler ) 接收直接由 Mesos Master 发送的该 Mesos Slave 上的每个任务 TASK_UNREACHABLE。</li><li>Mesos Slave 重启完成。</li><li>执行器( Elastic-Job-Cloud-Executor ) 重新注册到重启好的 Mesos Slave ，并继续运行任务。</li></ul><p>如果 Elastic-Job-Cloud-Scheduler 注册到 Mesos Master 时，关闭了 <code>PARTITION_AWARE</code> 和 <code>checkpoint</code>，表现同 <strong>TASK_LOST</strong> 描述的过程。</p><p>开启 <code>checkpoint</code> 和 <code>PARTITION_AWARE</code> 实现代码如下：</p><pre><code><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// SchedulerService.java</span></div><div class="line"><span class="function"><span class="keyword">private</span> SchedulerDriver <span class="title">getSchedulerDriver</span><span class="params">(<span class="keyword">final</span> TaskScheduler taskScheduler, <span class="keyword">final</span> JobEventBus jobEventBus, <span class="keyword">final</span> FrameworkIDService frameworkIDService)</span> </span>&#123;</div><div class="line">      Protos.FrameworkInfo.Builder builder = Protos.FrameworkInfo.newBuilder();</div><div class="line">      <span class="comment">// PARTITION_AWARE</span></div><div class="line">      builder.addCapabilitiesBuilder().setType(Protos.FrameworkInfo.Capability.Type.PARTITION_AWARE);</div><div class="line">      Protos.FrameworkInfo frameworkInfo = builder.setUser(mesosConfig.getUser()).setName(frameworkName)</div><div class="line">          .setHostname(mesosConfig.getHostname()).setFailoverTimeout(FRAMEWORK_FAILOVER_TIMEOUT_SECONDS)</div><div class="line">          .setWebuiUrl(WEB_UI_PROTOCOL + env.getFrameworkHostPort())</div><div class="line">          .setCheckpoint(<span class="keyword">true</span>) <span class="comment">// checkpoint</span></div><div class="line">          .build();</div><div class="line">      <span class="comment">// ... 省略无关代码</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</code></pre><p><strong>是不是开启了 <code>checkpoint</code>，Mesos Slave 重启不会关闭执行器？</strong></p><p>答案当然是不是的。当 Mesos Slave 配置 <code>recover = cleanup</code> 或者 重启时间超过 <code>recovery_timeout</code> ( 默认，15 分钟 )时，重启完成后，Mesos Slave 关闭运行在它上面的执行器( Elastic-Job-Cloud-Executor )，调度器( Elastic-Job-Cloud-Scheduler ) 接收到的该 Mesos Slave 上的每个任务 TASK_FAILED。</p><ul><li>参考文档：<a href="http://mesos.apache.org/documentation/latest/agent-recovery/" rel="external nofollow noopener noreferrer" target="_blank">《Mesos 官方文档 —— agent-recovery》</a>搜索标题 &quot;Agent Configuration&quot;。</li></ul></li></ul><p><img src="http://www.iocoder.cn/images/Elastic-Job/2018_01_10/01.png" alt=""></p><hr><p>调用 <code>FacadeService#recordFailoverTask(...)</code> 方法，记录失效转移队列，实现代码如下：</p><p></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recordFailoverTask</span><span class="params">(<span class="keyword">final</span> TaskContext taskContext)</span> </span>&#123;</div><div class="line">   Optional&lt;CloudJobConfiguration&gt; jobConfigOptional = jobConfigService.load(taskContext.getMetaInfo().getJobName());</div><div class="line">   <span class="keyword">if</span> (!jobConfigOptional.isPresent()) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (isDisable(jobConfigOptional.get())) &#123;</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   CloudJobConfiguration jobConfig = jobConfigOptional.get();</div><div class="line">   <span class="keyword">if</span> (jobConfig.getTypeConfig().getCoreConfig().isFailover() <span class="comment">// 开启失效转移</span></div><div class="line">           || CloudJobExecutionType.DAEMON == jobConfig.getJobExecutionType()) &#123; <span class="comment">// 常驻作业</span></div><div class="line">       failoverService.add(taskContext);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><ul><li>对于<strong>瞬时</strong>作业，必须开启 <code>JobCoreConfiguration.failover = true</code>，才能失效转移，这个比较好理解。</li><li>对于<strong>常驻</strong>作业，暂时不支持失效转移。因为常驻作业是在执行器( Elastic-Job-Executor ) 进行调度执行，如果不添加到失效转移作业队列，重新提交到执行器( Elastic-Job-Executor )，后续就不能调度执行该作业了。</li><li>调用 <code>FailoverService#add(...)</code> 方法，将任务放入失效转移队列，实现代码如下：</li></ul><p></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// FailoverService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">final</span> TaskContext taskContext)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (regCenter.getNumChildren(FailoverNode.ROOT) &gt; env.getFrameworkConfiguration().getJobStateQueueSize()) &#123;</div><div class="line">       log.warn(<span class="string">"Cannot add job, caused by read state queue size is larger than &#123;&#125;."</span>, env.getFrameworkConfiguration().getJobStateQueueSize());</div><div class="line">       <span class="keyword">return</span>;</div><div class="line">   &#125;</div><div class="line">   String failoverTaskNodePath = FailoverNode.getFailoverTaskNodePath(taskContext.getMetaInfo().toString());</div><div class="line">   <span class="keyword">if</span> (!regCenter.isExisted(failoverTaskNodePath) <span class="comment">// 判断不在失效转移队列</span></div><div class="line">           &amp;&amp; !runningService.isTaskRunning(taskContext.getMetaInfo())) &#123; <span class="comment">// 判断不在运行中</span></div><div class="line">       regCenter.persist(failoverTaskNodePath, taskContext.getId());</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// FailoverNode.java</span></div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FailoverNode</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ROOT = StateNode.ROOT + <span class="string">"/failover"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FAILOVER_JOB = ROOT + <span class="string">"/%s"</span>; <span class="comment">// %s=$&#123;JOB_NAME&#125;</span></div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FAILOVER_TASK = FAILOVER_JOB + <span class="string">"/%s"</span>; <span class="comment">// %s=$&#123;TASK_META_INFO&#125;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><ul><li><p>FailoverService，失效转移队列服务。</p></li><li><p><strong>失效转移队列</strong>存储在注册中心( Zookeeper )的<strong>持久</strong>数据节点 <code>/${NAMESPACE}/state/failover/${JOB_NAME}/${TASK_META_INFO}</code>，存储值为任务编号。使用 zkClient 查看如下：</p><p></p><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line">    [zk: localhost:2181(CONNECTED) 2] ls /elastic-job-cloud/state/failover/test_job_simple</div><div class="line">[test_job_simple@-@0]</div><div class="line">[zk: localhost:2181(CONNECTED) 3] get /elastic-job-cloud/state/failover/test_job_simple/test_job_simple@-@0</div><div class="line">test_job_simple@-@0@-@READY@-@4da72be3-43d5-4f02-9d7e-45feb30b8fcb-S2@-@8f2a5bb5-2941-4ece-b192-0f936e60faa7</div></pre></td></tr></table></figure><p></p></li><li><p>在运维平台，我们可以看到失效转移队列：</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2018_01_10/02.png" alt=""></p></li></ul><h1>3. 提交失效转移作业</h1><p>在<a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/?self">《Elastic-Job-Cloud 源码分析 —— 作业调度（一）》「4.1 创建 Fenzo 任务请求」</a>里，调用 <code>FacadeService#getEligibleJobContext()</code> 方法，获取有资格运行的作业时。<code>FacadeService#getEligibleJobContext()</code> 不仅调用 <code>ReadyService#getAllEligibleJobContexts(...)</code> 方法，从<strong>待执行队列</strong>中获取所有有资格执行的作业上下文，也调用 <code>FailoverService#getAllEligibleJobContexts()</code> 方法，从<strong>失效转移队列</strong>中获取所有有资格执行的作业上下文。实现代码如下：</p><p></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// FailoverService.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> Collection&lt;JobContext&gt; <span class="title">getAllEligibleJobContexts</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 不存在 失效转移队列</span></div><div class="line">   <span class="keyword">if</span> (!regCenter.isExisted(FailoverNode.ROOT)) &#123;</div><div class="line">       <span class="keyword">return</span> Collections.emptyList();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 获取 失效转移队列 的作业们</span></div><div class="line">   List&lt;String&gt; jobNames = regCenter.getChildrenKeys(FailoverNode.ROOT);</div><div class="line">   Collection&lt;JobContext&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(jobNames.size());</div><div class="line">   Set&lt;HashCode&gt; assignedTasks = <span class="keyword">new</span> HashSet&lt;&gt;(jobNames.size() * <span class="number">10</span>, <span class="number">1</span>);</div><div class="line">   <span class="keyword">for</span> (String each : jobNames) &#123;</div><div class="line">       <span class="comment">// 为空时，移除 失效转移队列 的作业</span></div><div class="line">       List&lt;String&gt; taskIdList = regCenter.getChildrenKeys(FailoverNode.getFailoverJobNodePath(each));</div><div class="line">       <span class="keyword">if</span> (taskIdList.isEmpty()) &#123;</div><div class="line">           regCenter.remove(FailoverNode.getFailoverJobNodePath(each));</div><div class="line">           <span class="keyword">continue</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 排除 作业配置 不存在的作业</span></div><div class="line">       Optional&lt;CloudJobConfiguration&gt; jobConfig = configService.load(each);</div><div class="line">       <span class="keyword">if</span> (!jobConfig.isPresent()) &#123;</div><div class="line">           regCenter.remove(FailoverNode.getFailoverJobNodePath(each));</div><div class="line">           <span class="keyword">continue</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 获得待执行的分片集合</span></div><div class="line">       List&lt;Integer&gt; assignedShardingItems = getAssignedShardingItems(each, taskIdList, assignedTasks);</div><div class="line">       <span class="comment">//</span></div><div class="line">       <span class="keyword">if</span> (!assignedShardingItems.isEmpty() &amp;&amp; jobConfig.isPresent()) &#123;</div><div class="line">           result.add(<span class="keyword">new</span> JobContext(jobConfig.get(), assignedShardingItems, ExecutionType.FAILOVER));    </div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">getAssignedShardingItems</span><span class="params">(<span class="keyword">final</span> String jobName, <span class="keyword">final</span> List&lt;String&gt; taskIdList, <span class="keyword">final</span> Set&lt;HashCode&gt; assignedTasks)</span> </span>&#123;</div><div class="line">   List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(taskIdList.size());</div><div class="line">   <span class="keyword">for</span> (String each : taskIdList) &#123;</div><div class="line">       TaskContext.MetaInfo metaInfo = TaskContext.MetaInfo.from(each);</div><div class="line">       <span class="keyword">if</span> (assignedTasks.add(Hashing.md5().newHasher().putString(jobName, Charsets.UTF_8).putInt(metaInfo.getShardingItems().get(<span class="number">0</span>)).hash()) <span class="comment">// 排重</span></div><div class="line">               &amp;&amp; !runningService.isTaskRunning(metaInfo)) &#123; <span class="comment">// 排除正在运行中</span></div><div class="line">           result.add(metaInfo.getShardingItems().get(<span class="number">0</span>));</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><hr><p>在<a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/?self">《Elastic-Job-Cloud 源码分析 —— 作业调度（一）》「4.4 创建 Mesos 任务信息」</a>里，调用 <code>LaunchingTasks#getIntegrityViolationJobs()</code> 方法，获得作业分片不完整的作业集合。实现代码如下：</p><p></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// LaunchingTasks.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获得作业分片不完整的作业集合</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> vmAssignmentResults 主机分配任务结果集合</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 作业分片不完整的作业集合</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function">Collection&lt;String&gt; <span class="title">getIntegrityViolationJobs</span><span class="params">(<span class="keyword">final</span> Collection&lt;VMAssignmentResult&gt; vmAssignmentResults)</span> </span>&#123;</div><div class="line">   Map&lt;String, Integer&gt; assignedJobShardingTotalCountMap = getAssignedJobShardingTotalCountMap(vmAssignmentResults);</div><div class="line">   Collection&lt;String&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(assignedJobShardingTotalCountMap.size(), <span class="number">1</span>);</div><div class="line">   <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : assignedJobShardingTotalCountMap.entrySet()) &#123;</div><div class="line">       JobContext jobContext = eligibleJobContextsMap.get(entry.getKey());</div><div class="line">       <span class="keyword">if</span> (ExecutionType.FAILOVER != jobContext.getType() <span class="comment">// 不包括 FAILOVER 执行类型的作业</span></div><div class="line">               &amp;&amp; !entry.getValue().equals(jobContext.getJobConfig().getTypeConfig().getCoreConfig().getShardingTotalCount())) &#123;</div><div class="line">           log.warn(<span class="string">"Job &#123;&#125; is not assigned at this time, because resources not enough to run all sharding instances."</span>, entry.getKey());</div><div class="line">           result.add(entry.getKey());</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><ul><li>一个作业可能存在部分分片需要失效转移，不需要考虑完整性。</li></ul><hr><p>在<a href="http://www.iocoder.cn/Elastic-Job/cloud-job-scheduler-and-executor-first/?self">《Elastic-Job-Cloud 源码分析 —— 作业调度（一）》「4.7 从队列中删除已运行的作业」</a>里，调用 <code>FailoverService#remove(...)</code> 方法，从失效转移队列中删除相关任务。实现代码如下：</p><p></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">final</span> Collection&lt;TaskContext.MetaInfo&gt; metaInfoList)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (TaskContext.MetaInfo each : metaInfoList) &#123;</div><div class="line">       regCenter.remove(FailoverNode.getFailoverTaskNodePath(each.toString()));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h1>666. 彩蛋</h1><p><img src="http://www.iocoder.cn/images/Architecture/2017_12_29/01.png" alt="知识星球"></p><p>原本以为会是一篇水更，后面研究 TASK_LOST，发现收获大大的，干货妥妥的。</p><p><img src="http://www.iocoder.cn/images/Elastic-Job/2018_01_10/03.png" alt=""></p><p>道友，赶紧上车，分享一波朋友圈！</p></div><footer class="article-footer clearfix"><div class="article-categories"><span></span> <a class="article-category-link" href="/categories/Elastic-Job-Cloud/">Elastic-Job-Cloud</a></div><div class="article-share" id="share"><div data-url="http://www.iocoder.cn/Elastic-Job/cloud-job-failover/" data-title="Elastic-Job-Cloud 源码分析 —— 作业失效转移 | 芋道源码 —— 纯源码解析博客" data-tsina="null" class="share clearfix"></div></div></footer></article><nav class="article-nav clearfix"><div class="prev"><a href="/Myth/good-collection/" title="Myth 源码解析 —— 精品合集"><strong>PREVIOUS:</strong><br><span>Myth 源码解析 —— 精品合集</span></a></div><div class="next"><a href="/Weekdays/2018-01-06/" title="芋道源码的周八（2018.01.06）"><strong>NEXT:</strong><br><span>芋道源码的周八（2018.01.06）</span></a></div></nav></div><div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div><div id="toc" class="toc-aside"><strong class="toc-title">文章目录</strong><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#undefined"><span class="toc-number">1.</span> <span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#undefined"><span class="toc-number">2.</span> <span class="toc-text">2. 记录作业失效转移</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#undefined"><span class="toc-number">3.</span> <span class="toc-text">3. 提交失效转移作业</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#undefined"><span class="toc-number">4.</span> <span class="toc-text">666. 彩蛋</span></a></li></ol></div><div id="asidepart"><aside class="clearfix"><div id="authorInfo"><div><img width="100%" src="/images/common/wechat_mp_2017_07_31_bak.jpg"></div><div class="social-list"></div></div><div class="categorieslist"><p class="asidetitle">微信公众号福利：芋道源码</p><ul><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">0. 阅读源码葵花宝典</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">1. RocketMQ / MyCAT / Sharding-JDBC 详细中文注释源码</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">2. 您对于源码的疑问每条留言都将得到认真回复</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">3. 新的源码解析文章实时收到通知，每周六十点更新</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">4. 认真的源码交流微信群</a></li></ul></div><div class="categorieslist"><p class="asidetitle">分类</p><ul><li><a href="/categories/Elastic-Job-Cloud/" title="Elastic-Job-Cloud">Elastic-Job-Cloud<sup>6</sup></a></li><li><a href="/categories/Elastic-Job-Lite/" title="Elastic-Job-Lite">Elastic-Job-Lite<sup>16</sup></a></li><li><a href="/categories/Eureka/" title="Eureka">Eureka<sup>23</sup></a></li><li><a href="/categories/Hystrix/" title="Hystrix">Hystrix<sup>9</sup></a></li><li><a href="/categories/MyCAT/" title="MyCAT">MyCAT<sup>9</sup></a></li><li><a href="/categories/RocketMQ/" title="RocketMQ">RocketMQ<sup>14</sup></a></li><li><a href="/categories/RxJava/" title="RxJava">RxJava<sup>5</sup></a></li><li><a href="/categories/Sharding-JDBC/" title="Sharding-JDBC">Sharding-JDBC<sup>18</sup></a></li><li><a href="/categories/SkyWalking/" title="SkyWalking">SkyWalking<sup>35</sup></a></li><li><a href="/categories/Spring-Cloud-Gateway/" title="Spring-Cloud-Gateway">Spring-Cloud-Gateway<sup>24</sup></a></li><li><a href="/categories/TCC-Transaction/" title="TCC-Transaction">TCC-Transaction<sup>7</sup></a></li><li><a href="/categories/TiKV/" title="TiKV">TiKV<sup>2</sup></a></li><li><a href="/categories/工作内推/" title="工作内推">工作内推<sup>6</sup></a></li><li><a href="/categories/芋道源码的周八/" title="芋道源码的周八">芋道源码的周八<sup>10</sup></a></li></ul></div><div id="authorInfo2"><div><img width="100%" src="/images/common/zsxq/02.png"></div></div></aside></div></div><footer><div id="footer"><img src="http://www.iocoder.cn/images/common/wechat_mp_simple.png" style="display:none"><p class="copyright">© 2018 <a href="http://www.iocoder.cn" target="_blank" title="芋道源码">芋道源码</a> && <span style="display:inline" id="busuanzi_container_site_uv">总访客数 <span id="busuanzi_value_site_uv" font="微软雅黑"></span> 次</span> && <span style="display:inline" id="busuanzi_container_site_pv">总访问量 <span id="busuanzi_value_site_pv" font="微软雅黑"></span> 次</span> && Hosted by <a href="https://pages.coding.me" style="font-weight:700" rel="external nofollow noopener noreferrer" target="_blank">Coding Pages</a></p></div><div class="copyright">沪ICP备17037075号-1</div></footer><script src="/js/jquery-2.1.0.min.js"></script><script type="text/javascript">$(document).ready(function(){function e(){"number"==typeof window.innerWidth?n=window.innerWidth:document.documentElement&&document.documentElement.clientWidth&&(n=document.documentElement.clientWidth)}$(".navbar").click(function(){$("header nav").toggleClass("shownav")});var n=0,s=$("#main"),a=$("#asidepart"),o=$(".closeaside"),d=$(".openaside");$(window).resize(function(){e(),n>=1024?$("header nav").removeClass("shownav"):(s.removeClass("moveMain"),a.css("display","block").removeClass("fadeOut"),d.css("display","none"),$("#toc.toc-aside").css("display","none"))}),o.click(function(){a.addClass("fadeOut").css("display","none"),d.css("display","block").addClass("fadeIn"),s.addClass("moveMain")}),d.click(function(){d.css("display","none").removeClass("beforeFadeIn"),a.css("display","block").removeClass("fadeOut").addClass("fadeIn"),s.removeClass("moveMain")}),$(window).scroll(function(){d.css("top",Math.max(80,260-$(this).scrollTop()))})})</script><script type="text/javascript">$(document).ready(function(){var a=$(".article-content>iframe"),t=$(".article-content>embed"),n=$("#toc");$("article h2"),ah=$("article h2"),ta=$("#toc.toc-aside"),o=$(".openaside"),c=$(".closeaside"),a.length>0&&a.wrap('<div class="video-container" />'),t.length>0&&t.wrap('<div class="video-container" />'),0==ah.length?n.css("display","none"):(c.click(function(){ta.css("display","block").addClass("fadeIn")}),o.click(function(){ta.css("display","none")}),$(window).scroll(function(){ta.css("top",Math.max(140,320-$(this).scrollTop()))}))})</script><script type="text/javascript">$(document).ready(function(){var t=$(".share"),a=t.attr("data-url"),e=encodeURIComponent(a),r=['<a href="#" class="overlay" id="qrcode"></a>','<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url='+e+'"/></div>','<a href="#textlogo" class="article-back-to-top" title="Top"></a>','<a href="https://www.facebook.com/sharer.php?u='+e+'" class="article-share-facebook" target="_blank" title="Facebook"></a>','<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>','<a href="https://twitter.com/intent/tweet?url='+e+'" class="article-share-twitter" target="_blank" title="Twitter"></a>','<a href="http://service.weibo.com/share/share.php?title='+t.attr("data-title")+"&url="+e+"&ralateUid="+t.attr("data-tsina")+'&searchPic=true&style=number" class="article-share-weibo" target="_blank" title="Weibo"></a>','<span title="Share to"></span>'].join("");t.append(r),$(".article-share-qrcode").click(function(){var t=$("#qrcode-pic").attr("data-src");$("#qrcode-pic").attr("src",t),$("#qrcode-pic").load(function(){$(".qrcode strong").text(" ")})})})</script><link rel="stylesheet" href="/alert/css/alert.css"><script src="/alert/js/alert.js"></script><script src="/js/jquery.cookie.js"></script><script src="/js/util.js"></script><script type="text/javascript">!function(e,a,t,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=a.createElement(t),s=a.getElementsByTagName(t)[0],o.async=1,o.src="//www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s)}(window,document,"script",0,"ga"),ga("create","UA-107572620-1","auto"),ga("send","pageview")</script></body>