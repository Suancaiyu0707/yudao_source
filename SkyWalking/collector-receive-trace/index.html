<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="google-site-verification" content="GkJ68PCnxM9Ih7Zm9v8p91FOCV7ymNCO2KdGbflLh3E"><meta name="360-site-verification" content="dd6547587641bfede036f7c79561e8a0"><meta name="shenma-site-verification" content="fd96cf3751972c9b05f8471d2ccadddc_1496951214"><meta name="msvalidate.01" content="1D38B05050A977F6FDEDA481198343F1"><meta name="sogou_site_verification" content="MpPsku240L"><title>SkyWalking 源码分析 —— Collector 接收 Trace 数据 | 芋道源码 —— 纯源码解析博客</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=3,minimum-scale=1"><meta name="author" content="芋道源码"><meta name="description" content="摘要: 原创出处 http://www.iocoder.cn/SkyWalking/collector-receive-trace/ 「芋道源码」欢迎转载，保留摘要，谢谢！
本文主要基于 SkyWalking 3.2.6 正式版

1. 概述
2. TraceSegmentServiceHandle"><meta name="keywords" content="Java,架构,后端,服务端,RocketMQ,MyCAT,分布式消息队列,分布式存储,技术博客,Sharding-JDBC,分库分表"><link rel="alternate" href="atom.xml" title="芋道源码 —— 纯源码解析博客" type="application/atom+xml"><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/style.css"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?9e70e3362807c1bd185a79655b307027";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script>!function(){var t="http:"==document.location.protocol?"http://js.passport.qihucdn.com/11.0.1.js?f05b61dd54bbc38386611a5238672938":"https://jspassport.ssl.qhimg.com/11.0.1.js?f05b61dd54bbc38386611a5238672938";document.write('<script src="'+t+'" id="sozz"><\/script>')}()</script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></head></html><body><header><div><div id="textlogo"><h1 class="site-name"><a href="/" title="芋道源码 —— 纯源码解析博客">芋道源码 —— 纯源码解析博客</a></h1><a class="blog-motto">愿半生编码，如一生老友！</a></div><div class="navbar"><a class="navbutton navmobile" href="#" title="菜单"></a></div><nav class="animated"><ul><ul><li><a href="/">文章</a></li><li><a href="/2018-meet-you">知识星球</a></li><li><a href="https://github.com/YunaiV" rel="external nofollow noopener noreferrer" target="_blank">Github</a></li><li><a href="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31_bak.jpg">微信公众号</a></li><li><a href="/categories/%E5%B7%A5%E4%BD%9C%E5%86%85%E6%8E%A8/">工作内推</a></li><li><a href="/link_url">友链</a></li></ul></ul></nav></div></header><div id="container"><div id="main" class="post" itemscope="" itemprop="blogPost"><article itemprop="articleBody"><header class="article-info clearfix"><h1 itemprop="name"><a href="/SkyWalking/collector-receive-trace/" title="SkyWalking 源码分析 —— Collector 接收 Trace 数据" itemprop="url">SkyWalking 源码分析 —— Collector 接收 Trace 数据</a></h1><p class="article-author"></p><p class="article-time">总阅读量:<span id="busuanzi_value_page_pv"></span>次</p></header><div class="article-content"><p>摘要: 原创出处 http://www.iocoder.cn/SkyWalking/collector-receive-trace/ 「芋道源码」欢迎转载，保留摘要，谢谢！</p><p><strong>本文主要基于 SkyWalking 3.2.6 正式版</strong></p><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-receive-trace/">1. 概述</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-receive-trace/">2. TraceSegmentServiceHandler</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-receive-trace/">2.1 TraceSegmentService</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-receive-trace/">2.2 SegmentParse</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-receive-trace/">2.3 Standardization 标准化</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-receive-trace/">3. Buffer 文件</a><ul><li><a href="http://www.iocoder.cn/SkyWalking/collector-receive-trace/">3.1 初始化</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-receive-trace/">3.2 写入</a></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-receive-trace/">3.3 读取</a></li></ul></li><li><a href="http://www.iocoder.cn/SkyWalking/collector-receive-trace/">666. 彩蛋</a></li></ul><hr><p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p><blockquote><p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p><ol><li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li><li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li><li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li><li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li><li><strong>认真的</strong>源码交流微信群。</li></ol></blockquote><hr><h1>1. 概述</h1><p>分布式链路追踪系统，链路的追踪大体流程如下：</p><ol><li>Agent 收集 Trace 数据。</li><li>Agent 发送 Trace 数据给 Collector 。</li><li><strong>Collector 接收 Trace 数据</strong>。</li><li>Collector 存储 Trace 数据到存储器，例如，数据库。</li></ol><p>本文主要分享【第三部分】 <strong>SkyWalking Collector 接收 Trace 数据</strong>。</p><blockquote><p>友情提示：Collector 接收到 TraceSegment 的数据，对应的类是 Protobuf 生成的。考虑到更加易读易懂，本文使用 TraceSegment 相关的<strong>原始类</strong>。</p></blockquote><p>大体流程如下：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_10/01.png" alt=""></p><ul><li>Collector 接收到 TraceSegment 数据后，进行<strong>构建</strong>。</li><li>【蓝色流程】构建<strong>成功</strong>，进行流式处理，最终存储到存储器( 例如，ES / H2 )。</li><li>【粉色流程】构建<strong>失败</strong>，写入 Buffer 文件进行暂存。</li><li>【绿色流程】后台线程，定时读取 Buffer 文件，重新提交构建。</li></ul><p><strong>什么是构建</strong>？</p><p>从 TraceSegment <strong>数据</strong>中，会构建出更多的<strong>数据维度</strong>，如下图所示：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_10_10/02.png" alt=""></p><p>构建的过程，本文只分享<strong>调用</strong>的过程，具体怎么<strong>生成</strong>新的数据，数据的<strong>流式处理与存储</strong>，在 <a href="http://www.iocoder.cn/SkyWalking/collector-store-trace/?self">《SkyWalking 源码解析 —— Collector 存储 Trace 数据》</a> 详细解析。</p><p><strong>为什么构建会失败</strong>？</p><p>在 TraceSegment 里的数据结构，例如操作名( <code>operationName</code> )和操作编号( <code>operationId</code> ) ，在 <a href="http://www.iocoder.cn/SkyWalking/agent-collect-trace/?self">《SkyWalking 源码分析 —— Agent 收集 Trace 数据》</a> 中我们可以看到，考虑到网络传输，优先使用 <code>operationId</code> ，若不存在( 例如操作还未注册，或者注册了 Agent 未同步到本地 )，则使用 <code>operationName</code> 。</p><p>但是，Collector 构建过程时，要求的是 <code>operationId</code> ，如果传递的是 <code>operationName</code> 时，需要将 <code>operationName</code> 转换成 <code>operationId</code> 。若此时 <code>operationName</code> 未注册时，则无法获取到 <code>operationId</code> ，导致<strong>构建失败</strong>。</p><p>那么有胖友可能有疑惑，在构建过程中，注册 <code>operationName</code> 呢？答案是不行， 在 <a href="http://www.iocoder.cn/SkyWalking/agent-dictionary/?self">《SkyWalking 源码分析 —— Agent DictionaryManager 字典管理》「2.2 操作的同步 API」</a> 中，我们可以看到，<code>operationName</code> 的注册，是<strong>异步</strong>的过程。因而，即使构建的过程中，调用注册，也无法获得 <code>operationId</code> 。</p><p>涉及的逻辑点比较多，如果胖友理解不能，下面我们可以直接看代码。</p><h1>2. TraceSegmentServiceHandler</h1><p>我们先来看看 API 的定义，<a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-network/src/main/proto/TraceSegmentService.proto#L9" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceSegmentService.proto</code></a> ，如下图所示：</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_10_10/03.png" alt=""></p><p><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-grpc/collector-agent-grpc-provider/src/main/java/org/skywalking/apm/collector/agent/grpc/handler/TraceSegmentServiceHandler.java#L47" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceSegmentServiceHandler#collect(Application, StreamObserver&lt;ApplicationMapping&gt;)</code></a>, 代码如下：</p><ul><li>第 51 行：调用 <code>ITraceSegmentService#send(UpstreamSegment)</code> 方法，处理<strong>一条</strong> TraceSegment 。</li></ul><h2>2.1 TraceSegmentService</h2><p><code>org.skywalking.apm.collector.agent.stream.service.trace.ITraceSegmentService</code> ，继承 <a href="https://github.com/YunaiV/skywalking/blob/40823179d7228207b06b603b9a1c09dfc4f78593/apm-collector/apm-collector-core/src/main/java/org/skywalking/apm/collector/core/module/Service.java" rel="external nofollow noopener noreferrer" target="_blank">Service</a> 接口，TraceSegment 服务接口。</p><ul><li>定义了 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-define/src/main/java/org/skywalking/apm/collector/agent/stream/service/trace/ITraceSegmentService.java#L31" rel="external nofollow noopener noreferrer" target="_blank"><code>#send(UpstreamSegment)</code></a> <strong>接口</strong>方法，处理<strong>一条</strong> TraceSegment 。</li></ul><p><code>org.skywalking.apm.collector.agent.stream.worker.trace.ApplicationIDService</code> ，实现 IApplicationIDService 接口，TraceSegment 服务实现类。</p><ul><li><p>实现了 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/worker/trace/TraceSegmentService.java#L39" rel="external nofollow noopener noreferrer" target="_blank"><code>#send(UpstreamSegment)</code></a> 方法，代码如下：</p><ul><li>第 40 至 41 行：创建 SegmentParse 对象，后调用 <code>SegmentParse#parse(UpstreamSegment, Source)</code> 方法，解析并处理 TraceSegment 。</li></ul></li></ul><h2>2.2 SegmentParse</h2><p><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/SegmentParse.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.parser.SegmentParse</code></a> ，Segment 解析器。属性如下：</p><ul><li><code>spanListeners</code> 属性，Span 监听器集合。<strong>通过不同的监听器，对 TraceSegment 进行构建，生成不同的数据</strong>。在 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/SegmentParse.java#L72" rel="external nofollow noopener noreferrer" target="_blank"><code>#SegmentParse(ModuleManager)</code> 构造方法</a> ，会看到它的初始化。</li><li><code>segmentId</code> 属性，TraceSegment 编号，即 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegment.java#L47" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceSegment.traceSegmentId</code></a> 。</li><li><code>timeBucket</code> 属性，第一个 Span 的开始时间。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/SegmentParse.java#L86" rel="external nofollow noopener noreferrer" target="_blank"><code>#parse(UpstreamSegment, Source)</code></a> 方法，解析并处理 TraceSegment 。在该方法里，我们会看到，本文开头提到的【<strong>构造</strong>】。整个构造的过程，实际分成<strong>两步</strong>：1）预构建；2）执行构建。代码如下：</p><ul><li>第 88 至 89 行：从 <code>segment</code> 参数中，解析出 ：<ul><li><code>traceIds</code> ，关联的链路追踪<strong>全局编号</strong>。</li><li><code>segmentObject</code> ，TraceSegmentObject 对象。</li></ul></li><li>第 91 行：创建 SegmentDecorator 对象。该对象的用途，在 <a href="#">「2.3 Standardization 标准化」</a> 统一解析。</li><li>-------- 构建失败 --------</li><li>第 94 行：调用 <code>#preBuild(List&lt;UniqueId&gt;, SegmentDecorator)</code> 方法，<strong>预构建</strong>。</li><li>第 97 至 99 行：调用 <code>#writeToBufferFile()</code> 方法，将 TraceSegment 写入 Buffer 文件<strong>暂存</strong>。为什么会判断 <code>source == Source.Agent</code> 呢？<code>#parse(UpstreamSegment, Source)</code> 方法的调用，共有<strong>两个</strong> <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/SegmentParse.java#L256" rel="external nofollow noopener noreferrer" target="_blank">Source</a> ：<ul><li>目前我们看到 TraceSegmentService 的调用使用的是 <code>Source.Agent</code> 。</li><li>而后台线程，定时调用该方法重新构建使用的是 <code>Source.Buffer</code> ，如果不加盖判断，会预构建失败<strong>重复</strong>写入。</li></ul></li><li>第 100 行：返回 <code>false</code> ，表示构建失败。</li><li>-------- 构建成功 --------</li><li>第 106 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/SegmentParse.java#L199" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyListenerToBuild()</code></a> 方法，通知 Span 监听器们，<strong>执行构建</strong>各自的数据。在 <a href="http://www.iocoder.cn/SkyWalking/collector-store-trace/?self">《SkyWalking 源码解析 —— Collector 存储 Trace 数据》</a> 详细解析。</li><li>第 109 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/SegmentParse.java#L177" rel="external nofollow noopener noreferrer" target="_blank"><code>buildSegment(id, dataBinary)</code></a> 方法，<strong>执行构建</strong> TraceSegment 。</li><li>第 110 行：返回 <code>true</code> ，表示构建成功。</li><li>第 112 至 115 行：发生 InvalidProtocolBufferException 异常，返回 <code>false</code> ，表示构建失败。</li></ul><h3>2.2.1 预构建</h3><p><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/SegmentParse.java#L118" rel="external nofollow noopener noreferrer" target="_blank"><code>#preBuild(List&lt;UniqueId&gt;, SegmentDecorator)</code></a> 方法，前置构建，用于<strong>通过不同的监听器，对 TraceSegment 进行构建，生成不同的数据</strong>。在该过程中，会发生我们在文章头所说的，&quot;<strong>为什么构建会失败</strong>&quot;。代码如下：</p><ul><li>第 120 至 128 行：拼接生成 <code>segmentId</code> 。</li><li>第 131 至 133 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/SegmentParse.java#L132" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyGlobalsListener(...)</code></a> 方法，使用 GlobalTraceSpanListener 处理链路追踪全局编号数组( <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegment.java#L70" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceSegment.relatedGlobalTraces</code></a> )。</li><li>第 139 至 147 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/SegmentParse.java#L239" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyRefsListener(...)</code></a> 方法，使用 RefsListener 处理父 Segment 指向数组( <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegment.java#L54" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceSegment.refs</code></a> )。<ul><li>第 140 至 144 行：调用 <code>ReferenceIdExchanger#exchange(ReferenceDecorator, applicationId)</code> 方法，将 TraceSegmentRef 未生成编号的属性，进行兑换处理。<strong>若兑换失败，返回构造失败</strong>。在 <a href="#">「2.3 Standardization 标准化」</a> 详细解析。</li></ul></li><li>第 149 至 172 行：处理 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegment.java#L60" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceSegment.spans</code></a> 属性。<ul><li>第 150 至 154 行：将 Span 未生成编号的属性，进行兑换处理。<strong>若兑换失败，返回构造失败</strong>。在 <a href="#">「2.3 Standardization 标准化」</a> 详细解析。</li><li>第 157 至 160 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/SegmentParse.java#L230" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyFirstListener(...)</code></a> ，使用 FirstSpanListener 处理<strong>第一个</strong> Span 。</li><li>第 164 行：若是 ExitSpan ，调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/SegmentParse.java#L230" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyExitListener(...)</code></a> ，使用 ExitSpanListener 处理。</li><li>第 166 行：若是 EntrySpan ，调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/SegmentParse.java#L212" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyEntryListener(...)</code></a> ，使用 EntrySpanListener 处理。</li><li>第 168 行：若是 LocalSpan ，调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/SegmentParse.java#L221" rel="external nofollow noopener noreferrer" target="_blank"><code>#notifyLocalListener(...)</code></a> ，使用 LocalSpanListener 处理。</li></ul></li><li>第 174 行：返回 <code>true</code> ，<strong>预构建成功</strong>。</li></ul><h3>2.2.2 写入 Buffer 文件</h3><p><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/SegmentParse.java#L191" rel="external nofollow noopener noreferrer" target="_blank"><code>#writeToBufferFile(id, upstreamSegment)</code></a> 方法，将 TraceSegment 写入 Buffer 文件。代码如下：</p><ul><li>第 193 行：创建 193 至 194 行：创建 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/SegmentStandardization.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.parser.standardization.SegmentStandardization</code></a> 对象，并设置 TraceSegment 属性。</li><li>第 195 行：获得 <code>TraceStreamGraph.SEGMENT_STANDARDIZATION_GRAPH_ID</code> 对象的 Graph 对象。在 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/graph/TraceStreamGraph.java#L85" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceStreamGraph#createSegmentStandardizationGraph()</code></a> 方法中，我们可以看到，该 Graph 对象只有一个 SegmentStandardizationWorker 。</li><li>第 196 行：调用 <code>Graph#start(INPUT)</code> 方法，执行<strong>该 Graph 实现的</strong>流式处理，将 TraceSegment 写到 Buffer 文件。</li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/SegmentStandardizationWorker.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.parser.standardization.SegmentStandardizationWorker</code></a> ，继承 AbstractLocalAsyncWorker 抽象类，TraceSegment 标准化 Worker ，负责将接收到的 TraceSegment <strong>异步</strong>写到 Buffer 文件。</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/SegmentStandardizationWorker.java#L59" rel="external nofollow noopener noreferrer" target="_blank">Factory</a> 内部类，实现 AbstractLocalAsyncWorkerProvider 抽象类，在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（一）》「3.2.2 AbstractLocalAsyncWorker」</a> 有详细解析。</li><li><strong>AbstractLocalAsyncWorker</strong> ，在 <a href="http://www.iocoder.cn/SkyWalking/collector-streaming-first/?self">《SkyWalking 源码分析 —— Collector Streaming Computing 流式处理（一）》「3.2.2 AbstractLocalAsyncWorker」</a> 有详细解析。</li><li><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/SegmentStandardizationWorker.java#L47" rel="external nofollow noopener noreferrer" target="_blank"><code>#id()</code></a> 实现方法，返回 108 。</li><li><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/SegmentStandardizationWorker.java#L51" rel="external nofollow noopener noreferrer" target="_blank"><code>#onWork(SegmentStandardization)</code></a> 实现方法，将接收到的 TraceSegment <strong>异步</strong>写到 Buffer 文件。。代码如下：<ul><li>第 52 行：调用 <code>SegmentBufferManager#writeBuffer(UpstreamSegment)</code> 方法，将接收到的 TraceSegment 写到 Buffer 文件。在 <a href="#">「3. Buffer 文件」</a> 详细解析。</li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/SegmentStandardizationWorker.java#L65" rel="external nofollow noopener noreferrer" target="_blank"><code>Factory#workerInstance(ModuleManager)</code></a> 方法，创建 SegmentStandardizationWorker 后，会调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/SegmentStandardizationWorker.java#L75" rel="external nofollow noopener noreferrer" target="_blank"><code>#startTimer(SegmentStandardizationWorker)</code></a> 方法，创建定时任务。该定时任务调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/SegmentStandardizationWorker.java#L55" rel="external nofollow noopener noreferrer" target="_blank"><code>#flushAndSwitch()</code></a> 方法，定时将 Buffer 文件 flush 。目前 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/SegmentBufferManager.java#L139" rel="external nofollow noopener noreferrer" target="_blank"><code>SegmentBufferManager#flush()</code></a> 是个空方法。为什么不这里不需要 flush 呢？因为 <code>SegmentBufferManager#writeBuffer(UpstreamSegment)</code> <strong>已经进行 flush</strong> 。</li></ul><h2>2.3 Standardization 标准化</h2><p>本小节涉及到的类如下图：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_10/04.png" alt=""></p><p>我们先来说说，什么叫 standardization <strong>标准化</strong>？其实就是我们在文章开头说的&quot;<strong>例如将</strong> <code>operationName</code> <strong>转换成</strong> <code>operationId</code>&quot;。</p><h3>2.3.1 StandardBuilder</h3><p><code>org.skywalking.apm.collector.agent.stream.parser.standardization.StandardBuilder</code> ，标准化 Builder 接口。</p><ul><li>定义了 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/StandardBuilder.java#L31" rel="external nofollow noopener noreferrer" target="_blank"><code>#toBuilder()</code></a> <strong>接口</strong>方法，转换成 Builder 。感觉这个接口方法<strong>怪怪的</strong>？不要捉急，等会看一个实现类就明白了。</li></ul><p>StandardBuilder 有三个实现类：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/SegmentDecorator.java" rel="external nofollow noopener noreferrer" target="_blank">SegmentDecorator</a> ，TraceSegment 装饰者。</li><li><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/ReferenceDecorator.java" rel="external nofollow noopener noreferrer" target="_blank">ReferenceDecorator</a> ，ReferenceDecorator 装饰者。</li><li><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/SpanDecorator.java" rel="external nofollow noopener noreferrer" target="_blank">SpanDecorator</a> ，Span 装饰者。</li></ul><p>怎么都是<strong>装饰者</strong>呢，而且恰好和一个数据结构对应？以 SpanDecorator 为例子，代码如下：</p><ul><li><code>spanObject</code> 属性，SpanObject ，Span 的 Protobuf 数据对象。</li><li><code>standardBuilder</code> 属性，SpanObject 的 Builder 对象。</li><li><code>isOrigin</code> 属性，是否是原始对象。<ul><li><code>isOrigin = true</code> ，使用 <code>spanObject</code>属性 。</li><li><code>isOrigin = false</code> ，使用 <code>standardBuilder</code> 属性。</li></ul></li><li>在 Protobuf 里，数据修改值时，需要使用对应的 Builder 对象。通过使用<strong>装饰者</strong>设计模式，对使用者屏蔽细节，调用也更加方便。下面在来看看如下方法，是不是就更加明白了：<ul><li><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/SpanDecorator.java#L165" rel="external nofollow noopener noreferrer" target="_blank"><code>#setOperationNameId(value)</code></a></li><li><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/SpanDecorator.java#L172" rel="external nofollow noopener noreferrer" target="_blank"><code>#getOperationName()</code></a></li></ul></li><li><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/SpanDecorator.java#L195" rel="external nofollow noopener noreferrer" target="_blank"><code>#toBuilder()</code></a> <strong>实现</strong>方法，创建 SpanObject 对应的 Builder ，并修改 <code>isOrigin = false</code> 。另外，会调用 <code>standardBuilder</code> 属性的 <code>#toBuilder()</code> 方法，目前在项目里，此处的 <code>standardBuilder</code> 属性为 SegmentDecorator 。</li></ul><p>SegmentDecorator 、ReferenceDecorator 和 SpanDecorator 目的一致。</p><h3>2.3.2 IdExchanger</h3><p><code>org.skywalking.apm.collector.agent.stream.parser.standardization.IdExchanger</code> ，编号兑换器<strong>接口</strong>。</p><ul><li>定义了 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/IdExchanger.java#L35" rel="external nofollow noopener noreferrer" target="_blank"><code>#exchange(standardBuilder, applicationId)</code></a> <strong>接口</strong>方法，兑换 standardBuilder 里的属性，并返回是否兑换成功。</li></ul><p>IdExchanger 有三个实现类：</p><ul><li><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/ReferenceIdExchanger.java" rel="external nofollow noopener noreferrer" target="_blank">ReferenceIdExchanger</a> ：TraceSegmentRef 编号兑换器。</li><li><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/SpanIdExchanger.java" rel="external nofollow noopener noreferrer" target="_blank">SpanIdExchanger</a> ：Span 编号兑换器。</li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/ReferenceIdExchanger.java#L58" rel="external nofollow noopener noreferrer" target="_blank"><code>ReferenceIdExchanger#exchange(standardBuilder, applicationId)</code></a> 方法，代码如下：</p><ul><li>第 60 至 73 行：<a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegmentRef.java#L81" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceSegmentRef.entryOperationId</code></a> 为空，将 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegmentRef.java#L76" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceSegmentRef.entryOperationName</code></a> 进行兑换。<ul><li>第 61 行：调用 <code>ServiceNameService#getOrCreate(applicationId, serviceName)</code> 方法，根据应用编号和操作名获得或创建操作编号。</li><li>第 62 至 67 行：获得<strong>不到</strong>，因为创建的过程是异步的。返回 <code>false</code> 。</li><li>第 68 至 72 行：获得<strong>到</strong>，调用 <code>ReferenceDecorator#toBuilder()</code> 方法，创建 Builder ，然后设置操作编号。</li></ul></li><li>第 75 至 89 行：<a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegmentRef.java#L71" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceSegmentRef.parentApplicationInstanceId</code></a> 为空，将 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegmentRef.java#L90" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceSegmentRef.parentOperationName</code></a> 进行兑换。</li><li>第 92 至 104 行：<a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegmentRef.java#L76" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceSegmentRef.entryOperationName</code></a> 为空，将 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegmentRef.java#L62" rel="external nofollow noopener noreferrer" target="_blank"><code>TraceSegmentRef.peerHost</code></a> 进行兑换。在【第 93 行】，我们可以看到，调用 <code>ApplicationIDService#getOrCreate(applicationCode)</code> 方法，将<strong>服务地址</strong>作为 <code>applicationCode</code> 使用。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/parser/standardization/SpanIdExchanger.java#L54" rel="external nofollow noopener noreferrer" target="_blank"><code>SpanIdExchanger#exchange(standardBuilder, applicationId)</code></a> 方法，类似，已经添加代码注释，胖友自己阅读理解。</p><h1>3. Buffer 文件</h1><p>本小节涉及到的类如下图：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_10/05.png" alt=""></p><p>我们先来看看 Buffer 包括哪些文件：</p><p></p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">yunai$ pwd</div><div class="line">/Users/yunai/Java/buffer</div><div class="line">yunai$ ls</div><div class="line">data_20171205004132.sw		offset_20171205004132.sw</div></pre></td></tr></table></figure><p></p><ul><li>Data 文件，记录 TraceSegment 具体数据，通过 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/OffsetManager.java" rel="external nofollow noopener noreferrer" target="_blank">SegmentBufferManager</a> 管理。</li><li>Offset 文件，记录偏移，包括写入文件的名字和偏移，读取文件的名字和偏移，通过 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/SegmentBufferManager.java" rel="external nofollow noopener noreferrer" target="_blank">OffsetManager</a> 管理。</li><li>从命名上，我们可以看出，这<strong>两种</strong>文件，文件名字格式为 <code>类型_${时间}.sw</code> ，并且<strong>相同类型，同时可以存在多个</strong>。</li></ul><p><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/BufferFileConfig.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.buffer.BufferFileConfig</code></a> ，Buffer 文件配置 。</p><p><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/Offset.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.collector.agent.stream.buffer.Offset</code></a> ，偏移 。</p><p>下面，我们来一起看看 Buffer 文件的初始化、写入、读取的三种操作过程。</p><h2>3.1 初始化</h2><p><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/SegmentBufferManager.java#L54" rel="external nofollow noopener noreferrer" target="_blank"><code>SegmentBufferManager#initialize(ModuleManager)</code></a> 方法，初始化 Offset 文件、Data 文件、定期读取 Buffer 文件的任务。代码如下：</p><ul><li>第 58 行：调用 <code>OffsetManager#initialize()</code> 方法，初始化 Offset 文件。</li><li>第 60 至 63 行：创建 Buffer 文件夹成功( 意味着该文件夹不存在 )，调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/SegmentBufferManager.java#L113" rel="external nofollow noopener noreferrer" target="_blank"><code>#newDataFile()</code></a> ，创建 Data 文件。代码如下：<ul><li>第 116 至 119 行：创建<strong>新</strong>的 Data 文件。文件名格式为，<code>data_${yyyyMMddHHmmss}.sw</code> 。</li><li>第 121 行：调用 <code>OffsetManager#setWriteOffset(writeFileName, writeFileOffset)</code> 方法，设置 Offset 的<strong>写入</strong>的文件名和偏移。</li><li>第 124 至 126 行：关闭<strong>老</strong>的 Data 文件的 <code>outputStream</code> 。</li><li>第 129 至 130 行：创建<strong>新</strong>的 Data 文件的 <code>outputStream</code> 。</li></ul></li><li>第 66 至 77 行：获得 Offset 的<strong>写入</strong>的 Data 文件，并创建对应的 <code>outputStream</code> 。</li><li>第 80 行：调用 <code>SegmentBufferReader#initialize(ModuleManager)</code> 方法，初始化定期读取 Buffer 文件的任务。</li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/OffsetManager.java#L72" rel="external nofollow noopener noreferrer" target="_blank"><code>OffsetManager#initialize()</code></a> 方法，初始化 Offset 文件。代码如下：</p><ul><li>第 74 行：创建 Offer 对象。该对象包含了<strong>当前</strong>分别写入和读取的文件名与偏移量。</li><li>第 60 至 63 行：创建 Buffer 文件夹成功( 意味着该文件夹不存在 )，调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/OffsetManager.java#L112" rel="external nofollow noopener noreferrer" target="_blank"><code>#createOffsetFile()</code></a> ，创建 Data 文件。代码如下：<ul><li>第 114 至 116 行：创建<strong>新</strong>的 Offset 文件。文件名格式为，<code>offset_${yyyyMMddHHmmss}.sw</code> 。</li><li>第 118 至 121 行：设置 Offset 对象的写入和读取的文件名与偏移量都为<strong>空</strong>。在上面的方法，此处的【空】，在 Data 文件创建时，会重新设置 Offset 。</li><li>第 123 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/OffsetManager.java#L129" rel="external nofollow noopener noreferrer" target="_blank"><code>#flush()</code></a> 方法，写入 Offset 对象到 Offset 文件。代码如下：<ul><li>第 131 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/Offset.java#L49" rel="external nofollow noopener noreferrer" target="_blank"><code>Offset#serialize()</code></a> 方法，序列化读写偏移，格式为 <code>${读取文件名},${读取文件偏移量},${写入文件名},${写入文件偏移量}</code> 。</li><li>第 133 至 142 行：写入 Offset 对象到 Offset 文件。写入方式为<strong>整行</strong>，如下图所示：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_10/06.png" alt=""></li></ul></li></ul></li><li>第 82 至 94 行：获得所有 Offset 文件，删除老的 Offset 文件，保留最后一个。若不存在 Offset 文件，则调用 <code>#createOffsetFile()</code> 方法，创建<strong>新</strong>的 Offset 文件。</li><li>第 98 至 99 行：从 Offset 文件的<strong>最后一行</strong>读取，反序列化到 Offset 对象。</li><li>第 103 行：创建定义任务，延迟 10 秒，间隔 3 秒，调用 <code>#flush()</code> 方法，<strong>定时</strong>写入 Offset 对象到 Offset 文件。<strong>注意，所以 Offset 改变时，不是立即写入 Offset 文件，而是周期性刷盘</strong>。</li></ul><hr><p><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/SegmentBufferReader.java#L52" rel="external nofollow noopener noreferrer" target="_blank"><code>SegmentBufferReader#initialize(ModuleManager)</code></a> 方法，初始化定期读取 Buffer 文件的任务。代码如下：</p><ul><li>第 56 行：创建定时任务，延迟 3 秒，间隔 3 秒，调用 <code>#preRead()</code> 方法，读取 Buffer 文件，将 TraceSegment 提交给 SegmentParse 重新解析与构建处理。</li></ul><h2>3.2 写入</h2><p><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/SegmentBufferManager.java#L91" rel="external nofollow noopener noreferrer" target="_blank"><code>SegmentBufferManager#writeBuffer(UpstreamSegment)</code></a> 方法，将 TraceSegment 写入 Buffer 文件，包括两个步骤：1）将 TraceSegment 写入 Data 文件；2）更新 Offset 文件的偏移。代码如下：</p><ul><li>第 94 至 95 行：调用 <code>AbstractMessageLite#writeDelimitedTo(OutputStream)</code> 方法，将 TraceSegment 写入 Data 文件。该方法包括 <strong>flush</strong> 操作，代码如下：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_10/07.png" alt=""></li><li>第 97 至 98 行：超过 Buffer <strong>单文件容量上限</strong>，调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/SegmentBufferManager.java#L113" rel="external nofollow noopener noreferrer" target="_blank"><code>#newDataFile()</code></a> ，创建 Data 文件。</li><li>第 99 至 102 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/OffsetManager.java#L186" rel="external nofollow noopener noreferrer" target="_blank"><code>OffsetManager#setWriteOffset(position)</code></a> 方法，设置 Offset 对象的写入偏移。</li></ul><h2>3.3 读取</h2><p><a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/SegmentBufferReader.java#L59" rel="external nofollow noopener noreferrer" target="_blank"><code>SegmentBufferReader#preRead()</code></a> 方法，读取 Buffer 文件，将 TraceSegment 提交给 SegmentParse 重新解析与构建处理。<strong>另外该方法，会删除已经读取完成的 Data 文件</strong>。代码如下：</p><ul><li>-------- 读取文件存在</li><li>该情况发生于，Data 文件未被读取完成</li><li>第 65 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/SegmentBufferReader.java#L88" rel="external nofollow noopener noreferrer" target="_blank"><code>#deleteTheDataFilesBeforeReadFile(readFileName)</code></a> 方法，删除比指定文件早创建的 Data 文件，<strong>基于文件名带有创建时间</strong>。</li><li>第 67 至 68 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/SegmentBufferReader.java#L130" rel="external nofollow noopener noreferrer" target="_blank"><code>#read()</code></a> 方法，读取 Buffer 文件，将 TraceSegment 提交给 SegmentParse 重新解析与构建处理。另外，返回 <code>true</code> ，文件被全部读取完成、处理并删除。返回 <code>false</code> ，文件未被全部读取完成。<ul><li>第 133 至 134 行：创建 FileInputStream 对象，并跳转到读取位置。</li><li>第 137 至 141 行：获取<strong>读取结束</strong>的位置。</li><li>第 143 至 159 行：<strong>循环读取处理</strong>，直到到达读取文件上限位置<ul><li>第 144 至 146 行：从 Data 文件，读取一条 TraceSegment 。</li><li>第 149 至 152 行：将 TraceSegment 提交给 SegmentParse 重新解析与构建处理。若解析处理失败，返回 <code>false</code> ，结束循环，等待下次读取处理。</li><li>第 155 至 158 行：设置 Offset 对象的读取偏移。</li></ul></li><li>第 161 至 165 行：<strong>全部读取处理完成，关闭 InputStream ，同时删除读取的 Data 文件</strong>。</li><li>第 166 至 169 行：发生 IOException 异常，返回 <code>false</code> 。</li><li>第 170 行：返回 <code>true</code> ，文件被全部读取完成、处理并删除。</li></ul></li><li>第 75 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/c15cf5e1356c7b44a23f2146b8209ab78c2009ac/apm-collector/apm-collector-agent-stream/collector-agent-stream-provider/src/main/java/org/skywalking/apm/collector/agent/stream/buffer/SegmentBufferReader.java#L110" rel="external nofollow noopener noreferrer" target="_blank"><code>#readEarliestCreateDataFile()</code></a> 方法，循环顺序读取 Data 文件，直到有一个没读完。<ul><li>第 112 至 118 行：若第一个 Data 文件和 Offset 读取的文件相同，返回。说明，在上一次 <code>#read()</code> 方法里，没有读完。</li><li>第 121 至 127 行：循环顺序调用 <code>#read(readFile, readFileOffset)</code> 方法，读取 Data 文件，直到有一个没读完。</li></ul></li><li>-------- 读取文件不存在 --------</li><li>该情况发生于，Data 文件被全部读取完成，并且删除。</li><li>第 73 行：调用 <code>#deleteTheDataFilesBeforeReadFile(readFileName)</code> 方法，删除比指定文件早创建的 Data 文件。</li><li>第 75 行：调用 <code>#readEarliestCreateDataFile()</code> 方法，循环顺序读取 Data 文件，直到有一个没读完。</li><li>-------- 没有可读取的文件 --------</li><li>该情况发生于，Data 文件、Buffer 文件<strong>首次</strong>初始化创建，未设置可读文件名。</li><li>第 79 行：调用 <code>#readEarliestCreateDataFile()</code> 方法，循环顺序读取 Data 文件，直到有一个没读完。</li></ul><h1>666. 彩蛋</h1><p>呼呼，即将开始 Trace 流式处理的文章，很嗨皮。</p><p><img src="http://www.iocoder.cn/images/SkyWalking/2020_10_10/08.png" alt=""></p><p>胖友，分享个朋友圈可好？</p></div><footer class="article-footer clearfix"><div class="article-categories"><span></span> <a class="article-category-link" href="/categories/SkyWalking/">SkyWalking</a></div><div class="article-share" id="share"><div data-url="http://www.iocoder.cn/SkyWalking/collector-receive-trace/" data-title="SkyWalking 源码分析 —— Collector 接收 Trace 数据 | 芋道源码 —— 纯源码解析博客" data-tsina="null" class="share clearfix"></div></div></footer></article><nav class="article-nav clearfix"><div class="prev"><a href="/SkyWalking/collector-store-trace/" title="SkyWalking 源码分析 —— Collector 存储 Trace 数据"><strong>PREVIOUS:</strong><br><span>SkyWalking 源码分析 —— Collector 存储 Trace 数据</span></a></div><div class="next"><a href="/SkyWalking/agent-send-trace/" title="SkyWalking 源码分析 —— Agent 发送 Trace 数据"><strong>NEXT:</strong><br><span>SkyWalking 源码分析 —— Agent 发送 Trace 数据</span></a></div></nav></div><div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div><div id="toc" class="toc-aside"><strong class="toc-title">文章目录</strong><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#undefined"><span class="toc-number">1.</span> <span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#undefined"><span class="toc-number">2.</span> <span class="toc-text">2. TraceSegmentServiceHandler</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 TraceSegmentService</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 SegmentParse</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1 预构建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2 写入 Buffer 文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 Standardization 标准化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1 StandardBuilder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2 IdExchanger</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#undefined"><span class="toc-number">3.</span> <span class="toc-text">3. Buffer 文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 写入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 读取</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#undefined"><span class="toc-number">4.</span> <span class="toc-text">666. 彩蛋</span></a></li></ol></div><div id="asidepart"><aside class="clearfix"><div id="authorInfo"><div><img width="100%" src="/images/common/wechat_mp_2017_07_31_bak.jpg"></div><div class="social-list"></div></div><div class="categorieslist"><p class="asidetitle">微信公众号福利：芋道源码</p><ul><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">0. 阅读源码葵花宝典</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">1. RocketMQ / MyCAT / Sharding-JDBC 详细中文注释源码</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">2. 您对于源码的疑问每条留言都将得到认真回复</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">3. 新的源码解析文章实时收到通知，每周六十点更新</a></li><li><a href="/images/common/wechat_mp_2017_07_31_bak.jpg">4. 认真的源码交流微信群</a></li></ul></div><div class="categorieslist"><p class="asidetitle">分类</p><ul><li><a href="/categories/Docker/" title="Docker">Docker<sup>2</sup></a></li><li><a href="/categories/Dubbo/" title="Dubbo">Dubbo<sup>1</sup></a></li><li><a href="/categories/Elastic-Job-Cloud/" title="Elastic-Job-Cloud">Elastic-Job-Cloud<sup>6</sup></a></li><li><a href="/categories/Elastic-Job-Lite/" title="Elastic-Job-Lite">Elastic-Job-Lite<sup>16</sup></a></li><li><a href="/categories/Eureka/" title="Eureka">Eureka<sup>23</sup></a></li><li><a href="/categories/Happylifeplat-TCC/" title="Happylifeplat-TCC">Happylifeplat-TCC<sup>1</sup></a></li><li><a href="/categories/Hystrix/" title="Hystrix">Hystrix<sup>9</sup></a></li><li><a href="/categories/JUC/" title="JUC">JUC<sup>1</sup></a></li><li><a href="/categories/MyCAT/" title="MyCAT">MyCAT<sup>9</sup></a></li><li><a href="/categories/Myth/" title="Myth">Myth<sup>1</sup></a></li><li><a href="/categories/Nginx/" title="Nginx">Nginx<sup>1</sup></a></li><li><a href="/categories/RocketMQ/" title="RocketMQ">RocketMQ<sup>14</sup></a></li><li><a href="/categories/RxJava/" title="RxJava">RxJava<sup>5</sup></a></li><li><a href="/categories/Sharding-JDBC/" title="Sharding-JDBC">Sharding-JDBC<sup>18</sup></a></li><li><a href="/categories/SkyWalking/" title="SkyWalking">SkyWalking<sup>35</sup></a></li><li><a href="/categories/Spring/" title="Spring">Spring<sup>1</sup></a></li><li><a href="/categories/Spring-Cloud-Gateway/" title="Spring-Cloud-Gateway">Spring-Cloud-Gateway<sup>24</sup></a></li><li><a href="/categories/Spring-MVC/" title="Spring-MVC">Spring-MVC<sup>1</sup></a></li><li><a href="/categories/Spring-Security/" title="Spring-Security">Spring-Security<sup>1</sup></a></li><li><a href="/categories/TCC-Transaction/" title="TCC-Transaction">TCC-Transaction<sup>7</sup></a></li><li><a href="/categories/TiKV/" title="TiKV">TiKV<sup>2</sup></a></li><li><a href="/categories/工作内推/" title="工作内推">工作内推<sup>5</sup></a></li><li><a href="/categories/技术杂文/" title="技术杂文">技术杂文<sup>5</sup></a></li><li><a href="/categories/数据库实体设计/" title="数据库实体设计">数据库实体设计<sup>1</sup></a></li><li><a href="/categories/芋道源码的周八/" title="芋道源码的周八">芋道源码的周八<sup>5</sup></a></li></ul></div></aside></div></div><footer><div id="footer"><img src="http://www.iocoder.cn/images/common/wechat_mp_simple.png" style="display:none"><p class="copyright">© 2018 <a href="http://www.iocoder.cn" target="_blank" title="芋道源码">芋道源码</a> && <span style="display:inline" id="busuanzi_container_site_uv">总访客数 <span id="busuanzi_value_site_uv" font="微软雅黑"></span> 次</span> && <span style="display:inline" id="busuanzi_container_site_pv">总访问量 <span id="busuanzi_value_site_pv" font="微软雅黑"></span> 次</span></p></div><div class="copyright">沪ICP备17037075号-1</div></footer><script src="/js/jquery-2.1.0.min.js"></script><script type="text/javascript">$(document).ready(function(){function e(){"number"==typeof window.innerWidth?n=window.innerWidth:document.documentElement&&document.documentElement.clientWidth&&(n=document.documentElement.clientWidth)}$(".navbar").click(function(){$("header nav").toggleClass("shownav")});var n=0,s=$("#main"),a=$("#asidepart"),o=$(".closeaside"),d=$(".openaside");$(window).resize(function(){e(),n>=1024?$("header nav").removeClass("shownav"):(s.removeClass("moveMain"),a.css("display","block").removeClass("fadeOut"),d.css("display","none"),$("#toc.toc-aside").css("display","none"))}),o.click(function(){a.addClass("fadeOut").css("display","none"),d.css("display","block").addClass("fadeIn"),s.addClass("moveMain")}),d.click(function(){d.css("display","none").removeClass("beforeFadeIn"),a.css("display","block").removeClass("fadeOut").addClass("fadeIn"),s.removeClass("moveMain")}),$(window).scroll(function(){d.css("top",Math.max(80,260-$(this).scrollTop()))})})</script><script type="text/javascript">$(document).ready(function(){var a=$(".article-content>iframe"),t=$(".article-content>embed"),n=$("#toc");$("article h2");ah=$("article h2"),ta=$("#toc.toc-aside"),o=$(".openaside"),c=$(".closeaside"),a.length>0&&a.wrap('<div class="video-container" />'),t.length>0&&t.wrap('<div class="video-container" />'),0==ah.length?n.css("display","none"):(c.click(function(){ta.css("display","block").addClass("fadeIn")}),o.click(function(){ta.css("display","none")}),$(window).scroll(function(){ta.css("top",Math.max(140,320-$(this).scrollTop()))}))})</script><script type="text/javascript">$(document).ready(function(){var t=$(".share"),a=t.attr("data-url"),e=encodeURIComponent(a),r=['<a href="#" class="overlay" id="qrcode"></a>','<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url='+e+'"/></div>','<a href="#textlogo" class="article-back-to-top" title="Top"></a>','<a href="https://www.facebook.com/sharer.php?u='+e+'" class="article-share-facebook" target="_blank" title="Facebook"></a>','<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>','<a href="https://twitter.com/intent/tweet?url='+e+'" class="article-share-twitter" target="_blank" title="Twitter"></a>','<a href="http://service.weibo.com/share/share.php?title='+t.attr("data-title")+"&url="+e+"&ralateUid="+t.attr("data-tsina")+'&searchPic=true&style=number" class="article-share-weibo" target="_blank" title="Weibo"></a>','<span title="Share to"></span>'].join("");t.append(r),$(".article-share-qrcode").click(function(){var t=$("#qrcode-pic").attr("data-src");$("#qrcode-pic").attr("src",t),$("#qrcode-pic").load(function(){$(".qrcode strong").text(" ")})})})</script><link rel="stylesheet" href="/alert/css/alert.css"><script src="/alert/js/alert.js"></script><script src="/js/jquery.cookie.js"></script><script src="/js/util.js"></script><script type="text/javascript">!function(e,a,t,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=a.createElement(t),s=a.getElementsByTagName(t)[0],o.async=1,o.src="//www.google-analytics.com/analytics.js",s.parentNode.insertBefore(o,s)}(window,document,"script",0,"ga"),ga("create","UA-107572620-1","auto"),ga("send","pageview")</script></body>