
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">

    <meta name="google-site-verification" content="GkJ68PCnxM9Ih7Zm9v8p91FOCV7ymNCO2KdGbflLh3E">
    <meta name="360-site-verification" content="dd6547587641bfede036f7c79561e8a0">
    <meta name="shenma-site-verification" content="fd96cf3751972c9b05f8471d2ccadddc_1496951214">
    <meta name="msvalidate.01" content="1D38B05050A977F6FDEDA481198343F1">
    <meta name="sogou_site_verification" content="MpPsku240L">

  
    <title>SkyWalking 源码分析 —— Agent 收集 Trace 数据 | 芋道源码 —— 纯源码解析BLOG</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="芋道源码">
    
    <meta name="description" content="摘要: 原创出处 http://www.iocoder.cn/SkyWalking/agent-collect-trace/ 「芋道源码」欢迎转载，保留摘要，谢谢！

1. 概述
2. Trace
2.1 ID
2.2 AbstractSpan
2.3 TraceSegmentRef
2.4 Tra">
    

    
    <meta name="keywords" content="Java,架构,后端,服务端,RocketMQ,MyCAT,分布式消息队列,分布式存储,技术博客,Sharding-JDBC,分库分表">
    

    
    
    <link rel="alternate" href="atom.xml" title="芋道源码 —— 纯源码解析BLOG" type="application/atom+xml">
    
    
    <link rel="icon" href="/images/favicon.ico">
    
    
    <link rel="stylesheet" href="/css/style.css">
    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            var _bdId ='9e70e3362807c1bd185a79655b307027';
             hm.src = "//hm.baidu.com/hm.js?" + _bdId;
             var s = document.getElementsByTagName("script")[0]; 
             s.parentNode.insertBefore(hm, s);
        })();
    </script>
    

    <!-- 百度站长-被动推送 -->
    <script>
        (function(){
            var bp = document.createElement('script');
            var curProtocol = window.location.protocol.split(':')[0];
            if (curProtocol === 'https') {
                bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
            }
            else {
                bp.src = 'http://push.zhanzhang.baidu.com/push.js';
            }
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(bp, s);
        })();
    </script>

    <!-- 360搜索-自动收录 -->
    <script>
        (function(){
            var src = (document.location.protocol == "http:") ? "http://js.passport.qihucdn.com/11.0.1.js?f05b61dd54bbc38386611a5238672938":"https://jspassport.ssl.qhimg.com/11.0.1.js?f05b61dd54bbc38386611a5238672938";
            document.write('<script src="' + src + '" id="sozz"><\/script>');
        })();
    </script>

    <!-- 不蒜子统计 -->
    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</head>
</html>
  <body>
    <header>
      <div>
    
    <div id="textlogo">
        <h1 class="site-name"><a href="/" title="芋道源码 —— 纯源码解析BLOG">芋道源码 —— 纯源码解析BLOG</a></h1>
        <a class="blog-motto">
            
            愿半生编码，如一生老友！
            
        </a>
    </div>
    <div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
        </a></div>
    <nav class="animated">
        <ul>
            <ul>
                
                <li><a href="/">文章</a></li>
                
                <li><a href="/2018-meet-you">知识星球</a></li>
                
                <li><a href="https://github.com/YunaiV" rel="external nofollow noopener noreferrer" target="_blank">Github</a></li>
                
                <li><a href="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31_bak.jpg">微信公众号</a></li>
                
                <li><a href="/categories/%E5%B7%A5%E4%BD%9C%E5%86%85%E6%8E%A8/">工作内推</a></li>
                
                <li><a href="/link_url">友链</a></li>
                
                <!--<li>-->
                    <!---->
                        <!--<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">-->
                            <!--<label>Search</label>-->
                            <!--<input type="text" id="search" name="q" autocomplete="off" maxlength="20"-->
                                   <!--placeholder="搜索"/>-->
                            <!--<input type="hidden" name="q" value="site:www.iocoder.cn">-->
                        <!--</form>-->
                        <!---->
                <!--</li>-->
            </ul>
    </ul></nav>
</div>

    </header>
    <div id="container">

        <div id="main" class="post" itemscope="" itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/SkyWalking/agent-collect-trace/" title="SkyWalking 源码分析 —— Agent 收集 Trace 数据" itemprop="url">SkyWalking 源码分析 —— Agent 收集 Trace 数据</a>
  </h1>
  <p class="article-author">
      <!--By-->
    <!---->
      <!--<a href="http://www.iocoder.cn" title="芋道源码">芋道源码</a>-->
    <!---->
  </p>
  <p class="article-time">
    <!--<time datetime="2020-09-30T16:00:00.000Z" itemprop="datePublished">2020-10-01</time>-->
    <!--更新日期:<time datetime="2018-01-02T09:13:00.000Z" itemprop="dateModified">2018-01-02</time>-->
    <!---->
      总阅读量:<span id="busuanzi_value_page_pv"></span>次
  </p>
</header>
	<div class="article-content">
		
		
		<p>摘要: 原创出处 <a href="http://www.iocoder.cn/SkyWalking/agent-collect-trace/">http://www.iocoder.cn/SkyWalking/agent-collect-trace/</a> 「芋道源码」欢迎转载，保留摘要，谢谢！</p>
<ul>
<li><a href="http://www.iocoder.cn/SkyWalking/agent-collect-trace/">1. 概述</a></li>
<li><a href="http://www.iocoder.cn/SkyWalking/agent-collect-trace/">2. Trace</a><ul>
<li><a href="http://www.iocoder.cn/SkyWalking/agent-collect-trace/">2.1 ID</a></li>
<li><a href="http://www.iocoder.cn/SkyWalking/agent-collect-trace/">2.2 AbstractSpan</a></li>
<li><a href="http://www.iocoder.cn/SkyWalking/agent-collect-trace/">2.3 TraceSegmentRef</a></li>
<li><a href="http://www.iocoder.cn/SkyWalking/agent-collect-trace/">2.4 TraceSegment</a></li>
</ul>
</li>
<li><a href="http://www.iocoder.cn/SkyWalking/agent-collect-trace/">3. Context</a><ul>
<li><a href="http://www.iocoder.cn/SkyWalking/agent-collect-trace/">3.1 ContextManager</a></li>
<li><a href="http://www.iocoder.cn/SkyWalking/agent-collect-trace/">3.2 AbstractTracerContext</a></li>
<li><a href="http://www.iocoder.cn/SkyWalking/agent-collect-trace/">3.3 SamplingService</a></li>
</ul>
</li>
<li><a href="http://www.iocoder.cn/SkyWalking/agent-collect-trace/">666. 彩蛋</a></li>
</ul>
<hr>
<p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注<strong>微信公众号：【芋道源码】</strong>有福利：  </p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表  </li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong>  </li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。  </li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。  </li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>分布式链路追踪系统，链路的追踪大体流程如下：</p>
<ol>
<li><strong>Agent 收集 Trace 数据</strong>。</li>
<li>Agent 发送 Trace 数据给 Collector 。</li>
<li>Collector 接收 Trace 数据。</li>
<li>Collector 存储 Trace 数据到存储器，例如，数据库。</li>
</ol>
<p>本文主要分享【第一部分】 <strong>SkyWalking Agent 收集 Trace 数据</strong>。文章的内容顺序如下：</p>
<ul>
<li>Trace 的数据结构</li>
<li>Context 收集 Trace 的方法</li>
</ul>
<p>不包括插件对 Context 收集的方法的<strong>调用</strong>，后续单独文章专门分享，胖友也可以阅读完本文后，自己去看 <a href="https://github.com/YunaiV/skywalking/tree/0830d985227c42f0e0f3787ebc99a2b197486b69/apm-sniffer/apm-sdk-plugin" rel="external nofollow noopener noreferrer" target="_blank"><code>apm-sdk-plugin</code></a> 的实现代码。</p>
<p>本文涉及到的代码如下图：</p>
<p><img src="http://www.iocoder.cn/images/SkyWalking/2020_10_01/01.png" alt=""></p>
<ul>
<li><strong>红框</strong>部分：Trace 的数据结构，在 <a href="#">「2. Trace」</a> 分享。</li>
<li><strong>黄框</strong>部分：Context 收集 Trace 的方法，在 <a href="#">「3. Context」</a> 分享。</li>
</ul>
<h1 id="2-Trace"><a href="#2-Trace" class="headerlink" title="2. Trace"></a>2. Trace</h1><blockquote>
<p>友情提示：胖友，请先行阅读 <a href="https://github.com/opentracing-contrib/opentracing-specification-zh/blob/master/specification.md" rel="external nofollow noopener noreferrer" target="_blank">《OpenTracing语义标准》</a> 。  </p>
<p>本小节，笔者认为胖友已经对 OpenTracing 有一定的理解。</p>
</blockquote>
<p><a href="https://github.com/YunaiV/skywalking/blob/2a75efbeddac2b9565816af0ab0873ec3d998424/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegment.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.trace.TraceSegment</code></a> ，是<strong>一次</strong>分布式链路追踪( Distributed Trace ) 的<strong>一段</strong>。</p>
<ul>
<li><strong>一条</strong> TraceSegment ，用于记录所在<strong>线程</strong>( Thread )的链路。</li>
<li><strong>一次</strong>分布式链路追踪，可以包含<strong>多条</strong> TraceSegment ，因为存在<strong>跨进程</strong>( 例如，RPC 、MQ 等等)，或者垮<strong>线程</strong>( 例如，并发执行、异步回调等等 )。</li>
</ul>
<p>TraceSegment 属性，如下：</p>
<ul>
<li><code>traceSegmentId</code> 属性，TraceSegment 的编号，全局唯一。在 <a href="#">「2.1 ID」</a> 详细解析。</li>
<li><code>refs</code> 属性，TraceSegmentRef <strong>数组</strong>，指向的<strong>父</strong> TraceSegment 数组。<ul>
<li><strong>为什么会有多个爸爸</strong>？下面统一讲。</li>
<li>TraceSegmentRef ，在 <a href="#">「2.3 TraceSegmentRef」</a> 详细解析。</li>
</ul>
</li>
<li><code>relatedGlobalTraces</code> 属性，关联的 DistributedTraceId <strong>数组</strong>。<ul>
<li><strong>为什么会有多个爸爸</strong>？下面统一讲。</li>
<li>DistributedTraceId ，在 <a href="#">「2.1.2 DistributedTraceId」</a> 详细解析。</li>
</ul>
</li>
<li><code>spans</code> 属性，包含的 Span <strong>数组</strong>。在 <a href="#">「2.2 AbstractSpan」</a> 详细解析。这是 TraceSegment 的<strong>主体</strong>，总的来说，TraceSegment 是 Span 数组的封装。</li>
<li><code>ignore</code> 属性，是否忽略该条 TraceSegment 。在一些情况下，我们会忽略 TraceSegment ，即不收集链路追踪，在下面 <a href="#">「3. Context」</a> 部分内容，我们将会看到这些情况。</li>
<li><code>isSizeLimited</code> 属性，Span 是否超过上限( <a href="https://github.com/YunaiV/skywalking/blob/2961e9f539286ef91af1ff1ef7681d0a06f156b0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/conf/Config.java#L56" rel="external nofollow noopener noreferrer" target="_blank"><code>Config.Agent.SPAN_LIMIT_PER_SEGMENT</code></a> )。超过上限，不在记录 Span 。</li>
</ul>
<p><strong>为什么会有多个爸爸</strong>？</p>
<ul>
<li>我们先来看看<strong>一个爸爸</strong>的情况，常见于 RPC 调用。例如，【服务 A】调用【服务 B】时，【服务 B】新建一个 TraceSegment 对象：<ul>
<li>将自己的 <code>refs</code> 指向【服务 A】的 TraceSegment 。</li>
<li>将自己的 <code>relatedGlobalTraces</code> 设置为 【服务 A】的 DistributedTraceId 对象。</li>
</ul>
</li>
<li>我们再来看看<strong>多个爸爸</strong>的情况，常见于 MQ / Batch 调用。例如，MQ 批量消费消息时，消息来自【多个服务】。每次批量消费时，【消费者】新建一个 TraceSegment 对象：<ul>
<li>将自己的 <code>refs</code> 指向【多个服务】的<strong>多个</strong> TraceSegment 。</li>
<li>将自己的 <code>relatedGlobalTraces</code> 设置为【多个服务】的<strong>多个</strong> DistributedTraceId 。</li>
</ul>
</li>
</ul>
<blockquote>
<p>友情提示：多个爸爸的故事，可能比较难懂，等胖友读完全文，在回过头想想。或者拿起来代码调试调试。</p>
</blockquote>
<p>下面，我们来具体看看 TraceSegment 的每个元素，最后，我们会回过头，在 <a href="#">「2.4 TraceSegment」</a> 详细解析它。</p>
<h2 id="2-1-ID"><a href="#2-1-ID" class="headerlink" title="2.1 ID"></a>2.1 ID</h2><p><a href="https://github.com/YunaiV/skywalking/blob/cc27e35d69d922ba8fa38fbe4e8cc4704960f602/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ids/ID.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.ids.ID</code></a> ，编号。从类的定义上，这是一个<strong>通用</strong>的编号，由三段整数组成。</p>
<p>目前使用 GlobalIdGenerator 生成，作为<strong>全局唯一编号</strong>。属性如下：</p>
<ul>
<li><code>part1</code> 属性，应用实例编号。</li>
<li><code>part2</code> 属性，线程编号。</li>
<li><code>part3</code> 属性，时间戳串，生成方式为 <code>${时间戳} * 10000 + 线程自增序列([0, 9999])</code> 。例如：15127007074950012 。具体生成方法的代码，在 GlobalIdGenerator 中详细解析。</li>
<li><code>encoding</code> 属性，编码后的字符串。格式为 <code>&quot;${part1}.${part2}.${part3}&quot;</code> 。例如，<code>&quot;12.35.15127007074950000&quot;</code> 。<ul>
<li>使用 <a href="https://github.com/YunaiV/skywalking/blob/cc27e35d69d922ba8fa38fbe4e8cc4704960f602/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ids/ID.java#L83" rel="external nofollow noopener noreferrer" target="_blank"><code>#encode()</code></a> 方法，编码编号。</li>
</ul>
</li>
<li><code>isValid</code> 属性，编号是否合法。<ul>
<li>使用 <a href="https://github.com/YunaiV/skywalking/blob/cc27e35d69d922ba8fa38fbe4e8cc4704960f602/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ids/ID.java#L56" rel="external nofollow noopener noreferrer" target="_blank"><code>ID(encodingString)</code></a> 构造方法，解析字符串，生成 ID 。</li>
</ul>
</li>
</ul>
<h3 id="2-1-1-GlobalIdGenerator"><a href="#2-1-1-GlobalIdGenerator" class="headerlink" title="2.1.1 GlobalIdGenerator"></a>2.1.1 GlobalIdGenerator</h3><p><a href="https://github.com/YunaiV/skywalking/blob/9db53fd95e1c4c10f0f7a939e4484d7e2102ad3f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ids/GlobalIdGenerator.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.ids.GlobalIdGenerator</code></a> ，全局编号生成器。</p>
<p><a href="https://github.com/YunaiV/skywalking/blob/9db53fd95e1c4c10f0f7a939e4484d7e2102ad3f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ids/GlobalIdGenerator.java#L62" rel="external nofollow noopener noreferrer" target="_blank"><code>#generate()</code></a> 方法，生成 ID 对象。代码如下：</p>
<ul>
<li>第 67 行：获得线程对应的 IDContext 对象。</li>
<li>第 69 至 73 行：生成 ID 对象。<ul>
<li>第 70 行：<code>ID.part1</code> 属性，应用编号实例。</li>
<li>第 71 行：<code>ID.part2</code> 属性，线程编号。</li>
<li>第 72 行：<code>ID.part3</code> 属性，调用 <a href="https://github.com/YunaiV/skywalking/blob/9db53fd95e1c4c10f0f7a939e4484d7e2102ad3f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ids/GlobalIdGenerator.java#L102" rel="external nofollow noopener noreferrer" target="_blank"><code>IDContext#nextSeq()</code></a> 方法，生成带有时间戳的序列号。</li>
</ul>
</li>
<li>ps ：代码比较易懂，已经添加完成注释。</li>
</ul>
<h3 id="2-1-2-DistributedTraceId"><a href="#2-1-2-DistributedTraceId" class="headerlink" title="2.1.2 DistributedTraceId"></a>2.1.2 DistributedTraceId</h3><p><a href="https://github.com/YunaiV/skywalking/blob/5fb841b3ae5b78f07d06c6186adf9a8c08295a07/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ids/DistributedTraceId.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.ids.DistributedTraceId</code></a> ，分布式链路追踪编号<strong>抽象类</strong>。</p>
<ul>
<li><code>id</code> 属性，全局编号。</li>
</ul>
<p>DistributedTraceId 有两个实现类：</p>
<ul>
<li><a href="https://github.com/YunaiV/skywalking/blob/5fb841b3ae5b78f07d06c6186adf9a8c08295a07/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ids/NewDistributedTraceId.java" rel="external nofollow noopener noreferrer" target="_blank">org.skywalking.apm.agent.core.context.ids.NewDistributedTraceId</a> ，<strong>新建的</strong>分布式链路追踪编号。当全局链路追踪开始，创建 TraceSegment 对象的过程中，会调用 <a href="https://github.com/YunaiV/skywalking/blob/5fb841b3ae5b78f07d06c6186adf9a8c08295a07/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ids/NewDistributedTraceId.java#L30" rel="external nofollow noopener noreferrer" target="_blank"><code>DistributedTraceId()</code> 构造方法</a>，创建 DistributedTraceId 对象。该构造方法内部会调用 <code>GlobalIdGenerator#generate()</code> 方法，创建 ID 对象。</li>
<li><a href="https://github.com/YunaiV/skywalking/blob/5fb841b3ae5b78f07d06c6186adf9a8c08295a07/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ids/PropagatedTraceId.java" rel="external nofollow noopener noreferrer" target="_blank">org.skywalking.apm.agent.core.context.ids.PropagatedTraceId</a> ，<strong>传播的</strong>分布式链路追踪编号。例如，A 服务调用 B 服务时，A 服务会将 DistributedTraceId 对象带给 B 服务，B 服务会调用 <a href="https://github.com/YunaiV/skywalking/blob/5fb841b3ae5b78f07d06c6186adf9a8c08295a07/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ids/PropagatedTraceId.java#L30" rel="external nofollow noopener noreferrer" target="_blank"><code>PropagatedTraceId(String id)</code> 构造方法</a> ，创建 PropagatedTraceId 对象。该构造方法内部会解析 id ，生成 ID 对象。</li>
</ul>
<h3 id="2-1-3-DistributedTraceIds"><a href="#2-1-3-DistributedTraceIds" class="headerlink" title="2.1.3 DistributedTraceIds"></a>2.1.3 DistributedTraceIds</h3><p><a href="https://github.com/YunaiV/skywalking/blob/2961e9f539286ef91af1ff1ef7681d0a06f156b0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ids/DistributedTraceIds.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.ids.DistributedTraceIds</code></a> ，DistributedTraceId 数组的封装。</p>
<ul>
<li><code>relatedGlobalTraces</code> 属性，关联的 DistributedTraceId <strong>链式</strong>数组。</li>
</ul>
<p><a href="https://github.com/YunaiV/skywalking/blob/ad259ad680df86296036910ede262765ffb44e5e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ids/DistributedTraceIds.java#L50" rel="external nofollow noopener noreferrer" target="_blank"><code>#append(DistributedTraceId)</code></a> 方法，添加分布式链路追踪编号( DistributedTraceId )。代码如下：</p>
<ul>
<li>第 51 至 54 行：移除<strong>首个</strong> NewDistributedTraceId 对象。为什么呢？在 <a href="#">「2.4 TraceSegment」</a> 的构造方法中，会默认创建 NewDistributedTraceId 对象。在跨线程、或者跨进程的情况下时，创建的 TraceSegment 对象，需要指向父 Segment 的 DistributedTraceId ，所以需要移除默认创建的。</li>
<li>第 56 至 58 行：添加 DistributedTraceId 对象到数组。</li>
</ul>
<h2 id="2-2-AbstractSpan"><a href="#2-2-AbstractSpan" class="headerlink" title="2.2 AbstractSpan"></a>2.2 AbstractSpan</h2><p><a href="https://github.com/YunaiV/skywalking/blob/96fd1f0aacb995f725c446b1cfcdc3124058e6a6/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/AbstractSpan.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.trace.AbstractSpan</code></a> ，Span <strong>接口</strong>( 不是抽象类 )，定义了 Span 通用属性的接口方法：</p>
<ul>
<li><code>#getSpanId()</code> 方法，获得 Span 编号。一个整数，在 TraceSegment 内<strong>唯一</strong>，从 0 开始自增，在创建 Span 对象时生成。</li>
<li><code>#setOperationName(operationName)</code> 方法，设置操作名。<ul>
<li>操作名，定义如下：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_01/01.png" alt=""></li>
<li><code>#setOperationId(operationId)</code> 方法，设置操作编号。考虑到操作名是字符串，Agent 发送给 Collector 占用流量较大。因此，Agent 会将操作注册到 Collector ，生成操作编号。在 <a href="http://www.iocoder.cn/SkyWalking/agent-dictionary/?self">《SkyWalking 源码分析 —— Agent DictionaryManager 字典管理》</a> 有详细解析。</li>
</ul>
</li>
<li><p><code>#setComponent(Component)</code> 方法，设置 <a href="https://github.com/YunaiV/skywalking/blob/a51e197a78f82400edae5c33b523ba1cb5224b8f/apm-network/src/main/java/org/skywalking/apm/network/trace/component/Component.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.network.trace.component.Component</code></a> ，例如：MongoDB / SpringMVC / Tomcat 等等。目前，官方在 <a href="https://github.com/YunaiV/skywalking/blob/a51e197a78f82400edae5c33b523ba1cb5224b8f/apm-network/src/main/java/org/skywalking/apm/network/trace/component/ComponentsDefine.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.network.trace.component.ComponentsDefine</code></a> 定义了目前已经支持的 Component 。</p>
<ul>
<li><p><code>#setComponent(componentName)</code> 方法，直接设置 Component 名字。大多数情况下，我们不使用该方法。</p>
<blockquote>
<p>Only use this method in explicit instrumentation, like opentracing-skywalking-bridge.<br>It it higher recommend don’t use this for performance consideration.</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>#setLayer(SpanLayer)</code> 方法，设置 <a href="https://github.com/YunaiV/skywalking/blob/a51e197a78f82400edae5c33b523ba1cb5224b8f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/NoopSpan.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.trace.SpanLayer</code></a> 。目前有，DB 、RPC_FRAMEWORK 、HTTP 、MQ ，未来会增加 CACHE 。</p>
</li>
<li><p><code>#tag(key, value)</code> 方法，设置键值对的标签。可以调用多次，构成 Span 的标签集合。在 <a href="#">「2.2.1 Tag」</a> 详细解析。</p>
</li>
<li>日志相关<ul>
<li><code>#log(timestampMicroseconds, fields)</code> 方法，记录一条通用日志，包含 <code>fields</code> 键值对集合。</li>
<li><code>#log(Throwable)</code> 方法，记录一条异常日志，包含异常信息。 </li>
</ul>
</li>
<li><code>#errorOccurred()</code> 方法，标记发生异常。大多数情况下，配置 <code>#log(Throwable)</code> 方法一起使用。</li>
<li><code>#start()</code> 方法，开始 Span 。一般情况的实现，设置开始时间。</li>
<li><code>#isEntry()</code> 方法，是否是入口 Span ，在 <a href="#">「2.2.2.1 EntrySpan」</a> 详细解析。</li>
<li><code>#isExit()</code> 方法，是否是出口 Span ，在 <a href="#">「2.2.2.2 ExitSpan」</a> 详细解析。</li>
</ul>
<h3 id="2-2-1-Tag"><a href="#2-2-1-Tag" class="headerlink" title="2.2.1 Tag"></a>2.2.1 Tag</h3><h4 id="2-2-1-1-AbstractTag"><a href="#2-2-1-1-AbstractTag" class="headerlink" title="2.2.1.1 AbstractTag"></a>2.2.1.1 AbstractTag</h4><p><a href="https://github.com/YunaiV/skywalking/blob/e0c449745dfabe847b2e918d5352381f191a4469/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/tag/AbstractTag.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.tag.AbstractTag&lt;T&gt;</code></a> ，标签<strong>抽象类</strong>。注意，这个类的用途是将标签属性设置到 Span 上，或者说，它是设置 Span 的标签的<strong>工具类</strong>。代码如下：</p>
<ul>
<li><code>key</code> 属性，标签的键。</li>
<li><code>#set(AbstractSpan span, T tagValue)</code> <strong>抽象</strong>方法，设置 Span 的标签键 <code>key</code> 的值为 <code>tagValue</code> 。</li>
</ul>
<h4 id="2-2-1-2-StringTag"><a href="#2-2-1-2-StringTag" class="headerlink" title="2.2.1.2 StringTag"></a>2.2.1.2 StringTag</h4><p><a href="https://github.com/YunaiV/skywalking/blob/e0c449745dfabe847b2e918d5352381f191a4469/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/tag/StringTag.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.tag.StringTag</code></a> ，值类型为 String 的标签<strong>实现类</strong>。</p>
<ul>
<li><code>#set(AbstractSpan span, String tagValue)</code> <strong>实现</strong>方法，设置 Span 的标签键 <code>key</code> 的值为 <code>tagValue</code> 。</li>
</ul>
<h4 id="2-2-1-3-Tags"><a href="#2-2-1-3-Tags" class="headerlink" title="2.2.1.3 Tags"></a>2.2.1.3 Tags</h4><p><a href="https://github.com/YunaiV/skywalking/blob/e0c449745dfabe847b2e918d5352381f191a4469/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/tag/Tags.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.tag.Tags</code></a> ，<strong>常用</strong> Tag <strong>枚举类</strong>，内部定义了<strong>多个</strong> HTTP 、DB 相关的 StringTag 的静态变量。</p>
<p>在 <a href="https://github.com/opentracing-contrib/opentracing-specification-zh/blob/master/semantic_conventions.md#%E6%A0%87%E5%87%86%E7%9A%84span-tag-%E5%92%8C-log-field" rel="external nofollow noopener noreferrer" target="_blank">《opentracing-specification-zh —— 语义惯例》</a> 里，定义了标准的 Span Tag 。</p>
<h3 id="2-2-2-AbstractSpan-实现类"><a href="#2-2-2-AbstractSpan-实现类" class="headerlink" title="2.2.2 AbstractSpan 实现类"></a>2.2.2 AbstractSpan 实现类</h3><p>AbstractSpan 实现类如下图：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_01/03.png" alt=""></p>
<ul>
<li>左半边的 Span 实现类：<strong>有</strong>具体操作的 Span 。</li>
<li>右半边的 Span 实现类：<strong>无</strong>具体操作的 Span ，和左半边的 Span 实现类<strong>相对</strong>，用于不需要收集 Span 的场景。</li>
</ul>
<p>抛开右半边的 Span 实现类的特殊处理，Span 只有三种实现类：</p>
<ul>
<li>EntrySpan ：入口 Span</li>
<li>LocalSpan ：本地 Span</li>
<li>ExitSpan ：出口 Span</li>
</ul>
<p>下面，我们分小节逐步分享。</p>
<h4 id="2-2-2-1-AbstractTracingSpan"><a href="#2-2-2-1-AbstractTracingSpan" class="headerlink" title="2.2.2.1 AbstractTracingSpan"></a>2.2.2.1 AbstractTracingSpan</h4><p><a href="https://github.com/YunaiV/skywalking/blob/11b66b8d36943d6492f51c676b455f29c9c0abc6/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/AbstractTracingSpan.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.trace.AbstractTracingSpan</code></a> ，实现 AbstractSpan 接口，链路追踪 Span <strong>抽象类</strong>。</p>
<p>在创建 AbstractTracingSpan 时，会传入 <code>spanId</code> , <code>parentSpanId</code> , <code>operationName</code> / <code>operationId</code> 参数。参见构造方法：</p>
<ul>
<li><code>#AbstractTracingSpan(spanId, parentSpanId, operationName)</code></li>
<li><code>#AbstractTracingSpan(spanId, parentSpanId, operationId)</code></li>
</ul>
<hr>
<p>大部分是 setting / getting 方法，或者类似方法，已经添加注释，胖友自己阅读。</p>
<p><a href="https://github.com/YunaiV/skywalking/blob/11b66b8d36943d6492f51c676b455f29c9c0abc6/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/AbstractTracingSpan.java#L126" rel="external nofollow noopener noreferrer" target="_blank"><code>#finish(TraceSegment)</code></a> 方法，完成( 结束 ) Span ，将当前 Span ( 自己 )添加到 TraceSegment 。为什么会调用该方法，在 <a href="#">「3. Context」</a> 详细解析。</p>
<h4 id="2-2-2-2-StackBasedTracingSpan"><a href="#2-2-2-2-StackBasedTracingSpan" class="headerlink" title="2.2.2.2 StackBasedTracingSpan"></a>2.2.2.2 StackBasedTracingSpan</h4><p> <a href="https://github.com/YunaiV/skywalking/blob/c1e513b4581443e7ca720f4e9c91ad97cc6f0de1/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/StackBasedTracingSpan.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.trace.StackBasedTracingSpan</code></a> ，实现 AbstractTracingSpan 抽象类，基于<strong>栈</strong>的链路追踪 Span 抽象类。这种 Span 能够被多次调用 <code>#start(...)</code> 和 <code>#finish(...)</code> 方法，在类似堆栈的调用中。在 <a href="#">「2.2.2.2.1 EntrySpan」</a> 中详细举例子。代码如下：</p>
<ul>
<li><code>stackDepth</code> 属，<strong>栈</strong>深度。</li>
<li><a href="https://github.com/YunaiV/skywalking/blob/c1e513b4581443e7ca720f4e9c91ad97cc6f0de1/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/StackBasedTracingSpan.java#L52" rel="external nofollow noopener noreferrer" target="_blank"><code>#finish(TraceSegment)</code></a> <strong>实现</strong>方法，完成( 结束 ) Span ，将当前 Span ( 自己 )添加到 TraceSegment 。<strong>当且仅当 <code>stackDepth == 0</code> 时，添加成功</strong>。代码如下：<ul>
<li>第 53 至 73 行：栈深度为零，出栈成功。调用 <code>super#finish(TraceSegment)</code> 方法，完成( 结束 ) Span ，将当前 Span ( 自己 )添加到 TraceSegment 。<ul>
<li>第 55 至 72 行：当操作编号为空时，尝试使用操作名获得操作编号并设置。用于<strong>减少</strong> Agent 发送 Collector 数据的网络流量。</li>
</ul>
</li>
<li>第 74 至 76 行：栈深度非零，出栈失败。</li>
</ul>
</li>
</ul>
<h5 id="2-2-2-2-1-EntrySpan"><a href="#2-2-2-2-1-EntrySpan" class="headerlink" title="2.2.2.2.1 EntrySpan"></a>2.2.2.2.1 EntrySpan</h5><p><strong>重点</strong></p>
<p><a href="https://github.com/YunaiV/skywalking/blob/d36f6a47a208720f4caac9d9a8b7263bd36f2187/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/EntrySpan.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.trace.EntrySpan</code></a> ，实现 StackBasedTracingSpan 抽象类，<strong>入口</strong> Span ，用于服务提供者( Service Provider ) ，例如 Tomcat 。</p>
<p>EntrySpan 是 TraceSegment 的第一个 Span ，这也是为什么称为”<strong>入口</strong>“ Span 的原因。</p>
<p><strong>那么为什么 EntrySpan 继承 StackBasedTracingSpan</strong> ？</p>
<p>例如，我们常用的 SprintBoot 场景下，Agent 会在 SkyWalking 插件在 Tomcat 定义的方法切面，创建 EntrySpan 对象，也会在 SkyWalking 插件在 SpringMVC 定义的方法切面，创建 EntrySpan 对象。那岂不是出现<strong>两个</strong> EntrySpan ，一个 TraceSegment 出现了两个入口 Span ？</p>
<p>答案是当然不会！Agent 只会在第一个方法切面，生成 EntrySpan 对象，第二个方法切面，栈深度 <strong>+ 1</strong>。这也是上面我们看到的 <code>#finish(TraceSegment)</code> 方法，只在栈深度为零时，出栈成功。通过这样的方式，保持一个 TraceSegment 有且仅有一个 EntrySpan 对象。</p>
<p>当然，多个 TraceSegment 会有多个 EntrySpan 对象 ，例如【服务 A】远程调用【服务 B】。</p>
<p>另外，虽然 EntrySpan 在第一个服务提供者创建，EntrySpan 代表的是最后一个服务提供者，例如，上面的例子，EntrySpan 代表的是 Spring MVC 的方法切面。所以，<code>startTime</code> 和 <code>endTime</code> 以第一个为准，<code>componentId</code> 、<code>componentName</code> 、<code>layer</code> 、<code>logs</code> 、<code>tags</code> 、<code>operationName</code> 、<code>operationId</code> 等等以最后一个为准。并且，一般情况下，最后一个服务提供者的信息也会<strong>更加详细</strong>。</p>
<p><strong>ps</strong>：如上内容信息量较大，胖友可以对照着实现方法，在理解理解。HOHO ，良心笔者当然也是加了注释的。</p>
<p>如下是一个 EntrySpan 在 SkyWalking 展示的例子：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_01/04.png" alt=""></p>
<h5 id="2-2-2-2-2-ExitSpan"><a href="#2-2-2-2-2-ExitSpan" class="headerlink" title="2.2.2.2.2 ExitSpan"></a>2.2.2.2.2 ExitSpan</h5><p><strong>重点</strong></p>
<p><a href="https://github.com/YunaiV/skywalking/blob/958830d8db481b5b8a70498a09bc18eb7c721737/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/ExitSpan.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.trace.ExitSpan</code></a> ，继承 StackBasedTracingSpan 抽象类，<strong>出口</strong> Span ，用于服务消费者( Service Consumer ) ，例如 HttpClient 、MongoDBClient 。</p>
<hr>
<p>ExitSpan 实现 <a href="https://github.com/YunaiV/skywalking/blob/958830d8db481b5b8a70498a09bc18eb7c721737/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/WithPeerInfo.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.trace.WithPeerInfo</code></a> 接口，代码如下：</p>
<ul>
<li><code>peer</code> 属性，节点地址。</li>
<li><code>peerId</code> 属性，节点编号。</li>
</ul>
<p>如下是一个 ExitSpan 在 SkyWalking 展示的例子：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_01/05.png" alt=""></p>
<hr>
<p><strong>那么为什么 ExitSpan 继承 StackBasedTracingSpan</strong> ？</p>
<p>例如，我们可能在使用的 Dubbox 场景下，【Dubbox 服务 A】使用 HTTP 调用【Dubbox 服务 B】时，实际过程是，【Dubbox 服务 A】=》【HttpClient】=》【Dubbox 服务 B】。Agent 会在【Dubbox 服务 A】创建 ExitSpan 对象，也会在 【HttpClient】创建 ExitSpan 对象。那岂不是<strong>一次出口</strong>，出现<strong>两个</strong> ExitSpan ？</p>
<p>答案是当然不会！Agent 只会在【Dubbox 服务 A】，生成 EntrySpan 对象，第二个方法切面，栈深度 <strong>+ 1</strong>。这也是上面我们看到的 <code>#finish(TraceSegment)</code> 方法，只在栈深度为零时，出栈成功。通过这样的方式，保持<strong>一次出口</strong>有且仅有一个 ExitSpan 对象。</p>
<p>当然，一个 TraceSegment 会有多个 ExitSpan 对象 ，例如【服务 A】远程调用【服务 B】，然后【服务 A】再次远程调用【服务 B】，或者然后【服务 A】远程调用【服务 C】。</p>
<p>另外，虽然 ExitSpan 在第一个消费者创建，ExitSpan 代表的也是第一个服务提消费者，例如，上面的例子，ExitSpan 代表的是【Dubbox 服务 A】。</p>
<p><strong>ps</strong>：如上内容信息量较大，胖友可以对照着实现方法，在理解理解。HOHO ，良心笔者当然也是加了注释的。</p>
<h4 id="2-2-2-3-LocalSpan"><a href="#2-2-2-3-LocalSpan" class="headerlink" title="2.2.2.3 LocalSpan"></a>2.2.2.3 LocalSpan</h4><p><a href="https://github.com/YunaiV/skywalking/blob/96fd1f0aacb995f725c446b1cfcdc3124058e6a6/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/LocalSpan.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.trace.LocalSpan</code></a> ，继承 AbstractTracingSpan 抽象类，本地 Span ，用于一个普通方法的链路追踪，例如本地方法。</p>
<p>如下是一个 EntrySpan 在 SkyWalking 展示的例子：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_01/06.png" alt=""></p>
<h4 id="2-2-2-4-NoopSpan"><a href="#2-2-2-4-NoopSpan" class="headerlink" title="2.2.2.4 NoopSpan"></a>2.2.2.4 NoopSpan</h4><p><a href="https://github.com/YunaiV/skywalking/blob/f00d2f405ca23e89778febeb4ada7b389858f258/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/NoopSpan.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.trace.NoopSpan</code></a> ，实现 AbstractSpan 接口，<strong>无操作</strong>的 Span 。配置 IgnoredTracerContext 一起使用，在 IgnoredTracerContext 声明<a href="https://github.com/YunaiV/skywalking/blob/f00d2f405ca23e89778febeb4ada7b389858f258/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/IgnoredTracerContext.java#L37" rel="external nofollow noopener noreferrer" target="_blank">单例</a> ，以减少不收集 Span 时的对象创建，达到减少内存使用和 GC 时间。</p>
<h5 id="2-2-2-3-1-NoopExitSpan"><a href="#2-2-2-3-1-NoopExitSpan" class="headerlink" title="2.2.2.3.1 NoopExitSpan"></a>2.2.2.3.1 NoopExitSpan</h5><p><a href="https://github.com/YunaiV/skywalking/blob/f00d2f405ca23e89778febeb4ada7b389858f258/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/ExitSpan.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.trace.NoopExitSpan</code></a> ，实现 <a href="https://github.com/YunaiV/skywalking/blob/958830d8db481b5b8a70498a09bc18eb7c721737/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/WithPeerInfo.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.trace.WithPeerInfo</code></a> 接口，继承 StackBasedTracingSpan 抽象类，<strong>出口</strong> Span ，无操作的<strong>出口</strong> Span 。和 ExitSpan <strong>相对</strong>，不记录服务消费者的出口 Span 。</p>
<h2 id="2-3-TraceSegmentRef"><a href="#2-3-TraceSegmentRef" class="headerlink" title="2.3 TraceSegmentRef"></a>2.3 TraceSegmentRef</h2><p><a href="https://github.com/YunaiV/skywalking/blob/49dc81a8bcaad1879b3a3be9917944b0b8b5a7a4/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegmentRef.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.trace.TraceSegmentRef</code></a> ，TraceSegment 指向，通过 <code>traceSegmentId</code> 和 <code>spanId</code> 属性，指向父级 TraceSegment 的指定 Span 。</p>
<ul>
<li><p><code>type</code> 属性，指向类型( <a href="https://github.com/YunaiV/skywalking/blob/49dc81a8bcaad1879b3a3be9917944b0b8b5a7a4/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegmentRef.java#L206" rel="external nofollow noopener noreferrer" target="_blank">SegmentRefType</a> ) 。不同的指向类型，使用不同的构造方法。</p>
<ul>
<li><code>CROSS_PROCESS</code> ，跨进程，例如远程调用，对应构造方法 <a href="https://github.com/YunaiV/skywalking/blob/49dc81a8bcaad1879b3a3be9917944b0b8b5a7a4/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegmentRef.java#L97" rel="external nofollow noopener noreferrer" target="_blank">#TraceSegmentRef(ContextCarrier)</a> 。 </li>
<li><code>CROSS_THREAD</code> ，跨线程，例如异步线程任务，对应构造方法 <a href="https://github.com/YunaiV/skywalking/blob/49dc81a8bcaad1879b3a3be9917944b0b8b5a7a4/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegmentRef.java#L123" rel="external nofollow noopener noreferrer" target="_blank">#TraceSegmentRef(ContextSnapshot)</a> 。</li>
<li>构造方法的代码，在 <a href="#">「3. Context」</a> 中，伴随着调用过程，一起解析。</li>
</ul>
</li>
<li><p><code>traceSegmentId</code> 属性，<strong>父</strong> TraceSegment 编号。<strong>重要</strong></p>
</li>
<li><code>spanId</code> 属性，<strong>父</strong> Span 编号。<strong>重要</strong></li>
<li><code>peerId</code> 属性，节点编号。<strong>注意，此处的节点编号就是应用( Application )编号</strong>。</li>
<li><code>peerHost</code> 属性，节点地址。</li>
<li><code>entryApplicationInstanceId</code> 属性，<strong>入口</strong>应用实例编号。例如，在一个分布式链路 <code>A-&gt;B-&gt;C</code> 中，此字段为 A 应用的实例编号。</li>
<li><code>parentApplicationInstanceId</code> 属性，<strong>父</strong>应用实例编号。</li>
<li><code>entryOperationName</code> 属性，<strong>入口</strong>操作名。</li>
<li><code>entryOperationId</code> 属性，<strong>入口</strong>操作编号。</li>
<li><code>parentOperationName</code> 属性，<strong>父</strong>操作名。</li>
<li><code>parentOperationId</code> 属性，<strong>父</strong>操作编号。</li>
</ul>
<h2 id="2-4-TraceSegment"><a href="#2-4-TraceSegment" class="headerlink" title="2.4 TraceSegment"></a>2.4 TraceSegment</h2><p>在看完了 TraceSegment 的各个元素，我们来看看 TraceSegment 内部实现的方法。</p>
<p><a href="https://github.com/YunaiV/skywalking/blob/ad259ad680df86296036910ede262765ffb44e5e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegment.java#L79" rel="external nofollow noopener noreferrer" target="_blank">TraceSegment 构造方法</a>，代码如下：</p>
<ul>
<li>第 80 行：调用 <code>GlobalIdGenerator#generate()</code> 方法，生成 ID 对象，赋值给 <code>traceSegmentId</code> 。</li>
<li>第 81 行：创建 <code>spans</code> 数组。<ul>
<li><a href="https://github.com/YunaiV/skywalking/blob/ad259ad680df86296036910ede262765ffb44e5e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegment.java#L114" rel="external nofollow noopener noreferrer" target="_blank"><code>#archive(AbstractTracingSpan)</code></a> 方法，被 <code>AbstractSpan#finish(TraceSegment)</code> 方法调用，添加到 <code>spans</code> 数组。</li>
</ul>
</li>
<li>第 83 至 84 行：创建 DistributedTraceIds 对象，并添加 NewDistributedTraceId 到它。<ul>
<li><strong>注意</strong>，当 TraceSegment 是一次分布式链路追踪的<strong>首条</strong>记录，创建的 NewDistributedTraceId 对象，即为分布式链路追踪的<strong>全局编号</strong>。</li>
<li><a href="https://github.com/YunaiV/skywalking/blob/ad259ad680df86296036910ede262765ffb44e5e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegment.java#L104" rel="external nofollow noopener noreferrer" target="_blank"><code>#relatedGlobalTraces(DistributedTraceId)</code></a> 方法，添加 DistributedTraceId 对象。被 <code>TracingContext#continued(ContextSnapshot)</code> 或者 <code>TracingContext#extract(ContextCarrier)</code> 方法调用，在 <a href="#">「3. Context」</a> 详细解析。</li>
</ul>
</li>
</ul>
<p><a href="https://github.com/YunaiV/skywalking/blob/ad259ad680df86296036910ede262765ffb44e5e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegment.java#L92" rel="external nofollow noopener noreferrer" target="_blank"><code>#ref(TraceSegmentRef)</code></a> 方法，添加 TraceSegmentRef 对象，到 <code>refs</code> 属性，即<strong>指向</strong>父 Segment 。</p>
<h1 id="3-Context"><a href="#3-Context" class="headerlink" title="3. Context"></a>3. Context</h1><p>在 <a href="#">「2. Trace」</a> 中，我们看了 Trace 的数据结构，本小节，我们一起来看看 Context 是怎么收集 Trace 数据的。</p>
<h2 id="3-1-ContextManager"><a href="#3-1-ContextManager" class="headerlink" title="3.1 ContextManager"></a>3.1 ContextManager</h2><p><code>org.skywalking.apm.agent.core.context.ContextManager</code> ，实现了 BootService 、TracingContextListener 、IgnoreTracerContextListener 接口，链路追踪上下文管理器。</p>
<hr>
<p><a href="https://github.com/YunaiV/skywalking/blob/ad259ad680df86296036910ede262765ffb44e5e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ContextManager.java#L52" rel="external nofollow noopener noreferrer" target="_blank"><code>CONTEXT</code></a> <strong>静态</strong>属性，线程变量，存储 AbstractTracerContext 对象。为什么是<strong>线程变量</strong>呢？</p>
<p><strong>一个</strong> TraceSegment 对象，关联到<strong>一个</strong>线程，负责收集该线程的链路追踪数据，因此使用线程变量。</p>
<p>而<strong>一个</strong> AbstractTracerContext 会关联<strong>一个</strong> TraceSegment 对象，ContextManager 负责获取、创建、销毁 AbstractTracerContext 对象。</p>
<p><a href="https://github.com/YunaiV/skywalking/blob/ad259ad680df86296036910ede262765ffb44e5e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ContextManager.java#L61" rel="external nofollow noopener noreferrer" target="_blank"><code>#getOrCreate(operationName, forceSampling)</code></a> <strong>静态</strong>方法，获取 AbstractTracerContext 对象。若不存在，进行<strong>创建</strong>。</p>
<ul>
<li><strong>要</strong>需要收集 Trace 数据的情况下，创建 <a href="https://github.com/YunaiV/skywalking/blob/ad259ad680df86296036910ede262765ffb44e5e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java" rel="external nofollow noopener noreferrer" target="_blank">TracingContext</a> 对象。</li>
<li><strong>不</strong>需要收集 Trace 数据的情况下，创建 <a href="https://github.com/YunaiV/skywalking/blob/ad259ad680df86296036910ede262765ffb44e5e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/IgnoredTracerContext.java" rel="external nofollow noopener noreferrer" target="_blank">IgnoredTracerContext</a> 对象。</li>
</ul>
<p>在下面的 <code>#createEntrySpan(...)</code> 、<code>#createLocalSpan(...)</code> 、<code>#createExitSpan(...)</code> 等等方法中，都会调用 AbstractTracerContext 提供的方法。这些方法的代码，我们放在 <a href="#">「3.2 AbstractTracerContext」</a> 一起解析，保证流程的整体性。</p>
<p>另外，ContextManager 封装了<strong>所有</strong> AbstractTracerContext 提供的方法，从而实现，外部调用者，例如 SkyWalking 的插件，只调用 ContextManager 的方法，而不调用 AbstractTracerContext 的方法。</p>
<hr>
<p><a href="https://github.com/YunaiV/skywalking/blob/ad259ad680df86296036910ede262765ffb44e5e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ContextManager.java#L201" rel="external nofollow noopener noreferrer" target="_blank"><code>#boot()</code></a> <strong>实现</strong>方法，启动时，将自己注册到 <a href="">TracingContext.ListenerManager</a> 和 <a href="">IgnoredTracerContext.ListenerManager</a> 中，这样一次链路追踪上下文( Context )完成时，从而被回调如下方法，清理上下文：</p>
<ul>
<li><a href="https://github.com/YunaiV/skywalking/blob/ad259ad680df86296036910ede262765ffb44e5e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ContextManager.java#L216" rel="external nofollow noopener noreferrer" target="_blank"><code>#afterFinished(TraceSegment)</code></a></li>
<li><a href="https://github.com/YunaiV/skywalking/blob/ad259ad680df86296036910ede262765ffb44e5e/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ContextManager.java#L221" rel="external nofollow noopener noreferrer" target="_blank"><code>#afterFinished(IgnoredTracerContext)</code></a></li>
</ul>
<h2 id="3-2-AbstractTracerContext"><a href="#3-2-AbstractTracerContext" class="headerlink" title="3.2 AbstractTracerContext"></a>3.2 AbstractTracerContext</h2><p><a href="https://github.com/YunaiV/skywalking/blob/2a75efbeddac2b9565816af0ab0873ec3d998424/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/AbstractTracerContext.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.AbstractTracerContext</code></a> ，链路追踪上下文<strong>接口</strong>。定义了如下方法：</p>
<ul>
<li><code>#getReadableGlobalTraceId()</code> 方法，获得<strong>关联</strong>的全局链路追踪编号。</li>
<li><code>#createEntrySpan(operationName)</code> 方法，创建 EntrySpan 对象。</li>
<li><code>#createLocalSpan(operationName)</code> 方法，创建 LocalSpan 对象。</li>
<li><code>#createExitSpan(operationName, remotePeer)</code> 方法，创建 ExitSpan 对象。</li>
<li><code>#activeSpan()</code> 方法，获得当前<strong>活跃</strong>的 Span 对象。</li>
<li><code>#stopSpan(AbstractSpan)</code> 方法，停止( 完成 )指定 AbstractSpan 对象。</li>
<li>——— 跨进程( cross-process ) ———</li>
<li><code>#inject(ContextCarrier)</code> 方法，将 Context <strong>注入</strong>到 ContextCarrier ，用于跨进程，<strong>传播</strong>上下文。</li>
<li><code>#extract(ContextCarrier)</code> 方法，将 ContextCarrier <strong>解压</strong>到 Context ，用于跨进程，<strong>接收</strong>上下文。</li>
<li>——— 跨线程( cross-thread ) ———</li>
<li><code>#capture()</code> 方法，将 Context <strong>快照</strong>到 ContextSnapshot ，用于跨线程，<strong>传播</strong>上下文。</li>
<li><code>#continued(ContextSnapshot)</code> 方法，将 ContextSnapshot <strong>解压</strong>到 Context ，用于跨线程，<strong>接收</strong>上下文。</li>
</ul>
<h3 id="3-2-1-TracingContext"><a href="#3-2-1-TracingContext" class="headerlink" title="3.2.1 TracingContext"></a>3.2.1 TracingContext</h3><p><code>org.skywalking.apm.agent.core.context.TracingContext</code> ，实现 AbstractTracerContext 接口，链路追踪上下文<strong>实现类</strong>。</p>
<ul>
<li><code>segment</code> 属性，上下文对应的 TraceSegment 对象。</li>
<li><code>activeSpanStack</code> 属性，AbstractSpan <strong>链表</strong>数组，收集当前<strong>活跃</strong>的 Span 对象。正如方法的调用与执行一样，在一个<strong>调用栈</strong>中，先执行的方法后结束。</li>
<li><code>spanIdGenerator</code> 属性，Span 编号自增序列。创建的 Span 的编号，通过该变量自增生成。</li>
</ul>
<p><a href="https://github.com/YunaiV/skywalking/blob/2a75efbeddac2b9565816af0ab0873ec3d998424/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L79" rel="external nofollow noopener noreferrer" target="_blank">TracingContext 构造方法</a> ，代码如下：</p>
<ul>
<li>第 80 行：创建 TraceSegment 对象。</li>
<li>第 81 行：设置 <code>spanIdGenerator = 0</code> 。</li>
</ul>
<p><a href="https://github.com/YunaiV/skywalking/blob/5eb4b28e18e8a47de10ec331a9667444d16f4933/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L79" rel="external nofollow noopener noreferrer" target="_blank"><code>#getReadableGlobalTraceId()</code></a> <strong>实现</strong>方法，获得 TraceSegment 的<strong>首个</strong> DistributedTraceId 作为返回。</p>
<h4 id="3-2-1-1-创建-EntrySpan"><a href="#3-2-1-1-创建-EntrySpan" class="headerlink" title="3.2.1.1 创建 EntrySpan"></a>3.2.1.1 创建 EntrySpan</h4><p>调用 <a href="https://github.com/YunaiV/skywalking/blob/5eb4b28e18e8a47de10ec331a9667444d16f4933/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ContextManager.java#L118" rel="external nofollow noopener noreferrer" target="_blank"><code>ContextManager#createEntrySpan(operationName, carrier)</code></a> 方法，创建 EntrySpan 对象。代码如下：</p>
<ul>
<li>第 121 至 131 行：调用 <code>#getOrCreate(operationName, forceSampling)</code> 方法，获取 AbstractTracerContext 对象。若不存在，进行创建。<ul>
<li>第 122 至 125 行：有<strong>传播</strong> Context 的情况下，<strong>强制</strong>收集 Trace 数据。</li>
<li>第 127 行：调用 <code>TracingContext#extract(ContextCarrier)</code> 方法，将 ContextCarrier <strong>解压</strong>到 Context ，<strong>跨进程</strong>，接收上下文。在 <a href="#">「3.2.3 ContextCarrier」</a> 详细解析。</li>
</ul>
</li>
<li>第 133 行：调用 <code>TracingContext#createEntrySpan(operationName)</code> 方法，创建 EntrySpan 对象。</li>
</ul>
<hr>
<p>调用 <a href="https://github.com/YunaiV/skywalking/blob/5eb4b28e18e8a47de10ec331a9667444d16f4933/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L230" rel="external nofollow noopener noreferrer" target="_blank"><code>TracingContext#createEntrySpan(operationName)</code></a> 方法，创建 EntrySpan 对象。代码如下：</p>
<ul>
<li>第 223 至 227 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/5eb4b28e18e8a47de10ec331a9667444d16f4933/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L500" rel="external nofollow noopener noreferrer" target="_blank"><code>#isLimitMechanismWorking()</code></a> 方法，判断 Span 数量<strong>超过上限</strong>，创建 NoopSpan 对象，并调用 <code>#push(AbstractSpan)</code> 方法，添加到 <code>activeSpanStack</code> 中。</li>
<li>第 229 至 231 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/5eb4b28e18e8a47de10ec331a9667444d16f4933/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L489" rel="external nofollow noopener noreferrer" target="_blank"><code>#peek()</code></a> 方法，获得当前活跃的 AbstractSpan 对象。</li>
<li>第 232 至 249 行：若<strong>父</strong> Span 对象不存在，创建 EntrySpan 对象。<ul>
<li>第 235 至 244 行：创建 EntrySpan 对象。</li>
<li>第 247 行：调用 <code>EntrySpan#start()</code> 方法，开始 EntrySpan 。</li>
<li>第 249 行：调用 <code>#push(AbstractSpan)</code> 方法，添加到 <code>activeSpanStack</code> 中。</li>
</ul>
</li>
<li>第 251 至 264 行：若<strong>父</strong> EntrySpan 对象存在，<strong>重新</strong>开始 EntrySpan 。参见 <a href="#">「2.2.2.2.1 EntrySpan」</a> 。</li>
<li>第 265 至 267 行：<code>&quot;The Entry Span can&#39;t be the child of Non-Entry Span&quot;</code> 。</li>
</ul>
<h4 id="3-2-1-2-创建-LocalSpan"><a href="#3-2-1-2-创建-LocalSpan" class="headerlink" title="3.2.1.2 创建 LocalSpan"></a>3.2.1.2 创建 LocalSpan</h4><p>调用 <a href="https://github.com/YunaiV/skywalking/blob/97777afc4975ee3bd466fd8870d7dbbc3da9ddd0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ContextManager.java#L136" rel="external nofollow noopener noreferrer" target="_blank"><code>ContextManager#createLocalSpan(operationName)</code></a> 方法，创建 LocalSpan 对象。</p>
<ul>
<li>第 138 行：调用 <code>#getOrCreate(operationName, forceSampling)</code> 方法，获取 AbstractTracerContext 对象。若不存在，进行创建。</li>
<li>第 140 行：调用 <code>TracingContext#createLocalSpan(operationName)</code> 方法，创建 LocalSpan 对象。</li>
</ul>
<hr>
<p>调用 <a href="https://github.com/YunaiV/skywalking/blob/97777afc4975ee3bd466fd8870d7dbbc3da9ddd0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L278" rel="external nofollow noopener noreferrer" target="_blank"><code>TracingContext#createLocalSpan(operationName)</code></a> 方法，创建 LocalSpan 对象。代码如下：</p>
<ul>
<li>第 280 至 283 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/5eb4b28e18e8a47de10ec331a9667444d16f4933/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L500" rel="external nofollow noopener noreferrer" target="_blank"><code>#isLimitMechanismWorking()</code></a> 方法，判断 Span 数量<strong>超过上限</strong>，创建 NoopSpan 对象，并调用 <code>#push(AbstractSpan)</code> 方法，添加到 <code>activeSpanStack</code> 中。</li>
<li>第 284 至 286 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/5eb4b28e18e8a47de10ec331a9667444d16f4933/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L489" rel="external nofollow noopener noreferrer" target="_blank"><code>#peek()</code></a> 方法，获得当前活跃的 AbstractSpan 对象。</li>
<li>第 288 至 300 行：创建 LocalSpan 对象。</li>
<li>第 302 行：调用 <code>LocalSpan#start()</code> 方法，开始 LocalSpan 。</li>
<li>第 304 行：调用 <code>#push(AbstractSpan)</code> 方法，添加到 <code>activeSpanStack</code> 中。</li>
</ul>
<h4 id="3-2-1-3-创建-ExitSpan"><a href="#3-2-1-3-创建-ExitSpan" class="headerlink" title="3.2.1.3 创建 ExitSpan"></a>3.2.1.3 创建 ExitSpan</h4><p>调用 <a href="https://github.com/YunaiV/skywalking/blob/97777afc4975ee3bd466fd8870d7dbbc3da9ddd0/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ContextManager.java#L143" rel="external nofollow noopener noreferrer" target="_blank"><code>ContextManager#createExitSpan(operationName, carrier, remotePeer)</code></a> 方法，创建 ExitSpan 对象。</p>
<ul>
<li>第 148 行：调用 <code>#getOrCreate(operationName, forceSampling)</code> 方法，获取 AbstractTracerContext 对象。若不存在，进行创建。</li>
<li>第 150 行：调用 <code>TracingContext#createExitSpan(operationName, remotePeer)</code> 方法，创建 ExitSpan 对象。</li>
<li>第 160 行：<code>TracingContext#inject(ContextCarrier)</code> 方法，将 Context <strong>注入</strong>到 ContextCarrier ，<strong>跨进程</strong>，传播上下文。在 <a href="#">「3.2.3 ContextCarrier」</a> 详细解析。</li>
</ul>
<hr>
<p>调用 <a href="https://github.com/YunaiV/skywalking/blob/5eb4b28e18e8a47de10ec331a9667444d16f4933/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L230" rel="external nofollow noopener noreferrer" target="_blank"><code>TracingContext#createEntrySpan(operationName)</code></a> 方法，创建 ExitSpan 对象。代码如下：</p>
<ul>
<li>第 319 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/5eb4b28e18e8a47de10ec331a9667444d16f4933/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L489" rel="external nofollow noopener noreferrer" target="_blank"><code>#peek()</code></a> 方法，获得当前活跃的 AbstractSpan 对象。</li>
<li>第 320 至 322 行：若 ExitSpan 对象存在，直接使用，不重新创建。参见 <a href="#">「2.2.2.2.2 ExitSpan」</a> 。</li>
<li>第 324 至 377 行：创建 ExitSpan 对象，并添加到 <code>activeSpanStack</code> 中。<ul>
<li>第 327 行：根据 <code>remotePeer</code> 参数，查找 <code>peerId</code> 。<strong>注意</strong>，此处会创建一个 Application 对象，通过 ServiceMapping 表，和远程的 Application 进行<strong>匹配映射</strong>。后续有文章会分享这块。</li>
<li>第 322 至 324 行 || 第 335 至 358 行：判断 Span 数量<strong>超过上限</strong>，创建 NoopExitSpan 对象，并调用 <code>#push(AbstractSpan)</code> 方法，添加到 <code>activeSpanStack</code> 中。</li>
</ul>
</li>
<li>第 380 行：开始 ExitSpan 。</li>
</ul>
<h4 id="3-2-1-4-结束-Span"><a href="#3-2-1-4-结束-Span" class="headerlink" title="3.2.1.4 结束 Span"></a>3.2.1.4 结束 Span</h4><p>调用 <a href="https://github.com/YunaiV/skywalking/blob/85effa4f5752bdfe3efa43294293af0634a40626/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L316" rel="external nofollow noopener noreferrer" target="_blank"><code>ContextManager#stopSpan()</code></a> 方法，结束 Span 。代码如下：</p>
<ul>
<li>第 199 行：调用 <code>TracingContext#stopSpan(AbstractSpan)</code> 方法，结束 Span 。<strong>当所有活跃的 Span 都被结束后，当前线程的 TraceSegment 完成</strong>。</li>
</ul>
<hr>
<p>调用 <a href="https://github.com/YunaiV/skywalking/blob/7b39e952da408f722a53168e6d6a0cd7e7ff372f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L403" rel="external nofollow noopener noreferrer" target="_blank"><code>TracingContext#stopSpan(AbstractSpan)</code></a> 方法，结束 Span 。代码如下：</p>
<ul>
<li>第 405 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/5eb4b28e18e8a47de10ec331a9667444d16f4933/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L489" rel="external nofollow noopener noreferrer" target="_blank"><code>#peek()</code></a> 方法，获得当前活跃的 AbstractSpan 对象。</li>
<li>第 408 至 414 行：当 Span 为 AbstractTracingSpan 的子类，即记录链路追踪的 Span ，调用 <code>AbstractTracingSpan#finish(TraceSegment)</code> 方法，完成 Span 。<ul>
<li>当完成<strong>成功</strong>时，调用 <code>#pop()</code> 方法，移除出 <code>activeSpanStack</code> 。</li>
<li>当完成<strong>失败</strong>时，原因参见 <a href="#">「2.2.2.2 StackBasedTracingSpan」</a> 。</li>
</ul>
</li>
<li>第 416 至 419 行：当 Span 为 NoopSpan 的子类，即不记录链路追踪的 Span ，调用 <code>#pop()</code> 方法，移除出 <code>activeSpanStack</code> 。</li>
<li>第 425 至 427 行：当所有活跃的 Span 都被结束后，调用 <code>#finish()</code> 方法，当前线程的 TraceSegment 完成。</li>
</ul>
<hr>
<p>调用 <a href="https://github.com/YunaiV/skywalking/blob/7b39e952da408f722a53168e6d6a0cd7e7ff372f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L434" rel="external nofollow noopener noreferrer" target="_blank"><code>TracingContext#stopSpan(AbstractSpan)</code></a> 方法，完成 Context 。代码如下：</p>
<ul>
<li>第 436 行：调用 <code>TraceSegment#finish(isSizeLimited)</code> 方法，完成 TraceSegment 。</li>
<li>第 444 至 448 行：若满足条件，调用 <code>TraceSegment#setIgnore(true)</code> 方法，标记该 TraceSegment 忽略，不发送给 Collector 。<ul>
<li><code>!samplingService.trySampling()</code> ：不采样。 </li>
<li><code>!segment.hasRef()</code> ：无父 TraceSegment 指向。如果此处忽略采样，则会导致整条分布式链路追踪<strong>不完整</strong>。</li>
<li><code>segment.isSingleSpanSegment()</code> ：TraceSegment 只有<strong>一个</strong> Span 。</li>
<li>TODO 【4010】</li>
</ul>
</li>
<li>第 450 行：调用 <a href="https://github.com/YunaiV/skywalking/blob/7b39e952da408f722a53168e6d6a0cd7e7ff372f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L476" rel="external nofollow noopener noreferrer" target="_blank"><code>TracingContext.ListenerManager#notifyFinish(TraceSegment)</code></a> 方法，通知监听器，一次 TraceSegment 完成。通过这样的方式，TraceSegment 会被 <a href="https://github.com/YunaiV/skywalking/blob/7b39e952da408f722a53168e6d6a0cd7e7ff372f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/remote/TraceSegmentServiceClient.java#L157" rel="external nofollow noopener noreferrer" target="_blank">TraceSegmentServiceClient</a> <strong>异步</strong>发送给 Collector 。下一篇文章，我们详细分享发送的过程。</li>
</ul>
<h3 id="3-2-2-IgnoredTracerContext"><a href="#3-2-2-IgnoredTracerContext" class="headerlink" title="3.2.2 IgnoredTracerContext"></a>3.2.2 IgnoredTracerContext</h3><p><a href="https://github.com/YunaiV/skywalking/blob/7b39e952da408f722a53168e6d6a0cd7e7ff372f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/IgnoredTracerContext.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.IgnoredTracerContext</code></a> ，实现 AbstractTracerContext 接口，忽略( <strong>不记录</strong> )链路追踪的上下文。代码如下：</p>
<ul>
<li><code>NOOP_SPAN</code> <strong>静态</strong>属性，NoopSpan 单例。<ul>
<li>所有的创建 Span 方法，返回的都是该对象。</li>
</ul>
</li>
<li><code>stackDepth</code> 属性，栈深度。<ul>
<li>不同于 TracingContext 使用<strong>链式数组</strong>来处理 Span 的<strong>出入栈</strong>，IgnoredTracerContext 使用 <code>stackDepth</code> 来计数，从而实现<strong>出入栈</strong>的效果。</li>
</ul>
</li>
<li>通过这两个属性和相应<strong>空</strong>方法的实现，以减少 NoopSpan 时的对象创建，达到减少内存使用和 GC 时间。</li>
</ul>
<p>代码比较简单，胖友自己阅读该类的实现。</p>
<h3 id="3-2-3-ContextCarrier"><a href="#3-2-3-ContextCarrier" class="headerlink" title="3.2.3 ContextCarrier"></a>3.2.3 ContextCarrier</h3><p><a href="https://github.com/YunaiV/skywalking/blob/4c4c62d0d5ec2ce17e3d36cad0f6598247b582e1/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ContextCarrier.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.ContextCarrier</code></a> ，实现 <code>java.io.Serializable</code> 接口，<strong>跨进程</strong> Context 传输<strong>载体</strong>。</p>
<h4 id="3-2-3-1-解压"><a href="#3-2-3-1-解压" class="headerlink" title="3.2.3.1 解压"></a>3.2.3.1 解压</h4><p>我们来打开 <a href="https://github.com/YunaiV/skywalking/blob/4c4c62d0d5ec2ce17e3d36cad0f6598247b582e1/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegmentRef.java#L97" rel="external nofollow noopener noreferrer" target="_blank"><code>#TraceSegmentRef(ContextCarrier)</code></a> <strong>构造</strong>方法，该方法用于将 ContextCarrier 转换成 TraceSegmentRef ，对比下两者的属性，<strong>基本一致</strong>，差异如下：</p>
<ul>
<li><code>peerHost</code> 属性，节点地址。<ul>
<li>当字符串<strong>不</strong>以 <code>#</code> 号开头，代表节点编号，格式为 <code>${peerId}</code> ，例如 <code>&quot;123&quot;</code> 。</li>
<li>当字符串以 <code>#</code> 号开头，代表地址，格式为 <code>${peerHost}</code> ，例如 <code>&quot;192.168.16.1:8080&quot;</code> 。</li>
</ul>
</li>
<li><code>entryOperationName</code> 属性，入口操作名。<ul>
<li>当字符串<strong>不</strong>以 <code>#</code> 号开头，代表入口操作编号，格式为 <code>#${entryOperationId}</code> ，例如 <code>&quot;666&quot;</code> 。</li>
<li>当字符串以 <code>#</code> 号开头，代表入口操作名，格式为 <code>#${entryOperationName}</code> ，例如 <code>&quot;#user/login&quot;</code> 。</li>
</ul>
</li>
<li><code>parentOperationName</code> 属性，父操作名。类似 <code>entryOperationName</code> 属。</li>
<li><code>primaryDistributedTraceId</code> 属性，分布式链路追踪<strong>全局</strong>编号。<strong>它不在此处处理，而在 <code>TracingContext#extract(ContextCarrier)</code> 方法中</strong>。</li>
</ul>
<p>在 <a href="https://github.com/YunaiV/skywalking/blob/49dc81a8bcaad1879b3a3be9917944b0b8b5a7a4/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ContextManager.java#L127" rel="external nofollow noopener noreferrer" target="_blank"><code>ContextManager#createEntrySpan(operationName, carrier)</code></a> 方法中，当<strong>存在</strong> ContextCarrier 传递时，创建 Context 后，会将 ContextCarrier <strong>解压</strong>到 Context 中，以达到跨进程传播。<a href="https://github.com/YunaiV/skywalking/blob/4c4c62d0d5ec2ce17e3d36cad0f6598247b582e1/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L147" rel="external nofollow noopener noreferrer" target="_blank"><code>TracingContext#extract(ContextCarrier)</code></a> 方法，代码如下：</p>
<ul>
<li>第 148 行：将 ContextCarrier 转换成 TraceSegmentRef 对象，调用 <code>TraceSegment#ref(TraceSegmentRef)</code> 方法，进行指向父 TraceSegment。</li>
<li>第 149 行：调用 <code>TraceSegment#relatedGlobalTraces(DistributedTraceId)</code> 方法，将传播的分布式链路追踪<strong>全局</strong>编号，添加到 TraceSegment 中，进行指向<strong>全局</strong>编号。</li>
</ul>
<p>另外，ContextManager <strong>单独</strong>提供 <a href="https://github.com/YunaiV/skywalking/blob/49dc81a8bcaad1879b3a3be9917944b0b8b5a7a4/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ContextManager.java#L161" rel="external nofollow noopener noreferrer" target="_blank"><code>#extract(ContextCarrier)</code></a> 方法，将<strong>多个</strong> ContextCarrier 注入到<strong>一个</strong> Context 中，从而解决”<strong>多个爸爸</strong>“的场景，例如 RocketMQ 插件的 <a href="https://github.com/YunaiV/skywalking/blob/49dc81a8bcaad1879b3a3be9917944b0b8b5a7a4/apm-sniffer/apm-sdk-plugin/rocketMQ-4.x-plugin/src/main/java/org/skywalking/apm/plugin/rocketMQ/v4/AbstractMessageConsumeInterceptor.java#L56" rel="external nofollow noopener noreferrer" target="_blank"><code>AbstractMessageConsumeInterceptor#beforeMethod(...)</code></a> 方法。</p>
<h4 id="3-2-3-2-注入"><a href="#3-2-3-2-注入" class="headerlink" title="3.2.3.2 注入"></a>3.2.3.2 注入</h4><p>在 <a href="https://github.com/YunaiV/skywalking/blob/4c4c62d0d5ec2ce17e3d36cad0f6598247b582e1/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ContextManager.java#L152" rel="external nofollow noopener noreferrer" target="_blank"><code>ContextManager#createExitSpan(operationName, carrier, remotePeer)</code></a> 方法中，当<strong>需要</strong> Context <strong>跨进程</strong>传递时，将 Context <strong>注入</strong>到 ContextCarrier 中，为 <a href="#">「3.2.3.3 传输」</a> 做准备。<a href="https://github.com/YunaiV/skywalking/blob/23c2146c134e0ef0a37a43758a1e04727de7697a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L87" rel="external nofollow noopener noreferrer" target="_blank"><code>TracingContext#inject(ContextCarrier)</code></a> 方法，代码比较易懂，胖友自己阅读理解。</p>
<h4 id="3-2-3-3-传输"><a href="#3-2-3-3-传输" class="headerlink" title="3.2.3.3 传输"></a>3.2.3.3 传输</h4><blockquote>
<p>友情提示：胖友，请先阅读 <a href="https://github.com/apache/incubator-skywalking/blob/master/docs/cn/Skywalking-Cross-Process-Propagation-Headers-Protocol-CN-v1.md" rel="external nofollow noopener noreferrer" target="_blank">《Skywalking Cross Process Propagation Headers Protocol》</a> 。</p>
</blockquote>
<p><a href="https://github.com/YunaiV/skywalking/blob/dd6d9bff2d160f3aa60bc0be5152c49ecc9d94a4/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/CarrierItem.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.CarrierItem</code></a> ，传输载体<strong>项</strong>。代码如：</p>
<ul>
<li><code>headKey</code> 属性，Header 键。</li>
<li><code>headValue</code> 属性，Header 值。</li>
<li><code>next</code> 属性，下一个项。</li>
</ul>
<p>CarrierItem 有两个子类：</p>
<ul>
<li><a href="https://github.com/YunaiV/skywalking/blob/dd6d9bff2d160f3aa60bc0be5152c49ecc9d94a4/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/CarrierItemHead.java" rel="external nofollow noopener noreferrer" target="_blank">CarrierItemHead</a> ：Carrier 项的头( Head )，即首个元素。</li>
<li><a href="https://github.com/YunaiV/skywalking/blob/dd6d9bff2d160f3aa60bc0be5152c49ecc9d94a4/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/SW3CarrierItem.java" rel="external nofollow noopener noreferrer" target="_blank">SW3CarrierItem</a> ：<code>header = sw3</code> ，用于传输 ContextCarrier 。</li>
</ul>
<p>如下是 Dubbo 插件，使用 CarrierItem 的代码例子：<img src="http://www.iocoder.cn/images/SkyWalking/2020_10_01/07.png" alt=""></p>
<ul>
<li><a href="https://github.com/YunaiV/skywalking/blob/dd6d9bff2d160f3aa60bc0be5152c49ecc9d94a4/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ContextCarrier.java#L110" rel="external nofollow noopener noreferrer" target="_blank"><code>ContextCarrier#serialize()</code></a></li>
<li><a href="https://github.com/YunaiV/skywalking/blob/dd6d9bff2d160f3aa60bc0be5152c49ecc9d94a4/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ContextCarrier.java#L131" rel="external nofollow noopener noreferrer" target="_blank"><code>ContextCarrier#deserialize(text)</code></a></li>
</ul>
<h3 id="3-2-4-ContextSnapshot"><a href="#3-2-4-ContextSnapshot" class="headerlink" title="3.2.4 ContextSnapshot"></a>3.2.4 ContextSnapshot</h3><p><a href="https://github.com/YunaiV/skywalking/blob/dd6d9bff2d160f3aa60bc0be5152c49ecc9d94a4/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ContextSnapshot.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.context.ContextSnapshot</code></a> ，<strong>跨线程</strong> Context 传递<strong>快照</strong>。和 ContextCarrier 基本一致，由于不需要<strong>跨进程传输</strong>，可以少<strong>传递</strong>一些属性：</p>
<ul>
<li><code>parentApplicationInstanceId</code> </li>
<li><code>peerHost</code></li>
</ul>
<p>ContextSnapshot 和 ContextCarrier 比较类似，笔者就列举一些方法：</p>
<ul>
<li><a href="https://github.com/YunaiV/skywalking/blob/dd6d9bff2d160f3aa60bc0be5152c49ecc9d94a4/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/trace/TraceSegmentRef.java#L126" rel="external nofollow noopener noreferrer" target="_blank"><code>#TraceSegmentRef(ContextSnapshot)</code></a></li>
<li><a href="https://github.com/YunaiV/skywalking/blob/23c2146c134e0ef0a37a43758a1e04727de7697a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L163" rel="external nofollow noopener noreferrer" target="_blank"><code>TracingContext#capture()</code></a></li>
<li><a href="https://github.com/YunaiV/skywalking/blob/23c2146c134e0ef0a37a43758a1e04727de7697a/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/TracingContext.java#L205" rel="external nofollow noopener noreferrer" target="_blank"><code>TracingContext#continued(ContextSnapshot)</code></a></li>
</ul>
<h2 id="3-3-SamplingService"><a href="#3-3-SamplingService" class="headerlink" title="3.3 SamplingService"></a>3.3 SamplingService</h2><p><a href="https://github.com/YunaiV/skywalking/blob/7b39e952da408f722a53168e6d6a0cd7e7ff372f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/sampling/SamplingService.java" rel="external nofollow noopener noreferrer" target="_blank"><code>org.skywalking.apm.agent.core.sampling.SamplingService</code></a> ，实现 Service 接口，Agent 抽样服务。该服务的作用是，如何对 TraceSegment 抽样收集。考虑到如果每条 TraceSegment 都进行追踪，会带来一定的 CPU ( 用于序列化与反序列化 ) 和网络的开销。通过配置 <code>Config.Agent.SAMPLE_N_PER_3_SECS</code> 属性，设置<strong>每三秒</strong>，收集 TraceSegment 的条数。默认情况下，不开启抽样服务，即全部收集。</p>
<p>代码如下：</p>
<ul>
<li><code>on</code> 属性，是否开启抽样服务。</li>
<li><code>samplingFactorHolder</code> 属性，抽样计数器。通过定时任务，每三秒重置一次。</li>
<li><code>scheduledFuture</code> 属性，定时任务。</li>
<li><code>#boot()</code> <strong>实现</strong>方法，若开启抽样服务( <code>Config.Agent.SAMPLE_N_PER_3_SECS &gt; 0</code> ) 时，创建定时任务，每三秒，调用一次 <code>#resetSamplingFactor()</code> 方法，重置计数器。</li>
<li><code>#trySampling()</code> 方法，若开启抽样服务，判断是否超过每三秒的抽样<strong>上限</strong>。若不是，返回 <code>true</code> ，并增加计数器。否则，返回 <code>false</code> 。</li>
<li><code>#forceSampled()</code> 方法，<strong>强制</strong>增加计数器加一。一般情况下，该方法用于链路追踪上下文传播时，被调用服务必须记录链路，参见调用处的<a href="https://github.com/YunaiV/skywalking/blob/7b39e952da408f722a53168e6d6a0cd7e7ff372f/apm-sniffer/apm-agent-core/src/main/java/org/skywalking/apm/agent/core/context/ContextManager.java#L123" rel="external nofollow noopener noreferrer" target="_blank">代码</a>。</li>
<li><code>#resetSamplingFactor()</code> 方法，重置计数器。</li>
</ul>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>元旦很认真( 硬憋 )出一篇”硬货”。哈哈哈。</p>
<p>由于篇幅较长，内容略多，如果有错误的或者解释不清晰的，烦请胖友斧正。</p>
<p><img src="http://www.iocoder.cn/images/SkyWalking/2020_10_01/08.png" alt=""></p>
<p>胖友，分享个朋友圈可好？</p>
  
	</div>
		<footer class="article-footer clearfix">


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/SkyWalking/">SkyWalking</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://www.iocoder.cn/SkyWalking/agent-collect-trace/" data-title="SkyWalking 源码分析 —— Agent 收集 Trace 数据 | 芋道源码 —— 纯源码解析BLOG" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev">
 <a href="/SkyWalking/agent-send-trace/" title="SkyWalking 源码分析 —— Agent 发送 Trace 数据">
  <strong>PREVIOUS:</strong><br>
  <span>
  SkyWalking 源码分析 —— Agent 发送 Trace 数据</span>
</a>
</div>


<div class="next">
<a href="/SkyWalking/agent-dictionary/" title="SkyWalking 源码分析 —— Agent DictionaryManager 字典管理">
 <strong>NEXT:</strong><br> 
 <span>SkyWalking 源码分析 —— Agent DictionaryManager 字典管理
</span>
</a>
</div>

</nav>

	

</div>  
        <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="toc" class="toc-aside">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-概述"><span class="toc-number">1.</span> <span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Trace"><span class="toc-number">2.</span> <span class="toc-text">2. Trace</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-ID"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 ID</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-GlobalIdGenerator"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1 GlobalIdGenerator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-DistributedTraceId"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.2 DistributedTraceId</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-DistributedTraceIds"><span class="toc-number">2.1.3.</span> <span class="toc-text">2.1.3 DistributedTraceIds</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-AbstractSpan"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 AbstractSpan</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-Tag"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1 Tag</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-1-AbstractTag"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">2.2.1.1 AbstractTag</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-2-StringTag"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">2.2.1.2 StringTag</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-3-Tags"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">2.2.1.3 Tags</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-AbstractSpan-实现类"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2 AbstractSpan 实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-1-AbstractTracingSpan"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">2.2.2.1 AbstractTracingSpan</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-2-StackBasedTracingSpan"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">2.2.2.2 StackBasedTracingSpan</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-2-2-1-EntrySpan"><span class="toc-number">2.2.2.2.1.</span> <span class="toc-text">2.2.2.2.1 EntrySpan</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-2-2-2-ExitSpan"><span class="toc-number">2.2.2.2.2.</span> <span class="toc-text">2.2.2.2.2 ExitSpan</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-3-LocalSpan"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">2.2.2.3 LocalSpan</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-4-NoopSpan"><span class="toc-number">2.2.2.4.</span> <span class="toc-text">2.2.2.4 NoopSpan</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-2-3-1-NoopExitSpan"><span class="toc-number">2.2.2.4.1.</span> <span class="toc-text">2.2.2.3.1 NoopExitSpan</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-TraceSegmentRef"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 TraceSegmentRef</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-TraceSegment"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 TraceSegment</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Context"><span class="toc-number">3.</span> <span class="toc-text">3. Context</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-ContextManager"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 ContextManager</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-AbstractTracerContext"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 AbstractTracerContext</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-TracingContext"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1 TracingContext</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-1-创建-EntrySpan"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">3.2.1.1 创建 EntrySpan</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-2-创建-LocalSpan"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">3.2.1.2 创建 LocalSpan</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-3-创建-ExitSpan"><span class="toc-number">3.2.1.3.</span> <span class="toc-text">3.2.1.3 创建 ExitSpan</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-4-结束-Span"><span class="toc-number">3.2.1.4.</span> <span class="toc-text">3.2.1.4 结束 Span</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-IgnoredTracerContext"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2 IgnoredTracerContext</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-ContextCarrier"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.2.3 ContextCarrier</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-1-解压"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">3.2.3.1 解压</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-2-注入"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">3.2.3.2 注入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-3-传输"><span class="toc-number">3.2.3.3.</span> <span class="toc-text">3.2.3.3 传输</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-4-ContextSnapshot"><span class="toc-number">3.2.4.</span> <span class="toc-text">3.2.4 ContextSnapshot</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-SamplingService"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 SamplingService</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#666-彩蛋"><span class="toc-number">4.</span> <span class="toc-text">666. 彩蛋</span></a></li></ol>
</div>

<div id="asidepart">
    <!--<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>-->
    <aside class="clearfix">
        <div id="authorInfo">
            <!---->
            <!--<div class="author-logo"></div>-->
            <!---->

            <div> <img width="100%" src="/images/common/wechat_mp_2017_07_31_bak.jpg"> </div>

            <div class="social-list">
                
                
                
                
                
            </div>
        </div>

        
        <div class="categorieslist">
    <p class="asidetitle">微信公众号福利：芋道源码</p>
    <ul>

        <li> <a href="/images/common/wechat_mp_2017_07_31_bak.jpg"> 0. 阅读源码葵花宝典 </a></li>

        <li> <a href="/images/common/wechat_mp_2017_07_31_bak.jpg"> 1. RocketMQ / MyCAT / Sharding-JDBC 详细中文注释源码 </a> </li>

        <li> <a href="/images/common/wechat_mp_2017_07_31_bak.jpg"> 2. 您对于源码的疑问每条留言都将得到认真回复 </a> </li>

        <li> <a href="/images/common/wechat_mp_2017_07_31_bak.jpg"> 3. 新的源码解析文章实时收到通知，每周六十点更新 </a> </li>

        <li> <a href="/images/common/wechat_mp_2017_07_31_bak.jpg">4. 认真的源码交流微信群 </a> </li>


    </ul>
</div>
        
        
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
            
			    <li><a href="/categories/Docker/" title="Docker">Docker<sup>2</sup></a></li>
            
		
            
			    <li><a href="/categories/Dubbo/" title="Dubbo">Dubbo<sup>1</sup></a></li>
            
		
            
			    <li><a href="/categories/Elastic-Job-Cloud/" title="Elastic-Job-Cloud">Elastic-Job-Cloud<sup>6</sup></a></li>
            
		
            
			    <li><a href="/categories/Elastic-Job-Lite/" title="Elastic-Job-Lite">Elastic-Job-Lite<sup>16</sup></a></li>
            
		
            
			    <li><a href="/categories/Eureka/" title="Eureka">Eureka<sup>23</sup></a></li>
            
		
            
			    <li><a href="/categories/Happylifeplat-TCC/" title="Happylifeplat-TCC">Happylifeplat-TCC<sup>1</sup></a></li>
            
		
            
			    <li><a href="/categories/Hystrix/" title="Hystrix">Hystrix<sup>9</sup></a></li>
            
		
            
			    <li><a href="/categories/JUC/" title="JUC">JUC<sup>1</sup></a></li>
            
		
            
			    <li><a href="/categories/MyCAT/" title="MyCAT">MyCAT<sup>9</sup></a></li>
            
		
            
			    <li><a href="/categories/Nginx/" title="Nginx">Nginx<sup>1</sup></a></li>
            
		
            
			    <li><a href="/categories/RocketMQ/" title="RocketMQ">RocketMQ<sup>14</sup></a></li>
            
		
            
			    <li><a href="/categories/RxJava/" title="RxJava">RxJava<sup>5</sup></a></li>
            
		
            
			    <li><a href="/categories/Sharding-JDBC/" title="Sharding-JDBC">Sharding-JDBC<sup>18</sup></a></li>
            
		
            
			    <li><a href="/categories/SkyWalking/" title="SkyWalking">SkyWalking<sup>22</sup></a></li>
            
		
            
			    <li><a href="/categories/Spring/" title="Spring">Spring<sup>1</sup></a></li>
            
		
            
			    <li><a href="/categories/Spring-Cloud-Gateway/" title="Spring-Cloud-Gateway">Spring-Cloud-Gateway<sup>24</sup></a></li>
            
		
            
			    <li><a href="/categories/Spring-MVC/" title="Spring-MVC">Spring-MVC<sup>1</sup></a></li>
            
		
            
			    <li><a href="/categories/Spring-Security/" title="Spring-Security">Spring-Security<sup>1</sup></a></li>
            
		
            
			    <li><a href="/categories/TCC-Transaction/" title="TCC-Transaction">TCC-Transaction<sup>7</sup></a></li>
            
		
            
			    <li><a href="/categories/TiKV/" title="TiKV">TiKV<sup>2</sup></a></li>
            
		
            
			    <li><a href="/categories/工作内推/" title="工作内推">工作内推<sup>4</sup></a></li>
            
		
            
			    <li><a href="/categories/技术杂文/" title="技术杂文">技术杂文<sup>5</sup></a></li>
            
		
		</ul>
</div>

        
    </aside>
</div>
    </div>
    <footer><div id="footer">
    <img src="http://www.iocoder.cn/images/common/wechat_mp_simple.png" style="display: none">
    
            <p class="copyright"> © 2018 
		
		<a href="http://www.iocoder.cn" target="_blank" title="芋道源码">芋道源码</a>
		
            && <span style="display: inline;" id="busuanzi_container_site_uv">总访客数 <span id="busuanzi_value_site_uv" font="微软雅黑"></span> 次</span>
            && <span style="display: inline;" id="busuanzi_container_site_pv">总访问量 <span id="busuanzi_value_site_pv" font="微软雅黑"></span> 次</span>
            <!--&& Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a>-->
            <!--&& Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> && Theme by <a href="http://gengbiao.me" target="_blank" title="coney">coney</a>-->
            </p></div>
            <div class="copyright">沪ICP备17037075号-1</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>






<link rel="stylesheet" href="/alert/css/alert.css">
<script src="/alert/js/alert.js"></script>
<script src="/js/jquery.cookie.js"></script>
<script src="/js/util.js"></script>





<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-107572620-1', 'auto');  
ga('send', 'pageview');
</script>

  </body>


