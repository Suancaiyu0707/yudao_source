
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">

    <meta name="google-site-verification" content="GkJ68PCnxM9Ih7Zm9v8p91FOCV7ymNCO2KdGbflLh3E">
    <meta name="360-site-verification" content="dd6547587641bfede036f7c79561e8a0">
    <meta name="shenma-site-verification" content="fd96cf3751972c9b05f8471d2ccadddc_1496951214">
    <meta name="msvalidate.01" content="1D38B05050A977F6FDEDA481198343F1">
    <meta name="sogou_site_verification" content="MpPsku240L">

  
    <title>TCC-Transaction 源码分析 —— TCC 实现 | 芋道源码 —— 纯源码解析博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="芋道源码">
    
    <meta name="description" content="摘要: 原创出处 http://www.iocoder.cn/TCC-Transaction/tcc-core 「芋道源码」欢迎转载，保留摘要，谢谢！
本文主要基于 TCC-Transaction 1.2.3.3 正式版

1. 概述
2. TCC 原理
3. TCC-Transaction 原理
">
    

    
    <meta name="keywords" content="Java,架构,后端,服务端,RocketMQ,MyCAT,分布式消息队列,分布式存储,技术博客,Sharding-JDBC,分库分表">
    

    
    
    <link rel="alternate" href="atom.xml" title="芋道源码 —— 纯源码解析博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/images/favicon.ico">
    
    
    <link rel="stylesheet" href="/css/style.css">
    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            var _bdId ='9e70e3362807c1bd185a79655b307027';
             hm.src = "//hm.baidu.com/hm.js?" + _bdId;
             var s = document.getElementsByTagName("script")[0]; 
             s.parentNode.insertBefore(hm, s);
        })();
    </script>
    

    <!-- 百度站长-被动推送 -->
    <script>
        (function(){
            var bp = document.createElement('script');
            var curProtocol = window.location.protocol.split(':')[0];
            if (curProtocol === 'https') {
                bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
            }
            else {
                bp.src = 'http://push.zhanzhang.baidu.com/push.js';
            }
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(bp, s);
        })();
    </script>

    <!-- 360搜索-自动收录 -->
    <script>
        (function(){
            var src = (document.location.protocol == "http:") ? "http://js.passport.qihucdn.com/11.0.1.js?f05b61dd54bbc38386611a5238672938":"https://jspassport.ssl.qhimg.com/11.0.1.js?f05b61dd54bbc38386611a5238672938";
            document.write('<script src="' + src + '" id="sozz"><\/script>');
        })();
    </script>

    <!-- 不蒜子统计 -->
    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</head>
</html>
  <body>
    <header>
      <div>
    
    <div id="textlogo">
        <h1 class="site-name"><a href="/" title="芋道源码 —— 纯源码解析博客">芋道源码 —— 纯源码解析博客</a></h1>
        <a class="blog-motto">
            
            愿半生编码，如一生老友！
            
        </a>
    </div>
    <div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
        </a></div>
    <nav class="animated">
        <ul>
            <ul>
                
                <li><a href="/">文章</a></li>
                
                <li><a href="/2018-meet-you">知识星球</a></li>
                
                <li><a href="https://github.com/YunaiV" rel="external nofollow noopener noreferrer" target="_blank">Github</a></li>
                
                <li><a href="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31_bak.jpg">微信公众号</a></li>
                
                <li><a href="/categories/%E5%B7%A5%E4%BD%9C%E5%86%85%E6%8E%A8/">工作内推</a></li>
                
                <li><a href="/link_url">友链</a></li>
                
                <!--<li>-->
                    <!---->
                        <!--<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">-->
                            <!--<label>Search</label>-->
                            <!--<input type="text" id="search" name="q" autocomplete="off" maxlength="20"-->
                                   <!--placeholder="搜索"/>-->
                            <!--<input type="hidden" name="q" value="site:www.iocoder.cn">-->
                        <!--</form>-->
                        <!---->
                <!--</li>-->
            </ul>
    </ul></nav>
</div>

    </header>
    <div id="container">

        <div id="main" class="post" itemscope="" itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/TCC-Transaction/tcc-core/" title="TCC-Transaction 源码分析 —— TCC 实现" itemprop="url">TCC-Transaction 源码分析 —— TCC 实现</a>
  </h1>
  <p class="article-author">
      <!--By-->
    <!---->
      <!--<a href="http://www.iocoder.cn" title="芋道源码">芋道源码</a>-->
    <!---->
  </p>
  <p class="article-time">
    <!--<time datetime="2018-02-07T16:00:00.000Z" itemprop="datePublished">2018-02-08</time>-->
    <!--更新日期:<time datetime="2018-02-24T15:07:31.000Z" itemprop="dateModified">2018-02-24</time>-->
    <!---->
      总阅读量:<span id="busuanzi_value_page_pv"></span>次
  </p>
</header>
	<div class="article-content">
		
		
		<p>摘要: 原创出处 http://www.iocoder.cn/TCC-Transaction/tcc-core 「芋道源码」欢迎转载，保留摘要，谢谢！</p>
<p><strong>本文主要基于 TCC-Transaction 1.2.3.3 正式版</strong></p>
<ul>
<li><a href="http://www.iocoder.cn//">1. 概述</a></li>
<li><a href="http://www.iocoder.cn//">2. TCC 原理</a></li>
<li><a href="http://www.iocoder.cn//">3. TCC-Transaction 原理</a></li>
<li><a href="http://www.iocoder.cn//">4. 事务与参与者</a>
<ul>
<li><a href="http://www.iocoder.cn//">4.1 事务</a></li>
<li><a href="http://www.iocoder.cn//">4.2 参与者</a></li>
</ul>
</li>
<li><a href="http://www.iocoder.cn//">5. 事务管理器</a>
<ul>
<li><a href="http://www.iocoder.cn//">5.1 发起根事务</a></li>
<li><a href="http://www.iocoder.cn//">5.2 传播发起分支事务</a></li>
<li><a href="http://www.iocoder.cn//">5.3 传播获取分支事务</a></li>
<li><a href="http://www.iocoder.cn//">5.4 提交事务</a></li>
<li><a href="http://www.iocoder.cn//">5.5 回滚事务</a></li>
<li><a href="http://www.iocoder.cn//">5.6 添加参与者到事务</a></li>
</ul>
</li>
<li><a href="http://www.iocoder.cn//">6. 事务拦截器</a>
<ul>
<li><a href="http://www.iocoder.cn//">6.1 Compensable</a></li>
<li><a href="http://www.iocoder.cn//">6.2 可补偿事务拦截器</a></li>
<li><a href="http://www.iocoder.cn//">6.3 资源协调者拦截器</a></li>
</ul>
</li>
<li><a href="http://www.iocoder.cn//">666. 彩蛋</a></li>
</ul>
<hr>
<p><img src="http://www.iocoder.cn/images/common/wechat_mp_2017_07_31.jpg" alt=""></p>
<blockquote>
<p>🙂🙂🙂关注**微信公众号：【芋道源码】**有福利：</p>
<ol>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
<li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
<li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
<li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
<li><strong>认真的</strong>源码交流微信群。</li>
</ol>
</blockquote>
<hr>
<h1>1. 概述</h1>
<p>本文分享 <strong>TCC 实现</strong>。主要涉及如下三个 Maven 项目：</p>
<ul>
<li><code>tcc-transaction-core</code> ：tcc-transaction 底层实现。</li>
<li><code>tcc-transaction-api</code> ：tcc-transaction 使用 API。</li>
<li><code>tcc-transaction-spring</code> ：tcc-transaction Spring 支持。</li>
</ul>
<blockquote>
<p>你行好事会因为得到赞赏而愉悦<br>
同理，开源项目贡献者会因为 Star 而更加有动力<br>
为 TCC-Transaction 点赞！<a href="https://github.com/changmingxie/tcc-transaction" rel="external nofollow noopener noreferrer" target="_blank">传送门</a></p>
</blockquote>
<p>OK，开始我们的第一段 TCC 旅程吧。</p>
<p>ps：笔者假设你已经阅读过<a href="https://github.com/changmingxie/tcc-transaction/wiki/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%971.2.x" rel="external nofollow noopener noreferrer" target="_blank">《tcc-transaction 官方文档 —— 使用指南1.2.x》</a>。</p>
<p>ps2：<strong>未特殊说明的情况下，本文事务指的是 TCC事务</strong>。</p>
<h1>2. TCC 原理</h1>
<blockquote>
<p>FROM https://support.hwclouds.com/devg-servicestage/zh-cn_topic_0056814426.html<br>
<strong>TCC事务</strong><br>
为了解决在事务运行过程中大颗粒度资源锁定的问题，业界提出一种新的事务模型，它是基于<strong>业务层面</strong>的事务定义。锁粒度完全由业务自己控制。它本质是一种补偿的思路。它把事务运行过程分成 Try、Confirm / Cancel 两个阶段。在每个阶段的逻辑由<strong>业务代码控制</strong>。这样就事务的锁粒度可以完全自由控制。业务可以在牺牲隔离性的情况下，获取更高的性能。</p>
</blockquote>
<ul>
<li>Try 阶段
<ul>
<li>Try ：尝试执行业务
<ul>
<li>完成所有业务检查( 一致性 )</li>
<li>预留必须业务资源( 准隔离性 )</li>
</ul>
</li>
</ul>
</li>
<li>Confirm / Cancel 阶段：
<ul>
<li>Confirm ：确认执行业务
<ul>
<li>真正执行业务</li>
<li>不做任务业务检查</li>
<li>Confirm 操作满足幂等性</li>
</ul>
</li>
<li>Cancel ：取消执行业务
<ul>
<li>释放 Try 阶段预留的业务资源</li>
<li>Cancel 操作满足幂等性</li>
</ul>
</li>
<li>Confirm 与 Cancel 互斥</li>
</ul>
</li>
</ul>
<p>整体流程如下图：</p>
<p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_02_08/01.jpeg" alt=""></p>
<ul>
<li>
<p><strong>红框部分</strong>功能由 <code>tcc-transaction-core</code> 实现：</p>
<ul>
<li>启动业务活动</li>
<li>登记业务操作</li>
<li>提交 / 回滚业务活动</li>
</ul>
</li>
<li>
<p><strong>黄框部分</strong>功能由 <code>tcc-transaction-http-sample</code> 实现( 官方提供的示例项目 )：</p>
<ul>
<li>Try 操作</li>
<li>Confirm 操作</li>
<li>Cancel 操作</li>
</ul>
</li>
</ul>
<p><strong>与 2PC协议 比较</strong>：</p>
<ul>
<li>位于业务服务层而非自愿层</li>
<li>没有单独的准备( Prepare )阶段，Try 操作兼备自愿操作与准备能力</li>
<li>Try 操作可以灵活选择业务资源的锁定粒度</li>
<li>较高开发成本</li>
</ul>
<p>参考资料：</p>
<ul>
<li><a href="https://www.zhihu.com/question/31813039" rel="external nofollow noopener noreferrer" target="_blank">《支付宝运营架构中柔性事务指的是什么？》</a></li>
<li><a href="http://kaimingwan.com/post/fen-bu-shi/fen-bu-shi-shi-wu-de-dian-xing-chu-li-fang-shi-2pc-tcc-yi-bu-que-bao-he-zui-da-nu-li-xing" rel="external nofollow noopener noreferrer" target="_blank">《分布式事务的典型处理方式:2PC、TCC、异步确保和最大努力型》</a></li>
</ul>
<h1>3. TCC-Transaction 原理</h1>
<p>在 TCC 里，一个业务活动可以有多个事务，每个业务操作归属于不同的事务，即一个事务可以包含多个业务操作。TCC-Transaction 将每个业务操作抽象成<strong>事务参与者</strong>，每个事务可以包含多个<strong>参与者</strong>。</p>
<p>参与者需要声明 try / confirm / cancel 三个类型的方法，和 TCC 的操作一一对应。在程序里，通过 @Compensable 注解标记在 try 方法上，并填写对应的 confirm / cancel 方法，示例代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// try</span></div><div class="line"><span class="meta">@Compensable</span>(confirmMethod = <span class="string">"confirmRecord"</span>, cancelMethod = <span class="string">"cancelRecord"</span>, transactionContextEditor = MethodTransactionContextEditor.class)</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">record</span><span class="params">(TransactionContext transactionContext, CapitalTradeOrderDto tradeOrderDto)</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// confirm</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirmRecord</span><span class="params">(TransactionContext transactionContext, CapitalTradeOrderDto tradeOrderDto)</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// cancel</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelRecord</span><span class="params">(TransactionContext transactionContext, CapitalTradeOrderDto tradeOrderDto)</span> </span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>在示例代码中，我们看到 TransactionContext，事务上下文，这个是怎么生成的呢？这里先卖一个关子。</li>
</ul>
<p>TCC-Transaction 有两个拦截器，通过对 @Compensable AOP 切面( 参与者 try 方法 )进行拦截，透明化对参与者 confirm / cancel 方法调用，从而实现 TCC 。<strong>简化</strong>流程如下图：</p>
<p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_02_08/03.png" alt=""></p>
<p>第一个拦截器，可补偿事务拦截器，实现如下功能：</p>
<ul>
<li>在 Try 阶段，对事务的发起、传播。</li>
<li>在 Confirm / Cancel 阶段，对事务提交或回滚。</li>
<li><strong>为什么会有对事务的传播呢</strong>？在远程调用服务的参与者时，会通过**&quot;参数&quot;**( 需要序列化 )的形式传递事务给远程参与者。</li>
</ul>
<p>第二个拦截器，资源协调者拦截器，实现如下功能：</p>
<ul>
<li>在 Try 阶段，添加参与者到事务中。当事务上下文不存在时，进行创建。</li>
</ul>
<p>实际拦截器对事务的处理会比上图复杂一些，在本文<a href="#">「6. 事务拦截器」</a>详细解析。</p>
<p>在 TCC-Transaction 代码实现上，组件分层如下图：</p>
<p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_02_08/04.png" alt=""></p>
<p>本文按照如下顺序分享：</p>
<ul>
<li><a href="#">「4. 事务拦截器」</a></li>
<li><a href="#">「5. 事务管理器」</a></li>
<li><a href="#">「6. 事务管理器」</a></li>
</ul>
<p>内容是<strong>自下而上</strong>的方式分享，每个组件可以更加整体的被认识。当然这可能对你理解时产生一脸闷逼，所以推荐两种阅读方式：</p>
<ul>
<li>简读 x 1 + 深读 x 1</li>
<li>倒着读，发现未分享的方法，全文检索该方法。</li>
</ul>
<p>事务存储器在<a href="http://www.iocoder.cn/TCC-Transaction/transaction-repository/?self">《TCC-Transaction 源码解析 —— 事务存储于恢复》</a>详细解析。</p>
<p>事务恢复在<a href="http://www.iocoder.cn/TCC-Transaction/transaction-recovery/?self">《TCC-Transaction 源码解析 —— 事务恢复》</a>详细解析。</p>
<h1>4. 事务与参与者</h1>
<p>在 TCC 里，<strong>一个</strong>事务( <code>org.mengyun.tcctransaction.Transaction</code> ) 可以有<strong>多个</strong>参与者( <code>org.mengyun.tcctransaction.Participant</code> )参与业务活动。类图关系如下( <a href="http://www.iocoder.cn/images/TCC-Transaction/2018_02_08/02.png">打开大图</a> )：</p>
<p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_02_08/02.png" alt=""></p>
<h2>4.1 事务</h2>
<p><strong>Transaction 实现代码如下</strong>：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7291423944314337931L</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 事务编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> TransactionXid xid;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 事务状态</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> TransactionStatus status;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 事务类型</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> TransactionType transactionType;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 重试次数</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> retriedCount = <span class="number">0</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 创建时间</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Date createTime = <span class="keyword">new</span> Date();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 最后更新时间</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Date lastUpdateTime = <span class="keyword">new</span> Date();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 版本号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> version = <span class="number">1</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 参与者集合</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> List&lt;Participant&gt; participants = <span class="keyword">new</span> ArrayList&lt;Participant&gt;();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 附带属性映射</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; attachments = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;();</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 添加参与者</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> participant 参与者</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enlistParticipant</span><span class="params">(Participant participant)</span> </span>&#123;</div><div class="line">        participants.add(participant);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 提交 TCC 事务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Participant participant : participants) &#123;</div><div class="line">            participant.commit();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 回滚 TCC 事务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Participant participant : participants) &#123;</div><div class="line">            participant.rollback();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>xid，事务编号( TransactionXid )，用于唯一标识一个事务。使用 UUID 算法生成，<strong>保证唯一性</strong>。<code>org.mengyun.tcctransaction.api.TransactionXid</code> 实现 <a href="https://docs.oracle.com/javase/8/docs/api/javax/transaction/xa/Xid.html" rel="external nofollow noopener noreferrer" target="_blank"><code>javax.transaction.xa.Xid</code></a> 接口，实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionXid</span> <span class="keyword">implements</span> <span class="title">Xid</span>, <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6817267250789142043L</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * xid 格式标识符</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> formatId = <span class="number">1</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 全局事务编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] globalTransactionId;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 分支事务编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] branchQualifier;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>TODO 为什么要继承 Xid 接口？</li>
</ul>
</li>
<li>
<p>status，事务状态( TransactionStatus )。<code>org.mengyun.tcctransaction.api.TransactionStatus</code> 实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> TransactionStatus &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 尝试中状态</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    TRYING(<span class="number">1</span>),</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 确认中状态</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    CONFIRMING(<span class="number">2</span>),</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 取消中状态</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    CANCELLING(<span class="number">3</span>);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>transactionType，事务类型( TransactionType )。<code>org.mengyun.tcctransaction.common.TransactionType</code> 实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> TransactionType &#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 根事务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    ROOT(<span class="number">1</span>),</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 分支事务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    BRANCH(<span class="number">2</span>);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> id;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>在<a href="#">「6.2 可补偿事务拦截器」</a>有详细解析，可以看到看到这两种事务是如何发起。</li>
</ul>
</li>
<li>
<p>retriedCount，重试次数。在 TCC 过程中，可能参与者异常崩溃，这个时候会进行重试直到成功或超过最大次数。在<a href="http://www.iocoder.cn/TCC-Transaction/transaction-recovery/?self">《TCC-Transaction 源码解析 —— 事务恢复》</a>详细解析。</p>
</li>
<li>
<p>version，版本号，用于乐观锁更新事务。在<a href="http://www.iocoder.cn/TCC-Transaction/transaction-repository/?self">《TCC-Transaction 源码解析 —— 事务存储器》</a>详细解析。</p>
</li>
<li>
<p>attachments，附带属性映射。在<a href="http://www.iocoder.cn/TCC-Transaction/dubbo-support/?self">《TCC-Transaction 源码解析 —— Dubbo 支持》</a>详细解析。</p>
</li>
<li>
<p>提供 <code>#enlistParticipant()</code> 方法，添加事务参与者。</p>
</li>
<li>
<p>提供 <code>#commit()</code> 方法，调用参与者们提交事务。</p>
</li>
<li>
<p>提供 <code>#rollback()</code> 方法，调用参与者回滚事务。</p>
</li>
</ul>
<h2>4.2 参与者</h2>
<p><strong>Participant 实现代码如下</strong>：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Participant</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4127729421281425247L</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 事务编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> TransactionXid xid;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 确认执行业务方法调用上下文</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> InvocationContext confirmInvocationContext;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 取消执行业务方法</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> InvocationContext cancelInvocationContext;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 执行器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Terminator terminator = <span class="keyword">new</span> Terminator();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 事务上下文编辑</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    Class&lt;? extends TransactionContextEditor&gt; transactionContextEditorClass;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 提交事务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</div><div class="line">        terminator.invoke(<span class="keyword">new</span> TransactionContext(xid, TransactionStatus.CONFIRMING.getId()), confirmInvocationContext, transactionContextEditorClass);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 回滚事务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span>&#123;</div><div class="line">        terminator.invoke(<span class="keyword">new</span> TransactionContext(xid, TransactionStatus.CANCELLING.getId()), cancelInvocationContext, transactionContextEditorClass);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>xid，参与者事务编号。通过 <code>TransactionXid.globalTransactionId</code> 属性，关联上其所属的事务。当参与者进行远程调用时，远程的<strong>分支</strong>事务的事务编号等于该参与者的事务编号。通过事务编号的关联，TCC Confirm / Cancel 阶段，使用参与者的事务编号和远程的<strong>分支</strong>事务进行关联，从而实现事务的提交和回滚，在<a href="#">「5.2 传播发起分支事务」 + 「6.2 可补偿事务拦截器」</a>可以看到具体实现。</p>
</li>
<li>
<p>confirmInvocationContext，确认执行业务方法调用上下文( InvocationContext )。<code>org.mengyun.tcctransaction.InvocationContext</code> 实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvocationContext</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7969140711432461165L</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 类</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Class targetClass;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 方法名</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> String methodName;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 参数类型数组</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Class[] parameterTypes;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 参数数组</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Object[] args;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>InvocationContext，执行方法调用上下文，记录类、方法名、参数类型数组、参数数组。通过这些属性，可以执行提交 / 回滚事务。在 <code>org.mengyun.tcctransaction.Terminator</code> 会看到具体的代码实现。<strong>本质上，TCC 通过多个参与者的 try / confirm / cancel 方法，实现事务的最终一致性</strong>。</li>
</ul>
</li>
<li>
<p>cancelInvocationContext，取消执行业务方法调用上下文( InvocationContext )。</p>
</li>
<li>
<p>terminator，执行器( Terminator )。<code>org.mengyun.tcctransaction.Terminator</code> 实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Terminator</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">164958655471605778L</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(TransactionContext transactionContext, InvocationContext invocationContext, Class&lt;? extends TransactionContextEditor&gt; transactionContextEditorClass)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(invocationContext.getMethodName())) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 获得 参与者对象</span></div><div class="line">                Object target = FactoryBuilder.factoryOf(invocationContext.getTargetClass()).getInstance();</div><div class="line">                <span class="comment">// 获得 方法</span></div><div class="line">                Method method = target.getClass().getMethod(invocationContext.getMethodName(), invocationContext.getParameterTypes());</div><div class="line">                <span class="comment">// 设置 事务上下文 到方法参数</span></div><div class="line">                FactoryBuilder.factoryOf(transactionContextEditorClass).getInstance().set(transactionContext, target, method, invocationContext.getArgs());</div><div class="line">                <span class="comment">// 执行方法</span></div><div class="line">                <span class="keyword">return</span> method.invoke(target, invocationContext.getArgs());</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SystemException(e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>FactoryBuilder，工厂 Builder，感兴趣的同学点击<a href="https://github.com/YunaiV/tcc-transaction/blob/8553baad29597603d9007d61aec3ea5201632d1b/tcc-transaction-core/src/main/java/org/mengyun/tcctransaction/support/FactoryBuilder.java" rel="external nofollow noopener noreferrer" target="_blank">链接</a>查看，已经添加完整中文代码注释。</li>
<li>TransactionContextEditor，在本文<a href="#">「6.1 Compensable」</a>详细解析。</li>
</ul>
</li>
<li>
<p>transactionContextEditorClass，事务上下文编辑，在<a href="#">「6.1 Compensable」</a>详细解析。</p>
</li>
<li>
<p>提交 <code>#commit()</code> 方法，提交参与者自己的事务。</p>
</li>
<li>
<p>提交 <code>#rollback()</code> 方法，回滚参与者自己的事务。</p>
</li>
</ul>
<h1>5. 事务管理器</h1>
<p><code>org.mengyun.tcctransaction.TransactionManager</code>，事务管理器，提供事务的获取、发起、提交、回滚，参与者的新增等等方法。</p>
<h2>5.1 发起根事务</h2>
<p>提供 <code>begin()</code> 方法，发起根事务。该方法在<strong>调用方法类型为 MethodType.ROOT 并且 事务处于 Try 阶段</strong>被调用。MethodType 在<a href="#">「6.2 可补偿事务拦截器」</a>详细解析。</p>
<p>实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TransactionManager.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 发起根事务</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 事务</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> Transaction <span class="title">begin</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 创建 根事务</span></div><div class="line">   Transaction transaction = <span class="keyword">new</span> Transaction(TransactionType.ROOT);</div><div class="line">   <span class="comment">// 存储 事务</span></div><div class="line">   transactionRepository.create(transaction);</div><div class="line">   <span class="comment">// 注册 事务</span></div><div class="line">   registerTransaction(transaction);</div><div class="line">   <span class="keyword">return</span> transaction;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>调用 Transaction 构造方法，创建<strong>根事务</strong>。实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Transaction.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 创建指定类型的事务</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> transactionType 事务类型</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Transaction</span><span class="params">(TransactionType transactionType)</span> </span>&#123;</div><div class="line">   <span class="keyword">this</span>.xid = <span class="keyword">new</span> TransactionXid();</div><div class="line">   <span class="keyword">this</span>.status = TransactionStatus.TRYING; <span class="comment">// 尝试中状态</span></div><div class="line">   <span class="keyword">this</span>.transactionType = transactionType;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>目前该构造方法只有 <code>TransactionManager#begin()</code> 在调用，即只创建<strong>根事务</strong>。</li>
</ul>
</li>
<li>
<p>调用 <code>TransactionRepository#crete()</code> 方法，存储事务。</p>
</li>
<li>
<p>调用 <code>#registerTransaction(...)</code> 方法，注册事务到当前线程事务队列。实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TransactionManager.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 当前线程事务队列</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Deque&lt;Transaction&gt;&gt; CURRENT = <span class="keyword">new</span> ThreadLocal&lt;Deque&lt;Transaction&gt;&gt;();</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 注册事务到当前线程事务队列</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> transaction 事务</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerTransaction</span><span class="params">(Transaction transaction)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (CURRENT.get() == <span class="keyword">null</span>) &#123;</div><div class="line">       CURRENT.set(<span class="keyword">new</span> LinkedList&lt;Transaction&gt;());</div><div class="line">   &#125;</div><div class="line">   CURRENT.get().push(transaction); <span class="comment">// 添加到头部</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><strong>可能有同学会比较好奇，为什么使用队列存储当前线程事务</strong>？TCC-Transaction 支持<strong>多个</strong>的事务<strong>独立存在</strong>，后创建的事务先提交，类似 Spring 的<code>org.springframework.transaction.annotation.Propagation.REQUIRES_NEW</code> 。在下文，很快我们就会看到 TCC-Transaction 自己的 <code>org.mengyun.tcctransaction.api.Propagation</code> 。</li>
</ul>
</li>
</ul>
<h2>5.2 传播发起分支事务</h2>
<p>调用 <code>#propagationNewBegin(...)</code> 方法，传播发起<strong>分支</strong>事务。该方法在<strong>调用方法类型为 MethodType.PROVIDER 并且 事务处于 Try 阶段</strong>被调用。MethodType 在<a href="#">「6.2 可补偿事务拦截器」</a>详细解析。</p>
<p>实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 传播发起分支事务</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> transactionContext 事务上下文</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 分支事务</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> Transaction <span class="title">propagationNewBegin</span><span class="params">(TransactionContext transactionContext)</span> </span>&#123;</div><div class="line">  <span class="comment">// 创建 分支事务</span></div><div class="line">  Transaction transaction = <span class="keyword">new</span> Transaction(transactionContext);</div><div class="line">  <span class="comment">// 存储 事务</span></div><div class="line">  transactionRepository.create(transaction);</div><div class="line">  <span class="comment">// 注册 事务</span></div><div class="line">  registerTransaction(transaction);</div><div class="line">  <span class="keyword">return</span> transaction;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>调用 Transaction 构造方法，创建<strong>分支事务</strong>。实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 创建分支事务</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> transactionContext 事务上下文</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Transaction</span><span class="params">(TransactionContext transactionContext)</span> </span>&#123;</div><div class="line">   <span class="keyword">this</span>.xid = transactionContext.getXid(); <span class="comment">// 事务上下文的 xid</span></div><div class="line">   <span class="keyword">this</span>.status = TransactionStatus.TRYING; <span class="comment">// 尝试中状态</span></div><div class="line">   <span class="keyword">this</span>.transactionType = TransactionType.BRANCH; <span class="comment">// 分支事务</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><strong>分支</strong>事务使用传播的事务上下文的事务编号。</li>
</ul>
</li>
<li>
<p>调用 <code>TransactionRepository#crete()</code> 方法，存储事务。为什么要存储<strong>分支</strong>事务，在<a href="#">「6.3 资源协调者拦截器」</a>详细解析。</p>
</li>
<li>
<p>调用 <code>#registerTransaction(...)</code> 方法，注册事务到当前线程事务队列。</p>
</li>
</ul>
<h2>5.3 传播获取分支事务</h2>
<p>调用 <code>#propagationExistBegin(...)</code> 方法，传播发起<strong>分支</strong>事务。该方法在<strong>调用方法类型为 MethodType.PROVIDER 并且 事务处于 Confirm / Cancel 阶段</strong>被调用。MethodType 在<a href="#">「6.2 可补偿事务拦截器」</a>详细解析。</p>
<p>实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 传播获取分支事务</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> transactionContext 事务上下文</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 分支事务</span></div><div class="line"><span class="comment">* <span class="doctag">@throws</span> NoExistedTransactionException 当事务不存在时</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> Transaction <span class="title">propagationExistBegin</span><span class="params">(TransactionContext transactionContext)</span> <span class="keyword">throws</span> NoExistedTransactionException </span>&#123;</div><div class="line">   <span class="comment">// 查询 事务</span></div><div class="line">   Transaction transaction = transactionRepository.findByXid(transactionContext.getXid());</div><div class="line">   <span class="keyword">if</span> (transaction != <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="comment">// 设置 事务 状态</span></div><div class="line">       transaction.changeStatus(TransactionStatus.valueOf(transactionContext.getStatus()));</div><div class="line">       <span class="comment">// 注册 事务</span></div><div class="line">       registerTransaction(transaction);</div><div class="line">       <span class="keyword">return</span> transaction;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> NoExistedTransactionException();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>调用 <code>TransactionRepository#findByXid()</code> 方法，查询事务。</li>
<li>调用 <code>Transaction#changeStatus(...)</code> 方法，<strong>设置</strong>事务状态为 CONFIRMING 或 CANCELLING。</li>
<li>调用 <code>#registerTransaction(...)</code> 方法，注册事务到当前线程事务队列。</li>
<li>为什么此处是<strong>分支</strong>事务呢？结合 <code>#propagationNewBegin(...)</code> 思考下。</li>
</ul>
<h2>5.4 提交事务</h2>
<p>调用 <code>#commit(...)</code> 方法，提交事务。该方法在<strong>事务处于 Confirm / Cancel 阶段</strong>被调用。</p>
<p>实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 提交事务</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 获取 事务</span></div><div class="line">   Transaction transaction = getCurrentTransaction();</div><div class="line">   <span class="comment">// 设置 事务状态 为 CONFIRMING</span></div><div class="line">   transaction.changeStatus(TransactionStatus.CONFIRMING);</div><div class="line">   <span class="comment">// 更新 事务</span></div><div class="line">   transactionRepository.update(transaction);</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 提交 事务</span></div><div class="line">       transaction.commit();</div><div class="line">       <span class="comment">// 删除 事务</span></div><div class="line">       transactionRepository.delete(transaction);</div><div class="line">   &#125; <span class="keyword">catch</span> (Throwable commitException) &#123;</div><div class="line">       logger.error(<span class="string">"compensable transaction confirm failed."</span>, commitException);</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ConfirmingException(commitException);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>调用 <code>#getCurrentTransaction()</code> 方法， 获取事务。实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Transaction <span class="title">getCurrentTransaction</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (isTransactionActive()) &#123;</div><div class="line">       <span class="keyword">return</span> CURRENT.get().peek(); <span class="comment">// 获得头部元素</span></div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTransactionActive</span><span class="params">()</span> </span>&#123;</div><div class="line">   Deque&lt;Transaction&gt; transactions = CURRENT.get();</div><div class="line">   <span class="keyword">return</span> transactions != <span class="keyword">null</span> &amp;&amp; !transactions.isEmpty();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>为什么获得队列<strong>头部</strong>元素呢？该元素即是上文调用 <code>#registerTransaction(...)</code> 注册到队列头部。</li>
</ul>
</li>
<li>
<p>调用 <code>Transaction#changeStatus(...)</code> 方法， <strong>设置</strong>事务状态为 CONFIRMING。</p>
</li>
<li>
<p>调用 <code>TransactionRepository#update(...)</code> 方法， <strong>更新</strong>事务。</p>
</li>
<li>
<p>调用 <code>Transaction#commit(...)</code> 方法， <strong>提交</strong>事务。</p>
</li>
<li>
<p>调用 <code>TransactionRepository#delete(...)</code> 方法，<strong>删除</strong>事务。</p>
</li>
</ul>
<h2>5.5 回滚事务</h2>
<p>调用 <code>#rollback(...)</code> 方法，取消事务，和 <code>#commit()</code> 方法基本类似。该方法在<strong>事务处于 Confirm / Cancel 阶段</strong>被调用。</p>
<p>实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 回滚事务</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// 获取 事务</span></div><div class="line">   Transaction transaction = getCurrentTransaction();</div><div class="line">   <span class="comment">// 设置 事务状态 为 CANCELLING</span></div><div class="line">   transaction.changeStatus(TransactionStatus.CANCELLING);</div><div class="line">   <span class="comment">// 更新 事务</span></div><div class="line">   transactionRepository.update(transaction);</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 提交 事务</span></div><div class="line">       transaction.rollback();</div><div class="line">       <span class="comment">// 删除 事务</span></div><div class="line">       transactionRepository.delete(transaction);</div><div class="line">   &#125; <span class="keyword">catch</span> (Throwable rollbackException) &#123;</div><div class="line">       logger.error(<span class="string">"compensable transaction rollback failed."</span>, rollbackException);</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> CancellingException(rollbackException);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>调用 <code>#getCurrentTransaction()</code> 方法，获取事务。</li>
<li>调用 <code>Transaction#changeStatus(...)</code> 方法， <strong>设置</strong>事务状态为 CANCELLING。</li>
<li>调用 <code>TransactionRepository#update(...)</code> 方法， <strong>更新</strong>事务。</li>
<li>调用 <code>Transaction#rollback(...)</code> 方法， <strong>回滚</strong>事务。</li>
<li>调用 <code>TransactionRepository#delete(...)</code> 方法，<strong>删除</strong>事务。</li>
</ul>
<h2>5.6 添加参与者到事务</h2>
<p>调用 <code>#enlistParticipant(...)</code> 方法，添加参与者到事务。该方法在<strong>事务处于 Try 阶段</strong>被调用，在<a href="#">「6.3 资源协调者拦截器」</a>有详细解析。</p>
<p>实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 添加参与者到事务</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> participant 参与者</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enlistParticipant</span><span class="params">(Participant participant)</span> </span>&#123;</div><div class="line">   <span class="comment">// 获取 事务</span></div><div class="line">   Transaction transaction = <span class="keyword">this</span>.getCurrentTransaction();</div><div class="line">   <span class="comment">// 添加参与者</span></div><div class="line">   transaction.enlistParticipant(participant);</div><div class="line">   <span class="comment">// 更新 事务</span></div><div class="line">   transactionRepository.update(transaction);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>调用 <code>#getCurrentTransaction()</code> 方法，获取事务。</li>
<li>调用 <code>Transaction#enlistParticipant(...)</code> 方法， 添加参与者到事务。</li>
<li>调用 <code>TransactionRepository#update(...)</code> 方法， <strong>更新</strong>事务。</li>
</ul>
<h1>6. 事务拦截器</h1>
<p>TCC-Transaction 基于 <code>org.mengyun.tcctransaction.api.@Compensable</code> + <code>org.aspectj.lang.annotation.@Aspect</code> <strong>注解</strong> <strong>AOP 切面</strong>实现业务方法的 TCC 事务声明<strong>拦截</strong>，同 Spring 的 <code>org.springframework.transaction.annotation.@Transactional</code> 的实现。</p>
<p>TCC-Transaction 有两个拦截器：</p>
<ul>
<li><code>org.mengyun.tcctransaction.interceptor.CompensableTransactionInterceptor</code>，可补偿事务拦截器。</li>
<li><code>org.mengyun.tcctransaction.interceptor.ResourceCoordinatorInterceptor</code>，资源协调者拦截器。</li>
</ul>
<p>在分享拦截器的实现之前，我们先一起看看 @Compensable 注解。</p>
<h2>6.1 Compensable</h2>
<p>@Compensable，标记可补偿的方法注解。实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Compensable &#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 传播级别</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">Propagation <span class="title">propagation</span><span class="params">()</span> <span class="keyword">default</span> Propagation.REQUIRED</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 确认执行业务方法</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">String <span class="title">confirmMethod</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 取消执行业务方法</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">String <span class="title">cancelMethod</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 事务上下文编辑</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    Class&lt;? extends TransactionContextEditor&gt; transactionContextEditor() <span class="keyword">default</span> DefaultTransactionContextEditor.class;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>propagation，传播级别( Propagation )，默认 Propagation.REQUIRED。和 Spring 的 Propagation 除了缺少几个属性，基本一致。实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Propagation &#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 支持当前事务，如果当前没有事务，就新建一个事务。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    REQUIRED(<span class="number">0</span>),</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 支持当前事务，如果当前没有事务，就以非事务方式执行。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    SUPPORTS(<span class="number">1</span>),</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 支持当前事务，如果当前没有事务，就抛出异常。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    MANDATORY(<span class="number">2</span>),</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 新建事务，如果当前存在事务，把当前事务挂起。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    REQUIRES_NEW(<span class="number">3</span>);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>confirmMethod，确认执行业务方法名。</p>
</li>
<li>
<p>cancelMethod，取消执行业务方法名。</p>
</li>
<li>
<p>TransactionContextEditor，事务上下文编辑器( TransactionContextEditor )，用于设置和获得事务上下文( TransactionContext )，在<a href="#">「6.3 资源协调者拦截器」</a>可以看到被调用，此处只看它的代码实现。<code>org.mengyun.tcctransaction.api.TransactionContextEditor</code> 接口代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionContextEditor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 从参数中获得事务上下文</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> target 对象</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> method 方法</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> args 参数</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 事务上下文</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">TransactionContext <span class="title">get</span><span class="params">(Object target, Method method, Object[] args)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 设置事务上下文到参数中</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> transactionContext 事务上下文</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> target 对象</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> method 方法</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> args 参数</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(TransactionContext transactionContext, Object target, Method method, Object[] args)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>DefaultTransactionContextEditor，<strong>默认</strong>事务上下文编辑器实现。实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultTransactionContextEditor</span> <span class="keyword">implements</span> <span class="title">TransactionContextEditor</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> TransactionContext <span class="title">get</span><span class="params">(Object target, Method method, Object[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> position = getTransactionContextParamPosition(method.getParameterTypes());</div><div class="line">        <span class="keyword">if</span> (position &gt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> (TransactionContext) args[position];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(TransactionContext transactionContext, Object target, Method method, Object[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> position = getTransactionContextParamPosition(method.getParameterTypes());</div><div class="line">        <span class="keyword">if</span> (position &gt;= <span class="number">0</span>) &#123;</div><div class="line">            args[position] = transactionContext; <span class="comment">// 设置方法参数</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获得事务上下文在方法参数里的位置</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> parameterTypes 参数类型集合</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 位置</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getTransactionContextParamPosition</span><span class="params">(Class&lt;?&gt;[] parameterTypes)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> position = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterTypes.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (parameterTypes[i].equals(org.mengyun.tcctransaction.api.TransactionContext.class)) &#123;</div><div class="line">                position = i;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> position;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>x</li>
</ul>
</li>
<li>
<p>NullableTransactionContextEditor，无事务上下文编辑器实现。实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NullableTransactionContextEditor</span> <span class="keyword">implements</span> <span class="title">TransactionContextEditor</span> </span>&#123;</div><div class="line">    </div><div class="line">     <span class="meta">@Override</span></div><div class="line">     <span class="function"><span class="keyword">public</span> TransactionContext <span class="title">get</span><span class="params">(Object target, Method method, Object[] args)</span> </span>&#123;</div><div class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">     &#125;</div><div class="line">    </div><div class="line">     <span class="meta">@Override</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(TransactionContext transactionContext, Object target, Method method, Object[] args)</span> </span>&#123;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>DubboTransactionContextEditor，Dubbo 事务上下文编辑器实现，通过 Dubbo 隐式传参方式获得事务上下文，在<a href="http://www.iocoder.cn/TCC-Transaction/dubbo-support/?self">《TCC-Transaction 源码解析 —— Dubbo 支持》</a>详细解析。</p>
</li>
</ul>
</li>
</ul>
<h2>6.2 可补偿事务拦截器</h2>
<p>先一起来看下可补偿事务拦截器对应的切面 <code>org.mengyun.tcctransaction.interceptor.CompensableTransactionAspect</code>，实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Aspect</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CompensableTransactionAspect</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> CompensableTransactionInterceptor compensableTransactionInterceptor;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCompensableTransactionInterceptor</span><span class="params">(CompensableTransactionInterceptor compensableTransactionInterceptor)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.compensableTransactionInterceptor = compensableTransactionInterceptor;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Pointcut</span>(<span class="string">"@annotation(org.mengyun.tcctransaction.api.Compensable)"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compensableService</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Around</span>(<span class="string">"compensableService()"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">interceptCompensableMethod</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="keyword">return</span> compensableTransactionInterceptor.interceptCompensableMethod(pjp);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>通过 <code>org.aspectj.lang.annotation.@Pointcut</code> + <code>org.aspectj.lang.annotation.@Around</code> 注解，配置对 <strong>@Compensable 注解的方法</strong>进行拦截，调用 <code>CompensableTransactionInterceptor#interceptCompensableMethod(...)</code> 方法进行处理。</li>
</ul>
<p><strong>CompensableTransactionInterceptor 实现代码如下</strong>：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompensableTransactionInterceptor</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> TransactionManager transactionManager;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Set&lt;Class&lt;? extends Exception&gt;&gt; delayCancelExceptions;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">interceptCompensableMethod</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="comment">// 获得带 @Compensable 注解的方法</span></div><div class="line">        Method method = CompensableMethodUtils.getCompensableMethod(pjp);</div><div class="line">        <span class="comment">//</span></div><div class="line">        Compensable compensable = method.getAnnotation(Compensable.class);</div><div class="line">        Propagation propagation = compensable.propagation();</div><div class="line">        <span class="comment">// 获得 事务上下文</span></div><div class="line">        TransactionContext transactionContext = FactoryBuilder.factoryOf(compensable.transactionContextEditor()).getInstance().get(pjp.getTarget(), method, pjp.getArgs());</div><div class="line">        <span class="comment">// 当前线程是否在事务中</span></div><div class="line">        <span class="keyword">boolean</span> isTransactionActive = transactionManager.isTransactionActive();</div><div class="line">        <span class="comment">// 判断事务上下文是否合法</span></div><div class="line">        <span class="keyword">if</span> (!TransactionUtils.isLegalTransactionContext(isTransactionActive, propagation, transactionContext)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SystemException(<span class="string">"no active compensable transaction while propagation is mandatory for method "</span> + method.getName());</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 计算方法类型</span></div><div class="line">        MethodType methodType = CompensableMethodUtils.calculateMethodType(propagation, isTransactionActive, transactionContext);</div><div class="line">        <span class="comment">// 处理</span></div><div class="line">        <span class="keyword">switch</span> (methodType) &#123;</div><div class="line">            <span class="keyword">case</span> ROOT:</div><div class="line">                <span class="keyword">return</span> rootMethodProceed(pjp);</div><div class="line">            <span class="keyword">case</span> PROVIDER:</div><div class="line">                <span class="keyword">return</span> providerMethodProceed(pjp, transactionContext);</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">return</span> pjp.proceed();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>调用 <code>CompensableMethodUtils#getCompensableMethod(...)</code> 方法，获得带 @Compensable 注解的方法。实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// CompensableMethodUtils.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 获得带 <span class="doctag">@Compensable</span> 注解的方法</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> pjp 切面点</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 方法</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Method <span class="title">getCompensableMethod</span><span class="params">(ProceedingJoinPoint pjp)</span> </span>&#123;</div><div class="line">   Method method = ((MethodSignature) (pjp.getSignature())).getMethod(); <span class="comment">// 代理方法对象</span></div><div class="line">   <span class="keyword">if</span> (method.getAnnotation(Compensable.class) == <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           method = pjp.getTarget().getClass().getMethod(method.getName(), method.getParameterTypes()); <span class="comment">// 实际方法对象</span></div><div class="line">       &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> method;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>调用 <code>TransactionContextEditor#get(...)</code> 方法，从参数中获得事务上下文。<strong>为什么从参数中可以获得事务上下文呢</strong>？在<a href="#">「6.3 资源协调者拦截器」</a>揭晓答案。</p>
</li>
<li>
<p>调用 <code>TransactionManager#isTransactionActive()</code> 方法，当前线程是否在事务中。实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TransactionManager.java</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Deque&lt;Transaction&gt;&gt; CURRENT = <span class="keyword">new</span> ThreadLocal&lt;Deque&lt;Transaction&gt;&gt;();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTransactionActive</span><span class="params">()</span> </span>&#123;</div><div class="line">   Deque&lt;Transaction&gt; transactions = CURRENT.get();</div><div class="line">   <span class="keyword">return</span> transactions != <span class="keyword">null</span> &amp;&amp; !transactions.isEmpty();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>调用 <code>TransactionUtils#isLegalTransactionContext(...)</code> 方法，判断事务上下文是否合法。实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TransactionUtils.java</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 判断事务上下文是否合法</span></div><div class="line"><span class="comment">* 在 Propagation.MANDATORY 必须有在事务内</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> isTransactionActive 是否</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> propagation 传播级别</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> transactionContext 事务上下文</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 是否合法</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLegalTransactionContext</span><span class="params">(<span class="keyword">boolean</span> isTransactionActive, Propagation propagation, TransactionContext transactionContext)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (propagation.equals(Propagation.MANDATORY) &amp;&amp; !isTransactionActive &amp;&amp; transactionContext == <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>当传播级别为 Propagation.MANDATORY 时，要求必须在事务中。</li>
</ul>
</li>
<li>
<p>调用 <code>CompensableMethodUtils#calculateMethodType(...)</code> 方法，计算方法类型。实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 计算方法类型</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> propagation 传播级别</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> isTransactionActive 是否事务开启</span></div><div class="line"><span class="comment">* <span class="doctag">@param</span> transactionContext 事务上下文</span></div><div class="line"><span class="comment">* <span class="doctag">@return</span> 方法类型</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MethodType <span class="title">calculateMethodType</span><span class="params">(Propagation propagation, <span class="keyword">boolean</span> isTransactionActive, TransactionContext transactionContext)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> ((propagation.equals(Propagation.REQUIRED) &amp;&amp; !isTransactionActive &amp;&amp; transactionContext == <span class="keyword">null</span>) <span class="comment">// Propagation.REQUIRED：支持当前事务，当前没有事务，就新建一个事务。</span></div><div class="line">           || propagation.equals(Propagation.REQUIRES_NEW)) &#123; <span class="comment">// Propagation.REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起。</span></div><div class="line">       <span class="keyword">return</span> MethodType.ROOT;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((propagation.equals(Propagation.REQUIRED) <span class="comment">// Propagation.REQUIRED：支持当前事务</span></div><div class="line">               || propagation.equals(Propagation.MANDATORY)) <span class="comment">// Propagation.MANDATORY：支持当前事务</span></div><div class="line">           &amp;&amp; !isTransactionActive &amp;&amp; transactionContext != <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="keyword">return</span> MethodType.PROVIDER;</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="keyword">return</span> MethodType.NORMAL;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>计算方法类型( MethodType )的目的，可以根据不同方法类型，做不同的事务处理。</li>
<li>方法类型为 MethodType.ROOT 时，发起<strong>根事务</strong>，判断条件如下二选一：
<ul>
<li>事务传播级别为 Propagation.REQUIRED，并且当前没有事务。</li>
<li>事务传播级别为 Propagation.REQUIRES_NEW，新建事务，如果当前存在事务，把当前事务挂起。<strong>此时，事务管理器的当前线程事务队列可能会存在多个事务</strong>。</li>
</ul>
</li>
<li>方法类型为 MethodType.ROOT 时，发起<strong>分支事务</strong>，判断条件如下二选一：
<ul>
<li>事务传播级别为 Propagation.REQUIRED，并且当前不存在事务，<strong>并且方法参数传递了事务上下文</strong>。</li>
<li>事务传播级别为 Propagation.PROVIDER，并且当前不存在事务，<strong>并且方法参数传递了事务上下文</strong>。</li>
<li><strong>当前不存在事务，方法参数传递了事务上下文是什么意思</strong>？当跨服务<strong>远程</strong>调用时，被调用服务本身( <strong>服务提供者</strong> )不在事务中，通过传递事务上下文参数，融入当前事务。</li>
</ul>
</li>
<li>方法类型为 MethodType.Normal 时，不进行事务处理。</li>
<li>MethodType.CONSUMER 项目已经不再使用，猜测已废弃。</li>
</ul>
</li>
<li>
<p>当方法类型为 MethodType.ROOT 时，调用 <code>#rootMethodProceed(...)</code> 方法，发起 <strong>TCC 整体流程</strong>。实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">rootMethodProceed</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">   Object returnValue;</div><div class="line">   Transaction transaction = <span class="keyword">null</span>;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 发起根事务</span></div><div class="line">       transaction = transactionManager.begin();</div><div class="line">       <span class="comment">// 执行方法原逻辑</span></div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           returnValue = pjp.proceed();</div><div class="line">       &#125; <span class="keyword">catch</span> (Throwable tryingException) &#123;</div><div class="line">           <span class="keyword">if</span> (isDelayCancelException(tryingException)) &#123; <span class="comment">// 是否延迟回滚</span></div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               logger.warn(String.format(<span class="string">"compensable transaction trying failed. transaction content:%s"</span>, JSON.toJSONString(transaction)), tryingException);</div><div class="line">               <span class="comment">// 回滚事务</span></div><div class="line">               transactionManager.rollback();</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">throw</span> tryingException;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 提交事务</span></div><div class="line">       transactionManager.commit();</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       <span class="comment">// 将事务从当前线程事务队列移除</span></div><div class="line">       transactionManager.cleanAfterCompletion(transaction);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> returnValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>调用 <code>#transactionManager()</code> 方法，发起<strong>根事务</strong>，<strong>TCC Try 阶段开始</strong>。</p>
</li>
<li>
<p>调用 <code>ProceedingJoinPoint#proceed()</code> 方法，执行方法<strong>原逻辑( 即 Try 逻辑 )</strong>。</p>
</li>
<li>
<p>当原逻辑执行异常时，<strong>TCC Try 阶段失败</strong>，调用 <code>TransactionManager#rollback(...)</code> 方法，<strong>TCC Cancel 阶段</strong>，回滚事务。此处 <code>#isDelayCancelException(...)</code> 方法，判断异常是否为延迟取消回滚异常，部分异常不适合立即回滚事务，在<a href="http://www.iocoder.cn/TCC-Transaction/transaction-recovery/?self">《TCC-Transaction 源码分析 —— 事务恢复》</a>详细解析。</p>
</li>
<li>
<p>当原逻辑执行成功时，<strong>TCC Try 阶段成功</strong>，调用 <code>TransactionManager#commit(...)</code> 方法，<strong>TCC Confirm 阶段</strong>，提交事务。</p>
</li>
<li>
<p>调用 <code>TransactionManager#cleanAfterCompletion(...)</code> 方法，将事务从当前线程事务队列移除，避免线程冲突。实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// TransactionManager.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanAfterCompletion</span><span class="params">(Transaction transaction)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isTransactionActive() &amp;&amp; transaction != <span class="keyword">null</span>) &#123;</div><div class="line">        Transaction currentTransaction = getCurrentTransaction();</div><div class="line">        <span class="keyword">if</span> (currentTransaction == transaction) &#123;</div><div class="line">            CURRENT.get().pop();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SystemException(<span class="string">"Illegal transaction when clean after completion"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>x</li>
</ul>
</li>
</ul>
</li>
<li>
<p>当方法类型为 Propagation.PROVIDER 时，服务提供者参与 <strong>TCC 整体流程</strong>。实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">providerMethodProceed</span><span class="params">(ProceedingJoinPoint pjp, TransactionContext transactionContext)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">   Transaction transaction = <span class="keyword">null</span>;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">switch</span> (TransactionStatus.valueOf(transactionContext.getStatus())) &#123;</div><div class="line">           <span class="keyword">case</span> TRYING:</div><div class="line">               <span class="comment">// 传播发起分支事务</span></div><div class="line">               transaction = transactionManager.propagationNewBegin(transactionContext);</div><div class="line">               <span class="keyword">return</span> pjp.proceed();</div><div class="line">           <span class="keyword">case</span> CONFIRMING:</div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                   <span class="comment">// 传播获取分支事务</span></div><div class="line">                   transaction = transactionManager.propagationExistBegin(transactionContext);</div><div class="line">                   <span class="comment">// 提交事务</span></div><div class="line">                   transactionManager.commit();</div><div class="line">               &#125; <span class="keyword">catch</span> (NoExistedTransactionException excepton) &#123;</div><div class="line">                   <span class="comment">//the transaction has been commit,ignore it.</span></div><div class="line">               &#125;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> CANCELLING:</div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                   <span class="comment">// 传播获取分支事务</span></div><div class="line">                   transaction = transactionManager.propagationExistBegin(transactionContext);</div><div class="line">                   <span class="comment">// 回滚事务</span></div><div class="line">                   transactionManager.rollback();</div><div class="line">               &#125; <span class="keyword">catch</span> (NoExistedTransactionException exception) &#123;</div><div class="line">                   <span class="comment">//the transaction has been rollback,ignore it.</span></div><div class="line">               &#125;</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">       &#125;</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       <span class="comment">// 将事务从当前线程事务队列移除</span></div><div class="line">       transactionManager.cleanAfterCompletion(transaction);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 返回空值</span></div><div class="line">   Method method = ((MethodSignature) (pjp.getSignature())).getMethod();</div><div class="line">   <span class="keyword">return</span> ReflectionUtils.getNullValue(method.getReturnType());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>当事务处于 TransactionStatus.TRYING 时，调用 <code>TransactionManager#propagationExistBegin(...)</code> 方法，传播发起<strong>分支</strong>事务。发起<strong>分支</strong>事务完成后，调用 <code>ProceedingJoinPoint#proceed()</code> 方法，执行方法<strong>原逻辑( 即 Try 逻辑 )</strong>。</p>
<ul>
<li><strong>为什么要传播发起分支事务</strong>？在<strong>根事务</strong>进行 Confirm / Cancel 时，调用<strong>根事务</strong>上的参与者们提交或回滚事务时，进行远程服务方法调用的参与者，可以通过自己的事务编号关联上传播的<strong>分支</strong>事务( 两者的事务编号相等 )，进行事务的提交或回滚。</li>
</ul>
</li>
<li>
<p>当事务处于 TransactionStatus.CONFIRMING 时，调用 <code>TransactionManager#commit()</code> 方法，提交事务。</p>
</li>
<li>
<p>当事务处于 TransactionStatus.CANCELLING 时，调用 <code>TransactionManager#rollback()</code> 方法，提交事务。</p>
</li>
<li>
<p>调用 <code>TransactionManager#cleanAfterCompletion(...)</code> 方法，将事务从当前线程事务队列移除，避免线程冲突。</p>
</li>
<li>
<p>当事务处于 TransactionStatus.CONFIRMING / TransactionStatus.CANCELLING 时，调用 <code>ReflectionUtils#getNullValue(...)</code> 方法，返回空值。<strong>为什么返回空值</strong>？Confirm / Cancel 相关方法，是通过 AOP 切面调用，只调用，不处理返回值，但是又不能没有返回值，因此直接返回空。实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getNullValue</span><span class="params">(Class type)</span> </span>&#123;</div><div class="line">   <span class="comment">// 处理基本类型</span></div><div class="line">   <span class="keyword">if</span> (<span class="keyword">boolean</span>.class.equals(type)) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">byte</span>.class.equals(type)) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">short</span>.class.equals(type)) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">int</span>.class.equals(type)) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">long</span>.class.equals(type)) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">float</span>.class.equals(type)) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">double</span>.class.equals(type)) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 处理对象</span></div><div class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
</ul>
</li>
<li>
<p>当方法类型为 Propagation.NORMAL 时，执行方法原逻辑，<strong>不进行事务处理</strong>。</p>
</li>
</ul>
<h2>6.3 资源协调者拦截器</h2>
<p>先一起来看下资源协调者拦截器  对应的切面 <code>org.mengyun.tcctransaction.interceptor.CompensableTransactionAspect</code>，实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Aspect</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceCoordinatorAspect</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> ResourceCoordinatorInterceptor resourceCoordinatorInterceptor;</div><div class="line"></div><div class="line">    <span class="meta">@Pointcut</span>(<span class="string">"@annotation(org.mengyun.tcctransaction.api.Compensable)"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transactionContextCall</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Around</span>(<span class="string">"transactionContextCall()"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">interceptTransactionContextMethod</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="keyword">return</span> resourceCoordinatorInterceptor.interceptTransactionContextMethod(pjp);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceCoordinatorInterceptor</span><span class="params">(ResourceCoordinatorInterceptor resourceCoordinatorInterceptor)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.resourceCoordinatorInterceptor = resourceCoordinatorInterceptor;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>通过 <code>org.aspectj.lang.annotation.@Pointcut</code> + <code>org.aspectj.lang.annotation.@Around</code> 注解，配置对 <strong>@Compensable 注解的方法</strong>进行拦截，调用 <code>ResourceCoordinatorInterceptor#interceptTransactionContextMethod(...)</code> 方法进行处理。</li>
</ul>
<p><strong>ResourceCoordinatorInterceptor 实现代码如下</strong>：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceCoordinatorInterceptor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> TransactionManager transactionManager;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">interceptTransactionContextMethod</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        Transaction transaction = transactionManager.getCurrentTransaction();</div><div class="line">        <span class="keyword">if</span> (transaction != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">switch</span> (transaction.getStatus()) &#123;</div><div class="line">                <span class="keyword">case</span> TRYING:</div><div class="line">                    <span class="comment">// 添加事务参与者</span></div><div class="line">                    enlistParticipant(pjp);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> CONFIRMING:</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                <span class="keyword">case</span> CANCELLING:</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 执行方法原逻辑</span></div><div class="line">        <span class="keyword">return</span> pjp.proceed(pjp.getArgs());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>当事务处于 TransactionStatus.TRYING 时，调用 <code>#enlistParticipant(...)</code> 方法，添加事务参与者。</li>
<li>调用 <code>ProceedingJoinPoint#proceed(...)</code> 方法，执行方法原逻辑。</li>
</ul>
<p><strong><code>ResourceCoordinatorInterceptor#enlistParticipant()</code> 实现代码如下</strong>：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enlistParticipant</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;</div><div class="line">   <span class="comment">// 获得 @Compensable 注解</span></div><div class="line">   Method method = CompensableMethodUtils.getCompensableMethod(pjp);</div><div class="line">   <span class="keyword">if</span> (method == <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(String.format(<span class="string">"join point not found method, point is : %s"</span>, pjp.getSignature().getName()));</div><div class="line">   &#125;</div><div class="line">   Compensable compensable = method.getAnnotation(Compensable.class);</div><div class="line">   <span class="comment">// 获得 确认执行业务方法 和 取消执行业务方法</span></div><div class="line">   String confirmMethodName = compensable.confirmMethod();</div><div class="line">   String cancelMethodName = compensable.cancelMethod();</div><div class="line">   <span class="comment">// 获取 当前线程事务第一个(头部)元素</span></div><div class="line">   Transaction transaction = transactionManager.getCurrentTransaction();</div><div class="line">   <span class="comment">// 创建 事务编号</span></div><div class="line">   TransactionXid xid = <span class="keyword">new</span> TransactionXid(transaction.getXid().getGlobalTransactionId());</div><div class="line">   <span class="comment">// TODO</span></div><div class="line">   <span class="keyword">if</span> (FactoryBuilder.factoryOf(compensable.transactionContextEditor()).getInstance().get(pjp.getTarget(), method, pjp.getArgs()) == <span class="keyword">null</span>) &#123;</div><div class="line">       FactoryBuilder.factoryOf(compensable.transactionContextEditor()).getInstance().set(<span class="keyword">new</span> TransactionContext(xid, TransactionStatus.TRYING.getId()), pjp.getTarget(), ((MethodSignature) pjp.getSignature()).getMethod(), pjp.getArgs());</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 获得类</span></div><div class="line">   Class targetClass = ReflectionUtils.getDeclaringType(pjp.getTarget().getClass(), method.getName(), method.getParameterTypes());</div><div class="line">   <span class="comment">// 创建 确认执行方法调用上下文 和 取消执行方法调用上下文</span></div><div class="line">   InvocationContext confirmInvocation = <span class="keyword">new</span> InvocationContext(targetClass,</div><div class="line">           confirmMethodName,</div><div class="line">           method.getParameterTypes(), pjp.getArgs());</div><div class="line">   InvocationContext cancelInvocation = <span class="keyword">new</span> InvocationContext(targetClass,</div><div class="line">           cancelMethodName,</div><div class="line">           method.getParameterTypes(), pjp.getArgs());</div><div class="line">   <span class="comment">// 创建 事务参与者</span></div><div class="line">   Participant participant =</div><div class="line">           <span class="keyword">new</span> Participant(</div><div class="line">                   xid,</div><div class="line">                   confirmInvocation,</div><div class="line">                   cancelInvocation,</div><div class="line">                   compensable.transactionContextEditor());</div><div class="line">   <span class="comment">// 添加 事务参与者 到 事务</span></div><div class="line">   transactionManager.enlistParticipant(participant);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>
<p>调用 <code>CompensableMethodUtils#getCompensableMethod(...)</code> 方法，获得带 @Compensable 注解的方法。</p>
</li>
<li>
<p>调用 <code>#getCurrentTransaction()</code> 方法， 获取事务。</p>
</li>
<li>
<p>调用 TransactionXid 构造方法，创建<strong>分支</strong>事务编号。实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 全局事务编号</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] globalTransactionId;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 分支事务编号</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] branchQualifier;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TransactionXid</span><span class="params">(<span class="keyword">byte</span>[] globalTransactionId)</span> </span>&#123;</div><div class="line">   <span class="keyword">this</span>.globalTransactionId = globalTransactionId;</div><div class="line">   branchQualifier = uuidToByteArray(UUID.randomUUID()); <span class="comment">// 生成 分支事务编号</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>分支事务编号( <code>branchQualifier</code> ) 需要生成。</li>
</ul>
</li>
<li>
<p>TODO TransactionContext 和 Participant 的关系。</p>
</li>
<li>
<p>调用 <code>ReflectionUtils#getDeclaringType(...)</code> 方法，获得声明 @Compensable 方法的实际类。实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Class <span class="title">getDeclaringType</span><span class="params">(Class aClass, String methodName, Class&lt;?&gt;[] parameterTypes)</span> </span>&#123;</div><div class="line">   Method method;</div><div class="line">   Class findClass = aClass;</div><div class="line">   <span class="keyword">do</span> &#123;</div><div class="line">       Class[] clazzes = findClass.getInterfaces();</div><div class="line">       <span class="keyword">for</span> (Class clazz : clazzes) &#123;</div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               method = clazz.getDeclaredMethod(methodName, parameterTypes);</div><div class="line">           &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</div><div class="line">               method = <span class="keyword">null</span>;</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">if</span> (method != <span class="keyword">null</span>) &#123;</div><div class="line">               <span class="keyword">return</span> clazz;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       findClass = findClass.getSuperclass();</div><div class="line">   &#125; <span class="keyword">while</span> (!findClass.equals(Object.class));</div><div class="line">   <span class="keyword">return</span> aClass;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>调用 InvocationContext 构造方法，分别创建确认执行方法调用上下文和取消执行方法调用上下文。实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 类</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> Class targetClass;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 方法名</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> String methodName;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 参数类型数组</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> Class[] parameterTypes;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 参数数组</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">private</span> Object[] args;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">InvocationContext</span><span class="params">(Class targetClass, String methodName, Class[] parameterTypes, Object... args)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.methodName = methodName;</div><div class="line">  <span class="keyword">this</span>.parameterTypes = parameterTypes;</div><div class="line">  <span class="keyword">this</span>.targetClass = targetClass;</div><div class="line">  <span class="keyword">this</span>.args = args;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>调用 Participant 构造方法，创建事务参与者。实现代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Participant</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4127729421281425247L</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 事务编号</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> TransactionXid xid;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 确认执行业务方法调用上下文</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> InvocationContext confirmInvocationContext;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 取消执行业务方法</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> InvocationContext cancelInvocationContext;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 执行器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> Terminator terminator = <span class="keyword">new</span> Terminator();</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 事务上下文编辑</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    Class&lt;? extends TransactionContextEditor&gt; transactionContextEditorClass;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Participant</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Participant</span><span class="params">(TransactionXid xid, InvocationContext confirmInvocationContext, InvocationContext cancelInvocationContext, Class&lt;? extends TransactionContextEditor&gt; transactionContextEditorClass)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.xid = xid;</div><div class="line">        <span class="keyword">this</span>.confirmInvocationContext = confirmInvocationContext;</div><div class="line">        <span class="keyword">this</span>.cancelInvocationContext = cancelInvocationContext;</div><div class="line">        <span class="keyword">this</span>.transactionContextEditorClass = transactionContextEditorClass;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
<li>
<p>调用 <code>TransactionManager#enlistParticipant(...)</code> 方法，添加事务参与者到事务。</p>
</li>
</ul>
<h1>666. 彩蛋</h1>
<p><img src="http://www.iocoder.cn/images/Architecture/2017_12_29/01.png" alt="知识星球"></p>
<p>受限于本人的能力，蛮多处表达不够清晰或者易懂，非常抱歉。如果你对任何地方有任何疑问，欢迎添加本人微信号( wangwenbin-server )，期待与你的交流。不限于 TCC，也可以是分布式事务，也可以是微服务，以及等等。</p>
<p><img src="http://www.iocoder.cn/images/TCC-Transaction/2018_02_08/05.png" alt=""></p>
<p>外送一本武林秘籍：带中文注释的 TCC-Transaction 仓库地址，目前正在慢慢完善。传送门：<a href="https://github.com/YunaiV/tcc-transaction" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/YunaiV/tcc-transaction</a>。</p>
<p>再送一本葵花宝典：<a href="https://my.oschina.net/fileoptions/blog/899991" rel="external nofollow noopener noreferrer" target="_blank">《TCC型分布式事务原理和实现》系列</a>。</p>
<p>胖友，分享一个朋友圈可好？</p>
  
	</div>
		<footer class="article-footer clearfix">


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/TCC-Transaction/">TCC-Transaction</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://www.iocoder.cn/TCC-Transaction/tcc-core/" data-title="TCC-Transaction 源码分析 —— TCC 实现 | 芋道源码 —— 纯源码解析博客" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev">
 <a href="/Weekdays/2018-02-11/" title="芋道源码的周八（2018.02.11）">
  <strong>PREVIOUS:</strong><br>
  <span>
  芋道源码的周八（2018.02.11）</span>
</a>
</div>


<div class="next">
<a href="/Weekdays/2018-02-04/" title="芋道源码的周八（2018.02.04）">
 <strong>NEXT:</strong><br> 
 <span>芋道源码的周八（2018.02.04）
</span>
</a>
</div>

</nav>

	

</div>  
        <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="toc" class="toc-aside">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#undefined"><span class="toc-number">1.</span> <span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#undefined"><span class="toc-number">2.</span> <span class="toc-text">2. TCC 原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#undefined"><span class="toc-number">3.</span> <span class="toc-text">3. TCC-Transaction 原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#undefined"><span class="toc-number">4.</span> <span class="toc-text">4. 事务与参与者</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 参与者</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#undefined"><span class="toc-number">5.</span> <span class="toc-text">5. 事务管理器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 发起根事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 传播发起分支事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 传播获取分支事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 提交事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">5.5.</span> <span class="toc-text">5.5 回滚事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">5.6.</span> <span class="toc-text">5.6 添加参与者到事务</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#undefined"><span class="toc-number">6.</span> <span class="toc-text">6. 事务拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 Compensable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 可补偿事务拦截器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 资源协调者拦截器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#undefined"><span class="toc-number">7.</span> <span class="toc-text">666. 彩蛋</span></a></li></ol>
</div>

<div id="asidepart">
    <!--<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>-->
    <aside class="clearfix">
        <div id="authorInfo">
            <!---->
            <!--<div class="author-logo"></div>-->
            <!---->

            <div> <img width="100%" src="/images/common/wechat_mp_2017_07_31_bak.jpg"> </div>

            <div class="social-list">
                
                
                
                
                
            </div>
        </div>

        
        <div class="categorieslist">
    <p class="asidetitle">微信公众号福利：芋道源码</p>
    <ul>

        <li> <a href="/images/common/wechat_mp_2017_07_31_bak.jpg"> 0. 阅读源码葵花宝典 </a></li>

        <li> <a href="/images/common/wechat_mp_2017_07_31_bak.jpg"> 1. RocketMQ / MyCAT / Sharding-JDBC 详细中文注释源码 </a> </li>

        <li> <a href="/images/common/wechat_mp_2017_07_31_bak.jpg"> 2. 您对于源码的疑问每条留言都将得到认真回复 </a> </li>

        <li> <a href="/images/common/wechat_mp_2017_07_31_bak.jpg"> 3. 新的源码解析文章实时收到通知，每周六十点更新 </a> </li>

        <li> <a href="/images/common/wechat_mp_2017_07_31_bak.jpg">4. 认真的源码交流微信群 </a> </li>


    </ul>
</div>

        
        
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
            
		
            
		
            
			    <li><a href="/categories/Elastic-Job-Cloud/" title="Elastic-Job-Cloud">Elastic-Job-Cloud<sup>6</sup></a></li>
            
		
            
			    <li><a href="/categories/Elastic-Job-Lite/" title="Elastic-Job-Lite">Elastic-Job-Lite<sup>16</sup></a></li>
            
		
            
			    <li><a href="/categories/Eureka/" title="Eureka">Eureka<sup>23</sup></a></li>
            
		
            
		
            
			    <li><a href="/categories/Hystrix/" title="Hystrix">Hystrix<sup>9</sup></a></li>
            
		
            
		
            
		
            
			    <li><a href="/categories/MyCAT/" title="MyCAT">MyCAT<sup>9</sup></a></li>
            
		
            
		
            
		
            
		
            
			    <li><a href="/categories/RocketMQ/" title="RocketMQ">RocketMQ<sup>14</sup></a></li>
            
		
            
			    <li><a href="/categories/RxJava/" title="RxJava">RxJava<sup>5</sup></a></li>
            
		
            
			    <li><a href="/categories/Sharding-JDBC/" title="Sharding-JDBC">Sharding-JDBC<sup>18</sup></a></li>
            
		
            
			    <li><a href="/categories/SkyWalking/" title="SkyWalking">SkyWalking<sup>35</sup></a></li>
            
		
            
		
            
			    <li><a href="/categories/Spring-Cloud-Gateway/" title="Spring-Cloud-Gateway">Spring-Cloud-Gateway<sup>24</sup></a></li>
            
		
            
		
            
		
            
			    <li><a href="/categories/TCC-Transaction/" title="TCC-Transaction">TCC-Transaction<sup>7</sup></a></li>
            
		
            
		
            
		
            
			    <li><a href="/categories/工作内推/" title="工作内推">工作内推<sup>2</sup></a></li>
            
		
            
		
            
		
            
			    <li><a href="/categories/芋道源码的周八/" title="芋道源码的周八">芋道源码的周八<sup>11</sup></a></li>
            
		
		</ul>
</div>

        

                <div id="authorInfo2">

                    <div> <img width="100%" src="/images/common/zsxq/02.png"> </div>

                </div>
    </aside>
</div>
    </div>
    <footer><div id="footer">
    <img src="http://www.iocoder.cn/images/common/wechat_mp_simple.png" style="display: none">
    
            <p class="copyright"> © 2018 
		
		<a href="http://www.iocoder.cn" target="_blank" title="芋道源码">芋道源码</a>
		
            && <span style="display: inline;" id="busuanzi_container_site_uv">总访客数 <span id="busuanzi_value_site_uv" font="微软雅黑"></span> 次</span>
            && <span style="display: inline;" id="busuanzi_container_site_pv">总访问量 <span id="busuanzi_value_site_pv" font="微软雅黑"></span> 次</span>
            && Hosted by <a href="https://pages.coding.me" style="font-weight: bold" rel="external nofollow noopener noreferrer" target="_blank">Coding Pages</a>
            <!--&& Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> && Theme by <a href="http://gengbiao.me" target="_blank" title="coney">coney</a>-->
            </p></div>
            <div class="copyright">沪ICP备17037075号-1</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>






<link rel="stylesheet" href="/alert/css/alert.css">
<script src="/alert/js/alert.js"></script>
<script src="/js/jquery.cookie.js"></script>
<script src="/js/util.js"></script>





<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-107572620-1', 'auto');  
ga('send', 'pageview');
</script>

  </body>


